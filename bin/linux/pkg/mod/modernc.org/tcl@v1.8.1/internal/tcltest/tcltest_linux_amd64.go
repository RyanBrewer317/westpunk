// Code generated by 'ccgo -export-defines "" -lmodernc.org/tcl/lib -nocapi -o internal/tcltest/tcltest_linux_amd64.go -trace-translation-units /tmp/go-generate-3952628766/cdb.json tclAppInit.o#1 tclTest.o tclTestObj.o tclTestProcBodyObj.o tclThreadTest.o tclUnixTest.o', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BUFSIZ                                = 8192
	CRTIMPORT                             = 0
	DLLIMPORT                             = 0
	EOF                                   = -1
	FILENAME_MAX                          = 4096
	FOPEN_MAX                             = 16
	HAVE_BLKCNT_T                         = 1
	HAVE_CAST_TO_UNION                    = 1
	HAVE_DECL_GETHOSTBYADDR_R             = 1
	HAVE_DECL_GETHOSTBYNAME_R             = 1
	HAVE_FREEADDRINFO                     = 1
	HAVE_FTS                              = 1
	HAVE_GAI_STRERROR                     = 1
	HAVE_GETADDRINFO                      = 1
	HAVE_GETCWD                           = 1
	HAVE_GETGRGID_R                       = 1
	HAVE_GETGRGID_R_5                     = 1
	HAVE_GETGRNAM_R                       = 1
	HAVE_GETGRNAM_R_5                     = 1
	HAVE_GETHOSTBYADDR_R                  = 1
	HAVE_GETHOSTBYADDR_R_8                = 1
	HAVE_GETHOSTBYNAME_R                  = 1
	HAVE_GETHOSTBYNAME_R_6                = 1
	HAVE_GETNAMEINFO                      = 1
	HAVE_GETPWNAM_R                       = 1
	HAVE_GETPWNAM_R_5                     = 1
	HAVE_GETPWUID_R                       = 1
	HAVE_GETPWUID_R_5                     = 1
	HAVE_GMTIME_R                         = 1
	HAVE_HIDDEN                           = 1
	HAVE_INTPTR_T                         = 1
	HAVE_INTTYPES_H                       = 1
	HAVE_LANGINFO                         = 1
	HAVE_LOCALTIME_R                      = 1
	HAVE_MEMORY_H                         = 1
	HAVE_MKSTEMP                          = 1
	HAVE_MKSTEMPS                         = 1
	HAVE_MKTIME                           = 1
	HAVE_OPENDIR                          = 1
	HAVE_PTHREAD_ATTR_SETSTACKSIZE        = 1
	HAVE_SIGNED_CHAR                      = 1
	HAVE_STDINT_H                         = 1
	HAVE_STDLIB_H                         = 1
	HAVE_STRINGS_H                        = 1
	HAVE_STRING_H                         = 1
	HAVE_STRTOL                           = 1
	HAVE_STRUCT_ADDRINFO                  = 1
	HAVE_STRUCT_IN6_ADDR                  = 1
	HAVE_STRUCT_SOCKADDR_IN6              = 1
	HAVE_STRUCT_SOCKADDR_STORAGE          = 1
	HAVE_STRUCT_STAT_ST_BLKSIZE           = 1
	HAVE_STRUCT_STAT_ST_BLOCKS            = 1
	HAVE_SYS_IOCTL_H                      = 1
	HAVE_SYS_PARAM_H                      = 1
	HAVE_SYS_STAT_H                       = 1
	HAVE_SYS_TIME_H                       = 1
	HAVE_SYS_TYPES_H                      = 1
	HAVE_TERMIOS_H                        = 1
	HAVE_TIMEZONE_VAR                     = 1
	HAVE_TM_GMTOFF                        = 1
	HAVE_UINTPTR_T                        = 1
	HAVE_UNISTD_H                         = 1
	HAVE_WAITPID                          = 1
	HAVE_ZLIB                             = 1
	INLINE                                = 0
	L_ctermid                             = 9
	L_tmpnam                              = 20
	MP_DIGIT_DECLARED                     = 0
	MP_FIXED_CUTOFFS                      = 1
	MP_INT_DECLARED                       = 0
	MP_NO_STDINT                          = 1
	MP_PREC                               = 4
	NDEBUG                                = 1
	NO_UNION_WAIT                         = 1
	NUM_STATIC_TOKENS                     = 20
	PACKAGE_BUGREPORT                     = ""
	PACKAGE_NAME                          = "tcl"
	PACKAGE_STRING                        = "tcl 8.6"
	PACKAGE_TARNAME                       = "tcl"
	PACKAGE_VERSION                       = "8.6"
	P_tmpdir                              = "/tmp"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	STDC_HEADERS                          = 1
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_BUILDTIME_LIBRARY                 = "/tmp/go-generate-3952628766/tcl8.6.10/library"
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CFGVAL_ENCODING                   = "iso8859-1"
	TCL_CFG_OPTIMIZED                     = 1
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "l"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.10"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 10
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SHLIB_EXT                         = ""
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_TEST                              = 1
	TCL_THREADS                           = 1
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TOMMATH                           = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UNLOAD_DLLS                       = 1
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WIDE_INT_IS_LONG                  = 1
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	TIME_WITH_SYS_TIME                    = 1
	TMP_MAX                               = 238328
	USE_THREAD_ALLOC                      = 1
	X_ANSI_STDARG_H_                      = 0
	X_ATFILE_SOURCE                       = 1
	X_BITS_STDIO_LIM_H                    = 1
	X_BITS_TIME64_H                       = 1
	X_BITS_TYPESIZES_H                    = 1
	X_BITS_TYPES_H                        = 1
	X_BSD_SIZE_T_                         = 0
	X_BSD_SIZE_T_DEFINED_                 = 0
	X_CLIENTDATA                          = 0
	X_DEFAULT_SOURCE                      = 1
	X_FEATURES_H                          = 1
	X_FILE_OFFSET_BITS                    = 64
	X_GCC_SIZE_T                          = 0
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_IO_EOF_SEEN                         = 0x0010
	X_IO_ERR_SEEN                         = 0x0020
	X_IO_USER_LOCK                        = 0x8000
	X_LARGEFILE64_SOURCE                  = 1
	X_LP64                                = 1
	X_POSIX_C_SOURCE                      = 200809
	X_POSIX_SOURCE                        = 1
	X_REENTRANT                           = 1
	X_SIZET_                              = 0
	X_SIZE_T                              = 0
	X_SIZE_T_                             = 0
	X_SIZE_T_DECLARED                     = 0
	X_SIZE_T_DEFINED                      = 0
	X_SIZE_T_DEFINED_                     = 0
	X_STDARG_H                            = 0
	X_STDC_PREDEF_H                       = 1
	X_STDIO_H                             = 1
	X_SYS_CDEFS_H                         = 1
	X_SYS_SIZE_T_H                        = 0
	X_TCL                                 = 0
	X_TCLDECLS                            = 0
	X_TCLPLATDECLS                        = 0
	X_THREAD_SAFE                         = 1
	X_T_SIZE                              = 0
	X_T_SIZE_                             = 0
	X_VA_LIST                             = 0
	X_VA_LIST_                            = 0
	X_VA_LIST_DEFINED                     = 0
	X_VA_LIST_T_H                         = 0
	Linux                                 = 1
	Unix                                  = 1
	ACCESSPERMS                           = 511
	AF_ALG                                = 38
	AF_APPLETALK                          = 5
	AF_ASH                                = 18
	AF_ATMPVC                             = 8
	AF_ATMSVC                             = 20
	AF_AX25                               = 3
	AF_BLUETOOTH                          = 31
	AF_BRIDGE                             = 7
	AF_CAIF                               = 37
	AF_CAN                                = 29
	AF_DECnet                             = 12
	AF_ECONET                             = 19
	AF_FILE                               = 1
	AF_IB                                 = 27
	AF_IEEE802154                         = 36
	AF_INET                               = 2
	AF_INET6                              = 10
	AF_IPX                                = 4
	AF_IRDA                               = 23
	AF_ISDN                               = 34
	AF_IUCV                               = 32
	AF_KCM                                = 41
	AF_KEY                                = 15
	AF_LLC                                = 26
	AF_LOCAL                              = 1
	AF_MAX                                = 45
	AF_MPLS                               = 28
	AF_NETBEUI                            = 13
	AF_NETLINK                            = 16
	AF_NETROM                             = 6
	AF_NFC                                = 39
	AF_PACKET                             = 17
	AF_PHONET                             = 35
	AF_PPPOX                              = 24
	AF_QIPCRTR                            = 42
	AF_RDS                                = 21
	AF_ROSE                               = 11
	AF_ROUTE                              = 16
	AF_RXRPC                              = 33
	AF_SECURITY                           = 14
	AF_SMC                                = 43
	AF_SNA                                = 22
	AF_TIPC                               = 30
	AF_UNIX                               = 1
	AF_UNSPEC                             = 0
	AF_VSOCK                              = 40
	AF_WANPIPE                            = 25
	AF_X25                                = 9
	AF_XDP                                = 44
	AIO_PRIO_DELTA_MAX                    = 20
	AI_ADDRCONFIG                         = 0x0020
	AI_ALL                                = 0x0010
	AI_CANONNAME                          = 0x0002
	AI_NUMERICHOST                        = 0x0004
	AI_NUMERICSERV                        = 0x0400
	AI_PASSIVE                            = 0x0001
	AI_V4MAPPED                           = 0x0008
	ALLOC_NOBJHIGH                        = 1200
	ALLPERMS                              = 4095
	AT_EACCESS                            = 0x200
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x200
	AT_SYMLINK_FOLLOW                     = 0x400
	AT_SYMLINK_NOFOLLOW                   = 0x100
	BC_BASE_MAX                           = 99
	BC_DIM_MAX                            = 2048
	BC_SCALE_MAX                          = 99
	BC_STRING_MAX                         = 1000
	BG_FLUSH_SCHEDULED                    = 128
	BIG_ENDIAN                            = 4321
	BN_H_                                 = 0
	BUFFER_PADDING                        = 16
	BUILD_tcl                             = 1
	BYTE_ORDER                            = 1234
	CANBSIZ                               = 255
	CANCELED                              = 0x1000
	CHANNELBUFFER_DEFAULT_SIZE            = 4096
	CHANNEL_BLOCKED                       = 2048
	CHANNEL_CLOSED                        = 256
	CHANNEL_CLOSEDWRITE                   = 2097152
	CHANNEL_DEAD                          = 8192
	CHANNEL_EOF                           = 512
	CHANNEL_INCLOSE                       = 524288
	CHANNEL_LINEBUFFERED                  = 16
	CHANNEL_NEED_MORE_DATA                = 16384
	CHANNEL_NONBLOCKING                   = 8
	CHANNEL_RAW_MODE                      = 65536
	CHANNEL_STICKY_EOF                    = 1024
	CHANNEL_UNBUFFERED                    = 32
	CHARCLASS_NAME_MAX                    = 2048
	CHAR_BIT                              = 8
	CHAR_MAX                              = 127
	CHAR_MIN                              = -128
	CLL_END                               = -1
	CLOCK_BOOTTIME                        = 7
	CLOCK_BOOTTIME_ALARM                  = 9
	CLOCK_MONOTONIC                       = 1
	CLOCK_MONOTONIC_COARSE                = 6
	CLOCK_MONOTONIC_RAW                   = 4
	CLOCK_PROCESS_CPUTIME_ID              = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_ALARM                  = 8
	CLOCK_REALTIME_COARSE                 = 5
	CLOCK_TAI                             = 11
	CLOCK_THREAD_CPUTIME_ID               = 3
	CMD_COMPILES_EXPANDED                 = 0x08
	CMD_HAS_EXEC_TRACES                   = 0x04
	CMD_IS_DELETED                        = 0x01
	CMD_REDEF_IN_PROGRESS                 = 0x10
	CMD_TRACE_ACTIVE                      = 0x02
	CMD_VIA_RESOLVER                      = 0x20
	COLL_WEIGHTS_MAX                      = 255
	DBL_DECIMAL_DIG                       = 17
	DBL_DIG                               = 15
	DBL_HAS_SUBNORM                       = 1
	DBL_MANT_DIG                          = 53
	DBL_MAX_10_EXP                        = 308
	DBL_MAX_EXP                           = 1024
	DBL_MIN_10_EXP                        = -307
	DBL_MIN_EXP                           = -1021
	DECIMAL_DIG                           = 21
	DEFFILEMODE                           = 438
	DELAYTIMER_MAX                        = 2147483647
	DELETED                               = 1
	DEV_BSIZE                             = 512
	DICT_PATH_CREATE                      = 5
	DICT_PATH_EXISTS                      = 2
	DICT_PATH_READ                        = 0
	DICT_PATH_UPDATE                      = 1
	DIGIT_BIT                             = 28
	DONT_COMPILE_CMDS_INLINE              = 0x20
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 98
	EADDRNOTAVAIL                         = 99
	EADV                                  = 68
	EAFNOSUPPORT                          = 97
	EAGAIN                                = 11
	EAI_AGAIN                             = -3
	EAI_BADFLAGS                          = -1
	EAI_FAIL                              = -4
	EAI_FAMILY                            = -6
	EAI_MEMORY                            = -10
	EAI_NONAME                            = -2
	EAI_OVERFLOW                          = -12
	EAI_SERVICE                           = -8
	EAI_SOCKTYPE                          = -7
	EAI_SYSTEM                            = -11
	EALREADY                              = 114
	EBADE                                 = 52
	EBADF                                 = 9
	EBADFD                                = 77
	EBADMSG                               = 74
	EBADR                                 = 53
	EBADRQC                               = 56
	EBADSLT                               = 57
	EBFONT                                = 59
	EBUSY                                 = 16
	ECANCELED                             = 125
	ECHILD                                = 10
	ECHRNG                                = 44
	ECOMM                                 = 70
	ECONNABORTED                          = 103
	ECONNREFUSED                          = 111
	ECONNRESET                            = 104
	EDEADLK                               = 35
	EDEADLOCK                             = 35
	EDESTADDRREQ                          = 89
	EDOM                                  = 33
	EDOTDOT                               = 73
	EDQUOT                                = 122
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EHOSTDOWN                             = 112
	EHOSTUNREACH                          = 113
	EHWPOISON                             = 133
	EIDRM                                 = 43
	EILSEQ                                = 84
	EINPROGRESS                           = 115
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 106
	EISDIR                                = 21
	EISNAM                                = 120
	EKEYEXPIRED                           = 127
	EKEYREJECTED                          = 129
	EKEYREVOKED                           = 128
	EL2HLT                                = 51
	EL2NSYNC                              = 45
	EL3HLT                                = 46
	EL3RST                                = 47
	ELIBACC                               = 79
	ELIBBAD                               = 80
	ELIBEXEC                              = 83
	ELIBMAX                               = 82
	ELIBSCN                               = 81
	ELNRNG                                = 48
	ELOOP                                 = 40
	EMEDIUMTYPE                           = 124
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 90
	EMULTIHOP                             = 72
	ENAMETOOLONG                          = 36
	ENAVAIL                               = 119
	ENETDOWN                              = 100
	ENETRESET                             = 102
	ENETUNREACH                           = 101
	ENFILE                                = 23
	ENOANO                                = 55
	ENOBUFS                               = 105
	ENOCSI                                = 50
	ENODATA                               = 61
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOKEY                                = 126
	ENOLCK                                = 37
	ENOLINK                               = 67
	ENOMEDIUM                             = 123
	ENOMEM                                = 12
	ENOMSG                                = 42
	ENONET                                = 64
	ENOPKG                                = 65
	ENOPROTOOPT                           = 92
	ENOSPC                                = 28
	ENOSR                                 = 63
	ENOSTR                                = 60
	ENOSYS                                = 38
	ENOTBLK                               = 15
	ENOTCONN                              = 107
	ENOTDIR                               = 20
	ENOTEMPTY                             = 39
	ENOTNAM                               = 118
	ENOTRECOVERABLE                       = 131
	ENOTSOCK                              = 88
	ENOTSUP                               = 95
	ENOTTY                                = 25
	ENOTUNIQ                              = 76
	ENSEMBLE_COMPILE                      = 0x4
	ENSEMBLE_DEAD                         = 0x1
	ENXIO                                 = 6
	EOPNOTSUPP                            = 95
	EOVERFLOW                             = 75
	EOWNERDEAD                            = 130
	EPERM                                 = 1
	EPFNOSUPPORT                          = 96
	EPIPE                                 = 32
	EPROTO                                = 71
	EPROTONOSUPPORT                       = 93
	EPROTOTYPE                            = 91
	ERANGE                                = 34
	EREMCHG                               = 78
	EREMOTE                               = 66
	EREMOTEIO                             = 121
	ERESTART                              = 85
	ERFKILL                               = 132
	EROFS                                 = 30
	ERR_ALREADY_LOGGED                    = 4
	ERR_LEGACY_COPY                       = 0x800
	ESHUTDOWN                             = 108
	ESOCKTNOSUPPORT                       = 94
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESRMNT                                = 69
	ESTALE                                = 116
	ESTRPIPE                              = 86
	ETIME                                 = 62
	ETIMEDOUT                             = 110
	ETOOMANYREFS                          = 109
	ETXTBSY                               = 26
	EUCLEAN                               = 117
	EUNATCH                               = 49
	EUSERS                                = 87
	EWOULDBLOCK                           = 11
	EXDEV                                 = 18
	EXEC_PAGESIZE                         = 4096
	EXFULL                                = 54
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	EXPR_NEST_MAX                         = 32
	FAPPEND                               = 1024
	FASYNC                                = 8192
	FD_CLOEXEC                            = 1
	FD_SETSIZE                            = 1024
	FFSYNC                                = 1052672
	FIOGETOWN                             = 0x8903
	FIOSETOWN                             = 0x8901
	FLT_DECIMAL_DIG                       = 9
	FLT_DIG                               = 6
	FLT_EPSILON                           = 0
	FLT_EVAL_METHOD                       = 0
	FLT_HAS_SUBNORM                       = 1
	FLT_MANT_DIG                          = 24
	FLT_MAX                               = 0
	FLT_MAX_10_EXP                        = 38
	FLT_MAX_EXP                           = 128
	FLT_MIN                               = 0
	FLT_MIN_10_EXP                        = -37
	FLT_MIN_EXP                           = -125
	FLT_RADIX                             = 2
	FLT_ROUNDS                            = 1
	FLT_TRUE_MIN                          = 0
	FNDELAY                               = 2048
	FNONBLOCK                             = 2048
	FP_ILOGB0                             = -2147483648
	FP_ILOGBNAN                           = -2147483648
	FP_INFINITE1                          = 1
	FP_NAN1                               = 0
	FP_NORMAL1                            = 4
	FP_SUBNORMAL1                         = 3
	FP_XSTATE_MAGIC1                      = 0x46505853
	FP_XSTATE_MAGIC2                      = 0x46505845
	FP_ZERO1                              = 2
	FRAME_IS_LAMBDA                       = 0x2
	FRAME_IS_METHOD                       = 0x4
	FRAME_IS_OO_DEFINE                    = 0x8
	FRAME_IS_PROC                         = 0x1
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 1030
	F_EXLCK                               = 4
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 5
	F_GETLK64                             = 5
	F_GETOWN                              = 9
	F_LOCK                                = 1
	F_OK                                  = 0
	F_RDLCK                               = 0
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 6
	F_SETLK64                             = 6
	F_SETLKW                              = 7
	F_SETLKW64                            = 7
	F_SETOWN                              = 8
	F_SHLCK                               = 8
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_WRLCK                               = 1
	HOST_NAME_MAX                         = 64
	HOST_NOT_FOUND                        = 1
	HZ                                    = 100
	INET6_ADDRSTRLEN                      = 46
	INET_ADDRSTRLEN                       = 16
	INPUT_SAW_CR                          = 4096
	INT16_MAX                             = 32767
	INT16_MIN                             = -32768
	INT32_MAX                             = 2147483647
	INT32_MIN                             = -2147483648
	INT64_MAX                             = 9223372036854775807
	INT64_MIN                             = -9223372036854775808
	INT8_MAX                              = 127
	INT8_MIN                              = -128
	INTERP_ALTERNATE_WRONG_ARGS           = 0x400
	INTERP_DEBUG_FRAME                    = 0x10
	INTERP_TRACE_IN_PROGRESS              = 0x200
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTPTR_MAX                            = 9223372036854775807
	INTPTR_MIN                            = -9223372036854775808
	INT_FAST16_MAX                        = 9223372036854775807
	INT_FAST16_MIN                        = -9223372036854775808
	INT_FAST32_MAX                        = 9223372036854775807
	INT_FAST32_MIN                        = -9223372036854775808
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST8_MAX                         = 127
	INT_FAST8_MIN                         = -128
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	INT_MAX                               = 2147483647
	INT_MIN                               = -2147483648
	IN_CLASSA_HOST                        = 16777215
	IN_CLASSA_MAX                         = 128
	IN_CLASSA_NET                         = 0xff000000
	IN_CLASSA_NSHIFT                      = 24
	IN_CLASSB_HOST                        = 65535
	IN_CLASSB_MAX                         = 65536
	IN_CLASSB_NET                         = 0xffff0000
	IN_CLASSB_NSHIFT                      = 16
	IN_CLASSC_HOST                        = 255
	IN_CLASSC_NET                         = 0xffffff00
	IN_CLASSC_NSHIFT                      = 8
	IN_LOOPBACKNET                        = 127
	IPPORT_RESERVED1                      = 1024
	IPV6_2292DSTOPTS                      = 4
	IPV6_2292HOPLIMIT                     = 8
	IPV6_2292HOPOPTS                      = 3
	IPV6_2292PKTINFO                      = 2
	IPV6_2292PKTOPTIONS                   = 6
	IPV6_2292RTHDR                        = 5
	IPV6_ADDRFORM                         = 1
	IPV6_ADDR_PREFERENCES                 = 72
	IPV6_ADD_MEMBERSHIP                   = 20
	IPV6_AUTHHDR                          = 10
	IPV6_AUTOFLOWLABEL                    = 70
	IPV6_CHECKSUM                         = 7
	IPV6_DONTFRAG                         = 62
	IPV6_DROP_MEMBERSHIP                  = 21
	IPV6_DSTOPTS                          = 59
	IPV6_FREEBIND                         = 78
	IPV6_HDRINCL                          = 36
	IPV6_HOPLIMIT                         = 52
	IPV6_HOPOPTS                          = 54
	IPV6_IPSEC_POLICY                     = 34
	IPV6_JOIN_ANYCAST                     = 27
	IPV6_JOIN_GROUP                       = 20
	IPV6_LEAVE_ANYCAST                    = 28
	IPV6_LEAVE_GROUP                      = 21
	IPV6_MINHOPCOUNT                      = 73
	IPV6_MTU                              = 24
	IPV6_MTU_DISCOVER                     = 23
	IPV6_MULTICAST_ALL                    = 29
	IPV6_MULTICAST_HOPS                   = 18
	IPV6_MULTICAST_IF                     = 17
	IPV6_MULTICAST_LOOP                   = 19
	IPV6_NEXTHOP                          = 9
	IPV6_ORIGDSTADDR                      = 74
	IPV6_PATHMTU                          = 61
	IPV6_PKTINFO                          = 50
	IPV6_PMTUDISC_DO                      = 2
	IPV6_PMTUDISC_DONT                    = 0
	IPV6_PMTUDISC_INTERFACE               = 4
	IPV6_PMTUDISC_OMIT                    = 5
	IPV6_PMTUDISC_PROBE                   = 3
	IPV6_PMTUDISC_WANT                    = 1
	IPV6_RECVDSTOPTS                      = 58
	IPV6_RECVERR                          = 25
	IPV6_RECVFRAGSIZE                     = 77
	IPV6_RECVHOPLIMIT                     = 51
	IPV6_RECVHOPOPTS                      = 53
	IPV6_RECVORIGDSTADDR                  = 74
	IPV6_RECVPATHMTU                      = 60
	IPV6_RECVPKTINFO                      = 49
	IPV6_RECVRTHDR                        = 56
	IPV6_RECVTCLASS                       = 66
	IPV6_ROUTER_ALERT                     = 22
	IPV6_ROUTER_ALERT_ISOLATE             = 30
	IPV6_RTHDR                            = 57
	IPV6_RTHDRDSTOPTS                     = 55
	IPV6_RTHDR_LOOSE                      = 0
	IPV6_RTHDR_STRICT                     = 1
	IPV6_RTHDR_TYPE_0                     = 0
	IPV6_RXDSTOPTS                        = 59
	IPV6_RXHOPOPTS                        = 54
	IPV6_TCLASS                           = 67
	IPV6_TRANSPARENT                      = 75
	IPV6_UNICAST_HOPS                     = 16
	IPV6_UNICAST_IF                       = 76
	IPV6_V6ONLY                           = 26
	IPV6_XFRM_POLICY                      = 35
	IP_ADD_MEMBERSHIP                     = 35
	IP_ADD_SOURCE_MEMBERSHIP              = 39
	IP_BIND_ADDRESS_NO_PORT               = 24
	IP_BLOCK_SOURCE                       = 38
	IP_CHECKSUM                           = 23
	IP_DEFAULT_MULTICAST_LOOP             = 1
	IP_DEFAULT_MULTICAST_TTL              = 1
	IP_DROP_MEMBERSHIP                    = 36
	IP_DROP_SOURCE_MEMBERSHIP             = 40
	IP_FREEBIND                           = 15
	IP_HDRINCL                            = 3
	IP_IPSEC_POLICY                       = 16
	IP_MAX_MEMBERSHIPS                    = 20
	IP_MINTTL                             = 21
	IP_MSFILTER                           = 41
	IP_MTU                                = 14
	IP_MTU_DISCOVER                       = 10
	IP_MULTICAST_ALL                      = 49
	IP_MULTICAST_IF                       = 32
	IP_MULTICAST_LOOP                     = 34
	IP_MULTICAST_TTL                      = 33
	IP_NODEFRAG                           = 22
	IP_OPTIONS                            = 4
	IP_ORIGDSTADDR                        = 20
	IP_PASSSEC                            = 18
	IP_PKTINFO                            = 8
	IP_PKTOPTIONS                         = 9
	IP_PMTUDISC                           = 10
	IP_PMTUDISC_DO                        = 2
	IP_PMTUDISC_DONT                      = 0
	IP_PMTUDISC_INTERFACE                 = 4
	IP_PMTUDISC_OMIT                      = 5
	IP_PMTUDISC_PROBE                     = 3
	IP_PMTUDISC_WANT                      = 1
	IP_RECVERR                            = 11
	IP_RECVFRAGSIZE                       = 25
	IP_RECVOPTS                           = 6
	IP_RECVORIGDSTADDR                    = 20
	IP_RECVRETOPTS                        = 7
	IP_RECVTOS                            = 13
	IP_RECVTTL                            = 12
	IP_RETOPTS                            = 7
	IP_ROUTER_ALERT                       = 5
	IP_TOS                                = 1
	IP_TRANSPARENT                        = 19
	IP_TTL                                = 2
	IP_UNBLOCK_SOURCE                     = 37
	IP_UNICAST_IF                         = 50
	IP_XFRM_POLICY                        = 17
	LC_ADDRESS                            = 9
	LC_ADDRESS_MASK                       = 512
	LC_ALL                                = 6
	LC_ALL_MASK                           = 8127
	LC_COLLATE                            = 3
	LC_COLLATE_MASK                       = 8
	LC_CTYPE                              = 0
	LC_CTYPE_MASK                         = 1
	LC_IDENTIFICATION                     = 12
	LC_IDENTIFICATION_MASK                = 4096
	LC_MEASUREMENT                        = 11
	LC_MEASUREMENT_MASK                   = 2048
	LC_MESSAGES                           = 5
	LC_MESSAGES_MASK                      = 32
	LC_MONETARY                           = 4
	LC_MONETARY_MASK                      = 16
	LC_NAME                               = 8
	LC_NAME_MASK                          = 256
	LC_NUMERIC                            = 1
	LC_NUMERIC_MASK                       = 2
	LC_PAPER                              = 7
	LC_PAPER_MASK                         = 128
	LC_TELEPHONE                          = 10
	LC_TELEPHONE_MASK                     = 1024
	LC_TIME                               = 2
	LC_TIME_MASK                          = 4
	LDBL_DECIMAL_DIG                      = 21
	LDBL_DIG                              = 18
	LDBL_EPSILON                          = 0
	LDBL_HAS_SUBNORM                      = 1
	LDBL_MANT_DIG                         = 64
	LDBL_MAX                              = 0
	LDBL_MAX_10_EXP                       = 4932
	LDBL_MAX_EXP                          = 16384
	LDBL_MIN                              = 0
	LDBL_MIN_10_EXP                       = -4931
	LDBL_MIN_EXP                          = -16381
	LDBL_TRUE_MIN                         = 0
	LINE_MAX                              = 2048
	LITTLE_ENDIAN                         = 1234
	LLONG_MAX                             = 9223372036854775807
	LLONG_MIN                             = -9223372036854775808
	LOCK_EX                               = 2
	LOCK_NB                               = 4
	LOCK_SH                               = 1
	LOCK_UN                               = 8
	LOGIN_NAME_MAX                        = 256
	LONG_MAX                              = 9223372036854775807
	LONG_MIN                              = -9223372036854775808
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MATH_ERREXCEPT                        = 2
	MATH_ERRNO                            = 1
	MAXHOSTNAMELEN                        = 64
	MAXNAMLEN                             = 255
	MAXPATHLEN                            = 4096
	MAXSYMLINKS                           = 20
	MAX_CANON                             = 255
	MAX_INPUT                             = 255
	MAX_NESTING_DEPTH                     = 1000
	MB_LEN_MAX                            = 16
	MCAST_BLOCK_SOURCE                    = 43
	MCAST_EXCLUDE                         = 0
	MCAST_INCLUDE                         = 1
	MCAST_JOIN_GROUP                      = 42
	MCAST_JOIN_SOURCE_GROUP               = 46
	MCAST_LEAVE_GROUP                     = 45
	MCAST_LEAVE_SOURCE_GROUP              = 47
	MCAST_MSFILTER                        = 48
	MCAST_UNBLOCK_SOURCE                  = 44
	MINSIGSTKSZ                           = 2048
	MP_28BIT                              = 0
	MP_BIG_ENDIAN                         = 1
	MP_BUF                                = -5
	MP_DIGIT_BIT                          = 28
	MP_EQ                                 = 0
	MP_ERR                                = -1
	MP_GT                                 = 1
	MP_ITER                               = -4
	MP_LITTLE_ENDIAN                      = -1
	MP_LSB_FIRST                          = -1
	MP_LT                                 = -1
	MP_MEM                                = -2
	MP_MSB_FIRST                          = 1
	MP_NATIVE_ENDIAN                      = 0
	MP_NEG                                = 1
	MP_NO                                 = 0
	MP_OKAY                               = 0
	MP_PRIME_2MSB_ON                      = 0x0008
	MP_PRIME_BBS                          = 0x0001
	MP_PRIME_SAFE                         = 0x0002
	MP_VAL                                = -3
	MP_WORD_DECLARED                      = 0
	MP_YES                                = 1
	MP_ZPOS                               = 0
	MQ_PRIO_MAX                           = 32768
	M_1_PI                                = 0.31830988618379067154
	M_2_PI                                = 0.63661977236758134308
	M_2_SQRTPI                            = 1.12837916709551257390
	M_E                                   = 2.7182818284590452354
	M_LN10                                = 2.30258509299404568402
	M_LN2                                 = 0.69314718055994530942
	M_LOG10E                              = 0.43429448190325182765
	M_LOG2E                               = 1.4426950408889634074
	M_PI                                  = 3.14159265358979323846
	M_PI_2                                = 1.57079632679489661923
	M_PI_4                                = 0.78539816339744830962
	M_SQRT1_2                             = 0.70710678118654752440
	M_SQRT2                               = 1.41421356237309504880
	NAME_MAX                              = 255
	NBBY                                  = 8
	NCARGS                                = 131072
	NETDB_INTERNAL                        = -1
	NETDB_SUCCESS                         = 0
	NGREG                                 = 23
	NGROUPS                               = 65536
	NGROUPS_MAX                           = 65536
	NI_DGRAM                              = 16
	NI_MAXHOST                            = 1025
	NI_MAXSERV                            = 32
	NI_NAMEREQD                           = 8
	NI_NOFQDN                             = 4
	NI_NUMERICHOST                        = 1
	NI_NUMERICSERV                        = 2
	NOFILE                                = 256
	NOGROUP                               = -1
	NO_ADDRESS                            = 4
	NO_DATA                               = 4
	NO_RECOVERY                           = 3
	NRE_ENABLE_ASSERTS                    = 0
	NRE_USE_SMALL_ALLOC                   = 1
	NSIG                                  = 65
	NSS_BUFLEN_GROUP                      = 1024
	NSS_BUFLEN_PASSWD                     = 1024
	NS_DEAD                               = 0x02
	NS_DYING                              = 0x01
	NS_KILLED                             = 0x04
	NS_SUPPRESS_COMPILATION               = 0x08
	O_ACCMODE                             = 0003
	O_APPEND                              = 02000
	O_ASYNC                               = 020000
	O_CLOEXEC                             = 524288
	O_CREAT                               = 0100
	O_DIRECTORY                           = 65536
	O_DSYNC                               = 4096
	O_EXCL                                = 0200
	O_FSYNC                               = 1052672
	O_LARGEFILE                           = 0
	O_NDELAY                              = 2048
	O_NOCTTY                              = 0400
	O_NOFOLLOW                            = 131072
	O_NONBLOCK                            = 04000
	O_RDONLY                              = 00
	O_RDWR                                = 02
	O_RSYNC                               = 1052672
	O_SYNC                                = 04010000
	O_TRUNC                               = 01000
	O_WRONLY                              = 01
	PATH_MAX                              = 4096
	PDP_ENDIAN                            = 3412
	PF_ALG                                = 38
	PF_APPLETALK                          = 5
	PF_ASH                                = 18
	PF_ATMPVC                             = 8
	PF_ATMSVC                             = 20
	PF_AX25                               = 3
	PF_BLUETOOTH                          = 31
	PF_BRIDGE                             = 7
	PF_CAIF                               = 37
	PF_CAN                                = 29
	PF_DECnet                             = 12
	PF_ECONET                             = 19
	PF_FILE                               = 1
	PF_IB                                 = 27
	PF_IEEE802154                         = 36
	PF_INET                               = 2
	PF_INET6                              = 10
	PF_IPX                                = 4
	PF_IRDA                               = 23
	PF_ISDN                               = 34
	PF_IUCV                               = 32
	PF_KCM                                = 41
	PF_KEY                                = 15
	PF_LLC                                = 26
	PF_LOCAL                              = 1
	PF_MAX                                = 45
	PF_MPLS                               = 28
	PF_NETBEUI                            = 13
	PF_NETLINK                            = 16
	PF_NETROM                             = 6
	PF_NFC                                = 39
	PF_PACKET                             = 17
	PF_PHONET                             = 35
	PF_PPPOX                              = 24
	PF_QIPCRTR                            = 42
	PF_RDS                                = 21
	PF_ROSE                               = 11
	PF_ROUTE                              = 16
	PF_RXRPC                              = 33
	PF_SECURITY                           = 14
	PF_SMC                                = 43
	PF_SNA                                = 22
	PF_TIPC                               = 30
	PF_UNIX                               = 1
	PF_UNSPEC                             = 0
	PF_VSOCK                              = 40
	PF_WANPIPE                            = 25
	PF_X25                                = 9
	PF_XDP                                = 44
	PIPE_BUF                              = 4096
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	PRIVATE_MP_PRIME_TAB_SIZE             = 256
	PRIX16                                = "X"
	PRIX32                                = "X"
	PRIX8                                 = "X"
	PRIXFAST8                             = "X"
	PRIXLEAST16                           = "X"
	PRIXLEAST32                           = "X"
	PRIXLEAST8                            = "X"
	PRId16                                = "d"
	PRId32                                = "d"
	PRId8                                 = "d"
	PRIdFAST8                             = "d"
	PRIdLEAST16                           = "d"
	PRIdLEAST32                           = "d"
	PRIdLEAST8                            = "d"
	PRIi16                                = "i"
	PRIi32                                = "i"
	PRIi8                                 = "i"
	PRIiFAST8                             = "i"
	PRIiLEAST16                           = "i"
	PRIiLEAST32                           = "i"
	PRIiLEAST8                            = "i"
	PRIo16                                = "o"
	PRIo32                                = "o"
	PRIo8                                 = "o"
	PRIoFAST8                             = "o"
	PRIoLEAST16                           = "o"
	PRIoLEAST32                           = "o"
	PRIoLEAST8                            = "o"
	PRIu16                                = "u"
	PRIu32                                = "u"
	PRIu8                                 = "u"
	PRIuFAST8                             = "u"
	PRIuLEAST16                           = "u"
	PRIuLEAST32                           = "u"
	PRIuLEAST8                            = "u"
	PRIx16                                = "x"
	PRIx32                                = "x"
	PRIx8                                 = "x"
	PRIxFAST8                             = "x"
	PRIxLEAST16                           = "x"
	PRIxLEAST32                           = "x"
	PRIxLEAST8                            = "x"
	PTHREAD_BARRIER_SERIAL_THREAD         = -1
	PTHREAD_DESTRUCTOR_ITERATIONS         = 4
	PTHREAD_KEYS_MAX                      = 1024
	PTHREAD_ONCE_INIT                     = 0
	PTHREAD_STACK_MIN                     = 16384
	PTRDIFF_MAX                           = 9223372036854775807
	PTRDIFF_MIN                           = -9223372036854775808
	RAND_MAX                              = 2147483647
	RAND_SEED_INITIALIZED                 = 0x40
	REG_ADVANCED                          = 000003
	REG_ADVF                              = 000002
	REG_ASSERT                            = 15
	REG_ATOI                              = 101
	REG_BADBR                             = 10
	REG_BADOPT                            = 18
	REG_BADPAT                            = 2
	REG_BADRPT                            = 13
	REG_BASIC                             = 000000
	REG_BOSONLY                           = 002000
	REG_DUMP                              = 004000
	REG_EBRACE                            = 9
	REG_EBRACK                            = 7
	REG_ECOLLATE                          = 3
	REG_ECOLORS                           = 20
	REG_ECTYPE                            = 4
	REG_EESCAPE                           = 5
	REG_EPAREN                            = 8
	REG_ERANGE                            = 11
	REG_ESPACE                            = 12
	REG_ESUBREG                           = 6
	REG_ETOOBIG                           = 19
	REG_EXPANDED                          = 000040
	REG_EXPECT                            = 001000
	REG_EXTENDED                          = 000001
	REG_FAKE                              = 010000
	REG_FTRACE                            = 0010
	REG_ICASE                             = 000010
	REG_INVARG                            = 16
	REG_ITOA                              = 102
	REG_MIXED                             = 17
	REG_MTRACE                            = 0020
	REG_NEWLINE                           = 000300
	REG_NLANCH                            = 000200
	REG_NLSTOP                            = 000100
	REG_NOMATCH                           = 1
	REG_NOSPEC                            = 4
	REG_NOSUB                             = 000020
	REG_NOTBOL                            = 0001
	REG_NOTEOL                            = 0002
	REG_OKAY                              = 0
	REG_PEND                              = 000400
	REG_PROGRESS                          = 020000
	REG_QUOTE                             = 000004
	REG_SMALL                             = 0040
	REG_STARTEND                          = 0004
	REG_UBACKREF                          = 000001
	REG_UBBS                              = 000100
	REG_UBOUNDS                           = 000004
	REG_UBRACES                           = 000010
	REG_UBSALNUM                          = 000020
	REG_UEMPTYMATCH                       = 004000
	REG_UIMPOSSIBLE                       = 010000
	REG_ULOCALE                           = 002000
	REG_ULOOKAHEAD                        = 000002
	REG_UNONPOSIX                         = 000200
	REG_UPBOTCH                           = 000040
	REG_USHORTEST                         = 020000
	REG_UUNPORT                           = 001000
	REG_UUNSPEC                           = 000400
	RESOLVER_KEY                          = "testInterpResolver"
	RE_DUP_MAX                            = 32767
	RTSIG_MAX                             = 32
	R_OK                                  = 4
	SAFE_INTERP                           = 0x80
	SA_INTERRUPT                          = 0x20000000
	SA_NOCLDSTOP                          = 1
	SA_NOCLDWAIT                          = 2
	SA_NODEFER                            = 0x40000000
	SA_NOMASK                             = 1073741824
	SA_ONESHOT                            = 2147483648
	SA_ONSTACK                            = 0x08000000
	SA_RESETHAND                          = 0x80000000
	SA_RESTART                            = 0x10000000
	SA_SIGINFO                            = 4
	SA_STACK                              = 134217728
	SCHAR_MAX                             = 127
	SCHAR_MIN                             = -128
	SCHED_FIFO                            = 1
	SCHED_OTHER                           = 0
	SCHED_RR                              = 2
	SCM_TIMESTAMP                         = 29
	SCM_TIMESTAMPING                      = 37
	SCM_TIMESTAMPING_OPT_STATS            = 54
	SCM_TIMESTAMPING_PKTINFO              = 58
	SCM_TIMESTAMPNS                       = 35
	SCM_TXTIME                            = 61
	SCM_WIFI_STATUS                       = 41
	SCNd16                                = "hd"
	SCNd32                                = "d"
	SCNd8                                 = "hhd"
	SCNdFAST8                             = "hhd"
	SCNdLEAST16                           = "hd"
	SCNdLEAST32                           = "d"
	SCNdLEAST8                            = "hhd"
	SCNi16                                = "hi"
	SCNi32                                = "i"
	SCNi8                                 = "hhi"
	SCNiFAST8                             = "hhi"
	SCNiLEAST16                           = "hi"
	SCNiLEAST32                           = "i"
	SCNiLEAST8                            = "hhi"
	SCNo16                                = "ho"
	SCNo32                                = "o"
	SCNo8                                 = "hho"
	SCNoFAST8                             = "hho"
	SCNoLEAST16                           = "ho"
	SCNoLEAST32                           = "o"
	SCNoLEAST8                            = "hho"
	SCNu16                                = "hu"
	SCNu32                                = "u"
	SCNu8                                 = "hhu"
	SCNuFAST8                             = "hhu"
	SCNuLEAST16                           = "hu"
	SCNuLEAST32                           = "u"
	SCNuLEAST8                            = "hhu"
	SCNx16                                = "hx"
	SCNx32                                = "x"
	SCNx8                                 = "hhx"
	SCNxFAST8                             = "hhx"
	SCNxLEAST16                           = "hx"
	SCNxLEAST32                           = "x"
	SCNxLEAST8                            = "hhx"
	SEM_VALUE_MAX                         = 2147483647
	SHRT_MAX                              = 32767
	SHRT_MIN                              = -32768
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 7
	SIGCHLD                               = 17
	SIGCLD                                = 17
	SIGCONT                               = 18
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINT                                = 2
	SIGIO                                 = 29
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGPIPE                               = 13
	SIGPOLL                               = 29
	SIGPROF                               = 27
	SIGPWR                                = 30
	SIGQUIT                               = 3
	SIGSEGV                               = 11
	SIGSTKFLT                             = 16
	SIGSTKSZ                              = 8192
	SIGSTOP                               = 19
	SIGSYS                                = 31
	SIGTERM                               = 15
	SIGTRAP                               = 5
	SIGTSTP                               = 20
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 23
	SIGUSR1                               = 10
	SIGUSR2                               = 12
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_ATOMIC_MAX                        = 2147483647
	SIG_ATOMIC_MIN                        = -2147483648
	SIG_BLOCK                             = 0
	SIG_SETMASK                           = 2
	SIG_UNBLOCK                           = 1
	SIOCATMARK                            = 0x8905
	SIOCGPGRP                             = 0x8904
	SIOCGSTAMP                            = 0x8906
	SIOCGSTAMPNS                          = 0x8907
	SIOCSPGRP                             = 0x8902
	SIZE_MAX                              = 18446744073709551615
	SOL_AAL                               = 265
	SOL_ALG                               = 279
	SOL_ATM                               = 264
	SOL_BLUETOOTH                         = 274
	SOL_CAIF                              = 278
	SOL_DCCP                              = 269
	SOL_DECNET                            = 261
	SOL_ICMPV6                            = 58
	SOL_IP                                = 0
	SOL_IPV6                              = 41
	SOL_IRDA                              = 266
	SOL_IUCV                              = 277
	SOL_KCM                               = 281
	SOL_LLC                               = 268
	SOL_NETBEUI                           = 267
	SOL_NETLINK                           = 270
	SOL_NFC                               = 280
	SOL_PACKET                            = 263
	SOL_PNPIPE                            = 275
	SOL_PPPOL2TP                          = 273
	SOL_RAW                               = 255
	SOL_RDS                               = 276
	SOL_RXRPC                             = 272
	SOL_SOCKET                            = 1
	SOL_TIPC                              = 271
	SOL_TLS                               = 282
	SOL_X25                               = 262
	SOL_XDP                               = 283
	SOMAXCONN                             = 4096
	SO_ACCEPTCONN                         = 30
	SO_ATTACH_BPF                         = 50
	SO_ATTACH_FILTER                      = 26
	SO_ATTACH_REUSEPORT_CBPF              = 51
	SO_ATTACH_REUSEPORT_EBPF              = 52
	SO_BINDTODEVICE                       = 25
	SO_BINDTOIFINDEX                      = 62
	SO_BPF_EXTENSIONS                     = 48
	SO_BROADCAST                          = 6
	SO_BSDCOMPAT                          = 14
	SO_BUSY_POLL                          = 46
	SO_CNX_ADVICE                         = 53
	SO_COOKIE                             = 57
	SO_DEBUG                              = 1
	SO_DETACH_BPF                         = 27
	SO_DETACH_FILTER                      = 27
	SO_DETACH_REUSEPORT_BPF               = 68
	SO_DOMAIN                             = 39
	SO_DONTROUTE                          = 5
	SO_ERROR                              = 4
	SO_GET_FILTER                         = 26
	SO_INCOMING_CPU                       = 49
	SO_INCOMING_NAPI_ID                   = 56
	SO_KEEPALIVE                          = 9
	SO_LINGER                             = 13
	SO_LOCK_FILTER                        = 44
	SO_MARK                               = 36
	SO_MAX_PACING_RATE                    = 47
	SO_MEMINFO                            = 55
	SO_NOFCS                              = 43
	SO_NO_CHECK                           = 11
	SO_OOBINLINE                          = 10
	SO_PASSCRED                           = 16
	SO_PASSSEC                            = 34
	SO_PEEK_OFF                           = 42
	SO_PEERCRED                           = 17
	SO_PEERGROUPS                         = 59
	SO_PEERNAME                           = 28
	SO_PEERSEC                            = 31
	SO_PRIORITY                           = 12
	SO_PROTOCOL                           = 38
	SO_RCVBUF                             = 8
	SO_RCVBUFFORCE                        = 33
	SO_RCVLOWAT                           = 18
	SO_RCVTIMEO                           = 20
	SO_RCVTIMEO_NEW                       = 66
	SO_RCVTIMEO_OLD                       = 20
	SO_REUSEADDR                          = 2
	SO_REUSEPORT                          = 15
	SO_RXQ_OVFL                           = 40
	SO_SECURITY_AUTHENTICATION            = 22
	SO_SECURITY_ENCRYPTION_NETWORK        = 24
	SO_SECURITY_ENCRYPTION_TRANSPORT      = 23
	SO_SELECT_ERR_QUEUE                   = 45
	SO_SNDBUF                             = 7
	SO_SNDBUFFORCE                        = 32
	SO_SNDLOWAT                           = 19
	SO_SNDTIMEO                           = 21
	SO_SNDTIMEO_NEW                       = 67
	SO_SNDTIMEO_OLD                       = 21
	SO_TIMESTAMP                          = 29
	SO_TIMESTAMPING                       = 37
	SO_TIMESTAMPING_NEW                   = 65
	SO_TIMESTAMPING_OLD                   = 37
	SO_TIMESTAMPNS                        = 35
	SO_TIMESTAMPNS_NEW                    = 64
	SO_TIMESTAMPNS_OLD                    = 35
	SO_TIMESTAMP_NEW                      = 63
	SO_TIMESTAMP_OLD                      = 29
	SO_TXTIME                             = 61
	SO_TYPE                               = 3
	SO_WIFI_STATUS                        = 41
	SO_ZEROCOPY                           = 60
	SSIZE_MAX                             = 9223372036854775807
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	SYNTHETIC_EVENT_TIME                  = 0
	SYS_NMLN                              = 65
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 24576
	S_IFCHR                               = 8192
	S_IFDIR                               = 16384
	S_IFIFO                               = 4096
	S_IFLNK                               = 40960
	S_IFMT                                = 61440
	S_IFREG                               = 32768
	S_IFSOCK                              = 49152
	S_IREAD                               = 256
	S_IRGRP                               = 32
	S_IROTH                               = 4
	S_IRUSR                               = 256
	S_IRWXG                               = 56
	S_IRWXO                               = 7
	S_IRWXU                               = 448
	S_ISGID                               = 1024
	S_ISUID                               = 2048
	S_ISVTX                               = 512
	S_IWGRP                               = 16
	S_IWOTH                               = 2
	S_IWRITE                              = 128
	S_IWUSR                               = 128
	S_IXGRP                               = 8
	S_IXOTH                               = 1
	S_IXUSR                               = 64
	TCLOO_H_INCLUDED                      = 0
	TCLOO_VERSION                         = "1.1.0"
	TCLTOMMATH_EPOCH                      = 0
	TCLTOMMATH_REVISION                   = 0
	TCL_ALLOW_EXCEPTIONS                  = 0x04
	TCL_AVOID_RESOLVERS                   = 0x40000
	TCL_CREATE_NS_IF_UNKNOWN              = 0x800
	TCL_DD_CONVERSION_TYPE_MASK           = 0x3
	TCL_DD_E_FORMAT                       = 0x2
	TCL_DD_F_FORMAT                       = 0x3
	TCL_DD_NO_QUICK                       = 0x8
	TCL_DD_SHORTEN_FLAG                   = 0x4
	TCL_DD_SHORTEST                       = 0x4
	TCL_DD_SHORTEST0                      = 0x0
	TCL_DD_STEELE                         = 0x5
	TCL_DD_STEELE0                        = 0x1
	TCL_EACH_COLLECT                      = 1
	TCL_EACH_KEEP_NONE                    = 0
	TCL_EVAL_DISCARD_RESULT               = 0x40
	TCL_EVAL_FILE                         = 0x02
	TCL_EVAL_NORESOLVE                    = 0x20
	TCL_EVAL_SOURCE_IN_FRAME              = 0x10
	TCL_FIND_ONLY_NS                      = 0x1000
	TCL_GLOBMODE_DIR                      = 4
	TCL_GLOBMODE_JOIN                     = 2
	TCL_GLOBMODE_NO_COMPLAIN              = 1
	TCL_GLOBMODE_TAILS                    = 8
	TCL_INDEX_AFTER                       = 2147483647
	TCL_INDEX_BEFORE                      = -1
	TCL_INDEX_END                         = -2
	TCL_INDEX_START                       = 0
	TCL_INVOKE_HIDDEN                     = 1
	TCL_INVOKE_NO_TRACEBACK               = 4
	TCL_INVOKE_NO_UNKNOWN                 = 2
	TCL_LOCATION_BC                       = 2
	TCL_LOCATION_EVAL                     = 0
	TCL_LOCATION_LAST                     = 6
	TCL_LOCATION_PREBC                    = 3
	TCL_LOCATION_PROC                     = 5
	TCL_LOCATION_SOURCE                   = 4
	TCL_MIN_GROWTH                        = 1024
	TCL_NUMBER_BIG                        = 3
	TCL_NUMBER_DOUBLE                     = 4
	TCL_NUMBER_LONG                       = 1
	TCL_NUMBER_NAN                        = 5
	TCL_NUMBER_WIDE                       = 2
	TCL_OO_METADATA_VERSION_CURRENT       = 1
	TCL_OO_METHOD_VERSION_CURRENT         = 1
	TCL_OUT_LINE_COMPILE                  = 1
	TCL_PARSE_BINARY_ONLY                 = 64
	TCL_PARSE_DECIMAL_ONLY                = 1
	TCL_PARSE_HEXADECIMAL_ONLY            = 4
	TCL_PARSE_INTEGER_ONLY                = 8
	TCL_PARSE_NO_WHITESPACE               = 32
	TCL_PARSE_OCTAL_ONLY                  = 2
	TCL_PARSE_SCAN_PREFIXES               = 16
	TCL_REG_BOSONLY                       = 002000
	TCL_TRACE_ENTER_EXEC                  = 1
	TCL_TRACE_LEAVE_EXEC                  = 2
	TIMER_ABSTIME                         = 1
	TIME_UTC                              = 1
	TRY_AGAIN                             = 2
	TTY_NAME_MAX                          = 32
	UCHAR_MAX                             = 255
	UINT16_MAX                            = 65535
	UINT32_MAX                            = 4294967295
	UINT64_MAX                            = 18446744073709551615
	UINT8_MAX                             = 255
	UINTMAX_MAX                           = 18446744073709551615
	UINTPTR_MAX                           = 18446744073709551615
	UINT_FAST16_MAX                       = 18446744073709551615
	UINT_FAST32_MAX                       = 18446744073709551615
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST8_MAX                        = 255
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST8_MAX                       = 255
	UINT_MAX                              = 4294967295
	ULLONG_MAX                            = 18446744073709551615
	ULONG_MAX                             = 18446744073709551615
	USE_TCLOO_STUBS                       = 0
	USE_TCL_STUBS                         = 0
	USHRT_MAX                             = 65535
	UTIME_NOW                             = 1073741823
	UTIME_OMIT                            = 1073741822
	VAR_ALL_HASH                          = 4236
	VAR_ALL_TRACES                        = 2160
	VAR_ARGUMENT                          = 0x100
	VAR_ARRAY                             = 0x1
	VAR_ARRAY_ELEMENT                     = 0x1000
	VAR_DEAD_HASH                         = 0x8
	VAR_IN_HASHTABLE                      = 0x4
	VAR_IS_ARGS                           = 0x400
	VAR_LINK                              = 0x2
	VAR_NAMESPACE_VAR                     = 0x80
	VAR_RESOLVED                          = 0x8000
	VAR_SEARCH_ACTIVE                     = 0x4000
	VAR_TEMPORARY                         = 0x200
	VAR_TRACED_ARRAY                      = 0x800
	VAR_TRACED_READ                       = 0x10
	VAR_TRACED_UNSET                      = 0x40
	VAR_TRACED_WRITE                      = 0x20
	VAR_TRACE_ACTIVE                      = 0x2000
	WAIT_ANY                              = -1
	WAIT_MYPGRP                           = 0
	WCHAR_MAX                             = 2147483647
	WCHAR_MIN                             = -2147483648
	WCONTINUED                            = 8
	WCOREFLAG                             = 128
	WEXITED                               = 4
	WINT_MAX                              = 4294967295
	WINT_MIN                              = 0
	WNOHANG                               = 1
	WNOWAIT                               = 0x01000000
	WSTOPPED                              = 2
	WUNTRACED                             = 2
	W_OK                                  = 2
	XATTR_LIST_MAX                        = 65536
	XATTR_NAME_MAX                        = 255
	XATTR_SIZE_MAX                        = 65536
	X_OK                                  = 1
	X_ALLOCA_H                            = 1
	X_ANSI_STDDEF_H                       = 0
	X_ARPA_INET_H                         = 1
	X_ASM_GENERIC_ERRNO_BASE_H            = 0
	X_ASM_GENERIC_ERRNO_H                 = 0
	X_ASM_X86_POSIX_TYPES_64_H            = 0
	X_BITS_BYTESWAP_H                     = 1
	X_BITS_CPU_SET_H                      = 1
	X_BITS_ENDIANNESS_H                   = 1
	X_BITS_ENDIAN_H                       = 1
	X_BITS_ERRNO_H                        = 1
	X_BITS_FLOATN_COMMON_H                = 0
	X_BITS_FLOATN_H                       = 0
	X_BITS_LIBM_SIMD_DECL_STUBS_H         = 1
	X_BITS_LOCALE_H                       = 1
	X_BITS_POSIX1_LIM_H                   = 1
	X_BITS_POSIX2_LIM_H                   = 1
	X_BITS_POSIX_OPT_H                    = 1
	X_BITS_PTHREADTYPES_ARCH_H            = 1
	X_BITS_PTHREADTYPES_COMMON_H          = 1
	X_BITS_SCHED_H                        = 1
	X_BITS_SETJMP_H                       = 1
	X_BITS_SIGACTION_H                    = 1
	X_BITS_SIGCONTEXT_H                   = 1
	X_BITS_SIGEVENT_CONSTS_H              = 1
	X_BITS_SIGINFO_ARCH_H                 = 1
	X_BITS_SIGINFO_CONSTS_H               = 1
	X_BITS_SIGNUM_GENERIC_H               = 1
	X_BITS_SIGNUM_H                       = 1
	X_BITS_SIGSTACK_H                     = 1
	X_BITS_SIGTHREAD_H                    = 1
	X_BITS_SOCKADDR_H                     = 1
	X_BITS_SS_FLAGS_H                     = 1
	X_BITS_STAT_H                         = 1
	X_BITS_STDINT_INTN_H                  = 1
	X_BITS_STDINT_UINTN_H                 = 1
	X_BITS_TIME_H                         = 1
	X_BITS_TYPES_LOCALE_T_H               = 1
	X_BITS_TYPES_STRUCT_SCHED_PARAM       = 1
	X_BITS_TYPES___LOCALE_T_H             = 1
	X_BITS_UINTN_IDENTITY_H               = 1
	X_BITS_WCHAR_H                        = 1
	X_BSD_PTRDIFF_T_                      = 0
	X_CTYPE_H                             = 1
	X_DIRENT_H                            = 1
	X_DIRENT_HAVE_D_OFF                   = 0
	X_DIRENT_HAVE_D_RECLEN                = 0
	X_DIRENT_HAVE_D_TYPE                  = 0
	X_DIRENT_MATCHES_DIRENT64             = 1
	X_ENDIAN_H                            = 1
	X_ERRNO_H                             = 1
	X_FCNTL_H                             = 1
	X_FLOAT_H___                          = 0
	X_GCC_LIMITS_H_                       = 0
	X_GCC_MAX_ALIGN_T                     = 0
	X_GCC_PTRDIFF_T                       = 0
	X_GCC_WCHAR_T                         = 0
	X_GCC_WRAP_STDINT_H                   = 0
	X_GETOPT_CORE_H                       = 1
	X_GETOPT_POSIX_H                      = 1
	X_GRP_H                               = 1
	X_INTTYPES_H                          = 1
	X_LFS64_ASYNCHRONOUS_IO               = 1
	X_LFS64_LARGEFILE                     = 1
	X_LFS64_STDIO                         = 1
	X_LFS_ASYNCHRONOUS_IO                 = 1
	X_LFS_LARGEFILE                       = 1
	X_LIBC_LIMITS_H_                      = 1
	X_LIMITS_H___                         = 0
	X_LINUX_LIMITS_H                      = 0
	X_LINUX_PARAM_H                       = 0
	X_LINUX_POSIX_TYPES_H                 = 0
	X_LOCALE_H                            = 1
	X_MATH_H                              = 1
	X_MKNOD_VER                           = 0
	X_MKNOD_VER_LINUX                     = 0
	X_NETDB_H                             = 1
	X_NETINET_IN_H                        = 1
	X_NSIG                                = 65
	X_PATH_HEQUIV                         = "/etc/hosts.equiv"
	X_PATH_HOSTS                          = "/etc/hosts"
	X_PATH_NETWORKS                       = "/etc/networks"
	X_PATH_NSSWITCH_CONF                  = "/etc/nsswitch.conf"
	X_PATH_PROTOCOLS                      = "/etc/protocols"
	X_PATH_SERVICES                       = "/etc/services"
	X_POSIX2_BC_BASE_MAX                  = 99
	X_POSIX2_BC_DIM_MAX                   = 2048
	X_POSIX2_BC_SCALE_MAX                 = 99
	X_POSIX2_BC_STRING_MAX                = 1000
	X_POSIX2_CHARCLASS_NAME_MAX           = 14
	X_POSIX2_CHAR_TERM                    = 200809
	X_POSIX2_COLL_WEIGHTS_MAX             = 2
	X_POSIX2_C_BIND                       = 200809
	X_POSIX2_C_DEV                        = 200809
	X_POSIX2_C_VERSION                    = 200809
	X_POSIX2_EXPR_NEST_MAX                = 32
	X_POSIX2_LINE_MAX                     = 2048
	X_POSIX2_LOCALEDEF                    = 200809
	X_POSIX2_RE_DUP_MAX                   = 255
	X_POSIX2_SW_DEV                       = 200809
	X_POSIX2_VERSION                      = 200809
	X_POSIX_ADVISORY_INFO                 = 200809
	X_POSIX_AIO_LISTIO_MAX                = 2
	X_POSIX_AIO_MAX                       = 1
	X_POSIX_ARG_MAX                       = 4096
	X_POSIX_ASYNCHRONOUS_IO               = 200809
	X_POSIX_ASYNC_IO                      = 1
	X_POSIX_BARRIERS                      = 200809
	X_POSIX_CHILD_MAX                     = 25
	X_POSIX_CHOWN_RESTRICTED              = 0
	X_POSIX_CLOCKRES_MIN                  = 20000000
	X_POSIX_CLOCK_SELECTION               = 200809
	X_POSIX_CPUTIME                       = 0
	X_POSIX_DELAYTIMER_MAX                = 32
	X_POSIX_FSYNC                         = 200809
	X_POSIX_HOST_NAME_MAX                 = 255
	X_POSIX_IPV6                          = 200809
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_LINK_MAX                      = 8
	X_POSIX_LOGIN_NAME_MAX                = 9
	X_POSIX_MAPPED_FILES                  = 200809
	X_POSIX_MAX_CANON                     = 255
	X_POSIX_MAX_INPUT                     = 255
	X_POSIX_MEMLOCK                       = 200809
	X_POSIX_MEMLOCK_RANGE                 = 200809
	X_POSIX_MEMORY_PROTECTION             = 200809
	X_POSIX_MESSAGE_PASSING               = 200809
	X_POSIX_MONOTONIC_CLOCK               = 0
	X_POSIX_MQ_OPEN_MAX                   = 8
	X_POSIX_MQ_PRIO_MAX                   = 32
	X_POSIX_NAME_MAX                      = 14
	X_POSIX_NGROUPS_MAX                   = 8
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_OPEN_MAX                      = 20
	X_POSIX_PATH_MAX                      = 256
	X_POSIX_PIPE_BUF                      = 512
	X_POSIX_PRIORITIZED_IO                = 200809
	X_POSIX_PRIORITY_SCHEDULING           = 200809
	X_POSIX_RAW_SOCKETS                   = 200809
	X_POSIX_READER_WRITER_LOCKS           = 200809
	X_POSIX_REALTIME_SIGNALS              = 200809
	X_POSIX_REENTRANT_FUNCTIONS           = 1
	X_POSIX_REGEXP                        = 1
	X_POSIX_RE_DUP_MAX                    = 255
	X_POSIX_RTSIG_MAX                     = 8
	X_POSIX_SAVED_IDS                     = 1
	X_POSIX_SEMAPHORES                    = 200809
	X_POSIX_SEM_NSEMS_MAX                 = 256
	X_POSIX_SEM_VALUE_MAX                 = 32767
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200809
	X_POSIX_SHELL                         = 1
	X_POSIX_SIGQUEUE_MAX                  = 32
	X_POSIX_SPAWN                         = 200809
	X_POSIX_SPIN_LOCKS                    = 200809
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SSIZE_MAX                     = 32767
	X_POSIX_STREAM_MAX                    = 8
	X_POSIX_SYMLINK_MAX                   = 255
	X_POSIX_SYMLOOP_MAX                   = 8
	X_POSIX_SYNCHRONIZED_IO               = 200809
	X_POSIX_THREADS                       = 200809
	X_POSIX_THREAD_ATTR_STACKADDR         = 200809
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200809
	X_POSIX_THREAD_CPUTIME                = 0
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS  = 4
	X_POSIX_THREAD_KEYS_MAX               = 128
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200809
	X_POSIX_THREAD_PRIO_INHERIT           = 200809
	X_POSIX_THREAD_PRIO_PROTECT           = 200809
	X_POSIX_THREAD_PROCESS_SHARED         = 200809
	X_POSIX_THREAD_ROBUST_PRIO_INHERIT    = 200809
	X_POSIX_THREAD_ROBUST_PRIO_PROTECT    = -1
	X_POSIX_THREAD_SAFE_FUNCTIONS         = 200809
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_THREAD_THREADS_MAX            = 64
	X_POSIX_TIMEOUTS                      = 200809
	X_POSIX_TIMERS                        = 200809
	X_POSIX_TIMER_MAX                     = 32
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TTY_NAME_MAX                  = 9
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_TZNAME_MAX                    = 6
	X_POSIX_V6_LP64_OFF64                 = 1
	X_POSIX_V6_LPBIG_OFFBIG               = -1
	X_POSIX_V7_LP64_OFF64                 = 1
	X_POSIX_V7_LPBIG_OFFBIG               = -1
	X_POSIX_VDISABLE                      = 0
	X_POSIX_VERSION                       = 200809
	X_PTHREAD_H                           = 1
	X_PTRDIFF_T                           = 0
	X_PTRDIFF_T_                          = 0
	X_PTRDIFF_T_DECLARED                  = 0
	X_PWD_H                               = 1
	X_REGEX_H_                            = 0
	X_RPC_NETDB_H                         = 1
	X_RWLOCK_INTERNAL_H                   = 0
	X_SCHED_H                             = 1
	X_SIGNAL_H                            = 0
	X_SS_SIZE                             = 128
	X_STATBUF_ST_BLKSIZE                  = 0
	X_STATBUF_ST_NSEC                     = 0
	X_STATBUF_ST_RDEV                     = 0
	X_STAT_VER                            = 1
	X_STAT_VER_KERNEL                     = 0
	X_STAT_VER_LINUX                      = 1
	X_STDDEF_H                            = 0
	X_STDDEF_H_                           = 0
	X_STDINT_H                            = 1
	X_STDLIB_H                            = 1
	X_STRINGS_H                           = 1
	X_STRING_H                            = 1
	X_STRUCT_TIMESPEC                     = 1
	X_SYS_FILE_H                          = 1
	X_SYS_PARAM_H                         = 1
	X_SYS_SELECT_H                        = 1
	X_SYS_SOCKET_H                        = 1
	X_SYS_STAT_H                          = 1
	X_SYS_TIME_H                          = 1
	X_SYS_TYPES_H                         = 1
	X_SYS_UCONTEXT_H                      = 1
	X_SYS_UTSNAME_H                       = 1
	X_SYS_WAIT_H                          = 1
	X_TCLINT                              = 0
	X_TCLINTDECLS                         = 0
	X_TCLINTPLATDECLS                     = 0
	X_TCLOODECLS                          = 0
	X_TCLPORT                             = 0
	X_TCLREGEXP                           = 0
	X_TCLTOMMATHDECLS                     = 0
	X_TCLUNIXPORT                         = 0
	X_THREAD_MUTEX_INTERNAL_H             = 1
	X_THREAD_SHARED_TYPES_H               = 1
	X_TIME_H                              = 1
	X_T_PTRDIFF                           = 0
	X_T_PTRDIFF_                          = 0
	X_T_WCHAR                             = 0
	X_T_WCHAR_                            = 0
	X_UNISTD_H                            = 1
	X_UTIME_H                             = 1
	X_UTSNAME_DOMAIN_LENGTH               = 65
	X_UTSNAME_LENGTH                      = 65
	X_UTSNAME_MACHINE_LENGTH              = 65
	X_UTSNAME_NODENAME_LENGTH             = 65
	X_UTSNAME_RELEASE_LENGTH              = 65
	X_UTSNAME_SYSNAME_LENGTH              = 65
	X_UTSNAME_VERSION_LENGTH              = 65
	X_WCHAR_T                             = 0
	X_WCHAR_T_                            = 0
	X_WCHAR_T_DECLARED                    = 0
	X_WCHAR_T_DEFINED                     = 0
	X_WCHAR_T_DEFINED_                    = 0
	X_WCHAR_T_H                           = 0
	X_XBS5_LP64_OFF64                     = 1
	X_XBS5_LPBIG_OFFBIG                   = -1
	X_XOPEN_ENH_I18N                      = 1
	X_XOPEN_LEGACY                        = 1
	X_XOPEN_REALTIME                      = 1
	X_XOPEN_REALTIME_THREADS              = 1
	X_XOPEN_SHM                           = 1
	X_XOPEN_UNIX                          = 1
	X_XOPEN_VERSION                       = 700
	X_XOPEN_XCU_VERSION                   = 4
	X_XOPEN_XPG2                          = 1
	X_XOPEN_XPG3                          = 1
	X_XOPEN_XPG4                          = 1
	Math_errhandling                      = 3
	BN_CUTOFFS_C                          = 0
	BN_DEPRECATED_C                       = 0
	BN_FAST_MP_INVMOD_C                   = 0
	BN_FAST_MP_MONTGOMERY_REDUCE_C        = 0
	BN_FAST_S_MP_MUL_DIGS_C               = 0
	BN_FAST_S_MP_MUL_HIGH_DIGS_C          = 0
	BN_FAST_S_MP_SQR_C                    = 0
	BN_MP_2EXPT_C                         = 0
	BN_MP_ABS_C                           = 0
	BN_MP_ADDMOD_C                        = 0
	BN_MP_ADD_C                           = 0
	BN_MP_ADD_D_C                         = 0
	BN_MP_AND_C                           = 0
	BN_MP_BALANCE_MUL_C                   = 0
	BN_MP_CLAMP_C                         = 0
	BN_MP_CLEAR_C                         = 0
	BN_MP_CLEAR_MULTI_C                   = 0
	BN_MP_CMP_C                           = 0
	BN_MP_CMP_D_C                         = 0
	BN_MP_CMP_MAG_C                       = 0
	BN_MP_CNT_LSB_C                       = 0
	BN_MP_COMPLEMENT_C                    = 0
	BN_MP_COPY_C                          = 0
	BN_MP_COUNT_BITS_C                    = 0
	BN_MP_DECR_C                          = 0
	BN_MP_DIV_2D_C                        = 0
	BN_MP_DIV_2_C                         = 0
	BN_MP_DIV_3_C                         = 0
	BN_MP_DIV_C                           = 0
	BN_MP_DIV_D_C                         = 0
	BN_MP_DR_IS_MODULUS_C                 = 0
	BN_MP_DR_REDUCE_C                     = 0
	BN_MP_DR_SETUP_C                      = 0
	BN_MP_ERROR_TO_STRING_C               = 0
	BN_MP_EXCH_C                          = 0
	BN_MP_EXPORT_C                        = 0
	BN_MP_EXPTMOD_C                       = 0
	BN_MP_EXPTMOD_FAST_C                  = 0
	BN_MP_EXPT_D_C                        = 0
	BN_MP_EXPT_D_EX_C                     = 0
	BN_MP_EXPT_U32_C                      = 0
	BN_MP_EXTEUCLID_C                     = 0
	BN_MP_FREAD_C                         = 0
	BN_MP_FROM_SBIN_C                     = 0
	BN_MP_FROM_UBIN_C                     = 0
	BN_MP_FWRITE_C                        = 0
	BN_MP_GCD_C                           = 0
	BN_MP_GET_BIT_C                       = 0
	BN_MP_GET_DOUBLE_C                    = 0
	BN_MP_GET_I32_C                       = 0
	BN_MP_GET_I64_C                       = 0
	BN_MP_GET_INT_C                       = 0
	BN_MP_GET_LL_C                        = 0
	BN_MP_GET_LONG_C                      = 0
	BN_MP_GET_LONG_LONG_C                 = 0
	BN_MP_GET_L_C                         = 0
	BN_MP_GET_MAG_U32_C                   = 0
	BN_MP_GET_MAG_U64_C                   = 0
	BN_MP_GET_MAG_ULL_C                   = 0
	BN_MP_GET_MAG_UL_C                    = 0
	BN_MP_GROW_C                          = 0
	BN_MP_IMPORT_C                        = 0
	BN_MP_INCR_C                          = 0
	BN_MP_INIT_C                          = 0
	BN_MP_INIT_COPY_C                     = 0
	BN_MP_INIT_I32_C                      = 0
	BN_MP_INIT_I64_C                      = 0
	BN_MP_INIT_LL_C                       = 0
	BN_MP_INIT_L_C                        = 0
	BN_MP_INIT_MULTI_C                    = 0
	BN_MP_INIT_SET_C                      = 0
	BN_MP_INIT_SET_INT_C                  = 0
	BN_MP_INIT_SIZE_C                     = 0
	BN_MP_INIT_U32_C                      = 0
	BN_MP_INIT_U64_C                      = 0
	BN_MP_INIT_ULL_C                      = 0
	BN_MP_INIT_UL_C                       = 0
	BN_MP_INVMOD_C                        = 0
	BN_MP_INVMOD_SLOW_C                   = 0
	BN_MP_ISEVEN_C                        = 0
	BN_MP_ISODD_C                         = 0
	BN_MP_IS_SQUARE_C                     = 0
	BN_MP_JACOBI_C                        = 0
	BN_MP_KARATSUBA_MUL_C                 = 0
	BN_MP_KARATSUBA_SQR_C                 = 0
	BN_MP_KRONECKER_C                     = 0
	BN_MP_LCM_C                           = 0
	BN_MP_LOG_U32_C                       = 0
	BN_MP_LSHD_C                          = 0
	BN_MP_MOD_2D_C                        = 0
	BN_MP_MOD_C                           = 0
	BN_MP_MOD_D_C                         = 0
	BN_MP_MONTGOMERY_CALC_NORMALIZATION_C = 0
	BN_MP_MONTGOMERY_REDUCE_C             = 0
	BN_MP_MONTGOMERY_SETUP_C              = 0
	BN_MP_MULMOD_C                        = 0
	BN_MP_MUL_2D_C                        = 0
	BN_MP_MUL_2_C                         = 0
	BN_MP_MUL_C                           = 0
	BN_MP_MUL_D_C                         = 0
	BN_MP_NEG_C                           = 0
	BN_MP_N_ROOT_C                        = 0
	BN_MP_N_ROOT_EX_C                     = 0
	BN_MP_OR_C                            = 0
	BN_MP_PACK_C                          = 0
	BN_MP_PACK_COUNT_C                    = 0
	BN_MP_PRIME_FERMAT_C                  = 0
	BN_MP_PRIME_FROBENIUS_UNDERWOOD_C     = 0
	BN_MP_PRIME_IS_DIVISIBLE_C            = 0
	BN_MP_PRIME_IS_PRIME_C                = 0
	BN_MP_PRIME_MILLER_RABIN_C            = 0
	BN_MP_PRIME_NEXT_PRIME_C              = 0
	BN_MP_PRIME_RABIN_MILLER_TRIALS_C     = 0
	BN_MP_PRIME_RANDOM_EX_C               = 0
	BN_MP_PRIME_RAND_C                    = 0
	BN_MP_PRIME_STRONG_LUCAS_SELFRIDGE_C  = 0
	BN_MP_RADIX_SIZE_C                    = 0
	BN_MP_RADIX_SMAP_C                    = 0
	BN_MP_RAND_C                          = 0
	BN_MP_RAND_DIGIT_C                    = 0
	BN_MP_RAND_SOURCE_C                   = 0
	BN_MP_READ_RADIX_C                    = 0
	BN_MP_READ_SIGNED_BIN_C               = 0
	BN_MP_READ_UNSIGNED_BIN_C             = 0
	BN_MP_REDUCE_2K_C                     = 0
	BN_MP_REDUCE_2K_L_C                   = 0
	BN_MP_REDUCE_2K_SETUP_C               = 0
	BN_MP_REDUCE_2K_SETUP_L_C             = 0
	BN_MP_REDUCE_C                        = 0
	BN_MP_REDUCE_IS_2K_C                  = 0
	BN_MP_REDUCE_IS_2K_L_C                = 0
	BN_MP_REDUCE_SETUP_C                  = 0
	BN_MP_ROOT_U32_C                      = 0
	BN_MP_RSHD_C                          = 0
	BN_MP_SBIN_SIZE_C                     = 0
	BN_MP_SET_C                           = 0
	BN_MP_SET_DOUBLE_C                    = 0
	BN_MP_SET_I32_C                       = 0
	BN_MP_SET_I64_C                       = 0
	BN_MP_SET_INT_C                       = 0
	BN_MP_SET_LL_C                        = 0
	BN_MP_SET_LONG_C                      = 0
	BN_MP_SET_LONG_LONG_C                 = 0
	BN_MP_SET_L_C                         = 0
	BN_MP_SET_U32_C                       = 0
	BN_MP_SET_U64_C                       = 0
	BN_MP_SET_ULL_C                       = 0
	BN_MP_SET_UL_C                        = 0
	BN_MP_SHRINK_C                        = 0
	BN_MP_SIGNED_BIN_SIZE_C               = 0
	BN_MP_SIGNED_RSH_C                    = 0
	BN_MP_SQRMOD_C                        = 0
	BN_MP_SQRTMOD_PRIME_C                 = 0
	BN_MP_SQRT_C                          = 0
	BN_MP_SQR_C                           = 0
	BN_MP_SUBMOD_C                        = 0
	BN_MP_SUB_C                           = 0
	BN_MP_SUB_D_C                         = 0
	BN_MP_TC_AND_C                        = 0
	BN_MP_TC_DIV_2D_C                     = 0
	BN_MP_TC_OR_C                         = 0
	BN_MP_TC_XOR_C                        = 0
	BN_MP_TOOM_MUL_C                      = 0
	BN_MP_TOOM_SQR_C                      = 0
	BN_MP_TORADIX_C                       = 0
	BN_MP_TORADIX_N_C                     = 0
	BN_MP_TO_RADIX_C                      = 0
	BN_MP_TO_SBIN_C                       = 0
	BN_MP_TO_SIGNED_BIN_C                 = 0
	BN_MP_TO_SIGNED_BIN_N_C               = 0
	BN_MP_TO_UBIN_C                       = 0
	BN_MP_TO_UNSIGNED_BIN_C               = 0
	BN_MP_TO_UNSIGNED_BIN_N_C             = 0
	BN_MP_UBIN_SIZE_C                     = 0
	BN_MP_UNPACK_C                        = 0
	BN_MP_UNSIGNED_BIN_SIZE_C             = 0
	BN_MP_XOR_C                           = 0
	BN_MP_ZERO_C                          = 0
	BN_PRIME_TAB_C                        = 0
	BN_S_MP_ADD_C                         = 0
	BN_S_MP_BALANCE_MUL_C                 = 0
	BN_S_MP_EXPTMOD_C                     = 0
	BN_S_MP_EXPTMOD_FAST_C                = 0
	BN_S_MP_GET_BIT_C                     = 0
	BN_S_MP_INVMOD_FAST_C                 = 0
	BN_S_MP_INVMOD_SLOW_C                 = 0
	BN_S_MP_KARATSUBA_MUL_C               = 0
	BN_S_MP_KARATSUBA_SQR_C               = 0
	BN_S_MP_MONTGOMERY_REDUCE_FAST_C      = 0
	BN_S_MP_MUL_DIGS_C                    = 0
	BN_S_MP_MUL_DIGS_FAST_C               = 0
	BN_S_MP_MUL_HIGH_DIGS_C               = 0
	BN_S_MP_MUL_HIGH_DIGS_FAST_C          = 0
	BN_S_MP_MUL_SI_C                      = 0
	BN_S_MP_PRIME_IS_DIVISIBLE_C          = 0
	BN_S_MP_PRIME_RANDOM_EX_C             = 0
	BN_S_MP_RAND_CB_C                     = 0
	BN_S_MP_RAND_JENKINS_C                = 0
	BN_S_MP_RAND_JENKINS_INIT_C           = 0
	BN_S_MP_RAND_PLATFORM_C               = 0
	BN_S_MP_RAND_SOURCE_C                 = 0
	BN_S_MP_REVERSE_C                     = 0
	BN_S_MP_SQR_C                         = 0
	BN_S_MP_SQR_FAST_C                    = 0
	BN_S_MP_SUB_C                         = 0
	BN_S_MP_TOOM_MUL_C                    = 0
	BN_S_MP_TOOM_SQR_C                    = 0
	LTM1                                  = 0
	LTM2                                  = 0
	LTM3                                  = 0
	LTM_ALL                               = 0
	LTM_LAST                              = 0
	MAX_STRINGS                           = 11
	NUMBER_OF_OBJECT_VARS                 = 20
	STATIC_BUILD                          = 1
	VARPTR_KEY                            = "TCLOBJTEST_VARPTR"
	TP_Dying                              = 0x001
	MAX_PIPES                             = 10
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	RLIM64_INFINITY                       = 0xffffffffffffffff
	RLIM_INFINITY                         = 0xffffffffffffffff
	RLIM_SAVED_CUR                        = 18446744073709551615
	RLIM_SAVED_MAX                        = 18446744073709551615
	X_SYS_RESOURCE_H                      = 1
)

// Positions to pass to Tcl_QueueEvent:

const ( /* tcl.h:1387:1: */
	TCL_QUEUE_TAIL = 0
	TCL_QUEUE_HEAD = 1
	TCL_QUEUE_MARK = 2
)

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

const ( /* tcl.h:1609:1: */
	TCL_PATH_ABSOLUTE        = 0
	TCL_PATH_RELATIVE        = 1
	TCL_PATH_VOLUME_RELATIVE = 2
)

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

const ( /* tcl.h:690:1: */
	TCL_INT      = 0
	TCL_DOUBLE   = 1
	TCL_EITHER   = 2
	TCL_WIDE_INT = 3
)

// TIP #268.
// Values for the selection mode, i.e the package require preferences.

const ( /* tclInt.h:1729:1: */
	PKG_PREFER_LATEST = 0
	PKG_PREFER_STABLE = 1
)

// Macros that use the TSD-ekeko.

// Macros for script cancellation support (TIP #285).

// Macros for splicing into and out of doubly linked lists. They assume
// existence of struct items 'prevPtr' and 'nextPtr'.
//
// a = element to add or remove.
// b = list head.
//
// TclSpliceIn adds to the head of the list.

// EvalFlag bits for Interp structures:
//
// TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
//			code other than TCL_OK or TCL_ERROR; 0 means codes
//			other than these should be turned into errors.

// Flag bits for Interp structures:
//
// DELETED:		Non-zero means the interpreter has been deleted:
//			don't process any more commands for it, and destroy
//			the structure as soon as all nested invocations of
//			Tcl_Eval are done.
// ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
//			iPtr->errorInfo for the current Tcl_Eval instance, so
//			Tcl_Eval needn't log it (used to implement the "error
//			message log" command).
// DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
//			not compile any commands into an inline sequence of
//			instructions. This is set 1, for example, when command
//			traces are requested.
// RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
//			has not be initialized. This is set 1 when we first
//			use the rand() or srand() functions.
// SAFE_INTERP:		Non zero means that the current interp is a safe
//			interp (i.e. it has only the safe commands installed,
//			less privilege than a regular interp).
// INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
//			debug/info mechanisms (e.g. info frame eval/uplevel
//			tracing) which are performance intensive.
// INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
//			active; so no further trace callbacks should be
//			invoked.
// INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
//			of the wrong-num-args string in Tcl_WrongNumArgs.
//			Makes it append instead of replacing and uses
//			different intermediate text.
// CANCELED:		Non-zero means that the script in progress should be
//			canceled as soon as possible. This can be checked by
//			extensions (and the core itself) by calling
//			Tcl_Canceled and checking if TCL_ERROR is returned.
//			This is a one-shot flag that is reset immediately upon
//			being detected; however, if the TCL_CANCEL_UNWIND flag
//			is set Tcl_Canceled will continue to report that the
//			script in progress has been canceled thereby allowing
//			the evaluation stack for the interp to be fully
//			unwound.
//
// WARNING: For the sake of some extensions that have made use of former
// internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
// or 8 (formerly ERROR_CODE_SET).

// Maximum number of levels of nesting permitted in Tcl commands (used to
// catch infinite recursion).

// The macro below is used to modify a "char" value (e.g. by casting it to an
// unsigned character) so that it can be used safely with macros such as
// isspace.

// This macro is used to properly align the memory allocated by Tcl, giving
// the same alignment as the native malloc.

// This macro is used to determine the offset needed to safely allocate any
// data structure in memory. Given a starting offset or size, it "rounds up"
// or "aligns" the offset to the next 8-byte boundary so that any data
// structure can be placed at the resulting offset without fear of an
// alignment error.
//
// WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
// wrong result on platforms that allocate addresses that are divisible by 4
// or 2. Only use it for offsets or sizes.
//
// This macro is only used by tclCompile.c in the core (Bug 926445). It
// however not be made file static, as extensions that touch bytecodes
// (notably tbcload) require it.

// The following enum values are used to specify the runtime platform setting
// of the tclPlatform variable.

const ( /* tclInt.h:2318:1: */
	TCL_PLATFORM_UNIX    = 0 // Any Unix-like OS.
	TCL_PLATFORM_WINDOWS = 2
)

// The following enum values are used to indicate the translation of a Tcl
// channel. Declared here so that each platform can define
// TCL_PLATFORM_TRANSLATION to the native translation on that platform.

const ( /* tclInt.h:2329:1: */
	TCL_TRANSLATE_AUTO = 0 // Eol == \r, \n and \r\n.
	TCL_TRANSLATE_CR   = 1 // Eol == \r.
	TCL_TRANSLATE_LF   = 2 // Eol == \n.
	TCL_TRANSLATE_CRLF = 3
)

// The "globParameters" argument of the function TclGlob is an or'ed
// combination of the following values:

const ( /* tclInt.h:2564:1: */
	TCL_PATH_DIRNAME   = 0
	TCL_PATH_TAIL      = 1
	TCL_PATH_EXTENSION = 2
	TCL_PATH_ROOT      = 3
)

const ( /* tclInt.h:2738:1: */
	TCL_EMPTYSTRING_UNKNOWN = -1
	TCL_EMPTYSTRING_NO      = 0
	TCL_EMPTYSTRING_YES     = 1
)

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard 7.4: Character handling	<ctype.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// These are all the characteristics of characters.
//    If there get to be more than 16 distinct characteristics,
//    many things must be changed that use `unsigned short int's.
//
//    The characteristics are stored always in network byte order (big
//    endian).  We define the bit value interpretations here dependent on the
//    machine's byte order.

// Endian macros for string.h functions
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

const ( /* ctype.h:46:1: */
	_ISupper  = 256   // UPPERCASE.
	_ISlower  = 512   // lowercase.
	_ISalpha  = 1024  // Alphabetic.
	_ISdigit  = 2048  // Numeric.
	_ISxdigit = 4096  // Hexadecimal numeric.
	_ISspace  = 8192  // Whitespace.
	_ISprint  = 16384 // Printing.
	_ISgraph  = 32768 // Graphical.
	_ISblank  = 1     // Blank (usually SPC and TAB).
	_IScntrl  = 2     // Control character.
	_ISpunct  = 4     // Punctuation.
	_ISalnum  = 8
)

// Inform libc code that these two types are effectively identical.

// These macros extract size information from a `struct dirent *'.
//    They may evaluate their argument multiple times, so it must not
//    have side effects.  Each of these may involve a relatively costly
//    call to `strlen' on some systems, so these values should be cached.
//
//    _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
//    its terminating null character.
//
//    _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
//    that is, the allocation size needed to hold the DP->d_name string.
//    Use this macro when you don't need the exact length, just an upper bound.
//    This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
//

// File types for `d_type'.
const ( /* dirent.h:97:1: */
	DT_UNKNOWN = 0
	DT_FIFO    = 1
	DT_CHR     = 2
	DT_DIR     = 4
	DT_BLK     = 6
	DT_REG     = 8
	DT_LNK     = 10
	DT_SOCK    = 12
	DT_WHT     = 14
)

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:853:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

// Standard well-known ports.
const ( /* in.h:122:1: */
	IPPORT_ECHO       = 7  // Echo service.
	IPPORT_DISCARD    = 9  // Discard transmissions service.
	IPPORT_SYSTAT     = 11 // System status service.
	IPPORT_DAYTIME    = 13 // Time of day service.
	IPPORT_NETSTAT    = 15 // Network status service.
	IPPORT_FTP        = 21 // File Transfer Protocol.
	IPPORT_TELNET     = 23 // Telnet protocol.
	IPPORT_SMTP       = 25 // Simple Mail Transfer Protocol.
	IPPORT_TIMESERVER = 37 // Timeserver service.
	IPPORT_NAMESERVER = 42 // Domain Name Service.
	IPPORT_WHOIS      = 43 // Internet Whois service.
	IPPORT_MTP        = 57

	IPPORT_TFTP    = 69 // Trivial File Transfer Protocol.
	IPPORT_RJE     = 77
	IPPORT_FINGER  = 79 // Finger service.
	IPPORT_TTYLINK = 87
	IPPORT_SUPDUP  = 95 // SUPDUP protocol.

	IPPORT_EXECSERVER  = 512 // execd service.
	IPPORT_LOGINSERVER = 513 // rlogind service.
	IPPORT_CMDSERVER   = 514
	IPPORT_EFSSERVER   = 520

	// UDP ports.
	IPPORT_BIFFUDP     = 512
	IPPORT_WHOSERVER   = 513
	IPPORT_ROUTESERVER = 520

	// Ports less than this value are reserved for privileged processes.
	IPPORT_RESERVED = 1024

	// Ports greater this value are reserved for (non-privileged) servers.
	IPPORT_USERRESERVED = 5000
)

// Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
//    The first word in the comment at the right is the data type used;
//    "bool" means a boolean value stored in an `int'.

// Advanced API (RFC3542) (1).

// Advanced API (RFC3542) (2).

// RFC5014.

// RFC5082.

// Obsolete synonyms for the above.

// IPV6_MTU_DISCOVER values.

// Socket level values for IPv6.

// Routing header options for IPv6.

// Standard well-defined IP protocols.
const ( /* in.h:40:1: */
	IPPROTO_IP      = 0   // Dummy protocol for TCP.
	IPPROTO_ICMP    = 1   // Internet Control Message Protocol.
	IPPROTO_IGMP    = 2   // Internet Group Management Protocol.
	IPPROTO_IPIP    = 4   // IPIP tunnels (older KA9Q tunnels use 94).
	IPPROTO_TCP     = 6   // Transmission Control Protocol.
	IPPROTO_EGP     = 8   // Exterior Gateway Protocol.
	IPPROTO_PUP     = 12  // PUP protocol.
	IPPROTO_UDP     = 17  // User Datagram Protocol.
	IPPROTO_IDP     = 22  // XNS IDP protocol.
	IPPROTO_TP      = 29  // SO Transport Protocol Class 4.
	IPPROTO_DCCP    = 33  // Datagram Congestion Control Protocol.
	IPPROTO_IPV6    = 41  // IPv6 header.
	IPPROTO_RSVP    = 46  // Reservation Protocol.
	IPPROTO_GRE     = 47  // General Routing Encapsulation.
	IPPROTO_ESP     = 50  // encapsulating security payload.
	IPPROTO_AH      = 51  // authentication header.
	IPPROTO_MTP     = 92  // Multicast Transport Protocol.
	IPPROTO_BEETPH  = 94  // IP option pseudo header for BEET.
	IPPROTO_ENCAP   = 98  // Encapsulation Header.
	IPPROTO_PIM     = 103 // Protocol Independent Multicast.
	IPPROTO_COMP    = 108 // Compression Header Protocol.
	IPPROTO_SCTP    = 132 // Stream Control Transmission Protocol.
	IPPROTO_UDPLITE = 136 // UDP-Lite protocol.
	IPPROTO_MPLS    = 137 // MPLS in IP.
	IPPROTO_RAW     = 255 // Raw IP packets.
	IPPROTO_MAX     = 256
)

// If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
//    network headers first and we should use those ABI-identical definitions
//    instead of our own, otherwise 0.
const ( /* in.h:99:1: */
	IPPROTO_HOPOPTS  = 0  // IPv6 Hop-by-Hop options.
	IPPROTO_ROUTING  = 43 // IPv6 routing header.
	IPPROTO_FRAGMENT = 44 // IPv6 fragmentation header.
	IPPROTO_ICMPV6   = 58 // ICMPv6.
	IPPROTO_NONE     = 59 // IPv6 no next header.
	IPPROTO_DSTOPTS  = 60 // IPv6 destination options.
	IPPROTO_MH       = 135
)

// Read-write lock types.
const ( /* pthread.h:100:1: */
	PTHREAD_RWLOCK_PREFER_READER_NP              = 0
	PTHREAD_RWLOCK_PREFER_WRITER_NP              = 1
	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2
	PTHREAD_RWLOCK_DEFAULT_NP                    = 0
)

// Read-write lock initializers.

// Scheduler inheritance.
const ( /* pthread.h:120:1: */
	PTHREAD_INHERIT_SCHED  = 0
	PTHREAD_EXPLICIT_SCHED = 1
)

// Scope handling.
const ( /* pthread.h:130:1: */
	PTHREAD_SCOPE_SYSTEM  = 0
	PTHREAD_SCOPE_PROCESS = 1
)

// Process shared or private flag.
const ( /* pthread.h:140:1: */
	PTHREAD_PROCESS_PRIVATE = 0
	PTHREAD_PROCESS_SHARED  = 1
)

// Cancellation
const ( /* pthread.h:164:1: */
	PTHREAD_CANCEL_ENABLE  = 0
	PTHREAD_CANCEL_DISABLE = 1
)
const ( /* pthread.h:171:1: */
	PTHREAD_CANCEL_DEFERRED     = 0
	PTHREAD_CANCEL_ASYNCHRONOUS = 1
)

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// NB: Include guard matches what <linux/time.h> uses.

// Detach state.
const ( /* pthread.h:33:1: */
	PTHREAD_CREATE_JOINABLE = 0
	PTHREAD_CREATE_DETACHED = 1
)

// Mutex types.
const ( /* pthread.h:43:1: */
	PTHREAD_MUTEX_TIMED_NP      = 0
	PTHREAD_MUTEX_RECURSIVE_NP  = 1
	PTHREAD_MUTEX_ERRORCHECK_NP = 2
	PTHREAD_MUTEX_ADAPTIVE_NP   = 3
	PTHREAD_MUTEX_NORMAL        = 0
	PTHREAD_MUTEX_RECURSIVE     = 1
	PTHREAD_MUTEX_ERRORCHECK    = 2
	PTHREAD_MUTEX_DEFAULT       = 0
)

// Robust mutex or not flags.
const ( /* pthread.h:65:1: */
	PTHREAD_MUTEX_STALLED    = 0
	PTHREAD_MUTEX_STALLED_NP = 0
	PTHREAD_MUTEX_ROBUST     = 1
	PTHREAD_MUTEX_ROBUST_NP  = 1
)

// Mutex protocols.
const ( /* pthread.h:77:1: */
	PTHREAD_PRIO_NONE    = 0
	PTHREAD_PRIO_INHERIT = 1
	PTHREAD_PRIO_PROTECT = 2
)

// Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
//    the `_SC_*' symbols for the NAME argument to `sysconf';
//    and the `_CS_*' symbols for the NAME argument to `confstr'.
// `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
//    Copyright (C) 1993-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Values for the NAME argument to `pathconf' and `fpathconf'.
const ( /* confname.h:24:1: */
	_PC_LINK_MAX           = 0
	_PC_MAX_CANON          = 1
	_PC_MAX_INPUT          = 2
	_PC_NAME_MAX           = 3
	_PC_PATH_MAX           = 4
	_PC_PIPE_BUF           = 5
	_PC_CHOWN_RESTRICTED   = 6
	_PC_NO_TRUNC           = 7
	_PC_VDISABLE           = 8
	_PC_SYNC_IO            = 9
	_PC_ASYNC_IO           = 10
	_PC_PRIO_IO            = 11
	_PC_SOCK_MAXBUF        = 12
	_PC_FILESIZEBITS       = 13
	_PC_REC_INCR_XFER_SIZE = 14
	_PC_REC_MAX_XFER_SIZE  = 15
	_PC_REC_MIN_XFER_SIZE  = 16
	_PC_REC_XFER_ALIGN     = 17
	_PC_ALLOC_SIZE_MIN     = 18
	_PC_SYMLINK_MAX        = 19
	_PC_2_SYMLINKS         = 20
)

// Values for the NAME argument to `confstr'.
const ( /* confname.h:533:1: */
	_CS_PATH = 0 // The default search path.

	_CS_V6_WIDTH_RESTRICTED_ENVS = 1

	_CS_GNU_LIBC_VERSION       = 2
	_CS_GNU_LIBPTHREAD_VERSION = 3

	_CS_V5_WIDTH_RESTRICTED_ENVS = 4

	_CS_V7_WIDTH_RESTRICTED_ENVS = 5

	_CS_LFS_CFLAGS      = 1000
	_CS_LFS_LDFLAGS     = 1001
	_CS_LFS_LIBS        = 1002
	_CS_LFS_LINTFLAGS   = 1003
	_CS_LFS64_CFLAGS    = 1004
	_CS_LFS64_LDFLAGS   = 1005
	_CS_LFS64_LIBS      = 1006
	_CS_LFS64_LINTFLAGS = 1007

	_CS_XBS5_ILP32_OFF32_CFLAGS     = 1100
	_CS_XBS5_ILP32_OFF32_LDFLAGS    = 1101
	_CS_XBS5_ILP32_OFF32_LIBS       = 1102
	_CS_XBS5_ILP32_OFF32_LINTFLAGS  = 1103
	_CS_XBS5_ILP32_OFFBIG_CFLAGS    = 1104
	_CS_XBS5_ILP32_OFFBIG_LDFLAGS   = 1105
	_CS_XBS5_ILP32_OFFBIG_LIBS      = 1106
	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
	_CS_XBS5_LP64_OFF64_CFLAGS      = 1108
	_CS_XBS5_LP64_OFF64_LDFLAGS     = 1109
	_CS_XBS5_LP64_OFF64_LIBS        = 1110
	_CS_XBS5_LP64_OFF64_LINTFLAGS   = 1111
	_CS_XBS5_LPBIG_OFFBIG_CFLAGS    = 1112
	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS   = 1113
	_CS_XBS5_LPBIG_OFFBIG_LIBS      = 1114
	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115

	_CS_POSIX_V6_ILP32_OFF32_CFLAGS     = 1116
	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS    = 1117
	_CS_POSIX_V6_ILP32_OFF32_LIBS       = 1118
	_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  = 1119
	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    = 1120
	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   = 1121
	_CS_POSIX_V6_ILP32_OFFBIG_LIBS      = 1122
	_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
	_CS_POSIX_V6_LP64_OFF64_CFLAGS      = 1124
	_CS_POSIX_V6_LP64_OFF64_LDFLAGS     = 1125
	_CS_POSIX_V6_LP64_OFF64_LIBS        = 1126
	_CS_POSIX_V6_LP64_OFF64_LINTFLAGS   = 1127
	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    = 1128
	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   = 1129
	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS      = 1130
	_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131

	_CS_POSIX_V7_ILP32_OFF32_CFLAGS     = 1132
	_CS_POSIX_V7_ILP32_OFF32_LDFLAGS    = 1133
	_CS_POSIX_V7_ILP32_OFF32_LIBS       = 1134
	_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS  = 1135
	_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS    = 1136
	_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS   = 1137
	_CS_POSIX_V7_ILP32_OFFBIG_LIBS      = 1138
	_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
	_CS_POSIX_V7_LP64_OFF64_CFLAGS      = 1140
	_CS_POSIX_V7_LP64_OFF64_LDFLAGS     = 1141
	_CS_POSIX_V7_LP64_OFF64_LIBS        = 1142
	_CS_POSIX_V7_LP64_OFF64_LINTFLAGS   = 1143
	_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS    = 1144
	_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS   = 1145
	_CS_POSIX_V7_LPBIG_OFFBIG_LIBS      = 1146
	_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147

	_CS_V6_ENV = 1148
	_CS_V7_ENV = 1149
)

// Values for the argument to `sysconf'.
const ( /* confname.h:71:1: */
	_SC_ARG_MAX               = 0
	_SC_CHILD_MAX             = 1
	_SC_CLK_TCK               = 2
	_SC_NGROUPS_MAX           = 3
	_SC_OPEN_MAX              = 4
	_SC_STREAM_MAX            = 5
	_SC_TZNAME_MAX            = 6
	_SC_JOB_CONTROL           = 7
	_SC_SAVED_IDS             = 8
	_SC_REALTIME_SIGNALS      = 9
	_SC_PRIORITY_SCHEDULING   = 10
	_SC_TIMERS                = 11
	_SC_ASYNCHRONOUS_IO       = 12
	_SC_PRIORITIZED_IO        = 13
	_SC_SYNCHRONIZED_IO       = 14
	_SC_FSYNC                 = 15
	_SC_MAPPED_FILES          = 16
	_SC_MEMLOCK               = 17
	_SC_MEMLOCK_RANGE         = 18
	_SC_MEMORY_PROTECTION     = 19
	_SC_MESSAGE_PASSING       = 20
	_SC_SEMAPHORES            = 21
	_SC_SHARED_MEMORY_OBJECTS = 22
	_SC_AIO_LISTIO_MAX        = 23
	_SC_AIO_MAX               = 24
	_SC_AIO_PRIO_DELTA_MAX    = 25
	_SC_DELAYTIMER_MAX        = 26
	_SC_MQ_OPEN_MAX           = 27
	_SC_MQ_PRIO_MAX           = 28
	_SC_VERSION               = 29
	_SC_PAGESIZE              = 30
	_SC_RTSIG_MAX             = 31
	_SC_SEM_NSEMS_MAX         = 32
	_SC_SEM_VALUE_MAX         = 33
	_SC_SIGQUEUE_MAX          = 34
	_SC_TIMER_MAX             = 35

	// Values for the argument to `sysconf'
	//        corresponding to _POSIX2_* symbols.
	_SC_BC_BASE_MAX        = 36
	_SC_BC_DIM_MAX         = 37
	_SC_BC_SCALE_MAX       = 38
	_SC_BC_STRING_MAX      = 39
	_SC_COLL_WEIGHTS_MAX   = 40
	_SC_EQUIV_CLASS_MAX    = 41
	_SC_EXPR_NEST_MAX      = 42
	_SC_LINE_MAX           = 43
	_SC_RE_DUP_MAX         = 44
	_SC_CHARCLASS_NAME_MAX = 45

	_SC_2_VERSION   = 46
	_SC_2_C_BIND    = 47
	_SC_2_C_DEV     = 48
	_SC_2_FORT_DEV  = 49
	_SC_2_FORT_RUN  = 50
	_SC_2_SW_DEV    = 51
	_SC_2_LOCALEDEF = 52

	_SC_PII                 = 53
	_SC_PII_XTI             = 54
	_SC_PII_SOCKET          = 55
	_SC_PII_INTERNET        = 56
	_SC_PII_OSI             = 57
	_SC_POLL                = 58
	_SC_SELECT              = 59
	_SC_UIO_MAXIOV          = 60
	_SC_IOV_MAX             = 60
	_SC_PII_INTERNET_STREAM = 61
	_SC_PII_INTERNET_DGRAM  = 62
	_SC_PII_OSI_COTS        = 63
	_SC_PII_OSI_CLTS        = 64
	_SC_PII_OSI_M           = 65
	_SC_T_IOV_MAX           = 66

	// Values according to POSIX 1003.1c (POSIX threads).
	_SC_THREADS                      = 67
	_SC_THREAD_SAFE_FUNCTIONS        = 68
	_SC_GETGR_R_SIZE_MAX             = 69
	_SC_GETPW_R_SIZE_MAX             = 70
	_SC_LOGIN_NAME_MAX               = 71
	_SC_TTY_NAME_MAX                 = 72
	_SC_THREAD_DESTRUCTOR_ITERATIONS = 73
	_SC_THREAD_KEYS_MAX              = 74
	_SC_THREAD_STACK_MIN             = 75
	_SC_THREAD_THREADS_MAX           = 76
	_SC_THREAD_ATTR_STACKADDR        = 77
	_SC_THREAD_ATTR_STACKSIZE        = 78
	_SC_THREAD_PRIORITY_SCHEDULING   = 79
	_SC_THREAD_PRIO_INHERIT          = 80
	_SC_THREAD_PRIO_PROTECT          = 81
	_SC_THREAD_PROCESS_SHARED        = 82

	_SC_NPROCESSORS_CONF = 83
	_SC_NPROCESSORS_ONLN = 84
	_SC_PHYS_PAGES       = 85
	_SC_AVPHYS_PAGES     = 86
	_SC_ATEXIT_MAX       = 87
	_SC_PASS_MAX         = 88

	_SC_XOPEN_VERSION     = 89
	_SC_XOPEN_XCU_VERSION = 90
	_SC_XOPEN_UNIX        = 91
	_SC_XOPEN_CRYPT       = 92
	_SC_XOPEN_ENH_I18N    = 93
	_SC_XOPEN_SHM         = 94

	_SC_2_CHAR_TERM = 95
	_SC_2_C_VERSION = 96
	_SC_2_UPE       = 97

	_SC_XOPEN_XPG2 = 98
	_SC_XOPEN_XPG3 = 99
	_SC_XOPEN_XPG4 = 100

	_SC_CHAR_BIT   = 101
	_SC_CHAR_MAX   = 102
	_SC_CHAR_MIN   = 103
	_SC_INT_MAX    = 104
	_SC_INT_MIN    = 105
	_SC_LONG_BIT   = 106
	_SC_WORD_BIT   = 107
	_SC_MB_LEN_MAX = 108
	_SC_NZERO      = 109
	_SC_SSIZE_MAX  = 110
	_SC_SCHAR_MAX  = 111
	_SC_SCHAR_MIN  = 112
	_SC_SHRT_MAX   = 113
	_SC_SHRT_MIN   = 114
	_SC_UCHAR_MAX  = 115
	_SC_UINT_MAX   = 116
	_SC_ULONG_MAX  = 117
	_SC_USHRT_MAX  = 118

	_SC_NL_ARGMAX  = 119
	_SC_NL_LANGMAX = 120
	_SC_NL_MSGMAX  = 121
	_SC_NL_NMAX    = 122
	_SC_NL_SETMAX  = 123
	_SC_NL_TEXTMAX = 124

	_SC_XBS5_ILP32_OFF32  = 125
	_SC_XBS5_ILP32_OFFBIG = 126
	_SC_XBS5_LP64_OFF64   = 127
	_SC_XBS5_LPBIG_OFFBIG = 128

	_SC_XOPEN_LEGACY           = 129
	_SC_XOPEN_REALTIME         = 130
	_SC_XOPEN_REALTIME_THREADS = 131

	_SC_ADVISORY_INFO          = 132
	_SC_BARRIERS               = 133
	_SC_BASE                   = 134
	_SC_C_LANG_SUPPORT         = 135
	_SC_C_LANG_SUPPORT_R       = 136
	_SC_CLOCK_SELECTION        = 137
	_SC_CPUTIME                = 138
	_SC_THREAD_CPUTIME         = 139
	_SC_DEVICE_IO              = 140
	_SC_DEVICE_SPECIFIC        = 141
	_SC_DEVICE_SPECIFIC_R      = 142
	_SC_FD_MGMT                = 143
	_SC_FIFO                   = 144
	_SC_PIPE                   = 145
	_SC_FILE_ATTRIBUTES        = 146
	_SC_FILE_LOCKING           = 147
	_SC_FILE_SYSTEM            = 148
	_SC_MONOTONIC_CLOCK        = 149
	_SC_MULTI_PROCESS          = 150
	_SC_SINGLE_PROCESS         = 151
	_SC_NETWORKING             = 152
	_SC_READER_WRITER_LOCKS    = 153
	_SC_SPIN_LOCKS             = 154
	_SC_REGEXP                 = 155
	_SC_REGEX_VERSION          = 156
	_SC_SHELL                  = 157
	_SC_SIGNALS                = 158
	_SC_SPAWN                  = 159
	_SC_SPORADIC_SERVER        = 160
	_SC_THREAD_SPORADIC_SERVER = 161
	_SC_SYSTEM_DATABASE        = 162
	_SC_SYSTEM_DATABASE_R      = 163
	_SC_TIMEOUTS               = 164
	_SC_TYPED_MEMORY_OBJECTS   = 165
	_SC_USER_GROUPS            = 166
	_SC_USER_GROUPS_R          = 167
	_SC_2_PBS                  = 168
	_SC_2_PBS_ACCOUNTING       = 169
	_SC_2_PBS_LOCATE           = 170
	_SC_2_PBS_MESSAGE          = 171
	_SC_2_PBS_TRACK            = 172
	_SC_SYMLOOP_MAX            = 173
	_SC_STREAMS                = 174
	_SC_2_PBS_CHECKPOINT       = 175

	_SC_V6_ILP32_OFF32  = 176
	_SC_V6_ILP32_OFFBIG = 177
	_SC_V6_LP64_OFF64   = 178
	_SC_V6_LPBIG_OFFBIG = 179

	_SC_HOST_NAME_MAX      = 180
	_SC_TRACE              = 181
	_SC_TRACE_EVENT_FILTER = 182
	_SC_TRACE_INHERIT      = 183
	_SC_TRACE_LOG          = 184

	_SC_LEVEL1_ICACHE_SIZE     = 185
	_SC_LEVEL1_ICACHE_ASSOC    = 186
	_SC_LEVEL1_ICACHE_LINESIZE = 187
	_SC_LEVEL1_DCACHE_SIZE     = 188
	_SC_LEVEL1_DCACHE_ASSOC    = 189
	_SC_LEVEL1_DCACHE_LINESIZE = 190
	_SC_LEVEL2_CACHE_SIZE      = 191
	_SC_LEVEL2_CACHE_ASSOC     = 192
	_SC_LEVEL2_CACHE_LINESIZE  = 193
	_SC_LEVEL3_CACHE_SIZE      = 194
	_SC_LEVEL3_CACHE_ASSOC     = 195
	_SC_LEVEL3_CACHE_LINESIZE  = 196
	_SC_LEVEL4_CACHE_SIZE      = 197
	_SC_LEVEL4_CACHE_ASSOC     = 198
	_SC_LEVEL4_CACHE_LINESIZE  = 199
	// Leave room here, maybe we need a few more cache levels some day.

	_SC_IPV6        = 235
	_SC_RAW_SOCKETS = 236

	_SC_V7_ILP32_OFF32  = 237
	_SC_V7_ILP32_OFFBIG = 238
	_SC_V7_LP64_OFF64   = 239
	_SC_V7_LPBIG_OFFBIG = 240

	_SC_SS_REPL_MAX = 241

	_SC_TRACE_EVENT_NAME_MAX = 242
	_SC_TRACE_NAME_MAX       = 243
	_SC_TRACE_SYS_MAX        = 244
	_SC_TRACE_USER_EVENT_MAX = 245

	_SC_XOPEN_STREAMS = 246

	_SC_THREAD_ROBUST_PRIO_INHERIT = 247
	_SC_THREAD_ROBUST_PRIO_PROTECT = 248
)

// Whose usage statistics do you want?
const ( /* resource.h:158:1: */
	// The calling process.
	RUSAGE_SELF = 0

	// All of its terminated child processes.
	RUSAGE_CHILDREN = -1
)

// Priority limits.

// The type of the WHICH argument to `getpriority' and `setpriority',
//    indicating what flavor of entity the WHO argument specifies.
const ( /* resource.h:187:1: */
	PRIO_PROCESS = 0 // WHO is a process ID.
	PRIO_PGRP    = 1 // WHO is a process group ID.
	PRIO_USER    = 2
)

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The headers are needed for the testalarm command that verifies the use of
// SA_RESTART in signal handlers.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the system-dependent definitions of structures and bit values.
// Bit values & structures for resource limits.  Linux version.
//    Copyright (C) 1994-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Transmute defines to enumerations.  The macro re-definitions are
//    necessary because some programs want to test for operating system
//    features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
//    definition is a no-op.

// Kinds of resource limit.
const ( /* resource.h:31:1: */
	// Per-process CPU limit, in seconds.
	RLIMIT_CPU = 0

	// Largest file that can be created, in bytes.
	RLIMIT_FSIZE = 1

	// Maximum size of data segment, in bytes.
	RLIMIT_DATA = 2

	// Maximum size of stack segment, in bytes.
	RLIMIT_STACK = 3

	// Largest core file that can be created, in bytes.
	RLIMIT_CORE = 4

	// Largest resident set size, in bytes.
	//      This affects swapping; processes that are exceeding their
	//      resident set size will be more likely to have physical memory
	//      taken from them.
	__RLIMIT_RSS = 5

	// Number of open files.
	RLIMIT_NOFILE  = 7
	__RLIMIT_OFILE = 7 // BSD name for same.

	// Address space limit.
	RLIMIT_AS = 9

	// Number of processes.
	__RLIMIT_NPROC = 6

	// Locked-in-memory address space.
	__RLIMIT_MEMLOCK = 8

	// Maximum number of file locks.
	__RLIMIT_LOCKS = 10

	// Maximum number of pending signals.
	__RLIMIT_SIGPENDING = 11

	// Maximum bytes in POSIX message queues.
	__RLIMIT_MSGQUEUE = 12

	// Maximum nice priority allowed to raise to.
	//      Nice levels 19 .. -20 correspond to 0 .. 39
	//      values of this resource limit.
	__RLIMIT_NICE = 13

	// Maximum realtime priority allowed for non-priviledged
	//      processes.
	__RLIMIT_RTPRIO = 14

	// Maximum CPU time in µs that a process scheduled under a real-time
	//      scheduling policy may consume without making a blocking system
	//      call before being forcibly descheduled.
	__RLIMIT_RTTIME = 15

	__RLIMIT_NLIMITS = 16
	__RLIM_NLIMITS   = 16
)

// POSIX names to access some of the members.

// sigevent constants.  Linux version.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// `sigev_notify' values.
const ( /* sigevent-consts.h:27:1: */
	SIGEV_SIGNAL = 0 // Notify via signal.
	SIGEV_NONE   = 1 // Other notification: meaningless.
	SIGEV_THREAD = 2 // Deliver via thread creation.

	SIGEV_THREAD_ID = 4
)

// `si_code' values for SIGSEGV signal.
const ( /* siginfo-consts.h:119:1: */
	SEGV_MAPERR  = 1 // Address not mapped to object.
	SEGV_ACCERR  = 2 // Invalid permissions for mapped object.
	SEGV_BNDERR  = 3 // Bounds checking failure.
	SEGV_PKUERR  = 4 // Protection key checking failure.
	SEGV_ACCADI  = 5 // ADI not enabled for mapped object.
	SEGV_ADIDERR = 6 // Disrupting MCD error.
	SEGV_ADIPERR = 7
)

// `si_code' values for SIGBUS signal.
const ( /* siginfo-consts.h:138:1: */
	BUS_ADRALN    = 1 // Invalid address alignment.
	BUS_ADRERR    = 2 // Non-existant physical address.
	BUS_OBJERR    = 3 // Object specific hardware error.
	BUS_MCEERR_AR = 4 // Hardware memory error: action required.
	BUS_MCEERR_AO = 5
)

// `si_code' values for SIGCHLD signal.
const ( /* siginfo-consts.h:172:1: */
	CLD_EXITED    = 1 // Child has exited.
	CLD_KILLED    = 2 // Child was killed.
	CLD_DUMPED    = 3 // Child terminated abnormally.
	CLD_TRAPPED   = 4 // Traced child has trapped.
	CLD_STOPPED   = 5 // Child has stopped.
	CLD_CONTINUED = 6
)

// `si_code' values for SIGPOLL signal.
const ( /* siginfo-consts.h:189:1: */
	POLL_IN  = 1 // Data input available.
	POLL_OUT = 2 // Output buffers available.
	POLL_MSG = 3 // Input message available.
	POLL_ERR = 4 // I/O error.
	POLL_PRI = 5 // High priority input available.
	POLL_HUP = 6
)

// X/Open requires some more fields with fixed names.

// siginfo constants.  Linux version.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Most of these constants are uniform across all architectures, but there
//    is one exception.
// Architecture-specific adjustments to siginfo_t.  x86 version.

// Values for `si_code'.  Positive values are reserved for kernel-generated
//    signals.
const ( /* siginfo-consts.h:35:1: */
	SI_ASYNCNL  = -60 // Sent by asynch name lookup completion.
	SI_DETHREAD = -7  // Sent by execve killing subsidiary
	// 				   threads.
	SI_TKILL   = -6 // Sent by tkill.
	SI_SIGIO   = -5 // Sent by queued SIGIO.
	SI_ASYNCIO = -4 // Sent by AIO completion.
	SI_MESGQ   = -3 // Sent by real time mesq state change.
	SI_TIMER   = -2 // Sent by timer expiration.
	SI_QUEUE   = -1 // Sent by sigqueue.
	SI_USER    = 0  // Sent by kill, sigsend.
	SI_KERNEL  = 128
)

// `si_code' values for SIGILL signal.
const ( /* siginfo-consts.h:71:1: */
	ILL_ILLOPC   = 1 // Illegal opcode.
	ILL_ILLOPN   = 2 // Illegal operand.
	ILL_ILLADR   = 3 // Illegal addressing mode.
	ILL_ILLTRP   = 4 // Illegal trap.
	ILL_PRVOPC   = 5 // Privileged opcode.
	ILL_PRVREG   = 6 // Privileged register.
	ILL_COPROC   = 7 // Coprocessor error.
	ILL_BADSTK   = 8 // Internal stack error.
	ILL_BADIADDR = 9
)

// `si_code' values for SIGFPE signal.
const ( /* siginfo-consts.h:94:1: */
	FPE_INTDIV   = 1  // Integer divide by zero.
	FPE_INTOVF   = 2  // Integer overflow.
	FPE_FLTDIV   = 3  // Floating point divide by zero.
	FPE_FLTOVF   = 4  // Floating point overflow.
	FPE_FLTUND   = 5  // Floating point underflow.
	FPE_FLTRES   = 6  // Floating point inexact result.
	FPE_FLTINV   = 7  // Floating point invalid operation.
	FPE_FLTSUB   = 8  // Subscript out of range.
	FPE_FLTUNK   = 14 // Undiagnosed floating-point exception.
	FPE_CONDTRAP = 15
)

// Bits in the FLAGS argument to `send', `recv', et al.
const ( /* socket.h:200:1: */
	MSG_OOB        = 1  // Process out-of-band data.
	MSG_PEEK       = 2  // Peek at incoming messages.
	MSG_DONTROUTE  = 4  // Don't use local routing.
	MSG_CTRUNC     = 8  // Control data lost before delivery.
	MSG_PROXY      = 16 // Supply or ask second address.
	MSG_TRUNC      = 32
	MSG_DONTWAIT   = 64  // Nonblocking IO.
	MSG_EOR        = 128 // End of record.
	MSG_WAITALL    = 256 // Wait for a full request.
	MSG_FIN        = 512
	MSG_SYN        = 1024
	MSG_CONFIRM    = 2048 // Confirm path validity.
	MSG_RST        = 4096
	MSG_ERRQUEUE   = 8192      // Fetch message from error queue.
	MSG_NOSIGNAL   = 16384     // Do not generate SIGPIPE.
	MSG_MORE       = 32768     // Sender will send more.
	MSG_WAITFORONE = 65536     // Wait for at least one packet to return.
	MSG_BATCH      = 262144    // sendmmsg: more messages coming.
	MSG_ZEROCOPY   = 67108864  // Use user data in kernel path.
	MSG_FASTOPEN   = 536870912 // Send data in TCP SYN.

	MSG_CMSG_CLOEXEC = 1073741824
)

// Socket level message types.  This must match the definitions in
//    <linux/socket.h>.
const ( /* socket.h:332:1: */
	SCM_RIGHTS = 1
)

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// This operating system-specific header file defines the SOCK_*, PF_*,
//    AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
//    `struct msghdr', and `struct linger' types.
// System-specific socket constants and types.  Linux version.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Type for length arguments in socket calls.

// Get the architecture-dependent definition of enum __socket_type.
// Define enum __socket_type for generic Linux.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Types of sockets.
const ( /* socket_type.h:24:1: */
	SOCK_STREAM = 1 // Sequenced, reliable, connection-based
	// 				   byte streams.
	SOCK_DGRAM = 2 // Connectionless, unreliable datagrams
	// 				   of fixed maximum length.
	SOCK_RAW       = 3 // Raw protocol interface.
	SOCK_RDM       = 4 // Reliably-delivered messages.
	SOCK_SEQPACKET = 5 // Sequenced, reliable, connection-based,
	// 				   datagrams of fixed maximum length.
	SOCK_DCCP   = 6  // Datagram Congestion Control Protocol.
	SOCK_PACKET = 10 // Linux specific way of getting packets
	// 				   at the dev level.  For writing rarp and
	// 				   other similar things on the user level.

	// Flags to be ORed into the type parameter of socket and socketpair and
	//      used for the flags parameter of paccept.

	SOCK_CLOEXEC = 524288 // Atomically set close-on-exec flag for the
	// 				   new descriptor(s).
	SOCK_NONBLOCK = 2048
)

// sigstack, sigaltstack definitions.
//    Copyright (C) 1998-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Minimum stack size for a signal handler.

// System default stack size.

// ss_flags values for stack_t.  Linux version.
//    Copyright (C) 1998-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Possible values for `ss_flags'.
const ( /* ss_flags.h:27:1: */
	SS_ONSTACK = 1
	SS_DISABLE = 2
)

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// These macros could also be defined in <stdlib.h>.
// This will define the `W*' macros for the flag
//    bits to `waitpid', `wait3', and `wait4'.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

const ( /* waitflags.h:52:1: */
	P_ALL  = 0 // Wait for any child.
	P_PID  = 1 // Wait for specified process.
	P_PGID = 2
)

// The following constants should be used for the second parameter of
//    `shutdown'.
const ( /* socket.h:41:1: */
	SHUT_RD   = 0 // No more receptions.
	SHUT_WR   = 1 // No more transmissions.
	SHUT_RDWR = 2
)

// Values for the first argument to `getitimer' and `setitimer'.
const ( /* time.h:89:1: */
	// Timers run in real time.
	ITIMER_REAL = 0
	// Timers run only when the process is executing.
	ITIMER_VIRTUAL = 1
	// Timers run when the process is executing and when
	//        the system is executing on behalf of the process.
	ITIMER_PROF = 2
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type _G_fpos_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
} /* __fpos_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type _G_fpos64_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
} /* __fpos64_t.h:10:9 */

type _IO_FILE = struct {
	_flags          int32
	_               [4]byte
	_IO_read_ptr    uintptr
	_IO_read_end    uintptr
	_IO_read_base   uintptr
	_IO_write_base  uintptr
	_IO_write_ptr   uintptr
	_IO_write_end   uintptr
	_IO_buf_base    uintptr
	_IO_buf_end     uintptr
	_IO_save_base   uintptr
	_IO_backup_base uintptr
	_IO_save_end    uintptr
	_markers        uintptr
	_chain          uintptr
	_fileno         int32
	_flags2         int32
	_old_offset     int64
	_cur_column     uint16
	_vtable_offset  int8
	_shortbuf       [1]int8
	_               [4]byte
	_lock           uintptr
	_offset         int64
	_codecvt        uintptr
	_wide_data      uintptr
	_freeres_list   uintptr
	_freeres_buf    uintptr
	__pad5          size_t
	_mode           int32
	_unused2        [20]int8
} /* __FILE.h:4:1 */

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = _IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type va_list = uintptr /* stdio.h:52:24 */

type off_t = int64   /* stdio.h:65:19 */
type off64_t = int64 /* stdio.h:70:19 */

type ssize_t = int64 /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type fpos_t = _G_fpos64_t   /* stdio.h:86:20 */
type fpos64_t = _G_fpos64_t /* stdio.h:89:20 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//    stdio.h, because ANSI C says that stdio.h is not supposed to define
//    va_list.  stdio.h needs to have access to that data type,
//    but must not use that name.  It should use the name __gnuc_va_list,
//    which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//    But on BSD NET2 we must not test or define or undef it.
//    (Note that the comments in NET 2's ansi.h
//    are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

type stat = struct {
	st_dev     uint64
	st_ino     uint64
	st_nlink   uint64
	st_mode    uint32
	st_uid     uint32
	st_gid     uint32
	__pad0     int32
	st_rdev    uint64
	st_size    int64
	st_blksize int64
	st_blocks  int64
	st_atim    struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_mtim struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_ctim struct {
		tv_sec  int64
		tv_nsec int64
	}
	__glibc_reserved [3]int64
} /* stat.h:46:1 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	resultDontUse    uintptr
	freeProcDontUse  uintptr
	errorLineDontUse int32
	_                [4]byte
} /* tcl.h:493:9 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	proc    uintptr
	nextPtr uintptr
} /* tcl.h:535:9 */

type Tcl_Event = Tcl_Event1    /* tcl.h:535:26 */
type Tcl_InterpState = uintptr /* tcl.h:536:33 */
type Tcl_LoadHandle_ = struct {
	clientData        ClientData
	findSymbolProcPtr uintptr
	unloadFileProcPtr uintptr
} /* tcl.h:537:9 */

type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	start int64
	end   int64
} /* tcl.h:623:9 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	nsubs       int32
	_           [4]byte
	matches     uintptr
	extendStart int64
	reserved    int64
} /* tcl.h:630:9 */

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	__type      Tcl_ValueType
	_           [4]byte
	intValue    int64
	doubleValue float64
	wideValue   Tcl_WideInt
} /* tcl.h:694:9 */

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	refCount    int32
	_           [4]byte
	bytes       uintptr
	length      int32
	_           [4]byte
	typePtr     uintptr
	internalRep struct {
		longValue int64
		_         [8]byte
	}
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	name             uintptr
	freeIntRepProc   uintptr
	dupIntRepProc    uintptr
	updateStringProc uintptr
	setFromAnyProc   uintptr
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	result       uintptr
	freeProc     uintptr
	objResultPtr uintptr
	appendResult uintptr
	appendAvl    int32
	appendUsed   int32
	resultSpace  [201]int8
	_            [7]byte
} /* tcl.h:864:9 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	name       uintptr
	fullName   uintptr
	clientData ClientData
	deleteProc uintptr
	parentPtr  uintptr
} /* tcl.h:881:9 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	nsPtr   uintptr
	dummy1  int32
	dummy2  int32
	dummy3  uintptr
	dummy4  uintptr
	dummy5  uintptr
	dummy6  int32
	_       [4]byte
	dummy7  uintptr
	dummy8  uintptr
	dummy9  int32
	_       [4]byte
	dummy10 uintptr
	dummy11 uintptr
	dummy12 uintptr
	dummy13 uintptr
} /* tcl.h:922:9 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	isNativeObjectProc int32
	_                  [4]byte
	objProc            uintptr
	objClientData      ClientData
	proc               uintptr
	clientData         ClientData
	deleteProc         uintptr
	deleteData         ClientData
	namespacePtr       uintptr
} /* tcl.h:954:9 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	string      uintptr
	length      int32
	spaceAvl    int32
	staticSpace [200]int8
} /* tcl.h:983:9 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	version         int32
	flags           int32
	hashKeyProc     uintptr
	compareKeysProc uintptr
	allocEntryProc  uintptr
	freeEntryProc   uintptr
} /* tcl.h:1152:9 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	downShift     int32
	mask          int32
	keyType       int32
	findProc      uintptr
	createProc    uintptr
	typePtr       uintptr
} /* tcl.h:1153:9 */

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	nextPtr    uintptr
	tablePtr   uintptr
	hash       uintptr
	clientData ClientData
	key        struct{ oneWordValue uintptr }
} /* tcl.h:1153:9 */

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	tablePtr     uintptr
	nextIndex    int32
	_            [4]byte
	nextEntryPtr uintptr
} /* tcl.h:1308:9 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	next          uintptr
	epoch         int32
	_             [4]byte
	dictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	sec  int64
	usec int64
} /* tcl.h:1405:9 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	typeName         uintptr
	version          Tcl_ChannelTypeVersion
	closeProc        uintptr
	inputProc        uintptr
	outputProc       uintptr
	seekProc         uintptr
	setOptionProc    uintptr
	getOptionProc    uintptr
	watchProc        uintptr
	getHandleProc    uintptr
	close2Proc       uintptr
	blockModeProc    uintptr
	flushProc        uintptr
	handlerProc      uintptr
	wideSeekProc     uintptr
	threadActionProc uintptr
	truncateProc     uintptr
} /* tcl.h:1524:9 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	__type     int32
	perm       int32
	macType    uintptr
	macCreator uintptr
} /* tcl.h:1620:9 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */
// We have to declare the utime structure here.
type utimbuf = struct {
	actime  int64
	modtime int64
} /* utime.h:36:1 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	typeName                 uintptr
	structureLength          int32
	_                        [4]byte
	version                  Tcl_FSVersion
	pathInFilesystemProc     uintptr
	dupInternalRepProc       uintptr
	freeInternalRepProc      uintptr
	internalToNormalizedProc uintptr
	createInternalRepProc    uintptr
	normalizePathProc        uintptr
	filesystemPathTypeProc   uintptr
	filesystemSeparatorProc  uintptr
	statProc                 uintptr
	accessProc               uintptr
	openFileChannelProc      uintptr
	matchInDirectoryProc     uintptr
	utimeProc                uintptr
	linkProc                 uintptr
	listVolumesProc          uintptr
	fileAttrStringsProc      uintptr
	fileAttrsGetProc         uintptr
	fileAttrsSetProc         uintptr
	createDirectoryProc      uintptr
	removeDirectoryProc      uintptr
	deleteFileProc           uintptr
	copyFileProc             uintptr
	renameFileProc           uintptr
	copyDirectoryProc        uintptr
	lstatProc                uintptr
	loadFileProc             uintptr
	getCwdProc               uintptr
	chdirProc                uintptr
} /* tcl.h:1726:9 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	setTimerProc          uintptr
	waitForEventProc      uintptr
	createFileHandlerProc uintptr
	deleteFileHandlerProc uintptr
	initNotifierProc      uintptr
	finalizeNotifierProc  uintptr
	alertNotifierProc     uintptr
	serviceModeHookProc   uintptr
} /* tcl.h:1894:9 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	__type        int32
	_             [4]byte
	start         uintptr
	size          int32
	numComponents int32
} /* tcl.h:1914:9 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	commentStart    uintptr
	commentSize     int32
	_               [4]byte
	commandStart    uintptr
	commandSize     int32
	numWords        int32
	tokenPtr        uintptr
	numTokens       int32
	tokensAvailable int32
	errorType       int32
	_               [4]byte
	string          uintptr
	end             uintptr
	interp          uintptr
	term            uintptr
	incomplete      int32
	_               [4]byte
	staticTokens    [20]Tcl_Token
} /* tcl.h:2030:9 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	encodingName uintptr
	toUtfProc    uintptr
	fromUtfProc  uintptr
	freeProc     uintptr
	clientData   ClientData
	nullSize     int32
	_            [4]byte
} /* tcl.h:2091:9 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	key   uintptr
	value uintptr
} /* tcl.h:2237:9 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int1 = struct {
	used  int32
	alloc int32
	sign  mp_sign
	_     [4]byte
	dp    uintptr
} /* tcl.h:2266:9 */

type mp_digit = uint32 /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	__type     int32
	_          [4]byte
	keyStr     uintptr
	srcPtr     uintptr
	dstPtr     uintptr
	helpStr    uintptr
	clientData ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	magic int32
	_     [4]byte
	hooks uintptr
} /* tclDecls.h:1840:11 */

type TclIntStubs1 = struct {
	magic                        int32
	_                            [4]byte
	hooks                        uintptr
	reserved0                    uintptr
	reserved1                    uintptr
	reserved2                    uintptr
	tclAllocateFreeObjects       uintptr
	reserved4                    uintptr
	tclCleanupChildren           uintptr
	tclCleanupCommand            uintptr
	tclCopyAndCollapse           uintptr
	tclCopyChannelOld            uintptr
	tclCreatePipeline            uintptr
	tclCreateProc                uintptr
	tclDeleteCompiledLocalVars   uintptr
	tclDeleteVars                uintptr
	reserved13                   uintptr
	tclDumpMemoryInfo            uintptr
	reserved15                   uintptr
	tclExprFloatError            uintptr
	reserved17                   uintptr
	reserved18                   uintptr
	reserved19                   uintptr
	reserved20                   uintptr
	reserved21                   uintptr
	tclFindElement               uintptr
	tclFindProc                  uintptr
	tclFormatInt                 uintptr
	tclFreePackageInfo           uintptr
	reserved26                   uintptr
	reserved27                   uintptr
	tclpGetDefaultStdChannel     uintptr
	reserved29                   uintptr
	reserved30                   uintptr
	tclGetExtension              uintptr
	tclGetFrame                  uintptr
	reserved33                   uintptr
	tclGetIntForIndex            uintptr
	reserved35                   uintptr
	reserved36                   uintptr
	tclGetLoadedPackages         uintptr
	tclGetNamespaceForQualName   uintptr
	tclGetObjInterpProc          uintptr
	tclGetOpenMode               uintptr
	tclGetOriginalCommand        uintptr
	tclpGetUserHome              uintptr
	reserved43                   uintptr
	tclGuessPackageName          uintptr
	tclHideUnsafeCommands        uintptr
	tclInExit                    uintptr
	reserved47                   uintptr
	reserved48                   uintptr
	reserved49                   uintptr
	tclInitCompiledLocals        uintptr
	tclInterpInit                uintptr
	reserved52                   uintptr
	tclInvokeObjectCommand       uintptr
	tclInvokeStringCommand       uintptr
	tclIsProc                    uintptr
	reserved56                   uintptr
	reserved57                   uintptr
	tclLookupVar                 uintptr
	reserved59                   uintptr
	tclNeedSpace                 uintptr
	tclNewProcBodyObj            uintptr
	tclObjCommandComplete        uintptr
	tclObjInterpProc             uintptr
	tclObjInvoke                 uintptr
	reserved65                   uintptr
	reserved66                   uintptr
	reserved67                   uintptr
	reserved68                   uintptr
	tclpAlloc                    uintptr
	reserved70                   uintptr
	reserved71                   uintptr
	reserved72                   uintptr
	reserved73                   uintptr
	tclpFree                     uintptr
	tclpGetClicks                uintptr
	tclpGetSeconds               uintptr
	tclpGetTime                  uintptr
	reserved78                   uintptr
	reserved79                   uintptr
	reserved80                   uintptr
	tclpRealloc                  uintptr
	reserved82                   uintptr
	reserved83                   uintptr
	reserved84                   uintptr
	reserved85                   uintptr
	reserved86                   uintptr
	reserved87                   uintptr
	tclPrecTraceProc             uintptr
	tclPreventAliasLoop          uintptr
	reserved90                   uintptr
	tclProcCleanupProc           uintptr
	tclProcCompileProc           uintptr
	tclProcDeleteProc            uintptr
	reserved94                   uintptr
	reserved95                   uintptr
	tclRenameCommand             uintptr
	tclResetShadowedCmdRefs      uintptr
	tclServiceIdle               uintptr
	reserved99                   uintptr
	reserved100                  uintptr
	tclSetPreInitScript          uintptr
	tclSetupEnv                  uintptr
	tclSockGetPort               uintptr
	tclSockMinimumBuffersOld     uintptr
	reserved105                  uintptr
	reserved106                  uintptr
	reserved107                  uintptr
	tclTeardownNamespace         uintptr
	tclUpdateReturnInfo          uintptr
	tclSockMinimumBuffers        uintptr
	tcl_AddInterpResolvers       uintptr
	tcl_AppendExportList         uintptr
	tcl_CreateNamespace          uintptr
	tcl_DeleteNamespace          uintptr
	tcl_Export                   uintptr
	tcl_FindCommand              uintptr
	tcl_FindNamespace            uintptr
	tcl_GetInterpResolvers       uintptr
	tcl_GetNamespaceResolvers    uintptr
	tcl_FindNamespaceVar         uintptr
	tcl_ForgetImport             uintptr
	tcl_GetCommandFromObj        uintptr
	tcl_GetCommandFullName       uintptr
	tcl_GetCurrentNamespace      uintptr
	tcl_GetGlobalNamespace       uintptr
	tcl_GetVariableFullName      uintptr
	tcl_Import                   uintptr
	tcl_PopCallFrame             uintptr
	tcl_PushCallFrame            uintptr
	tcl_RemoveInterpResolvers    uintptr
	tcl_SetNamespaceResolvers    uintptr
	tclpHasSockets               uintptr
	tclpGetDate                  uintptr
	reserved134                  uintptr
	reserved135                  uintptr
	reserved136                  uintptr
	reserved137                  uintptr
	tclGetEnv                    uintptr
	reserved139                  uintptr
	reserved140                  uintptr
	tclpGetCwd                   uintptr
	tclSetByteCodeFromAny        uintptr
	tclAddLiteralObj             uintptr
	tclHideLiteral               uintptr
	tclGetAuxDataType            uintptr
	tclHandleCreate              uintptr
	tclHandleFree                uintptr
	tclHandlePreserve            uintptr
	tclHandleRelease             uintptr
	tclRegAbout                  uintptr
	tclRegExpRangeUniChar        uintptr
	tclSetLibraryPath            uintptr
	tclGetLibraryPath            uintptr
	reserved154                  uintptr
	reserved155                  uintptr
	tclRegError                  uintptr
	tclVarTraceExists            uintptr
	tclSetStartupScriptFileName  uintptr
	tclGetStartupScriptFileName  uintptr
	reserved160                  uintptr
	tclChannelTransform          uintptr
	tclChannelEventScriptInvoker uintptr
	tclGetInstructionTable       uintptr
	tclExpandCodeArray           uintptr
	tclpSetInitialEncodings      uintptr
	tclListObjSetElement         uintptr
	tclSetStartupScriptPath      uintptr
	tclGetStartupScriptPath      uintptr
	tclpUtfNcmp2                 uintptr
	tclCheckInterpTraces         uintptr
	tclCheckExecutionTraces      uintptr
	tclInThreadExit              uintptr
	tclUniCharMatch              uintptr
	reserved174                  uintptr
	tclCallVarTraces             uintptr
	tclCleanupVar                uintptr
	tclVarErrMsg                 uintptr
	tcl_SetStartupScript         uintptr
	tcl_GetStartupScript         uintptr
	reserved180                  uintptr
	reserved181                  uintptr
	tclpLocaltime                uintptr
	tclpGmtime                   uintptr
	reserved184                  uintptr
	reserved185                  uintptr
	reserved186                  uintptr
	reserved187                  uintptr
	reserved188                  uintptr
	reserved189                  uintptr
	reserved190                  uintptr
	reserved191                  uintptr
	reserved192                  uintptr
	reserved193                  uintptr
	reserved194                  uintptr
	reserved195                  uintptr
	reserved196                  uintptr
	reserved197                  uintptr
	tclObjGetFrame               uintptr
	reserved199                  uintptr
	tclpObjRemoveDirectory       uintptr
	tclpObjCopyDirectory         uintptr
	tclpObjCreateDirectory       uintptr
	tclpObjDeleteFile            uintptr
	tclpObjCopyFile              uintptr
	tclpObjRenameFile            uintptr
	tclpObjStat                  uintptr
	tclpObjAccess                uintptr
	tclpOpenFileChannel          uintptr
	reserved209                  uintptr
	reserved210                  uintptr
	reserved211                  uintptr
	tclpFindExecutable           uintptr
	tclGetObjNameOfExecutable    uintptr
	tclSetObjNameOfExecutable    uintptr
	tclStackAlloc                uintptr
	tclStackFree                 uintptr
	tclPushStackFrame            uintptr
	tclPopStackFrame             uintptr
	reserved219                  uintptr
	reserved220                  uintptr
	reserved221                  uintptr
	reserved222                  uintptr
	reserved223                  uintptr
	tclGetPlatform               uintptr
	tclTraceDictPath             uintptr
	tclObjBeingDeleted           uintptr
	tclSetNsPath                 uintptr
	reserved228                  uintptr
	tclPtrMakeUpvar              uintptr
	tclObjLookupVar              uintptr
	tclGetNamespaceFromObj       uintptr
	tclEvalObjEx                 uintptr
	tclGetSrcInfoForPc           uintptr
	tclVarHashCreateVar          uintptr
	tclInitVarHashTable          uintptr
	tclBackgroundException       uintptr
	tclResetCancellation         uintptr
	tclNRInterpProc              uintptr
	tclNRInterpProcCore          uintptr
	tclNRRunCallbacks            uintptr
	tclNREvalObjEx               uintptr
	tclNREvalObjv                uintptr
	tclDbDumpActiveObjects       uintptr
	tclGetNamespaceChildTable    uintptr
	tclGetNamespaceCommandTable  uintptr
	tclInitRewriteEnsemble       uintptr
	tclResetRewriteEnsemble      uintptr
	tclCopyChannel               uintptr
	tclDoubleDigits              uintptr
	tclSetSlaveCancelFlags       uintptr
	tclRegisterLiteral           uintptr
	tclPtrGetVar                 uintptr
	tclPtrSetVar                 uintptr
	tclPtrIncrObjVar             uintptr
	tclPtrObjMakeUpvar           uintptr
	tclPtrUnsetVar               uintptr
	reserved257                  uintptr
	tclUnusedStubEntry           uintptr
} /* tclDecls.h:1841:11 */

type TclIntPlatStubs1 = struct {
	magic                    int32
	_                        [4]byte
	hooks                    uintptr
	tclGetAndDetachPids      uintptr
	tclpCloseFile            uintptr
	tclpCreateCommandChannel uintptr
	tclpCreatePipe           uintptr
	tclpCreateProcess        uintptr
	reserved5                uintptr
	tclpMakeFile             uintptr
	tclpOpenFile             uintptr
	tclUnixWaitForFile       uintptr
	tclpCreateTempFile       uintptr
	tclpReaddir              uintptr
	tclpLocaltime_unix       uintptr
	tclpGmtime_unix          uintptr
	tclpInetNtoa             uintptr
	tclUnixCopyFile          uintptr
	reserved15               uintptr
	reserved16               uintptr
	reserved17               uintptr
	reserved18               uintptr
	reserved19               uintptr
	reserved20               uintptr
	reserved21               uintptr
	reserved22               uintptr
	reserved23               uintptr
	reserved24               uintptr
	reserved25               uintptr
	reserved26               uintptr
	reserved27               uintptr
	reserved28               uintptr
	tclWinCPUID              uintptr
	tclUnixOpenTemporaryFile uintptr
} /* tclDecls.h:1842:11 */

type TclStubHooks = struct {
	tclPlatStubs    uintptr
	tclIntStubs     uintptr
	tclIntPlatStubs uintptr
} /* tclDecls.h:1843:3 */

type TclStubs1 = struct {
	magic                                  int32
	_                                      [4]byte
	hooks                                  uintptr
	tcl_PkgProvideEx                       uintptr
	tcl_PkgRequireEx                       uintptr
	tcl_Panic                              uintptr
	tcl_Alloc                              uintptr
	tcl_Free                               uintptr
	tcl_Realloc                            uintptr
	tcl_DbCkalloc                          uintptr
	tcl_DbCkfree                           uintptr
	tcl_DbCkrealloc                        uintptr
	tcl_CreateFileHandler                  uintptr
	tcl_DeleteFileHandler                  uintptr
	tcl_SetTimer                           uintptr
	tcl_Sleep                              uintptr
	tcl_WaitForEvent                       uintptr
	tcl_AppendAllObjTypes                  uintptr
	tcl_AppendStringsToObj                 uintptr
	tcl_AppendToObj                        uintptr
	tcl_ConcatObj                          uintptr
	tcl_ConvertToType                      uintptr
	tcl_DbDecrRefCount                     uintptr
	tcl_DbIncrRefCount                     uintptr
	tcl_DbIsShared                         uintptr
	tcl_DbNewBooleanObj                    uintptr
	tcl_DbNewByteArrayObj                  uintptr
	tcl_DbNewDoubleObj                     uintptr
	tcl_DbNewListObj                       uintptr
	tcl_DbNewLongObj                       uintptr
	tcl_DbNewObj                           uintptr
	tcl_DbNewStringObj                     uintptr
	tcl_DuplicateObj                       uintptr
	tclFreeObj                             uintptr
	tcl_GetBoolean                         uintptr
	tcl_GetBooleanFromObj                  uintptr
	tcl_GetByteArrayFromObj                uintptr
	tcl_GetDouble                          uintptr
	tcl_GetDoubleFromObj                   uintptr
	tcl_GetIndexFromObj                    uintptr
	tcl_GetInt                             uintptr
	tcl_GetIntFromObj                      uintptr
	tcl_GetLongFromObj                     uintptr
	tcl_GetObjType                         uintptr
	tcl_GetStringFromObj                   uintptr
	tcl_InvalidateStringRep                uintptr
	tcl_ListObjAppendList                  uintptr
	tcl_ListObjAppendElement               uintptr
	tcl_ListObjGetElements                 uintptr
	tcl_ListObjIndex                       uintptr
	tcl_ListObjLength                      uintptr
	tcl_ListObjReplace                     uintptr
	tcl_NewBooleanObj                      uintptr
	tcl_NewByteArrayObj                    uintptr
	tcl_NewDoubleObj                       uintptr
	tcl_NewIntObj                          uintptr
	tcl_NewListObj                         uintptr
	tcl_NewLongObj                         uintptr
	tcl_NewObj                             uintptr
	tcl_NewStringObj                       uintptr
	tcl_SetBooleanObj                      uintptr
	tcl_SetByteArrayLength                 uintptr
	tcl_SetByteArrayObj                    uintptr
	tcl_SetDoubleObj                       uintptr
	tcl_SetIntObj                          uintptr
	tcl_SetListObj                         uintptr
	tcl_SetLongObj                         uintptr
	tcl_SetObjLength                       uintptr
	tcl_SetStringObj                       uintptr
	tcl_AddErrorInfo                       uintptr
	tcl_AddObjErrorInfo                    uintptr
	tcl_AllowExceptions                    uintptr
	tcl_AppendElement                      uintptr
	tcl_AppendResult                       uintptr
	tcl_AsyncCreate                        uintptr
	tcl_AsyncDelete                        uintptr
	tcl_AsyncInvoke                        uintptr
	tcl_AsyncMark                          uintptr
	tcl_AsyncReady                         uintptr
	tcl_BackgroundError                    uintptr
	tcl_Backslash                          uintptr
	tcl_BadChannelOption                   uintptr
	tcl_CallWhenDeleted                    uintptr
	tcl_CancelIdleCall                     uintptr
	tcl_Close                              uintptr
	tcl_CommandComplete                    uintptr
	tcl_Concat                             uintptr
	tcl_ConvertElement                     uintptr
	tcl_ConvertCountedElement              uintptr
	tcl_CreateAlias                        uintptr
	tcl_CreateAliasObj                     uintptr
	tcl_CreateChannel                      uintptr
	tcl_CreateChannelHandler               uintptr
	tcl_CreateCloseHandler                 uintptr
	tcl_CreateCommand                      uintptr
	tcl_CreateEventSource                  uintptr
	tcl_CreateExitHandler                  uintptr
	tcl_CreateInterp                       uintptr
	tcl_CreateMathFunc                     uintptr
	tcl_CreateObjCommand                   uintptr
	tcl_CreateSlave                        uintptr
	tcl_CreateTimerHandler                 uintptr
	tcl_CreateTrace                        uintptr
	tcl_DeleteAssocData                    uintptr
	tcl_DeleteChannelHandler               uintptr
	tcl_DeleteCloseHandler                 uintptr
	tcl_DeleteCommand                      uintptr
	tcl_DeleteCommandFromToken             uintptr
	tcl_DeleteEvents                       uintptr
	tcl_DeleteEventSource                  uintptr
	tcl_DeleteExitHandler                  uintptr
	tcl_DeleteHashEntry                    uintptr
	tcl_DeleteHashTable                    uintptr
	tcl_DeleteInterp                       uintptr
	tcl_DetachPids                         uintptr
	tcl_DeleteTimerHandler                 uintptr
	tcl_DeleteTrace                        uintptr
	tcl_DontCallWhenDeleted                uintptr
	tcl_DoOneEvent                         uintptr
	tcl_DoWhenIdle                         uintptr
	tcl_DStringAppend                      uintptr
	tcl_DStringAppendElement               uintptr
	tcl_DStringEndSublist                  uintptr
	tcl_DStringFree                        uintptr
	tcl_DStringGetResult                   uintptr
	tcl_DStringInit                        uintptr
	tcl_DStringResult                      uintptr
	tcl_DStringSetLength                   uintptr
	tcl_DStringStartSublist                uintptr
	tcl_Eof                                uintptr
	tcl_ErrnoId                            uintptr
	tcl_ErrnoMsg                           uintptr
	tcl_Eval                               uintptr
	tcl_EvalFile                           uintptr
	tcl_EvalObj                            uintptr
	tcl_EventuallyFree                     uintptr
	tcl_Exit                               uintptr
	tcl_ExposeCommand                      uintptr
	tcl_ExprBoolean                        uintptr
	tcl_ExprBooleanObj                     uintptr
	tcl_ExprDouble                         uintptr
	tcl_ExprDoubleObj                      uintptr
	tcl_ExprLong                           uintptr
	tcl_ExprLongObj                        uintptr
	tcl_ExprObj                            uintptr
	tcl_ExprString                         uintptr
	tcl_Finalize                           uintptr
	tcl_FindExecutable                     uintptr
	tcl_FirstHashEntry                     uintptr
	tcl_Flush                              uintptr
	tcl_FreeResult                         uintptr
	tcl_GetAlias                           uintptr
	tcl_GetAliasObj                        uintptr
	tcl_GetAssocData                       uintptr
	tcl_GetChannel                         uintptr
	tcl_GetChannelBufferSize               uintptr
	tcl_GetChannelHandle                   uintptr
	tcl_GetChannelInstanceData             uintptr
	tcl_GetChannelMode                     uintptr
	tcl_GetChannelName                     uintptr
	tcl_GetChannelOption                   uintptr
	tcl_GetChannelType                     uintptr
	tcl_GetCommandInfo                     uintptr
	tcl_GetCommandName                     uintptr
	tcl_GetErrno                           uintptr
	tcl_GetHostName                        uintptr
	tcl_GetInterpPath                      uintptr
	tcl_GetMaster                          uintptr
	tcl_GetNameOfExecutable                uintptr
	tcl_GetObjResult                       uintptr
	tcl_GetOpenFile                        uintptr
	tcl_GetPathType                        uintptr
	tcl_Gets                               uintptr
	tcl_GetsObj                            uintptr
	tcl_GetServiceMode                     uintptr
	tcl_GetSlave                           uintptr
	tcl_GetStdChannel                      uintptr
	tcl_GetStringResult                    uintptr
	tcl_GetVar                             uintptr
	tcl_GetVar2                            uintptr
	tcl_GlobalEval                         uintptr
	tcl_GlobalEvalObj                      uintptr
	tcl_HideCommand                        uintptr
	tcl_Init                               uintptr
	tcl_InitHashTable                      uintptr
	tcl_InputBlocked                       uintptr
	tcl_InputBuffered                      uintptr
	tcl_InterpDeleted                      uintptr
	tcl_IsSafe                             uintptr
	tcl_JoinPath                           uintptr
	tcl_LinkVar                            uintptr
	reserved188                            uintptr
	tcl_MakeFileChannel                    uintptr
	tcl_MakeSafe                           uintptr
	tcl_MakeTcpClientChannel               uintptr
	tcl_Merge                              uintptr
	tcl_NextHashEntry                      uintptr
	tcl_NotifyChannel                      uintptr
	tcl_ObjGetVar2                         uintptr
	tcl_ObjSetVar2                         uintptr
	tcl_OpenCommandChannel                 uintptr
	tcl_OpenFileChannel                    uintptr
	tcl_OpenTcpClient                      uintptr
	tcl_OpenTcpServer                      uintptr
	tcl_Preserve                           uintptr
	tcl_PrintDouble                        uintptr
	tcl_PutEnv                             uintptr
	tcl_PosixError                         uintptr
	tcl_QueueEvent                         uintptr
	tcl_Read                               uintptr
	tcl_ReapDetachedProcs                  uintptr
	tcl_RecordAndEval                      uintptr
	tcl_RecordAndEvalObj                   uintptr
	tcl_RegisterChannel                    uintptr
	tcl_RegisterObjType                    uintptr
	tcl_RegExpCompile                      uintptr
	tcl_RegExpExec                         uintptr
	tcl_RegExpMatch                        uintptr
	tcl_RegExpRange                        uintptr
	tcl_Release                            uintptr
	tcl_ResetResult                        uintptr
	tcl_ScanElement                        uintptr
	tcl_ScanCountedElement                 uintptr
	tcl_SeekOld                            uintptr
	tcl_ServiceAll                         uintptr
	tcl_ServiceEvent                       uintptr
	tcl_SetAssocData                       uintptr
	tcl_SetChannelBufferSize               uintptr
	tcl_SetChannelOption                   uintptr
	tcl_SetCommandInfo                     uintptr
	tcl_SetErrno                           uintptr
	tcl_SetErrorCode                       uintptr
	tcl_SetMaxBlockTime                    uintptr
	tcl_SetPanicProc                       uintptr
	tcl_SetRecursionLimit                  uintptr
	tcl_SetResult                          uintptr
	tcl_SetServiceMode                     uintptr
	tcl_SetObjErrorCode                    uintptr
	tcl_SetObjResult                       uintptr
	tcl_SetStdChannel                      uintptr
	tcl_SetVar                             uintptr
	tcl_SetVar2                            uintptr
	tcl_SignalId                           uintptr
	tcl_SignalMsg                          uintptr
	tcl_SourceRCFile                       uintptr
	tcl_SplitList                          uintptr
	tcl_SplitPath                          uintptr
	tcl_StaticPackage                      uintptr
	tcl_StringMatch                        uintptr
	tcl_TellOld                            uintptr
	tcl_TraceVar                           uintptr
	tcl_TraceVar2                          uintptr
	tcl_TranslateFileName                  uintptr
	tcl_Ungets                             uintptr
	tcl_UnlinkVar                          uintptr
	tcl_UnregisterChannel                  uintptr
	tcl_UnsetVar                           uintptr
	tcl_UnsetVar2                          uintptr
	tcl_UntraceVar                         uintptr
	tcl_UntraceVar2                        uintptr
	tcl_UpdateLinkedVar                    uintptr
	tcl_UpVar                              uintptr
	tcl_UpVar2                             uintptr
	tcl_VarEval                            uintptr
	tcl_VarTraceInfo                       uintptr
	tcl_VarTraceInfo2                      uintptr
	tcl_Write                              uintptr
	tcl_WrongNumArgs                       uintptr
	tcl_DumpActiveMemory                   uintptr
	tcl_ValidateAllMemory                  uintptr
	tcl_AppendResultVA                     uintptr
	tcl_AppendStringsToObjVA               uintptr
	tcl_HashStats                          uintptr
	tcl_ParseVar                           uintptr
	tcl_PkgPresent                         uintptr
	tcl_PkgPresentEx                       uintptr
	tcl_PkgProvide                         uintptr
	tcl_PkgRequire                         uintptr
	tcl_SetErrorCodeVA                     uintptr
	tcl_VarEvalVA                          uintptr
	tcl_WaitPid                            uintptr
	tcl_PanicVA                            uintptr
	tcl_GetVersion                         uintptr
	tcl_InitMemory                         uintptr
	tcl_StackChannel                       uintptr
	tcl_UnstackChannel                     uintptr
	tcl_GetStackedChannel                  uintptr
	tcl_SetMainLoop                        uintptr
	reserved285                            uintptr
	tcl_AppendObjToObj                     uintptr
	tcl_CreateEncoding                     uintptr
	tcl_CreateThreadExitHandler            uintptr
	tcl_DeleteThreadExitHandler            uintptr
	tcl_DiscardResult                      uintptr
	tcl_EvalEx                             uintptr
	tcl_EvalObjv                           uintptr
	tcl_EvalObjEx                          uintptr
	tcl_ExitThread                         uintptr
	tcl_ExternalToUtf                      uintptr
	tcl_ExternalToUtfDString               uintptr
	tcl_FinalizeThread                     uintptr
	tcl_FinalizeNotifier                   uintptr
	tcl_FreeEncoding                       uintptr
	tcl_GetCurrentThread                   uintptr
	tcl_GetEncoding                        uintptr
	tcl_GetEncodingName                    uintptr
	tcl_GetEncodingNames                   uintptr
	tcl_GetIndexFromObjStruct              uintptr
	tcl_GetThreadData                      uintptr
	tcl_GetVar2Ex                          uintptr
	tcl_InitNotifier                       uintptr
	tcl_MutexLock                          uintptr
	tcl_MutexUnlock                        uintptr
	tcl_ConditionNotify                    uintptr
	tcl_ConditionWait                      uintptr
	tcl_NumUtfChars                        uintptr
	tcl_ReadChars                          uintptr
	tcl_RestoreResult                      uintptr
	tcl_SaveResult                         uintptr
	tcl_SetSystemEncoding                  uintptr
	tcl_SetVar2Ex                          uintptr
	tcl_ThreadAlert                        uintptr
	tcl_ThreadQueueEvent                   uintptr
	tcl_UniCharAtIndex                     uintptr
	tcl_UniCharToLower                     uintptr
	tcl_UniCharToTitle                     uintptr
	tcl_UniCharToUpper                     uintptr
	tcl_UniCharToUtf                       uintptr
	tcl_UtfAtIndex                         uintptr
	tcl_UtfCharComplete                    uintptr
	tcl_UtfBackslash                       uintptr
	tcl_UtfFindFirst                       uintptr
	tcl_UtfFindLast                        uintptr
	tcl_UtfNext                            uintptr
	tcl_UtfPrev                            uintptr
	tcl_UtfToExternal                      uintptr
	tcl_UtfToExternalDString               uintptr
	tcl_UtfToLower                         uintptr
	tcl_UtfToTitle                         uintptr
	tcl_UtfToUniChar                       uintptr
	tcl_UtfToUpper                         uintptr
	tcl_WriteChars                         uintptr
	tcl_WriteObj                           uintptr
	tcl_GetString                          uintptr
	tcl_GetDefaultEncodingDir              uintptr
	tcl_SetDefaultEncodingDir              uintptr
	tcl_AlertNotifier                      uintptr
	tcl_ServiceModeHook                    uintptr
	tcl_UniCharIsAlnum                     uintptr
	tcl_UniCharIsAlpha                     uintptr
	tcl_UniCharIsDigit                     uintptr
	tcl_UniCharIsLower                     uintptr
	tcl_UniCharIsSpace                     uintptr
	tcl_UniCharIsUpper                     uintptr
	tcl_UniCharIsWordChar                  uintptr
	tcl_UniCharLen                         uintptr
	tcl_UniCharNcmp                        uintptr
	tcl_UniCharToUtfDString                uintptr
	tcl_UtfToUniCharDString                uintptr
	tcl_GetRegExpFromObj                   uintptr
	tcl_EvalTokens                         uintptr
	tcl_FreeParse                          uintptr
	tcl_LogCommandInfo                     uintptr
	tcl_ParseBraces                        uintptr
	tcl_ParseCommand                       uintptr
	tcl_ParseExpr                          uintptr
	tcl_ParseQuotedString                  uintptr
	tcl_ParseVarName                       uintptr
	tcl_GetCwd                             uintptr
	tcl_Chdir                              uintptr
	tcl_Access                             uintptr
	tcl_Stat                               uintptr
	tcl_UtfNcmp                            uintptr
	tcl_UtfNcasecmp                        uintptr
	tcl_StringCaseMatch                    uintptr
	tcl_UniCharIsControl                   uintptr
	tcl_UniCharIsGraph                     uintptr
	tcl_UniCharIsPrint                     uintptr
	tcl_UniCharIsPunct                     uintptr
	tcl_RegExpExecObj                      uintptr
	tcl_RegExpGetInfo                      uintptr
	tcl_NewUnicodeObj                      uintptr
	tcl_SetUnicodeObj                      uintptr
	tcl_GetCharLength                      uintptr
	tcl_GetUniChar                         uintptr
	tcl_GetUnicode                         uintptr
	tcl_GetRange                           uintptr
	tcl_AppendUnicodeToObj                 uintptr
	tcl_RegExpMatchObj                     uintptr
	tcl_SetNotifier                        uintptr
	tcl_GetAllocMutex                      uintptr
	tcl_GetChannelNames                    uintptr
	tcl_GetChannelNamesEx                  uintptr
	tcl_ProcObjCmd                         uintptr
	tcl_ConditionFinalize                  uintptr
	tcl_MutexFinalize                      uintptr
	tcl_CreateThread                       uintptr
	tcl_ReadRaw                            uintptr
	tcl_WriteRaw                           uintptr
	tcl_GetTopChannel                      uintptr
	tcl_ChannelBuffered                    uintptr
	tcl_ChannelName                        uintptr
	tcl_ChannelVersion                     uintptr
	tcl_ChannelBlockModeProc               uintptr
	tcl_ChannelCloseProc                   uintptr
	tcl_ChannelClose2Proc                  uintptr
	tcl_ChannelInputProc                   uintptr
	tcl_ChannelOutputProc                  uintptr
	tcl_ChannelSeekProc                    uintptr
	tcl_ChannelSetOptionProc               uintptr
	tcl_ChannelGetOptionProc               uintptr
	tcl_ChannelWatchProc                   uintptr
	tcl_ChannelGetHandleProc               uintptr
	tcl_ChannelFlushProc                   uintptr
	tcl_ChannelHandlerProc                 uintptr
	tcl_JoinThread                         uintptr
	tcl_IsChannelShared                    uintptr
	tcl_IsChannelRegistered                uintptr
	tcl_CutChannel                         uintptr
	tcl_SpliceChannel                      uintptr
	tcl_ClearChannelHandlers               uintptr
	tcl_IsChannelExisting                  uintptr
	tcl_UniCharNcasecmp                    uintptr
	tcl_UniCharCaseMatch                   uintptr
	tcl_FindHashEntry                      uintptr
	tcl_CreateHashEntry                    uintptr
	tcl_InitCustomHashTable                uintptr
	tcl_InitObjHashTable                   uintptr
	tcl_CommandTraceInfo                   uintptr
	tcl_TraceCommand                       uintptr
	tcl_UntraceCommand                     uintptr
	tcl_AttemptAlloc                       uintptr
	tcl_AttemptDbCkalloc                   uintptr
	tcl_AttemptRealloc                     uintptr
	tcl_AttemptDbCkrealloc                 uintptr
	tcl_AttemptSetObjLength                uintptr
	tcl_GetChannelThread                   uintptr
	tcl_GetUnicodeFromObj                  uintptr
	tcl_GetMathFuncInfo                    uintptr
	tcl_ListMathFuncs                      uintptr
	tcl_SubstObj                           uintptr
	tcl_DetachChannel                      uintptr
	tcl_IsStandardChannel                  uintptr
	tcl_FSCopyFile                         uintptr
	tcl_FSCopyDirectory                    uintptr
	tcl_FSCreateDirectory                  uintptr
	tcl_FSDeleteFile                       uintptr
	tcl_FSLoadFile                         uintptr
	tcl_FSMatchInDirectory                 uintptr
	tcl_FSLink                             uintptr
	tcl_FSRemoveDirectory                  uintptr
	tcl_FSRenameFile                       uintptr
	tcl_FSLstat                            uintptr
	tcl_FSUtime                            uintptr
	tcl_FSFileAttrsGet                     uintptr
	tcl_FSFileAttrsSet                     uintptr
	tcl_FSFileAttrStrings                  uintptr
	tcl_FSStat                             uintptr
	tcl_FSAccess                           uintptr
	tcl_FSOpenFileChannel                  uintptr
	tcl_FSGetCwd                           uintptr
	tcl_FSChdir                            uintptr
	tcl_FSConvertToPathType                uintptr
	tcl_FSJoinPath                         uintptr
	tcl_FSSplitPath                        uintptr
	tcl_FSEqualPaths                       uintptr
	tcl_FSGetNormalizedPath                uintptr
	tcl_FSJoinToPath                       uintptr
	tcl_FSGetInternalRep                   uintptr
	tcl_FSGetTranslatedPath                uintptr
	tcl_FSEvalFile                         uintptr
	tcl_FSNewNativePath                    uintptr
	tcl_FSGetNativePath                    uintptr
	tcl_FSFileSystemInfo                   uintptr
	tcl_FSPathSeparator                    uintptr
	tcl_FSListVolumes                      uintptr
	tcl_FSRegister                         uintptr
	tcl_FSUnregister                       uintptr
	tcl_FSData                             uintptr
	tcl_FSGetTranslatedStringPath          uintptr
	tcl_FSGetFileSystemForPath             uintptr
	tcl_FSGetPathType                      uintptr
	tcl_OutputBuffered                     uintptr
	tcl_FSMountsChanged                    uintptr
	tcl_EvalTokensStandard                 uintptr
	tcl_GetTime                            uintptr
	tcl_CreateObjTrace                     uintptr
	tcl_GetCommandInfoFromToken            uintptr
	tcl_SetCommandInfoFromToken            uintptr
	tcl_DbNewWideIntObj                    uintptr
	tcl_GetWideIntFromObj                  uintptr
	tcl_NewWideIntObj                      uintptr
	tcl_SetWideIntObj                      uintptr
	tcl_AllocStatBuf                       uintptr
	tcl_Seek                               uintptr
	tcl_Tell                               uintptr
	tcl_ChannelWideSeekProc                uintptr
	tcl_DictObjPut                         uintptr
	tcl_DictObjGet                         uintptr
	tcl_DictObjRemove                      uintptr
	tcl_DictObjSize                        uintptr
	tcl_DictObjFirst                       uintptr
	tcl_DictObjNext                        uintptr
	tcl_DictObjDone                        uintptr
	tcl_DictObjPutKeyList                  uintptr
	tcl_DictObjRemoveKeyList               uintptr
	tcl_NewDictObj                         uintptr
	tcl_DbNewDictObj                       uintptr
	tcl_RegisterConfig                     uintptr
	tcl_CreateNamespace                    uintptr
	tcl_DeleteNamespace                    uintptr
	tcl_AppendExportList                   uintptr
	tcl_Export                             uintptr
	tcl_Import                             uintptr
	tcl_ForgetImport                       uintptr
	tcl_GetCurrentNamespace                uintptr
	tcl_GetGlobalNamespace                 uintptr
	tcl_FindNamespace                      uintptr
	tcl_FindCommand                        uintptr
	tcl_GetCommandFromObj                  uintptr
	tcl_GetCommandFullName                 uintptr
	tcl_FSEvalFileEx                       uintptr
	tcl_SetExitProc                        uintptr
	tcl_LimitAddHandler                    uintptr
	tcl_LimitRemoveHandler                 uintptr
	tcl_LimitReady                         uintptr
	tcl_LimitCheck                         uintptr
	tcl_LimitExceeded                      uintptr
	tcl_LimitSetCommands                   uintptr
	tcl_LimitSetTime                       uintptr
	tcl_LimitSetGranularity                uintptr
	tcl_LimitTypeEnabled                   uintptr
	tcl_LimitTypeExceeded                  uintptr
	tcl_LimitTypeSet                       uintptr
	tcl_LimitTypeReset                     uintptr
	tcl_LimitGetCommands                   uintptr
	tcl_LimitGetTime                       uintptr
	tcl_LimitGetGranularity                uintptr
	tcl_SaveInterpState                    uintptr
	tcl_RestoreInterpState                 uintptr
	tcl_DiscardInterpState                 uintptr
	tcl_SetReturnOptions                   uintptr
	tcl_GetReturnOptions                   uintptr
	tcl_IsEnsemble                         uintptr
	tcl_CreateEnsemble                     uintptr
	tcl_FindEnsemble                       uintptr
	tcl_SetEnsembleSubcommandList          uintptr
	tcl_SetEnsembleMappingDict             uintptr
	tcl_SetEnsembleUnknownHandler          uintptr
	tcl_SetEnsembleFlags                   uintptr
	tcl_GetEnsembleSubcommandList          uintptr
	tcl_GetEnsembleMappingDict             uintptr
	tcl_GetEnsembleUnknownHandler          uintptr
	tcl_GetEnsembleFlags                   uintptr
	tcl_GetEnsembleNamespace               uintptr
	tcl_SetTimeProc                        uintptr
	tcl_QueryTimeProc                      uintptr
	tcl_ChannelThreadActionProc            uintptr
	tcl_NewBignumObj                       uintptr
	tcl_DbNewBignumObj                     uintptr
	tcl_SetBignumObj                       uintptr
	tcl_GetBignumFromObj                   uintptr
	tcl_TakeBignumFromObj                  uintptr
	tcl_TruncateChannel                    uintptr
	tcl_ChannelTruncateProc                uintptr
	tcl_SetChannelErrorInterp              uintptr
	tcl_GetChannelErrorInterp              uintptr
	tcl_SetChannelError                    uintptr
	tcl_GetChannelError                    uintptr
	tcl_InitBignumFromDouble               uintptr
	tcl_GetNamespaceUnknownHandler         uintptr
	tcl_SetNamespaceUnknownHandler         uintptr
	tcl_GetEncodingFromObj                 uintptr
	tcl_GetEncodingSearchPath              uintptr
	tcl_SetEncodingSearchPath              uintptr
	tcl_GetEncodingNameFromEnvironment     uintptr
	tcl_PkgRequireProc                     uintptr
	tcl_AppendObjToErrorInfo               uintptr
	tcl_AppendLimitedToObj                 uintptr
	tcl_Format                             uintptr
	tcl_AppendFormatToObj                  uintptr
	tcl_ObjPrintf                          uintptr
	tcl_AppendPrintfToObj                  uintptr
	tcl_CancelEval                         uintptr
	tcl_Canceled                           uintptr
	tcl_CreatePipe                         uintptr
	tcl_NRCreateCommand                    uintptr
	tcl_NREvalObj                          uintptr
	tcl_NREvalObjv                         uintptr
	tcl_NRCmdSwap                          uintptr
	tcl_NRAddCallback                      uintptr
	tcl_NRCallObjProc                      uintptr
	tcl_GetFSDeviceFromStat                uintptr
	tcl_GetFSInodeFromStat                 uintptr
	tcl_GetModeFromStat                    uintptr
	tcl_GetLinkCountFromStat               uintptr
	tcl_GetUserIdFromStat                  uintptr
	tcl_GetGroupIdFromStat                 uintptr
	tcl_GetDeviceTypeFromStat              uintptr
	tcl_GetAccessTimeFromStat              uintptr
	tcl_GetModificationTimeFromStat        uintptr
	tcl_GetChangeTimeFromStat              uintptr
	tcl_GetSizeFromStat                    uintptr
	tcl_GetBlocksFromStat                  uintptr
	tcl_GetBlockSizeFromStat               uintptr
	tcl_SetEnsembleParameterList           uintptr
	tcl_GetEnsembleParameterList           uintptr
	tcl_ParseArgsObjv                      uintptr
	tcl_GetErrorLine                       uintptr
	tcl_SetErrorLine                       uintptr
	tcl_TransferResult                     uintptr
	tcl_InterpActive                       uintptr
	tcl_BackgroundException                uintptr
	tcl_ZlibDeflate                        uintptr
	tcl_ZlibInflate                        uintptr
	tcl_ZlibCRC32                          uintptr
	tcl_ZlibAdler32                        uintptr
	tcl_ZlibStreamInit                     uintptr
	tcl_ZlibStreamGetCommandName           uintptr
	tcl_ZlibStreamEof                      uintptr
	tcl_ZlibStreamChecksum                 uintptr
	tcl_ZlibStreamPut                      uintptr
	tcl_ZlibStreamGet                      uintptr
	tcl_ZlibStreamClose                    uintptr
	tcl_ZlibStreamReset                    uintptr
	tcl_SetStartupScript                   uintptr
	tcl_GetStartupScript                   uintptr
	tcl_CloseEx                            uintptr
	tcl_NRExprObj                          uintptr
	tcl_NRSubstObj                         uintptr
	tcl_LoadFile                           uintptr
	tcl_FindSymbol                         uintptr
	tcl_FSUnloadFile                       uintptr
	tcl_ZlibStreamSetCompressionDictionary uintptr
	reserved631                            uintptr
	reserved632                            uintptr
	reserved633                            uintptr
	reserved634                            uintptr
	reserved635                            uintptr
	reserved636                            uintptr
	reserved637                            uintptr
	reserved638                            uintptr
	reserved639                            uintptr
	reserved640                            uintptr
	reserved641                            uintptr
	reserved642                            uintptr
	reserved643                            uintptr
	reserved644                            uintptr
	reserved645                            uintptr
	reserved646                            uintptr
	reserved647                            uintptr
	tclUnusedStubEntry                     uintptr
} /* tclDecls.h:1845:9 */

type TclStubs = TclStubs1 /* tclDecls.h:2522:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// The following #if block allows you to change how Tcl finds the startup
// script, prime the library or encoding paths, fiddle with the argv, etc.,
// without needing to rewrite Tcl_Main()

//----------------------------------------------------------------------
//
// main --
//
//	This is the main program for the application.
//
// Results:
//	None: Tcl_Main never returns here, so this procedure never returns
//	either.
//
// Side effects:
//	Just about anything, since from here we call arbitrary Tcl code.
//
//----------------------------------------------------------------------

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* tclAppInit.c:72:1: */

	tcl.XTcl_MainEx(tls, argc, argv, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcl_AppInit})), tcl.XTcl_CreateInterp(tls))
	return 0 // Needed only to prevent compiler warning.
}

//----------------------------------------------------------------------
//
// Tcl_AppInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcl_AppInit(tls *libc.TLS, interp uintptr) int32 { /* tclAppInit.c:108:1: */
	if tcl.XTcl_Init(tls, interp) == TCL_ERROR {
		return TCL_ERROR
	}

	if Tcltest_Init(tls, interp) == TCL_ERROR {
		return TCL_ERROR
	}
	tcl.XTcl_StaticPackage(tls, interp, ts /* "Tcltest" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcltest_Init})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcltest_SafeInit})))

	// Call the init procedures for included packages. Each call should look
	// like this:
	//
	// if (Mod_Init(interp) == TCL_ERROR) {
	//     return TCL_ERROR;
	// }
	//
	// where "Mod" is the name of the module. (Dynamically-loadable packages
	// should have the same entry-point name.)

	// Call Tcl_CreateCommand for application-specific commands, if they
	// weren't already created by the init procedures called above.

	// Specify a user-specific startup file to invoke if the application is
	// run interactively. Typically the startup file is "~/.apprc" where "app"
	// is the name of the application. If this line is deleted then no
	// user-specific startup file will be run under any conditions.

	tcl.XTcl_ObjSetVar2(tls, interp, tcl.XTcl_NewStringObj(tls, ts+8 /* "tcl_rcFileName" */, -1), uintptr(0),
		tcl.XTcl_NewStringObj(tls, ts+23 /* "~/.tclshrc" */, -1), TCL_GLOBAL_ONLY)

	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// Get the definitions of O_*, F_*, FD_*: all the
//    numbers and flag bits for `open', `fcntl', et al.
// O_*, F_*, FD_* bit values for Linux/x86.
//    Copyright (C) 2001-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Not necessary, we always have 64-bit offsets.

type flock = struct {
	l_type   int16
	l_whence int16
	_        [4]byte
	l_start  int64
	l_len    int64
	l_pid    int32
	_        [4]byte
} /* fcntl.h:35:1 */

type flock64 = struct {
	l_type   int16
	l_whence int16
	_        [4]byte
	l_start  int64
	l_len    int64
	l_pid    int32
	_        [4]byte
} /* fcntl.h:50:1 */

// Include generic Linux declarations.
// O_*, F_*, FD_* bit values for Linux.
//    Copyright (C) 2001-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This file contains shared definitions between Linux architectures
//    and is included by <bits/fcntl.h> to declare them.  The various
//    #ifndef cases allow the architecture specific file to define those
//    values with different values.
//
//    A minimal <bits/fcntl.h> contains just:
//
//    struct flock {...}
//    #ifdef __USE_LARGEFILE64
//    struct flock64 {...}
//    #endif
//    #include <bits/fcntl-linux.h>

// open/fcntl.

// open file description locks.
//
//    Usually record locks held by a process are released on *any* close and are
//    not inherited across a fork.
//
//    These cmd values will set locks that conflict with process-associated record
//    locks, but are "owned" by the opened file description, not the process.
//    This means that they are inherited across fork or clone with CLONE_FILES
//    like BSD (flock) locks, and they are only released automatically when the
//    last reference to the the file description against which they were acquired
//    is put.

// For now, Linux has no separate synchronicity options for read
//    operations.  We define O_RSYNC therefore as the same as O_SYNC
//    since this is a superset.

// Values for the second argument to `fcntl'.

// For F_[GET|SET]FD.

// For posix fcntl() and `l_type' field of a `struct flock' for lockf().

// For old implementation of BSD flock.

// Operations for BSD flock, also used by the kernel implementation.

// Define some more compatibility macros to be backward compatible with
//    BSD systems which did not managed to hide these kernel macros.

// Advise to `posix_fadvise'.

// Values for `*at' functions.

// Detect if open needs mode as a third argument (or for openat as a fourth
//    argument).

// POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
//    Earlier POSIX standards permitted any type ending in `_t' to be defined
//    by any POSIX header, so we don't conditionalize the definitions here.
type mode_t = uint32 /* fcntl.h:50:18 */

type pid_t = int32 /* fcntl.h:69:17 */

// For XPG all symbols from <sys/stat.h> should also be available.
// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definitions for byte order, according to significance of bytes,
//    from low addresses to high addresses.  The value is what you get by
//    putting '4' in the most significant byte, '3' in the second most
//    significant byte, '2' in the second least significant byte, and '1'
//    in the least significant byte, and then writing down one digit for
//    each byte, starting with the byte at the lowest address at the left,
//    and proceeding to the byte with the highest address at the right.

// This file defines `__BYTE_ORDER' for the particular machine.

// i386/x86_64 are little-endian.

// Some machines may need to use a different endianness for floating point
//    values.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type timespec = struct {
	tv_sec  int64
	tv_nsec int64
} /* struct_timespec.h:10:1 */

// Note stat64 has the same shape as stat for x86-64.
type stat64 = struct {
	st_dev     uint64
	st_ino     uint64
	st_nlink   uint64
	st_mode    uint32
	st_uid     uint32
	st_gid     uint32
	__pad0     int32
	st_rdev    uint64
	st_size    int64
	st_blksize int64
	st_blocks  int64
	st_atim    struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_mtim struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_ctim struct {
		tv_sec  int64
		tv_nsec int64
	}
	__glibc_reserved [3]int64
} /* stat.h:119:1 */

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// The Single Unix specification says that some more types are
//    available here.
type gid_t = uint32 /* pwd.h:38:17 */

type uid_t = uint32 /* pwd.h:43:17 */

// A record in the user database.
type passwd = struct {
	pw_name   uintptr
	pw_passwd uintptr
	pw_uid    uint32
	pw_gid    uint32
	pw_gecos  uintptr
	pw_dir    uintptr
	pw_shell  uintptr
} /* pwd.h:49:1 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Signal number definitions.  Linux version.
//    Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Signal number constants.  Generic template.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Fake signal functions.

// We define here all the signal names listed in POSIX (1003.1-2008);
//    as of 1003.1-2013, no additional signals have been added by POSIX.
//    We also define here signal names that historically exist in every
//    real-world POSIX variant (e.g. SIGWINCH).
//
//    Signals in the 1-15 range are defined with their historical numbers.
//    For other signals, we use the BSD numbers.
//    There are two unallocated signal numbers in the 1-31 range: 7 and 29.
//    Signal number 0 is reserved for use as kill(pid, 0), to test whether
//    a process exists without sending it a signal.

// ISO C99 signals.

// Historical signals specified by POSIX.

// New(er) POSIX signals (1003.1-2008, 1003.1-2013).

// Nonstandard signals found in all modern POSIX systems
//    (including both BSD and Linux).

// Archaic names for compatibility.

// Not all systems support real-time signals.  bits/signum.h indicates
//    that they are supported by overriding __SIGRTMAX to a value greater
//    than __SIGRTMIN.  These constants give the kernel-level hard limits,
//    but some real-time signals may be used internally by glibc.  Do not
//    use these constants in application code; use SIGRTMIN and SIGRTMAX
//    (defined in signal.h) instead.

// Biggest signal number + 1 (including real-time signals).

// Adjustments and additions to the signal number constants for
//    most Linux systems.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// An integral type that can be modified atomically, without the
//    possibility of a signal arriving in the middle of the operation.
type sig_atomic_t = int32 /* sig_atomic_t.h:8:24 */

// A set of signals to be blocked, unblocked, or waited for.
type sigset_t = struct{ __val [16]uint64 } /* sigset_t.h:7:20 */

// We need `struct timespec' later on.
// NB: Include guard matches what <linux/time.h> uses.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Type for data associated with a signal.
type sigval = struct {
	_         [0]uint64
	sival_int int32
	_         [4]byte
} /* __sigval_t.h:24:1 */

// Some fields of siginfo_t have architecture-specific variations.
// Architecture-specific adjustments to siginfo_t.  x86 version.

type siginfo_t = struct {
	si_signo  int32
	si_errno  int32
	si_code   int32
	__pad0    int32
	_sifields struct {
		_    [0]uint64
		_pad [28]int32
	}
} /* siginfo_t.h:124:5 */

// Architectures might also add architecture-specific constants.
//    These are all considered GNU extensions.

// Define __sigval_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// To avoid sigval_t (not a standard type name) having C++ name
//    mangling depending on whether the selected standard includes union
//    sigval, it should not be defined at all when using a standard for
//    which the sigval name is not reserved; in that case, headers should
//    not include <bits/types/sigval_t.h> and should use only the
//    internal __sigval_t name.

type sigval_t = sigval /* sigval_t.h:16:20 */

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Forward declaration.
type pthread_attr_t1 = struct {
	_      [0]uint64
	__size [56]int8
} /* sigevent_t.h:17:9 */

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Forward declaration.
type pthread_attr_t = pthread_attr_t1 /* sigevent_t.h:17:30 */

// Structure to transport application-defined values with signals.
type sigevent = struct {
	sigev_value struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	sigev_signo  int32
	sigev_notify int32
	_sigev_un    struct {
		_    [0]uint64
		_pad [12]int32
	}
} /* sigevent_t.h:22:9 */

// Structure to transport application-defined values with signals.
type sigevent_t = sigevent /* sigevent_t.h:42:5 */

// 4.4 BSD uses the name `sig_t' for this.
type sig_t = uintptr /* signal.h:190:24 */

// Get the system-specific definitions of `struct sigaction'
//    and the `SA_*' and `SIG_*'. constants.
// The proper definitions for Linux's sigaction.
//    Copyright (C) 1993-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Structure describing the action to be taken when a signal arrives.
type sigaction = struct {
	__sigaction_handler struct{ sa_handler uintptr }
	sa_mask             struct{ __val [16]uint64 }
	sa_flags            int32
	_                   [4]byte
	sa_restorer         uintptr
} /* sigaction.h:27:1 */

// Get machine-dependent `struct sigcontext' and signal subcodes.
// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type _fpx_sw_bytes = struct {
	magic1            uint32
	extended_size     uint32
	xstate_bv         uint64
	xstate_size       uint32
	__glibc_reserved1 [7]uint32
} /* sigcontext.h:31:1 */

type _fpreg = struct {
	significand [4]uint16
	exponent    uint16
} /* sigcontext.h:40:1 */

type _fpxreg = struct {
	significand       [4]uint16
	exponent          uint16
	__glibc_reserved1 [3]uint16
} /* sigcontext.h:46:1 */

type _xmmreg = struct{ element [4]uint32 } /* sigcontext.h:53:1 */

type _fpstate = struct {
	cwd       uint16
	swd       uint16
	ftw       uint16
	fop       uint16
	rip       uint64
	rdp       uint64
	mxcsr     uint32
	mxcr_mask uint32
	_st       [8]struct {
		significand       [4]uint16
		exponent          uint16
		__glibc_reserved1 [3]uint16
	}
	_xmm              [16]struct{ element [4]uint32 }
	__glibc_reserved1 [24]uint32
} /* sigcontext.h:123:1 */

type sigcontext = struct {
	r8          uint64
	r9          uint64
	r10         uint64
	r11         uint64
	r12         uint64
	r13         uint64
	r14         uint64
	r15         uint64
	rdi         uint64
	rsi         uint64
	rbp         uint64
	rbx         uint64
	rdx         uint64
	rax         uint64
	rcx         uint64
	rsp         uint64
	rip         uint64
	eflags      uint64
	cs          uint16
	gs          uint16
	fs          uint16
	__pad0      uint16
	err         uint64
	trapno      uint64
	oldmask     uint64
	cr2         uint64
	__184       struct{ fpstate uintptr }
	__reserved1 [8]uint64
} /* sigcontext.h:139:1 */

type _xsave_hdr = struct {
	xstate_bv         uint64
	__glibc_reserved1 [2]uint64
	__glibc_reserved2 [5]uint64
} /* sigcontext.h:177:1 */

type _ymmh_state = struct{ ymmh_space [64]uint32 } /* sigcontext.h:184:1 */

type _xstate = struct {
	fpstate struct {
		cwd       uint16
		swd       uint16
		ftw       uint16
		fop       uint16
		rip       uint64
		rdp       uint64
		mxcsr     uint32
		mxcr_mask uint32
		_st       [8]struct {
			significand       [4]uint16
			exponent          uint16
			__glibc_reserved1 [3]uint16
		}
		_xmm              [16]struct{ element [4]uint32 }
		__glibc_reserved1 [24]uint32
	}
	xstate_hdr struct {
		xstate_bv         uint64
		__glibc_reserved1 [2]uint64
		__glibc_reserved2 [5]uint64
	}
	ymmh struct{ ymmh_space [64]uint32 }
} /* sigcontext.h:189:1 */

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Define stack_t.  Linux version.
//    Copyright (C) 1998-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Structure describing a signal stack.
type stack_t = struct {
	ss_sp    uintptr
	ss_flags int32
	_        [4]byte
	ss_size  size_t
} /* stack_t.h:31:5 */

// This will define `ucontext_t' and `mcontext_t'.
// Copyright (C) 2001-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define stack_t.  Linux version.
//    Copyright (C) 1998-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Type for general register.
type greg_t = int64 /* ucontext.h:37:37 */

// Number of general registers.

// Container for all general registers.
type gregset_t = [23]greg_t /* ucontext.h:46:16 */

type _libc_fpxreg = struct {
	significand       [4]uint16
	exponent          uint16
	__glibc_reserved1 [3]uint16
} /* ucontext.h:101:1 */

type _libc_xmmreg = struct{ element [4]uint32 } /* ucontext.h:108:1 */

type _libc_fpstate = struct {
	cwd       uint16
	swd       uint16
	ftw       uint16
	fop       uint16
	rip       uint64
	rdp       uint64
	mxcsr     uint32
	mxcr_mask uint32
	_st       [8]struct {
		significand       [4]uint16
		exponent          uint16
		__glibc_reserved1 [3]uint16
	}
	_xmm              [16]struct{ element [4]uint32 }
	__glibc_reserved1 [24]uint32
} /* ucontext.h:113:1 */

// Structure to describe FPU registers.
type fpregset_t = uintptr /* ucontext.h:130:30 */

// Context to describe whole processor state.
type mcontext_t = struct {
	gregs       gregset_t
	fpregs      fpregset_t
	__reserved1 [8]uint64
} /* ucontext.h:139:3 */

// Userlevel context.
type ucontext_t1 = struct {
	uc_flags     uint64
	uc_link      uintptr
	uc_stack     stack_t
	uc_mcontext  mcontext_t
	uc_sigmask   sigset_t
	__fpregs_mem struct {
		cwd       uint16
		swd       uint16
		ftw       uint16
		fop       uint16
		rip       uint64
		rdp       uint64
		mxcsr     uint32
		mxcr_mask uint32
		_st       [8]struct {
			significand       [4]uint16
			exponent          uint16
			__glibc_reserved1 [3]uint16
		}
		_xmm              [16]struct{ element [4]uint32 }
		__glibc_reserved1 [24]uint32
	}
	__ssp [4]uint64
} /* ucontext.h:142:9 */

// Userlevel context.
type ucontext_t = ucontext_t1 /* ucontext.h:151:5 */

// Define struct sigstack.
//    Copyright (C) 1998-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Structure describing a signal stack (obsolete).
type sigstack = struct {
	ss_sp      uintptr
	ss_onstack int32
	_          [4]byte
} /* struct_sigstack.h:23:1 */

// Some of the functions for handling signals in threaded programs must
//    be defined here.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Common definition of pthread_mutex_t.

type __pthread_internal_list = struct {
	__prev uintptr
	__next uintptr
} /* thread-shared-types.h:49:9 */

type __pthread_internal_slist = struct{ __next uintptr } /* thread-shared-types.h:55:9 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type __pthread_mutex_s = struct {
	__lock    int32
	__count   uint32
	__owner   int32
	__nusers  uint32
	__kind    int32
	__spins   int16
	__elision int16
	__list    struct {
		__prev uintptr
		__next uintptr
	}
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type __pthread_rwlock_arch_t = struct {
	__readers       uint32
	__writers       uint32
	__wrphase_futex uint32
	__writers_futex uint32
	__pad3          uint32
	__pad4          uint32
	__cur_writer    int32
	__shared        int32
	__rwelision     int8
	__pad1          [7]uint8
	__pad2          uint64
	__flags         uint32
	_               [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type __pthread_cond_s = struct {
	__0            struct{ __wseq uint64 }
	__8            struct{ __g1_start uint64 }
	__g_refs       [2]uint32
	__g_size       [2]uint32
	__g1_orig_size uint32
	__wrefs        uint32
	__g_signals    [2]uint32
} /* thread-shared-types.h:92:1 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type pthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type pthread_mutexattr_t = struct {
	_      [0]uint32
	__size [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type pthread_condattr_t = struct {
	_      [0]uint32
	__size [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type pthread_mutex_t = struct{ __data __pthread_mutex_s } /* pthreadtypes.h:72:3 */

type pthread_cond_t = struct{ __data __pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type pthread_rwlock_t = struct{ __data __pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type pthread_rwlockattr_t = struct {
	_      [0]uint64
	__size [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type pthread_barrier_t = struct {
	_      [0]uint64
	__size [32]int8
} /* pthreadtypes.h:112:3 */

type pthread_barrierattr_t = struct {
	_      [0]uint32
	__size [4]int8
} /* pthreadtypes.h:118:3 */

// System-specific extensions.
// System-specific extensions of <signal.h>, Linux version.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Compatibility header for old-style Unix parameters and limits.
//    Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type u_char = uint8                    /* types.h:33:18 */
type u_short = uint16                  /* types.h:34:19 */
type u_int = uint32                    /* types.h:35:17 */
type u_long = uint64                   /* types.h:36:18 */
type quad_t = int64                    /* types.h:37:18 */
type u_quad_t = uint64                 /* types.h:38:20 */
type fsid_t = struct{ __val [2]int32 } /* types.h:39:18 */
type loff_t = int64                    /* types.h:42:18 */

type ino_t = uint64   /* types.h:49:19 */
type ino64_t = uint64 /* types.h:54:19 */

type dev_t = uint64 /* types.h:59:17 */

type nlink_t = uint64 /* types.h:74:19 */

type id_t = uint32 /* types.h:103:16 */

type daddr_t = int32   /* types.h:114:19 */
type caddr_t = uintptr /* types.h:115:19 */

type key_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type clock_t = int64 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type clockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type time_t = int64 /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type timer_t = uintptr /* timer_t.h:7:19 */

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type ulong = uint64  /* types.h:148:27 */
type ushort = uint16 /* types.h:149:28 */
type uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type int8_t = int8   /* stdint-intn.h:24:18 */
type int16_t = int16 /* stdint-intn.h:25:19 */
type int32_t = int32 /* stdint-intn.h:26:19 */
type int64_t = int64 /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type u_int8_t = uint8   /* types.h:158:19 */
type u_int16_t = uint16 /* types.h:159:20 */
type u_int32_t = uint32 /* types.h:160:20 */
type u_int64_t = uint64 /* types.h:161:20 */

type register_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Get sigset_t.

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type timeval = struct {
	tv_sec  int64
	tv_usec int64
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

type suseconds_t = int64 /* select.h:43:23 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set = struct{ __fds_bits [16]int64 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type fd_mask = int64 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type blksize_t = int64 /* types.h:185:21 */

// Types from the Large File Support interface.
type blkcnt_t = int64    /* types.h:205:22 */ // Type to count number of disk blocks.
type fsblkcnt_t = uint64 /* types.h:209:24 */ // Type to count file system blocks.
type fsfilcnt_t = uint64 /* types.h:213:24 */ // Type to count file system inodes.

type blkcnt64_t = int64    /* types.h:219:22 */ // Type to count number of disk blocks.
type fsblkcnt64_t = uint64 /* types.h:220:24 */ // Type to count file system blocks.
type fsfilcnt64_t = uint64 /* types.h:221:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Maximum length of any multibyte character in any locale.
//    We define this value here since the gcc header does not define
//    the correct value.

// If we are not using GNU CC we have to define all the symbols ourself.
//    Otherwise use gcc's definitions (see below).

// Get the compiler's limits.h, which defines almost all the ISO constants.
//
//     We put this #include_next outside the double inclusion check because
//     it should be possible to include this file more than once and still get
//     the definitions from gcc's header.

// The <limits.h> files in some gcc versions don't define LLONG_MIN,
//    LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
//    ages are available.

// The integer width macros are not defined by GCC's <limits.h> before
//    GCC 7, or if _GNU_SOURCE rather than
//    __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.

// POSIX adds things to <limits.h>.
// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
//
//	Never include this file directly; use <limits.h> instead.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// These are the standard-mandated minimum values.

// Minimum number of operations in one list I/O call.

// Minimal number of outstanding asynchronous I/O operations.

// Maximum length of arguments to `execve', including environment.

// Maximum simultaneous processes per real user ID.

// Minimal number of timer expiration overruns.

// Maximum length of a host name (not including the terminating null)
//    as returned from the GETHOSTNAME function.

// Maximum link count of a file.

// Maximum length of login name.

// Number of bytes in a terminal canonical input queue.

// Number of bytes for which space will be
//    available in a terminal input queue.

// Maximum number of message queues open for a process.

// Maximum number of supported message priorities.

// Number of bytes in a filename.

// Number of simultaneous supplementary group IDs per process.

// Number of files one process can have open at once.

// Number of bytes in a pathname.

// Number of bytes than can be written atomically to a pipe.

// The number of repeated occurrences of a BRE permitted by the
//    REGEXEC and REGCOMP functions when using the interval notation.

// Minimal number of realtime signals reserved for the application.

// Number of semaphores a process can have.

// Maximal value of a semaphore.

// Number of pending realtime signals.

// Largest value of a `ssize_t'.

// Number of streams a process can have open at once.

// The number of bytes in a symbolic link.

// The number of symbolic links that can be traversed in the
//    resolution of a pathname in the absence of a loop.

// Number of timer for a process.

// Maximum number of characters in a tty name.

// Maximum length of a timezone name (element of `tzname').

// Maximum clock resolution in nanoseconds.

// Get the implementation-specific values for the above.
// Minimum guaranteed maximum values for system limits.  Linux version.
//    Copyright (C) 1993-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <https://www.gnu.org/licenses/>.

// The kernel header pollutes the namespace with the NR_OPEN symbol
//    and defines LINK_MAX although filesystems have different maxima.  A
//    similar thing is true for OPEN_MAX: the limit can be changed at
//    runtime and therefore the macro must not be defined.  Remove this
//    after including the header if necessary.

// The kernel sources contain a file with all the needed information.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Have to remove NR_OPEN?
// Have to remove LINK_MAX?
// Have to remove OPEN_MAX?
// Have to remove ARG_MAX?

// The number of data keys per process.
// This is the value this implementation supports.

// Controlling the iterations of destructors for thread-specific data.
// Number of iterations this implementation does.

// The number of threads per process.
// We have no predefined limit on the number of threads.

// Maximum amount by which a process can descrease its asynchronous I/O
//    priority level.

// Minimum size for a thread.  We are free to choose a reasonable value.

// Maximum number of timer expiration overruns.

// Maximum tty name length.

// Maximum login name length.  This is arbitrary.

// Maximum host name length.

// Maximum message queue priority level.

// Maximum value the semaphore can have.

// ssize_t is not formally required to be the signed type
//    corresponding to size_t, but it is for all configurations supported
//    by glibc.

// This value is a guaranteed minimum maximum.
//    The current maximum can be got from `sysconf'.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; include <limits.h> instead.

// The maximum `ibase' and `obase' values allowed by the `bc' utility.

// The maximum number of elements allowed in an array by the `bc' utility.

// The maximum `scale' value allowed by the `bc' utility.

// The maximum length of a string constant accepted by the `bc' utility.

// The maximum number of weights that can be assigned to an entry of
//    the LC_COLLATE `order' keyword in the locale definition file.

// The maximum number of expressions that can be nested
//    within parentheses by the `expr' utility.

// The maximum length, in bytes, of an input line.

// The maximum number of repeated occurrences of a regular expression
//    permitted when using the interval notation `\{M,N\}'.

// The maximum number of bytes in a character class name.  We have no
//    fixed limit, 2048 is a high number.

// These values are implementation-specific,
//    and may vary within the implementation.
//    Their precise values can be obtained from sysconf.

// This value is defined like this in regex.h.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// This file defines some things in system-specific ways.
// Old-style Unix parameters and limits.  Linux version.
//    Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// The kernel headers define ARG_MAX.  The value is wrong, though.

// The following are not really correct but it is a value we used for a
//    long time and which seems to be usable.  People should not use NOFILE
//    and NCARGS anyway.

// BSD names for some <limits.h> values.

// Magical constants.

// Unit of `st_blocks'.

// Bit map related macros.

// Macros for counting and rounding.

// Macros for min/max.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// This file defines `struct dirent'.
//
//    It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
//    member that gives the length of `d_name'.
//
//    It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
//    member that gives the size of the entire directory entry.
//
//    It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
//    member that gives the file offset of the next directory entry.
//
//    It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
//    member that gives the type of the file.
//

// Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

type dirent = struct {
	d_ino    uint64
	d_off    int64
	d_reclen uint16
	d_type   uint8
	d_name   [256]int8
	_        [5]byte
} /* dirent.h:22:1 */

type dirent64 = struct {
	d_ino    uint64
	d_off    int64
	d_reclen uint16
	d_type   uint8
	d_name   [256]int8
	_        [5]byte
} /* dirent.h:37:1 */

// System-specific extensions of <dirent.h>.  Linux version.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//---------------------------------------------------------------------------
// Parameterize for 64-bit filesystem support.
//---------------------------------------------------------------------------

type Tcl_DirEntry = dirent /* tclUnixPort.h:63:24 */

type Tcl_SeekOffset = off_t /* tclUnixPort.h:83:16 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Structure crudely representing a timezone.
//    This is obsolete and should never be used.
type timezone = struct {
	tz_minuteswest int32
	tz_dsttime     int32
} /* time.h:52:1 */

// Type of the second argument to `getitimer' and
//    the second and third arguments `setitimer'.
type itimerval = struct {
	it_interval struct {
		tv_sec  int64
		tv_usec int64
	}
	it_value struct {
		tv_sec  int64
		tv_usec int64
	}
} /* time.h:105:1 */

// Convenience macros for operations on timevals.
//    NOTE: `timercmp' does not work for >= or <=.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.23 Date and time	<time.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// This defines CLOCKS_PER_SEC, which is the number of processor clock
//    ticks per second, and possibly a number of other constants.
// System-dependent timing definitions.  Linux version.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <time.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// ISO/IEC 9899:1999 7.23.1: Components of time
//    The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
//    the number per second of the value returned by the `clock' function.
// CAE XSH, Issue 4, Version 2: <time.h>
//    The value of CLOCKS_PER_SEC is required to be 1 million on all
//    XSI-conformant systems.

// Identifier for system-wide realtime clock.
// Monotonic system-wide clock.
// High-resolution timer from the CPU.
// Thread-specific CPU-time clock.
// Monotonic system-wide clock, not adjusted for frequency scaling.
// Identifier for system-wide realtime clock, updated only on ticks.
// Monotonic system-wide clock, updated only on ticks.
// Monotonic system-wide clock that includes time spent in suspension.
// Like CLOCK_REALTIME but also wakes suspended system.
// Like CLOCK_BOOTTIME but also wakes suspended system.
// Like CLOCK_REALTIME but in International Atomic Time.

// Flag to indicate time is absolute.

// Many of the typedefs and structs whose official home is this header
//    may also need to be defined by other headers.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// ISO C `broken-down time' structure.
type tm = struct {
	tm_sec    int32
	tm_min    int32
	tm_hour   int32
	tm_mday   int32
	tm_mon    int32
	tm_year   int32
	tm_wday   int32
	tm_yday   int32
	tm_isdst  int32
	_         [4]byte
	tm_gmtoff int64
	tm_zone   uintptr
} /* struct_tm.h:7:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// NB: Include guard matches what <linux/time.h> uses.

// POSIX.1b structure for timer start values and intervals.
type itimerspec = struct {
	it_interval struct {
		tv_sec  int64
		tv_nsec int64
	}
	it_value struct {
		tv_sec  int64
		tv_nsec int64
	}
} /* struct_itimerspec.h:8:1 */

// Definition of locale_t.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type __locale_struct = struct {
	__locales       [13]uintptr
	__ctype_b       uintptr
	__ctype_tolower uintptr
	__ctype_toupper uintptr
	__names         [13]uintptr
} /* __locale_t.h:28:1 */

type locale_t = uintptr /* locale_t.h:24:20 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// These macros could also be defined in <stdlib.h>.
// This will define the `W*' macros for the flag
//    bits to `waitpid', `wait3', and `wait4'.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

type idtype_t = uint32 /* waitflags.h:57:3 */

// This being here makes the prototypes valid whether or not
//    we have already included <sys/resource.h> to define `struct rusage'.
type rusage = struct {
	ru_utime struct {
		tv_sec  int64
		tv_usec int64
	}
	ru_stime struct {
		tv_sec  int64
		tv_usec int64
	}
	__32  struct{ ru_maxrss int64 }
	__40  struct{ ru_ixrss int64 }
	__48  struct{ ru_idrss int64 }
	__56  struct{ ru_isrss int64 }
	__64  struct{ ru_minflt int64 }
	__72  struct{ ru_majflt int64 }
	__80  struct{ ru_nswap int64 }
	__88  struct{ ru_inblock int64 }
	__96  struct{ ru_oublock int64 }
	__104 struct{ ru_msgsnd int64 }
	__112 struct{ ru_msgrcv int64 }
	__120 struct{ ru_nsignals int64 }
	__128 struct{ ru_nvcsw int64 }
	__136 struct{ ru_nivcsw int64 }
} /* wait.h:129:1 */

// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the type definitions.
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// wchar_t type related definitions.
//    Copyright (C) 2000-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type uint8_t = uint8   /* stdint-uintn.h:24:19 */
type uint16_t = uint16 /* stdint-uintn.h:25:20 */
type uint32_t = uint32 /* stdint-uintn.h:26:20 */
type uint64_t = uint64 /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type int_least8_t = int8   /* stdint.h:43:24 */
type int_least16_t = int16 /* stdint.h:44:25 */
type int_least32_t = int32 /* stdint.h:45:25 */
type int_least64_t = int64 /* stdint.h:46:25 */

// Unsigned.
type uint_least8_t = uint8   /* stdint.h:49:25 */
type uint_least16_t = uint16 /* stdint.h:50:26 */
type uint_least32_t = uint32 /* stdint.h:51:26 */
type uint_least64_t = uint64 /* stdint.h:52:26 */

// Fast types.

// Signed.
type int_fast8_t = int8   /* stdint.h:58:22 */
type int_fast16_t = int64 /* stdint.h:60:19 */
type int_fast32_t = int64 /* stdint.h:61:19 */
type int_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type uint_fast8_t = uint8   /* stdint.h:71:24 */
type uint_fast16_t = uint64 /* stdint.h:73:27 */
type uint_fast32_t = uint64 /* stdint.h:74:27 */
type uint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type intptr_t = int64   /* stdint.h:87:19 */
type uintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type intmax_t = int64   /* stdint.h:101:21 */
type uintmax_t = uint64 /* stdint.h:102:22 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type imaxdiv_t = struct {
	quot int64
	rem  int64
} /* inttypes.h:275:5 */

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These may be used to determine what facilities are present at compile time.
//    Their values can be obtained at run time from `sysconf'.

// POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.

// These are not #ifdef __USE_POSIX2 because they are
//    in the theoretically application-owned namespace.

// The utilities on GNU systems also correspond to this version.

// The utilities on GNU systems also correspond to this version.

// This symbol was required until the 2001 edition of POSIX.

// If defined, the implementation supports the
//    C Language Bindings Option.

// If defined, the implementation supports the
//    C Language Development Utilities Option.

// If defined, the implementation supports the
//    Software Development Utilities Option.

// If defined, the implementation supports the
//    creation of locales with the localedef utility.

// X/Open version number to which the library conforms.  It is selectable.

// Commands and utilities from XPG4 are available.

// We are compatible with the old published standards as well.

// The X/Open Unix extensions are available.

// The enhanced internationalization capabilities according to XPG4.2
//    are present.

// The legacy interfaces are also available.

// Get values of POSIX options:
//
//    If these symbols are defined, the corresponding features are
//    always available.  If not, they may be available sometimes.
//    The current values can be obtained with `sysconf'.
//
//    _POSIX_JOB_CONTROL		Job control is supported.
//    _POSIX_SAVED_IDS		Processes have a saved set-user-ID
// 				and a saved set-group-ID.
//    _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
//    _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
//    _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
//    _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
//    _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
//    _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
//    _POSIX_FSYNC			The fsync function is present.
//    _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
//    _POSIX_MEMLOCK		Locking of all memory is supported.
//    _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
//    _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
//    _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
//    _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
//    _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
//    _POSIX_THREADS		POSIX.1c pthreads are supported.
//    _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
//    _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
//    _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
//    _POSIX_THREAD_PRIORITY_SCHEDULING
// 				POSIX.1c thread execution scheduling supported.
//    _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
//    _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
//    _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
//    _POSIX_PII			Protocol-independent interfaces are supported.
//    _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
//    _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
//    _POSIX_PII_INTERNET		Internet family of protocols supported.
//    _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
//    _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
//    _POSIX_PII_OSI		ISO/OSI family of protocols supported.
//    _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
//    _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
//    _POSIX_POLL			Implementation supports `poll' function.
//    _POSIX_SELECT		Implementation supports `select' and `pselect'.
//
//    _XOPEN_REALTIME		X/Open realtime support is available.
//    _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
//    _XOPEN_SHM			Shared memory interface according to XPG4.2.
//
//    _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
// 				int, long, pointer, and off_t types.
//    _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
// 				int, long, and pointer and off_t with at least
// 				64 bits.
//    _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
// 				int, and 64-bit long, pointer, and off_t types.
//    _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
// 				least 32 bits int and long, pointer, and off_t
// 				with at least 64 bits.
//
//    If any of these symbols is defined as -1, the corresponding option is not
//    true for any file.  If any is defined as other than -1, the corresponding
//    option is true for all files.  If a symbol is not defined at all, the value
//    for a specific file can be obtained from `pathconf' and `fpathconf'.
//
//    _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
// 				the owner of a file.  `chown' can only be used
// 				to change the group ID of a file to a group of
// 				which the calling process is a member.
//    _POSIX_NO_TRUNC		Pathname components longer than
// 				NAME_MAX generate an error.
//    _POSIX_VDISABLE		If defined, if the value of an element of the
// 				`c_cc' member of `struct termios' is
// 				_POSIX_VDISABLE, no character will have the
// 				effect associated with that element.
//    _POSIX_SYNC_IO		Synchronous I/O may be performed.
//    _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
//    _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
//
//    Support for the Large File Support interface is not generally available.
//    If it is available the following constants are defined to one.
//    _LFS64_LARGEFILE		Low-level I/O supports large files.
//    _LFS64_STDIO			Standard I/O supports large files.
//

// Define POSIX options for Linux.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <https://www.gnu.org/licenses/>.

// Job control is supported.

// Processes have a saved set-user-ID and a saved set-group-ID.

// Priority scheduling is not supported with the correct semantics,
//    but GNU/Linux applications expect that the corresponding interfaces
//    are available, even though the semantics do not meet the POSIX
//    requirements.  See glibc bug 14829.

// Synchronizing file data is supported.

// The fsync function is present.

// Mapping of files to memory is supported.

// Locking of all memory is supported.

// Locking of ranges of memory is supported.

// Setting of memory protections is supported.

// Some filesystems allow all users to change file ownership.

// `c_cc' member of 'struct termios' structure can be disabled by
//    using the value _POSIX_VDISABLE.

// Filenames are not silently truncated.

// X/Open realtime support is available.

// X/Open thread realtime support is available.

// XPG4.2 shared memory is supported.

// Tell we have POSIX threads.

// We have the reentrant functions described in POSIX.

// We provide priority scheduling for threads.

// We support user-defined stack sizes.

// We support user-defined stacks.

// We support priority inheritence.

// We support priority protection, though only for non-robust
//    mutexes.

// We support priority inheritence for robust mutexes.

// We do not support priority protection for robust mutexes.

// We support POSIX.1b semaphores.

// Real-time signals are supported.

// We support asynchronous I/O.
// Alternative name for Unix98.
// Support for prioritization is also available.

// The LFS support in asynchronous I/O is also available.

// The rest of the LFS is also available.

// POSIX shared memory objects are implemented.

// CPU-time clocks support needs to be checked at runtime.

// Clock support in threads must be also checked at runtime.

// GNU libc provides regular expression handling.

// Reader/Writer locks are available.

// We have a POSIX shell.

// We support the Timeouts option.

// We support spinlocks.

// The `spawn' function family is supported.

// We have POSIX timers.

// The barrier functions are available.

// POSIX message queues are available.

// Thread process-shared synchronization is supported.

// The monotonic clock might be available.

// The clock selection interfaces are available.

// Advisory information interfaces are available.

// IPv6 support is available.

// Raw socket support is available.

// We have at least one terminal.

// Neither process nor thread sporadic server interfaces is available.

// trace.h is not available.

// Typed memory objects are not available.

// Get the environment definitions from Unix98.
// Copyright (C) 1999-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// This header should define the following symbols under the described
//    situations.  A value `1' means that the model is always supported,
//    `-1' means it is never supported.  Undefined means it cannot be
//    statically decided.
//
//    _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
//    _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
//
//    _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
//    _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
//
//    The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
//    _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
//    _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
//    used in previous versions of the Unix standard and are available
//    only for compatibility.

// Environments with 32-bit wide pointers are optionally provided.
//    Therefore following macros aren't defined:
//    # undef _POSIX_V7_ILP32_OFF32
//    # undef _POSIX_V7_ILP32_OFFBIG
//    # undef _POSIX_V6_ILP32_OFF32
//    # undef _POSIX_V6_ILP32_OFFBIG
//    # undef _XBS5_ILP32_OFF32
//    # undef _XBS5_ILP32_OFFBIG
//    and users need to check at runtime.

// We also have no use (for now) for an environment with bigger pointers
//    and offsets.

// By default we have 64-bit wide `long int', pointers and `off_t'.

// Standard file descriptors.

// All functions that are not declared anywhere else.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// The Single Unix specification says that some more types are
//    available here.

type useconds_t = uint32 /* unistd.h:255:22 */

type socklen_t = uint32 /* unistd.h:274:21 */

//---------------------------------------------------------------------------
// Socket support stuff: This likely needs more work to parameterize for each
// system.
//---------------------------------------------------------------------------

// Declarations of socket constants, types, and functions.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define struct iovec.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Structure for scatter/gather I/O.
type iovec = struct {
	iov_base uintptr
	iov_len  size_t
} /* struct_iovec.h:26:1 */

// Protocol families.

// Address families.

// Socket level values.  Others are defined in the appropriate headers.
//
//    XXX These definitions also should go into the appropriate headers as
//    far as they are available.

// Maximum queue length specifiable by listen.

// Get the definition of the macro to define the common sockaddr members.
// Definition of struct sockaddr_* common members and sizes, generic version.
//    Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/socket.h> instead.

// POSIX.1g specifies this type name for the `sa_family' member.
type sa_family_t = uint16 /* sockaddr.h:28:28 */

// This macro is used to declare the initial common members
//    of the data types used for socket addresses, `struct sockaddr',
//    `struct sockaddr_in', `struct sockaddr_un', etc.

// Size of struct sockaddr_storage.

// Structure describing a generic socket address.
type sockaddr = struct {
	sa_family sa_family_t
	sa_data   [14]int8
} /* socket.h:178:1 */

// Structure large enough to hold any socket address (with the historical
//    exception of AF_UNIX).

type sockaddr_storage = struct {
	ss_family    sa_family_t
	__ss_padding [118]int8
	__ss_align   uint64
} /* socket.h:191:1 */

// Structure describing messages sent by
//    `sendmsg' and received by `recvmsg'.
type msghdr = struct {
	msg_name       uintptr
	msg_namelen    socklen_t
	_              [4]byte
	msg_iov        uintptr
	msg_iovlen     size_t
	msg_control    uintptr
	msg_controllen size_t
	msg_flags      int32
	_              [4]byte
} /* socket.h:257:1 */

// Structure used for storage of ancillary data object information.
type cmsghdr = struct {
	_          [0]uint64
	cmsg_len   size_t
	cmsg_level int32
	cmsg_type  int32
} /* socket.h:275:1 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Socket-level I/O control calls.

// For setsockopt(2)

// Security levels - as per NRL IPv6 - don't actually do anything

// Socket filtering

// Instruct lower device to use last 4-bytes of skb data as FCS

// on 64-bit and x32, avoid the ?: operator

// Structure used to manipulate the SO_LINGER option.
type linger = struct {
	l_onoff  int32
	l_linger int32
} /* socket.h:361:1 */

// This is the 4.3 BSD `struct sockaddr' format, which is used as wire
//    format in the grotty old 4.3 `talk' protocol.
type osockaddr = struct {
	sa_family uint16
	sa_data   [14]uint8
} /* struct_osockaddr.h:6:1 */

// Define some macros helping to catch buffer overflows.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 4.4 System Identification	<sys/utsname.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Length of the entries in `struct utsname' is 65.

// Linux provides as additional information in the `struct utsname'
//    the name of the current domain.  Define _UTSNAME_DOMAIN_LENGTH
//    to a value != 0 to activate this entry.

// Structure describing the system and machine.
type utsname = struct {
	sysname      [65]int8
	nodename     [65]int8
	release      [65]int8
	version      [65]int8
	machine      [65]int8
	__domainname [65]int8
} /* utsname.h:48:1 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define uintN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Declarations of socket constants, types, and functions.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Internet address.
type in_addr_t = uint32_t                 /* in.h:30:18 */
type in_addr = struct{ s_addr in_addr_t } /* in.h:31:1 */

// Get system-specific definitions.
// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Linux version.

// If the application has already included linux/in6.h from a linux-based
//    kernel then we will not define the IPv6 IPPROTO_* defines, in6_addr (nor the
//    defines), sockaddr_in6, or ipv6_mreq. Same for in6_ptkinfo or ip6_mtuinfo
//    in linux/ipv6.h. The ABI used by the linux-kernel and glibc match exactly.
//    Neither the linux kernel nor glibc should break this ABI without coordination.
//    In upstream kernel 56c176c9 the _UAPI prefix was stripped so we need to check
//    for _LINUX_IN6_H and _IPV6_H now, and keep checking the old versions for
//    maximum backwards compatibility.

// Options for use with `getsockopt' and `setsockopt' at the IP level.
//    The first word in the comment at the right is the data type used;
//    "bool" means a boolean value stored in an `int'.
// For BSD compatibility.

// TProxy original addresses

// IP_MTU_DISCOVER arguments.
// Always use interface mtu (ignores dst pmtu) but don't set DF flag.
//    Also incoming ICMP frag_needed notifications will be ignored on
//    this socket to prevent accepting spoofed ones.
// Like IP_PMTUDISC_INTERFACE but allow packets to be fragmented.

// To select the IP level.

// Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
//    The `ip_dst' field is used for the first-hop gateway when using a
//    source route (this gets put into the header proper).
type ip_opts = struct {
	ip_dst  struct{ s_addr in_addr_t }
	ip_opts [40]int8
} /* in.h:142:1 */

// Like `struct ip_mreq' but including interface specification by index.
type ip_mreqn = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_address   struct{ s_addr in_addr_t }
	imr_ifindex   int32
} /* in.h:149:1 */

// Structure used for IP_PKTINFO.
type in_pktinfo = struct {
	ipi_ifindex  int32
	ipi_spec_dst struct{ s_addr in_addr_t }
	ipi_addr     struct{ s_addr in_addr_t }
} /* in.h:157:1 */

// Type to represent a port.
type in_port_t = uint16_t /* in.h:119:18 */

// Definitions of the bits in an Internet address integer.
//
//    On subnets, host and network parts are found according to
//    the subnet mask, not these masks.

// Address to accept any incoming messages.
// Address to send to all hosts.
// Address indicating an error return.

// Network number for local host loopback.
// Address to loopback in software to local host.

// Defines for Multicast INADDR.

// IPv6 address
type in6_addr = struct {
	__in6_u struct {
		_          [0]uint32
		__u6_addr8 [16]uint8_t
	}
} /* in.h:212:1 */

// ::1

// Structure describing an Internet socket address.
type sockaddr_in = struct {
	sin_family sa_family_t
	sin_port   in_port_t
	sin_addr   struct{ s_addr in_addr_t }
	sin_zero   [8]uint8
} /* in.h:238:1 */

// Ditto, for IPv6.
type sockaddr_in6 = struct {
	sin6_family   sa_family_t
	sin6_port     in_port_t
	sin6_flowinfo uint32_t
	sin6_addr     struct {
		__in6_u struct {
			_          [0]uint32
			__u6_addr8 [16]uint8_t
		}
	}
	sin6_scope_id uint32_t
} /* in.h:253:1 */

// IPv4 multicast request.
type ip_mreq = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_interface struct{ s_addr in_addr_t }
} /* in.h:265:1 */

type ip_mreq_source = struct {
	imr_multiaddr  struct{ s_addr in_addr_t }
	imr_interface  struct{ s_addr in_addr_t }
	imr_sourceaddr struct{ s_addr in_addr_t }
} /* in.h:274:1 */

// Likewise, for IPv6.
type ipv6_mreq = struct {
	ipv6mr_multiaddr struct {
		__in6_u struct {
			_          [0]uint32
			__u6_addr8 [16]uint8_t
		}
	}
	ipv6mr_interface uint32
} /* in.h:289:1 */

// Multicast group request.
type group_req = struct {
	gr_interface uint32_t
	_            [4]byte
	gr_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]int8
		__ss_align   uint64
	}
} /* in.h:301:1 */

type group_source_req = struct {
	gsr_interface uint32_t
	_             [4]byte
	gsr_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]int8
		__ss_align   uint64
	}
	gsr_source struct {
		ss_family    sa_family_t
		__ss_padding [118]int8
		__ss_align   uint64
	}
} /* in.h:310:1 */

// Full-state filter operations.
type ip_msfilter = struct {
	imsf_multiaddr struct{ s_addr in_addr_t }
	imsf_interface struct{ s_addr in_addr_t }
	imsf_fmode     uint32_t
	imsf_numsrc    uint32_t
	imsf_slist     [1]struct{ s_addr in_addr_t }
} /* in.h:324:1 */

type group_filter = struct {
	gf_interface uint32_t
	_            [4]byte
	gf_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]int8
		__ss_align   uint64
	}
	gf_fmode  uint32_t
	gf_numsrc uint32_t
	gf_slist  [1]struct {
		ss_family    sa_family_t
		__ss_padding [118]int8
		__ss_align   uint64
	}
} /* in.h:345:1 */

// Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// All data returned by the network data base library are supplied in
//    host order and returned in network order (suitable for use in
//    system calls).

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define uintN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This is necessary to make this include file properly replace the
//    Sun version.
// @(#)netdb.h	2.1 88/07/29 3.9 RPCSRC
// Copyright (c) 2010, Oracle America, Inc.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials
//       provided with the distribution.
//     * Neither the name of the "Oracle America, Inc." nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
//   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Cleaned up for GNU C library roland@gnu.ai.mit.edu:
//    added multiple inclusion protection and use of <sys/cdefs.h>.
//    In GNU this file is #include'd by <netdb.h>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

type rpcent = struct {
	r_name    uintptr
	r_aliases uintptr
	r_number  int32
	_         [4]byte
} /* netdb.h:46:1 */

// Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Description of data base entry for a single network.  NOTE: here a
//    poor assumption is made.  The network number is expected to fit
//    into an unsigned long int variable.
type netent = struct {
	n_name     uintptr
	n_aliases  uintptr
	n_addrtype int32
	n_net      uint32_t
} /* netdb.h:26:1 */

// Description of data base entry for a single host.
type hostent = struct {
	h_name      uintptr
	h_aliases   uintptr
	h_addrtype  int32
	h_length    int32
	h_addr_list uintptr
} /* netdb.h:98:1 */

// Description of data base entry for a single service.
type servent = struct {
	s_name    uintptr
	s_aliases uintptr
	s_port    int32
	_         [4]byte
	s_proto   uintptr
} /* netdb.h:255:1 */

// Description of data base entry for a single service.
type protoent = struct {
	p_name    uintptr
	p_aliases uintptr
	p_proto   int32
	_         [4]byte
} /* netdb.h:324:1 */

// Extension from POSIX.1:2001.
// Structure to contain information about address of a service provider.
type addrinfo = struct {
	ai_flags     int32
	ai_family    int32
	ai_socktype  int32
	ai_protocol  int32
	ai_addrlen   socklen_t
	_            [4]byte
	ai_addr      uintptr
	ai_canonname uintptr
	ai_next      uintptr
} /* netdb.h:565:1 */

//---------------------------------------------------------------------------
// Darwin specifc configure overrides.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following macros and declarations represent the interface between
// generic and unix-specific parts of Tcl. Some of the macros may override
// functions declared in tclInt.h.
//---------------------------------------------------------------------------

// The default platform eol translation on Unix is TCL_TRANSLATE_LF.

//---------------------------------------------------------------------------
// The following macros have trivial definitions, allowing generic code to
// address platform-specific issues.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following defines wrap the system memory allocation routines.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following macros and declaration wrap the C runtime library functions.
//---------------------------------------------------------------------------

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get type definitions.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// NB: Include guard matches what <linux/time.h> uses.

// Get system specific constant and data structure definitions.
// Definitions of constants and data structure for POSIX 1003.1b-1993
//    scheduling interface.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Scheduling algorithms.

// Sched parameter structure.  Generic version.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library;  if not, see
//    <https://www.gnu.org/licenses/>.

// Data structure to describe a process' schedulability.
type sched_param = struct{ sched_priority int32 } /* struct_sched_param.h:23:1 */

// Basic access functions.

// Data structure to describe CPU mask.
type cpu_set_t = struct{ __bits [16]uint64 } /* cpu-set.h:42:3 */

// Conditional variable handling.

// Cleanup buffers
type _pthread_cleanup_buffer = struct {
	__routine    uintptr
	__arg        uintptr
	__canceltype int32
	_            [4]byte
	__prev       uintptr
} /* pthread.h:155:1 */

// No special attributes by default.

// Structure to hold the cleanup handler information.
type __pthread_cleanup_frame = struct {
	__cancel_routine uintptr
	__cancel_arg     uintptr
	__do_it          int32
	__cancel_type    int32
} /* pthread.h:516:1 */

// FIXME - Hyper-enormous platform assumption!

//---------------------------------------------------------------------------
// Set of MT-safe implementations of some known-to-be-MT-unsafe library calls.
// Instead of returning pointers to the static storage, those return pointers
// to the TSD data.
//---------------------------------------------------------------------------

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 9.2.2 User Database Access	<pwd.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 9.2.1 Group Database Access	<grp.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// For the Single Unix specification we must define this type here.

// The group structure.
type group = struct {
	gr_name   uintptr
	gr_passwd uintptr
	gr_gid    uint32
	_         [4]byte
	gr_mem    uintptr
} /* grp.h:42:1 */

type Tcl_StatBuf = stat /* tcl.h:470:25 */

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int = mp_int1 /* tcl.h:2266:23 */

// A null pointer constant.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this
//    glibc includes corresponding *f128 interfaces for it.  The required
//    libgcc support was added some time after the basic compiler
//    support, for x86_64 and x86.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.

// The remaining of this file provides support for older compilers.

// The type _Float128 exists only since GCC 7.0.

// __builtin_huge_valf128 doesn't exist before GCC 7.0.

// Older GCC has only a subset of built-in functions for _Float128 on
//    x86, and __builtin_infq is not usable in static initializers.
//    Converting a narrower sNaN to _Float128 produces a quiet NaN, so
//    attempts to use _Float128 sNaNs will not work properly with older
//    compilers.

// In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
//    e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
//    been a __builtin_signbitf128 in GCC and the type-generic builtin is
//    only available since GCC 6.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:80:5 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type random_data = struct {
	fptr      uintptr
	rptr      uintptr
	state     uintptr
	rand_type int32
	rand_deg  int32
	rand_sep  int32
	_         [4]byte
	end_ptr   uintptr
} /* stdlib.h:423:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type drand48_data = struct {
	__x     [3]uint16
	__old_x [3]uint16
	__c     uint16
	__init  uint16
	__a     uint64
} /* stdlib.h:490:1 */

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type max_align_t = struct {
	__max_align_ll int64
	__max_align_ld float64
} /* stddef.h:426:3 */

// Ensure WORDS_BIGENDIAN is defined correctly:
// Needs to happen here in addition to configure to work with fat compiles on
// Darwin (where configure runs only once for multiple architectures).

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Compatibility header for old-style Unix parameters and limits.
//    Copyright (C) 1995-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Used to tag functions that are only to be visible within the module being
// built and not outside it (where this is supported by the linker).

// Macros used to cast between pointers and integers (e.g. when storing an int
// in ClientData), on 64-bit architectures they avoid gcc warning about "cast
// to/from pointer from/to integer of different size".

// The following procedures allow namespaces to be customized to support
// special name resolution rules for commands/variables.

type Tcl_ResolvedVarInfo1 = struct {
	fetchProc  uintptr
	deleteProc uintptr
} /* tclInt.h:131:1 */

// The following structure encapsulates the routines needed to resolve a
// variable reference at runtime. Any variable specific state will typically
// be appended to this structure.

type Tcl_ResolvedVarInfo = Tcl_ResolvedVarInfo1 /* tclInt.h:147:3 */

type Tcl_ResolverInfo1 = struct {
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
} /* tclInt.h:159:9 */

type Tcl_ResolverInfo = Tcl_ResolverInfo1 /* tclInt.h:170:3 */
type NamespacePathEntry1 = struct {
	nsPtr        uintptr
	creatorNsPtr uintptr
	prevPtr      uintptr
	nextPtr      uintptr
} /* tclInt.h:194:9 */

type NamespacePathEntry = NamespacePathEntry1 /* tclInt.h:194:35 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable1 = struct {
	table Tcl_HashTable
	nsPtr uintptr
} /* tclInt.h:194:9 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type Namespace1 = struct {
	name                  uintptr
	fullName              uintptr
	clientData            ClientData
	deleteProc            uintptr
	parentPtr             uintptr
	childTable            Tcl_HashTable
	nsId                  int64
	interp                uintptr
	flags                 int32
	activationCount       int32
	refCount              int32
	_                     [4]byte
	cmdTable              Tcl_HashTable
	varTable              TclVarHashTable
	exportArrayPtr        uintptr
	numExportPatterns     int32
	maxExportPatterns     int32
	cmdRefEpoch           int32
	resolverEpoch         int32
	cmdResProc            uintptr
	varResProc            uintptr
	compiledVarResProc    uintptr
	exportLookupEpoch     int32
	_                     [4]byte
	ensembles             uintptr
	unknownHandlerPtr     uintptr
	commandPathLength     int32
	_                     [4]byte
	commandPathArray      uintptr
	commandPathSourceList uintptr
	earlyDeleteProc       uintptr
} /* tclInt.h:194:9 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable = TclVarHashTable1 /* tclInt.h:206:3 */

// This is for itcl - it likes to search our varTables directly :(

// Define this to reduce the amount of space that the average namespace
// consumes by only allocating the table of child namespaces when necessary.
// Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
// reach directly into the Namespace structure.

// The structure below defines a namespace.
// Note: the first five fields must match exactly the fields in a
// Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
// the other.

type Namespace = Namespace1 /* tclInt.h:345:3 */

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig1 = struct {
	nsPtr              uintptr
	token              Tcl_Command
	epoch              int32
	_                  [4]byte
	subcommandArrayPtr uintptr
	subcommandTable    Tcl_HashTable
	next               uintptr
	flags              int32
	_                  [4]byte
	subcommandDict     uintptr
	subcmdList         uintptr
	unknownHandler     uintptr
	parameterList      uintptr
	numParameters      int32
	_                  [4]byte
} /* tclInt.h:415:9 */

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig = EnsembleConfig1 /* tclInt.h:483:3 */

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	_          [4]byte
	nextPtr    uintptr
} /* tclInt.h:506:9 */

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace = VarTrace1 /* tclInt.h:516:3 */

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	_          [4]byte
	nextPtr    uintptr
	refCount   int32
	_          [4]byte
} /* tclInt.h:524:9 */

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace = CommandTrace1 /* tclInt.h:539:3 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace1 = struct {
	cmdPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
} /* tclInt.h:548:9 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type Command1 = struct {
	hPtr          uintptr
	nsPtr         uintptr
	refCount      int32
	cmdEpoch      int32
	compileProc   uintptr
	objProc       uintptr
	objClientData ClientData
	proc          uintptr
	clientData    ClientData
	deleteProc    uintptr
	deleteData    ClientData
	flags         int32
	_             [4]byte
	importRefPtr  uintptr
	tracePtr      uintptr
	nreProc       uintptr
} /* tclInt.h:548:9 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace = ActiveCommandTrace1 /* tclInt.h:559:3 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace1 = struct {
	varPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
} /* tclInt.h:569:9 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type Var1 = struct {
	flags int32
	_     [4]byte
	value struct{ objPtr uintptr }
} /* tclInt.h:569:9 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace = ActiveVarTrace1 /* tclInt.h:578:3 */

// The structure below defines a variable, which associates a string name with
// a Tcl_Obj value. These structures are kept in procedure call frames (for
// local variables recognized by the compiler) or in the heap (for global
// variables and any variable not known to the compiler). For each Var
// structure in the heap, a hash table entry holds the variable name and a
// pointer to the Var structure.

type Var = Var1 /* tclInt.h:604:3 */

type VarInHash1 = struct {
	__var    Var
	refCount int32
	_        [4]byte
	entry    Tcl_HashEntry
} /* tclInt.h:606:9 */

type VarInHash = VarInHash1 /* tclInt.h:621:3 */

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal1 = struct {
	nextPtr     uintptr
	nameLength  int32
	frameIndex  int32
	flags       int32
	_           [4]byte
	defValuePtr uintptr
	resolveInfo uintptr
	name        [1]int8
	_           [7]byte
} /* tclInt.h:900:9 */

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal = CompiledLocal1 /* tclInt.h:928:3 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc1 = struct {
	iPtr              uintptr
	refCount          int32
	_                 [4]byte
	cmdPtr            uintptr
	bodyPtr           uintptr
	numArgs           int32
	numCompiledLocals int32
	firstLocalPtr     uintptr
	lastLocalPtr      uintptr
} /* tclInt.h:936:9 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Interp1 = struct {
	result            uintptr
	freeProc          uintptr
	errorLine         int32
	_                 [4]byte
	stubTable         uintptr
	handle            TclHandle
	globalNsPtr       uintptr
	hiddenCmdTablePtr uintptr
	interpInfo        ClientData
	extra             struct {
		optimizer uintptr
		_         [80]byte
	}
	numLevels              int32
	maxNestingDepth        int32
	framePtr               uintptr
	varFramePtr            uintptr
	activeVarTracePtr      uintptr
	returnCode             int32
	_                      [4]byte
	rootFramePtr           uintptr
	lookupNsPtr            uintptr
	appendResult           uintptr
	appendAvl              int32
	appendUsed             int32
	packageTable           Tcl_HashTable
	packageUnknown         uintptr
	cmdCount               int32
	evalFlags              int32
	unused1                int32
	_                      [4]byte
	literalTable           LiteralTable
	compileEpoch           int32
	_                      [4]byte
	compiledProcPtr        uintptr
	resolverPtr            uintptr
	scriptFile             uintptr
	flags                  int32
	_                      [4]byte
	randSeed               int64
	tracePtr               uintptr
	assocData              uintptr
	execEnvPtr             uintptr
	emptyObjPtr            uintptr
	resultSpace            [201]int8
	_                      [7]byte
	objResultPtr           uintptr
	threadId               Tcl_ThreadId
	activeCmdTracePtr      uintptr
	activeInterpTracePtr   uintptr
	tracesForbiddingInline int32
	_                      [4]byte
	returnOpts             uintptr
	errorInfo              uintptr
	eiVar                  uintptr
	errorCode              uintptr
	ecVar                  uintptr
	returnLevel            int32
	_                      [4]byte
	limit                  struct {
		active            int32
		granularityTicker int32
		exceeded          int32
		cmdCount          int32
		cmdHandlers       uintptr
		cmdGranularity    int32
		_                 [4]byte
		time              Tcl_Time
		timeHandlers      uintptr
		timeGranularity   int32
		_                 [4]byte
		timeEvent         Tcl_TimerToken
		callbacks         Tcl_HashTable
	}
	ensembleRewrite struct {
		sourceObjs      uintptr
		numRemovedObjs  int32
		numInsertedObjs int32
	}
	chanMsg           uintptr
	cmdFramePtr       uintptr
	invokeCmdFramePtr uintptr
	invokeWord        int32
	_                 [4]byte
	linePBodyPtr      uintptr
	lineBCPtr         uintptr
	lineLABCPtr       uintptr
	lineLAPtr         uintptr
	scriptCLLocPtr    uintptr
	packagePrefer     int32
	_                 [4]byte
	varTraces         Tcl_HashTable
	varSearches       Tcl_HashTable
	allocCache        uintptr
	pendingObjDataPtr uintptr
	asyncReadyPtr     uintptr
	objectFoundation  uintptr
	deferredCallbacks uintptr
	asyncCancel       Tcl_AsyncHandler
	asyncCancelMsg    uintptr
	errorStack        uintptr
	upLiteral         uintptr
	callLiteral       uintptr
	innerLiteral      uintptr
	innerContext      uintptr
	resetErrorStack   int32
	_                 [4]byte
} /* tclInt.h:936:9 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc = Proc1 /* tclInt.h:963:3 */

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace1 = struct {
	level      int32
	_          [4]byte
	proc       uintptr
	clientData ClientData
	nextPtr    uintptr
	flags      int32
	_          [4]byte
	delProc    uintptr
} /* tclInt.h:936:9 */

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace = Trace1 /* tclInt.h:987:3 */

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace1 = struct {
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
} /* tclInt.h:936:9 */

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace = ActiveInterpTrace1 /* tclInt.h:1007:3 */

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData1 = struct {
	proc       uintptr
	clientData ClientData
} /* tclInt.h:1031:9 */

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData = AssocData1 /* tclInt.h:1034:3 */

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache1 = struct {
	refCount int32
	numVars  int32
	varName0 uintptr
} /* tclInt.h:936:9 */

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache = LocalCache1 /* tclInt.h:1059:3 */

type CallFrame1 = struct {
	nsPtr             uintptr
	isProcCallFrame   int32
	objc              int32
	objv              uintptr
	callerPtr         uintptr
	callerVarPtr      uintptr
	level             int32
	_                 [4]byte
	procPtr           uintptr
	varTablePtr       uintptr
	numCompiledLocals int32
	_                 [4]byte
	compiledLocals    uintptr
	clientData        ClientData
	localCachePtr     uintptr
	tailcallPtr       uintptr
} /* tclInt.h:936:9 */

type CallFrame = CallFrame1 /* tclInt.h:1123:3 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame1 = struct {
	__type   int32
	level    int32
	line     uintptr
	nline    int32
	_        [4]byte
	framePtr uintptr
	nextPtr  uintptr
	data     struct {
		eval struct{ path uintptr }
		_    [8]byte
	}
	cmdObj uintptr
	cmd    uintptr
	len    int32
	_      [4]byte
	litarg uintptr
} /* tclInt.h:936:9 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CFWordBC1 = struct {
	framePtr uintptr
	pc       int32
	word     int32
	prevPtr  uintptr
	nextPtr  uintptr
	obj      uintptr
} /* tclInt.h:936:9 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame = CmdFrame1 /* tclInt.h:1213:3 */

type CFWord1 = struct {
	framePtr uintptr
	word     int32
	refCount int32
} /* tclInt.h:1215:9 */

type CFWord = CFWord1 /* tclInt.h:1220:3 */

type CFWordBC = CFWordBC1 /* tclInt.h:1232:3 */

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc1 = struct {
	num int32
	loc [1]int32
} /* tclInt.h:936:9 */

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc = ContLineLoc1 /* tclInt.h:1263:3 */
type ExtraFrameInfoField = struct {
	name       uintptr
	proc       uintptr
	clientData ClientData
} /* tclInt.h:1303:3 */
type ExtraFrameInfo = struct {
	length int32
	_      [4]byte
	fields [2]ExtraFrameInfoField
} /* tclInt.h:1309:3 */

//----------------------------------------------------------------
// Data structures and procedures related to TclHandles, which are a very
// lightweight method of preserving enough information to determine if an
// arbitrary malloc'd block has been deleted.
//----------------------------------------------------------------

type TclHandle = uintptr /* tclInt.h:1319:14 */

// The data structure for a (linked list of) execution stacks.

type ExecStack1 = struct {
	prevPtr    uintptr
	nextPtr    uintptr
	markerPtr  uintptr
	endPtr     uintptr
	tosPtr     uintptr
	stackWords [1]uintptr
} /* tclInt.h:936:9 */

// The data structure for a (linked list of) execution stacks.

type ExecStack = ExecStack1 /* tclInt.h:1407:3 */

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext1 = struct {
	framePtr    uintptr
	varFramePtr uintptr
	cmdFramePtr uintptr
	lineLABCPtr uintptr
} /* tclInt.h:936:9 */

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext = CorContext1 /* tclInt.h:1422:3 */

type CoroutineData1 = struct {
	cmdPtr       uintptr
	eePtr        uintptr
	callerEEPtr  uintptr
	caller       CorContext
	running      CorContext
	lineLABCPtr  uintptr
	stackLevel   uintptr
	auxNumLevels int32
	nargs        int32
} /* tclInt.h:936:9 */

type ExecEnv1 = struct {
	execStackPtr uintptr
	constants    [2]uintptr
	interp       uintptr
	callbackPtr  uintptr
	corPtr       uintptr
	rewind       int32
	_            [4]byte
} /* tclInt.h:936:9 */

type CoroutineData = CoroutineData1 /* tclInt.h:1443:3 */

type NRE_callback1 = struct {
	procPtr uintptr
	data    [4]ClientData
	nextPtr uintptr
} /* tclInt.h:936:9 */

type ExecEnv = ExecEnv1 /* tclInt.h:1454:3 */

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry1 = struct {
	nextPtr  uintptr
	objPtr   uintptr
	refCount int32
	_        [4]byte
	nsPtr    uintptr
} /* tclInt.h:936:9 */

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry = LiteralEntry1 /* tclInt.h:1490:3 */

type LiteralTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	mask          int32
} /* tclInt.h:936:9 */

type LiteralTable = LiteralTable1 /* tclInt.h:1506:3 */

// The following structure defines for each Tcl interpreter various
// statistics-related information about the bytecode compiler and
// interpreter's operation in that interpreter.

// Structure used in implementation of those core ensembles which are
// partially compiled. Used as an array of these, with a terminating field
// whose 'name' is NULL.

type EnsembleImplMap = struct {
	name        uintptr
	proc        uintptr
	compileProc uintptr
	nreProc     uintptr
	clientData  ClientData
	unsafe      int32
	_           [4]byte
} /* tclInt.h:1560:3 */

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef1 = struct {
	importedCmdPtr uintptr
	nextPtr        uintptr
} /* tclInt.h:548:9 */

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef = ImportRef1 /* tclInt.h:1588:3 */

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData1 = struct {
	realCmdPtr uintptr
	selfPtr    uintptr
} /* tclInt.h:1596:9 */

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData = ImportedCmdData1 /* tclInt.h:1603:3 */

// A Command structure exists for each command in a namespace. The Tcl_Command
// opaque type actually refers to these structures.

type Command = Command1 /* tclInt.h:1653:3 */

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme1 = struct {
	name               uintptr
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
	nextPtr            uintptr
} /* tclInt.h:936:9 */

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme = ResolverScheme1 /* tclInt.h:1716:3 */

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache1 = struct {
	nextPtr     uintptr
	owner       Tcl_ThreadId
	firstObjPtr uintptr
	numObjects  int32
	_           [4]byte
} /* tclInt.h:936:9 */

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache = AllocCache1 /* tclInt.h:1749:3 */

//----------------------------------------------------------------
// This structure defines an interpreter, which is a collection of commands
// plus other state information related to interpreting commands, such as
// variable storage. Primary responsibility for this data structure is in
// tclBasic.c, but almost every Tcl source file uses something in here.
//----------------------------------------------------------------

type Interp = Interp1 /* tclInt.h:2145:3 */

// Macros that use the TSD-ekeko.

// Macros for script cancellation support (TIP #285).

// Macros for splicing into and out of doubly linked lists. They assume
// existence of struct items 'prevPtr' and 'nextPtr'.
//
// a = element to add or remove.
// b = list head.
//
// TclSpliceIn adds to the head of the list.

// EvalFlag bits for Interp structures:
//
// TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
//			code other than TCL_OK or TCL_ERROR; 0 means codes
//			other than these should be turned into errors.

// Flag bits for Interp structures:
//
// DELETED:		Non-zero means the interpreter has been deleted:
//			don't process any more commands for it, and destroy
//			the structure as soon as all nested invocations of
//			Tcl_Eval are done.
// ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
//			iPtr->errorInfo for the current Tcl_Eval instance, so
//			Tcl_Eval needn't log it (used to implement the "error
//			message log" command).
// DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
//			not compile any commands into an inline sequence of
//			instructions. This is set 1, for example, when command
//			traces are requested.
// RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
//			has not be initialized. This is set 1 when we first
//			use the rand() or srand() functions.
// SAFE_INTERP:		Non zero means that the current interp is a safe
//			interp (i.e. it has only the safe commands installed,
//			less privilege than a regular interp).
// INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
//			debug/info mechanisms (e.g. info frame eval/uplevel
//			tracing) which are performance intensive.
// INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
//			active; so no further trace callbacks should be
//			invoked.
// INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
//			of the wrong-num-args string in Tcl_WrongNumArgs.
//			Makes it append instead of replacing and uses
//			different intermediate text.
// CANCELED:		Non-zero means that the script in progress should be
//			canceled as soon as possible. This can be checked by
//			extensions (and the core itself) by calling
//			Tcl_Canceled and checking if TCL_ERROR is returned.
//			This is a one-shot flag that is reset immediately upon
//			being detected; however, if the TCL_CANCEL_UNWIND flag
//			is set Tcl_Canceled will continue to report that the
//			script in progress has been canceled thereby allowing
//			the evaluation stack for the interp to be fully
//			unwound.
//
// WARNING: For the sake of some extensions that have made use of former
// internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
// or 8 (formerly ERROR_CODE_SET).

// Maximum number of levels of nesting permitted in Tcl commands (used to
// catch infinite recursion).

// The macro below is used to modify a "char" value (e.g. by casting it to an
// unsigned character) so that it can be used safely with macros such as
// isspace.

// This macro is used to properly align the memory allocated by Tcl, giving
// the same alignment as the native malloc.

// This macro is used to determine the offset needed to safely allocate any
// data structure in memory. Given a starting offset or size, it "rounds up"
// or "aligns" the offset to the next 8-byte boundary so that any data
// structure can be placed at the resulting offset without fear of an
// alignment error.
//
// WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
// wrong result on platforms that allocate addresses that are divisible by 4
// or 2. Only use it for offsets or sizes.
//
// This macro is only used by tclCompile.c in the core (Bug 926445). It
// however not be made file static, as extensions that touch bytecodes
// (notably tbcload) require it.

// The following enum values are used to specify the runtime platform setting
// of the tclPlatform variable.

type TclPlatformType = uint32 /* tclInt.h:2321:3 */

// The following enum values are used to indicate the translation of a Tcl
// channel. Declared here so that each platform can define
// TCL_PLATFORM_TRANSLATION to the native translation on that platform.

type TclEolTranslation = uint32 /* tclInt.h:2334:3 */

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List1 = struct {
	refCount      int32
	maxElemCount  int32
	elemCount     int32
	canonicalFlag int32
	elements      uintptr
} /* tclInt.h:2363:9 */

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List = List1 /* tclInt.h:2373:3 */

type TclFileAttrProcs1 = struct {
	getProc uintptr
	setProc uintptr
} /* tclInt.h:2542:9 */

type TclFileAttrProcs = TclFileAttrProcs1 /* tclInt.h:2545:3 */

// Opaque handle used in pipeline routines to encapsulate platform-dependent
// state.

type TclFile = uintptr /* tclInt.h:2552:25 */

// The "globParameters" argument of the function TclGlob is an or'ed
// combination of the following values:

type Tcl_PathPart = uint32 /* tclInt.h:2569:3 */

//----------------------------------------------------------------
// Data structures related to procedures
//----------------------------------------------------------------

type TclCmdProcType = uintptr    /* tclInt.h:2588:21 */
type TclObjCmdProcType = uintptr /* tclInt.h:2589:24 */

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the master is kept as a counted string, with epoch and mutex
// control. Each ProcessGlobalValue struct should be a static variable in some
// file.

type ProcessGlobalValue1 = struct {
	epoch    int32
	numBytes int32
	value    uintptr
	encoding Tcl_Encoding
	proc     uintptr
	mutex    Tcl_Mutex
	key      Tcl_ThreadDataKey
} /* tclInt.h:2608:9 */

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the master is kept as a counted string, with epoch and mutex
// control. Each ProcessGlobalValue struct should be a static variable in some
// file.

type ProcessGlobalValue = ProcessGlobalValue1 /* tclInt.h:2623:3 */

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData1 = struct {
	cond uintptr
	body uintptr
	next uintptr
	msg  uintptr
	word int32
	_    [4]byte
} /* tclInt.h:2793:9 */

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData = ForIterData1 /* tclInt.h:2799:3 */

type memCmpFn_t = uintptr /* tclInt.h:3162:13 */

//----------------------------------------------------------------
// Macro used by the Tcl core to check whether a pattern has any characters
// special to [string match]. The ANSI C "prototype" for this macro is:
//
// MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
//----------------------------------------------------------------

//----------------------------------------------------------------
// Macros used by the Tcl core to set a Tcl_Obj's numeric representation
// avoiding the corresponding function calls in time critical parts of the
// core. They should only be called on unshared objects. The ANSI C
// "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
// MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
// MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
// MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
// programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
// The only "boolean" Tcl_Obj's shall be those holding the cached boolean
// value of strings like: "yes", "no", "true", "false", "on", "off".

//----------------------------------------------------------------
// Macros used by the Tcl core to create and initialise objects of standard
// types, avoiding the corresponding function calls in time critical parts of
// the core. The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
// MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
// MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
// MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
// MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
// MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
//
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean.
// See comment above TclSetBooleanObj macro above.

// The sLiteral argument *must* be a string literal; the incantation with
// sizeof(sLiteral "") will fail to compile otherwise.

//----------------------------------------------------------------
// Convenience macros for DStrings.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
//			const char *sLiteral);
// MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);

//----------------------------------------------------------------
// Macros used by the Tcl core to test for some special double values.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE int	TclIsInfinite(double d);
// MODULE_SCOPE int	TclIsNaN(double d);

// ----------------------------------------------------------------------
// Macro to use to find the offset of a field in a structure. Computes number
// of bytes from beginning of structure to a given field.

//----------------------------------------------------------------
// Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.

//----------------------------------------------------------------
// Inline version of TclCleanupCommand; still need the function as it is in
// the internal stubs, but the core can use the macro instead.

//----------------------------------------------------------------
// Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
// of calls out of the critical path. Note that this code isn't particularly
// readable; the non-inline version (in tclInterp.c) is much easier to
// understand. Note also that these macros takes different args (iPtr->limit)
// to the non-inline version.

// Compile-time assertions: these produce a compile time error if the
// expression is not known to be true at compile time. If the assertion is
// known to be false, the compiler (or optimizer?) will error out with
// "division by zero". If the assertion cannot be evaluated at compile time,
// the compiler will error out with "non-static initializer".
//
// Adapted with permission from
// http://www.pixelbeat.org/programming/gcc/static_assert.html

//----------------------------------------------------------------
// Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
// Only checked at compile time.
//
// ONLY USE FOR CONSTANT nBytes.
//
// DO NOT LET THEM CROSS THREAD BOUNDARIES
//----------------------------------------------------------------

// Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>

//----------------------------------------------------------------
// Parameters, structs and macros for the non-recursive engine (NRE)
//----------------------------------------------------------------

// This is the main data struct for representing NR commands. It is designed
// to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
// available.

type NRE_callback = NRE_callback1 /* tclInt.h:4891:3 */

type TclIntStubs = TclIntStubs1 /* tclIntDecls.h:908:3 */

type TclIntPlatStubs = TclIntPlatStubs1 /* tclIntPlatDecls.h:355:3 */

// Inline function declarations:

// Slot 5 is reserved
// Slot 15 is reserved
// Slot 16 is reserved
// Slot 17 is reserved
// Slot 18 is reserved
// Slot 19 is reserved
// Slot 20 is reserved
// Slot 21 is reserved
// Slot 22 is reserved
// Slot 23 is reserved
// Slot 24 is reserved
// Slot 25 is reserved
// Slot 26 is reserved
// Slot 27 is reserved
// Slot 28 is reserved

// !END!: Do not edit above this line.

//----------------------------------------------------------------------
//
// tclTomMathDecls.h --
//
//	This file contains the declarations for the 'libtommath'
//	functions that are exported by the Tcl library.
//
// Copyright (c) 2005 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution
// of this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// MS Visual C++ doesn't have a 128bit type for words, so fall back to 32bit MPI's (where words are 64bit)

// detect 64-bit mode if possible

// some default configurations.
//
// A "mp_digit" must be able to hold MP_DIGIT_BIT + 1 bits
// A "mp_word" must be able to hold 2*MP_DIGIT_BIT + 1 bits
//
// At the very least a mp_digit must be able to hold 7 bits
// [any size beyond that is ok provided it doesn't overflow the data type]

// this is the default case, 28-bit digits

// this is to make porting into LibTomCrypt easier :-)
type private_mp_word = uint64 /* tclTomMath.h:94:30 */

// default case is 28-bit digits, defines MP_28BIT as a handy macro to test

// otherwise the bits per digit is calculated automatically from the size of a mp_digit

// Primality generation flags

type mp_sign = int32   /* tclTomMath.h:163:13 */
type mp_ord = int32    /* tclTomMath.h:166:13 */
type mp_bool = int32   /* tclTomMath.h:170:13 */
type mp_err = int32    /* tclTomMath.h:173:13 */
type mp_order = int32  /* tclTomMath.h:181:13 */
type mp_endian = int32 /* tclTomMath.h:184:13 */

type TclTomMathStubs1 = struct {
	magic                       int32
	_                           [4]byte
	hooks                       uintptr
	tclBN_epoch                 uintptr
	tclBN_revision              uintptr
	tclBN_mp_add                uintptr
	tclBN_mp_add_d              uintptr
	tclBN_mp_and                uintptr
	tclBN_mp_clamp              uintptr
	tclBN_mp_clear              uintptr
	tclBN_mp_clear_multi        uintptr
	tclBN_mp_cmp                uintptr
	tclBN_mp_cmp_d              uintptr
	tclBN_mp_cmp_mag            uintptr
	tclBN_mp_copy               uintptr
	tclBN_mp_count_bits         uintptr
	tclBN_mp_div                uintptr
	tclBN_mp_div_d              uintptr
	tclBN_mp_div_2              uintptr
	tclBN_mp_div_2d             uintptr
	tclBN_mp_div_3              uintptr
	tclBN_mp_exch               uintptr
	tclBN_mp_expt_d             uintptr
	tclBN_mp_grow               uintptr
	tclBN_mp_init               uintptr
	tclBN_mp_init_copy          uintptr
	tclBN_mp_init_multi         uintptr
	tclBN_mp_init_set           uintptr
	tclBN_mp_init_size          uintptr
	tclBN_mp_lshd               uintptr
	tclBN_mp_mod                uintptr
	tclBN_mp_mod_2d             uintptr
	tclBN_mp_mul                uintptr
	tclBN_mp_mul_d              uintptr
	tclBN_mp_mul_2              uintptr
	tclBN_mp_mul_2d             uintptr
	tclBN_mp_neg                uintptr
	tclBN_mp_or                 uintptr
	tclBN_mp_radix_size         uintptr
	tclBN_mp_read_radix         uintptr
	tclBN_mp_rshd               uintptr
	tclBN_mp_shrink             uintptr
	tclBN_mp_set                uintptr
	tclBN_mp_sqr                uintptr
	tclBN_mp_sqrt               uintptr
	tclBN_mp_sub                uintptr
	tclBN_mp_sub_d              uintptr
	tclBN_mp_to_unsigned_bin    uintptr
	tclBN_mp_to_unsigned_bin_n  uintptr
	tclBN_mp_toradix_n          uintptr
	tclBN_mp_unsigned_bin_size  uintptr
	tclBN_mp_xor                uintptr
	tclBN_mp_zero               uintptr
	tclBN_reverse               uintptr
	tclBN_fast_s_mp_mul_digs    uintptr
	tclBN_fast_s_mp_sqr         uintptr
	tclBN_mp_karatsuba_mul      uintptr
	tclBN_mp_karatsuba_sqr      uintptr
	tclBN_mp_toom_mul           uintptr
	tclBN_mp_toom_sqr           uintptr
	tclBN_s_mp_add              uintptr
	tclBN_s_mp_mul_digs         uintptr
	tclBN_s_mp_sqr              uintptr
	tclBN_s_mp_sub              uintptr
	tclBN_mp_init_set_int       uintptr
	tclBN_mp_set_int            uintptr
	tclBN_mp_cnt_lsb            uintptr
	tclBNInitBignumFromLong     uintptr
	tclBNInitBignumFromWideInt  uintptr
	tclBNInitBignumFromWideUInt uintptr
	tclBN_mp_expt_d_ex          uintptr
	tclBN_mp_set_ull            uintptr
	reserved69                  uintptr
	reserved70                  uintptr
	reserved71                  uintptr
	reserved72                  uintptr
	tclBN_mp_tc_and             uintptr
	tclBN_mp_tc_or              uintptr
	tclBN_mp_tc_xor             uintptr
	tclBN_mp_signed_rsh         uintptr
	reserved77                  uintptr
	tclBN_mp_to_ubin            uintptr
	reserved79                  uintptr
	tclBN_mp_to_radix           uintptr
} /* tclTomMathDecls.h:351:9 */

type TclTomMathStubs = TclTomMathStubs1 /* tclTomMathDecls.h:436:3 */

// These are opaque types.

type Tcl_Class = uintptr         /* tclOO.h:52:27 */
type Tcl_Method = uintptr        /* tclOO.h:53:28 */
type Tcl_Object = uintptr        /* tclOO.h:54:28 */
type Tcl_ObjectContext = uintptr /* tclOO.h:55:35 */

// The type of a method implementation. This describes how to call the method
// implementation, how to delete it (when the object or class is deleted) and
// how to create a clone of it (when the object or class is copied).

type Tcl_MethodType = struct {
	version    int32
	_          [4]byte
	name       uintptr
	callProc   uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:93:3 */

// The correct value for the version field of the Tcl_MethodType structure.
// This allows new versions of the structure to be introduced without breaking
// binary compatability.

// The type of some object (or class) metadata. This describes how to delete
// the metadata (when the object or class is deleted) and how to create a
// clone of it (when the object or class is copied).

type Tcl_ObjectMetadataType = struct {
	version    int32
	_          [4]byte
	name       uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:120:3 */

type TclOOStubHooks = struct{ tclOOIntStubs uintptr } /* tclOODecls.h:122:3 */

type TclOOStubs1 = struct {
	magic                         int32
	_                             [4]byte
	hooks                         uintptr
	tcl_CopyObjectInstance        uintptr
	tcl_GetClassAsObject          uintptr
	tcl_GetObjectAsClass          uintptr
	tcl_GetObjectCommand          uintptr
	tcl_GetObjectFromObj          uintptr
	tcl_GetObjectNamespace        uintptr
	tcl_MethodDeclarerClass       uintptr
	tcl_MethodDeclarerObject      uintptr
	tcl_MethodIsPublic            uintptr
	tcl_MethodIsType              uintptr
	tcl_MethodName                uintptr
	tcl_NewInstanceMethod         uintptr
	tcl_NewMethod                 uintptr
	tcl_NewObjectInstance         uintptr
	tcl_ObjectDeleted             uintptr
	tcl_ObjectContextIsFiltering  uintptr
	tcl_ObjectContextMethod       uintptr
	tcl_ObjectContextObject       uintptr
	tcl_ObjectContextSkippedArgs  uintptr
	tcl_ClassGetMetadata          uintptr
	tcl_ClassSetMetadata          uintptr
	tcl_ObjectGetMetadata         uintptr
	tcl_ObjectSetMetadata         uintptr
	tcl_ObjectContextInvokeNext   uintptr
	tcl_ObjectGetMethodNameMapper uintptr
	tcl_ObjectSetMethodNameMapper uintptr
	tcl_ClassSetConstructor       uintptr
	tcl_ClassSetDestructor        uintptr
	tcl_GetObjectName             uintptr
} /* tclOODecls.h:124:9 */

type TclOOStubs = TclOOStubs1 /* tclOODecls.h:157:3 */

// Inline function declarations:

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Declarations for math functions.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//     float_t	floating-point type at least as wide as `float' used
// 		to evaluate `float' expressions
//     double_t	floating-point type at least as wide as `double' used
// 		to evaluate `double' expressions
type float_t = float32  /* math.h:149:15 */
type double_t = float64 /* math.h:150:16 */

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// When compiling in strict ISO C compatible mode we must not use the
//    inline functions since they, among other things, do not set the
//    `errno' variable correctly.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Get machine-dependent inline versions (if there are any).

// Required for Testregexp*Cmd
// tclRegexp.h --
//
//	This file contains definitions used internally by Henry Spencer's
//	regular expression code.
//
// Copyright (c) 1998 by Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// regular expressions
//
// Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
//
// Development of this software was funded, in part, by Cray Research Inc.,
// UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
// Corporation, none of whom are responsible for the results. The author
// thanks all of them.
//
// Redistribution and use in source and binary forms -- with or without
// modification -- are permitted for any purpose, provided that
// redistributions in source form retain this entire copyright notice and
// indicate the origin and nature of any modifications.
//
// I'd appreciate being given credit for this package in the documentation of
// software which uses it, but that is not a requirement.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
// HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// Prototypes etc. marked with "^" within comments get gathered up (and
// possibly edited) by the regfwd program and inserted near the bottom of this
// file.
//
// We offer the option of declaring one wide-character version of the RE
// functions as well as the char versions. To do that, define __REG_WIDE_T to
// the type of wide characters (unfortunately, there is no consensus that
// wchar_t is suitable) and __REG_WIDE_COMPILE and __REG_WIDE_EXEC to the
// names to be used for the compile and execute functions (suggestion:
// re_Xcomp and re_Xexec, where X is a letter suggestive of the wide type,
// e.g. re_ucomp and re_uexec for Unicode). For cranky old compilers, it may
// be necessary to do something like:
// #define	__REG_WIDE_COMPILE(a,b,c,d)	re_Xcomp(a,b,c,d)
// #define	__REG_WIDE_EXEC(a,b,c,d,e,f,g)	re_Xexec(a,b,c,d,e,f,g)
// rather than just #defining the names as parameterless macros.
//
// For some specialized purposes, it may be desirable to suppress the
// declarations of the "front end" functions, regcomp() and regexec(), or of
// the char versions of the compile and execute functions. To suppress the
// front-end functions, define __REG_NOFRONT. To suppress the char versions,
// define __REG_NOCHAR.
//
// The right place to do those defines (and some others you may want, see
// below) would be <sys/types.h>. If you don't have control of that file, the
// right place to add your own defines to this file is marked below. This is
// normally done automatically, by the makefile and regmkhdr, based on the
// contents of regcustom.h.

// voodoo for C++

// Add your own defines, if needed, here.

// Location where a chunk of regcustom.h is automatically spliced into this
// file (working from its prototype, regproto.h).

// --- begin ---
// ensure certain things don't sneak in from system headers
// interface types
// names and declarations
// --- end ---

// interface types etc.

// regoff_t has to be large enough to hold either off_t or ssize_t, and must
// be signed; it's only a guess that long is suitable, so we offer
// <sys/types.h> an override.
type regoff_t = int64 /* regex.h:123:24 */

// other interface types

// the biggie, a compiled RE (or rather, a front end to same)
type regex_t = struct {
	re_magic int32
	_        [4]byte
	re_nsub  size_t
	re_info  int64
	re_csize int32
	_        [4]byte
	re_endp  uintptr
	re_guts  uintptr
	re_fns   uintptr
} /* regex.h:156:3 */

// result reporting (may acquire more fields later)
type regmatch_t = struct {
	rm_so regoff_t
	rm_eo regoff_t
} /* regex.h:162:3 */

// supplementary control and reporting
type rm_detail_t = struct{ rm_extend regmatch_t } /* regex.h:167:3 */
// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp1 = struct {
	flags      int32
	_          [4]byte
	re         regex_t
	string     uintptr
	objPtr     uintptr
	globObjPtr uintptr
	matches    uintptr
	details    rm_detail_t
	refCount   int32
	_          [4]byte
} /* tclRegexp.h:27:9 */

// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp = TclRegexp1 /* tclRegexp.h:42:3 */

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Required for TestlocaleCmd
// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.11 Localization	<locale.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Definition of locale category symbol values.
//    Copyright (C) 2001-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are the possibilities for the first argument to setlocale.
//    The code assumes that the lowest LC_* symbol has the value zero.

// Structure giving information about numeric and monetary notation.
type lconv = struct {
	decimal_point      uintptr
	thousands_sep      uintptr
	grouping           uintptr
	int_curr_symbol    uintptr
	currency_symbol    uintptr
	mon_decimal_point  uintptr
	mon_thousands_sep  uintptr
	mon_grouping       uintptr
	positive_sign      uintptr
	negative_sign      uintptr
	int_frac_digits    int8
	frac_digits        int8
	p_cs_precedes      int8
	p_sep_by_space     int8
	n_cs_precedes      int8
	n_sep_by_space     int8
	p_sign_posn        int8
	n_sign_posn        int8
	int_p_cs_precedes  int8
	int_p_sep_by_space int8
	int_n_cs_precedes  int8
	int_n_sep_by_space int8
	int_p_sign_posn    int8
	int_n_sign_posn    int8
	_                  [2]byte
} /* locale.h:51:1 */

// This value can be passed to `uselocale' and may be returned by it.
//    Passing this value to any other function has undefined behavior.

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer1 = struct {
	refCount    int32
	nextAdded   int32
	nextRemoved int32
	bufLength   int32
	nextPtr     uintptr
	buf         [1]int8
	_           [7]byte
} /* tclIO.h:38:9 */

// This value can be passed to `uselocale' and may be returned by it.
//    Passing this value to any other function has undefined behavior.

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer = ChannelBuffer1 /* tclIO.h:51:3 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord1 = struct {
	chanPtr   uintptr
	scriptPtr uintptr
	interp    uintptr
	mask      int32
	_         [4]byte
	nextPtr   uintptr
} /* tclIO.h:75:9 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type Channel1 = struct {
	state        uintptr
	instanceData ClientData
	typePtr      uintptr
	downChanPtr  uintptr
	upChanPtr    uintptr
	inQueueHead  uintptr
	inQueueTail  uintptr
	refCount     int32
	_            [4]byte
} /* tclIO.h:75:9 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord = EventScriptRecord1 /* tclIO.h:86:3 */

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState1 = struct {
	channelName         uintptr
	flags               int32
	_                   [4]byte
	encoding            Tcl_Encoding
	inputEncodingState  Tcl_EncodingState
	inputEncodingFlags  int32
	_                   [4]byte
	outputEncodingState Tcl_EncodingState
	outputEncodingFlags int32
	inputTranslation    TclEolTranslation
	outputTranslation   TclEolTranslation
	inEofChar           int32
	outEofChar          int32
	unreportedError     int32
	refCount            int32
	_                   [4]byte
	closeCbPtr          uintptr
	outputStage         uintptr
	curOutPtr           uintptr
	outQueueHead        uintptr
	outQueueTail        uintptr
	saveInBufPtr        uintptr
	inQueueHead         uintptr
	inQueueTail         uintptr
	chPtr               uintptr
	interestMask        int32
	_                   [4]byte
	scriptRecordPtr     uintptr
	bufSize             int32
	_                   [4]byte
	timer               Tcl_TimerToken
	csPtrR              uintptr
	csPtrW              uintptr
	topChanPtr          uintptr
	bottomChanPtr       uintptr
	nextCSPtr           uintptr
	managingThread      Tcl_ThreadId
	chanMsg             uintptr
	unreportedMsg       uintptr
	epoch               int32
	_                   [4]byte
} /* tclIO.h:75:9 */

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type Channel = Channel1 /* tclIO.h:117:3 */

// struct ChannelState:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState = ChannelState1 /* tclIO.h:219:3 */

// Dynamic string shared by TestdcallCmd and DelCallbackProc; used to collect
// the results of the various deletion callbacks.

var delString Tcl_DString /* tclTest.c:61:20: */
var delInterp uintptr     /* tclTest.c:62:19: */

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler1 = struct {
	id      int32
	_       [4]byte
	handler Tcl_AsyncHandler
	command uintptr
	nextPtr uintptr
} /* tclTest.c:69:9 */

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler = TestAsyncHandler1 /* tclTest.c:76:3 */

var asyncTestMutex Tcl_Mutex /* tclTest.c:78:1: */

var firstHandler uintptr = uintptr(0) /* tclTest.c:80:25 */

// The dynamic string below is used by the "testdstring" command to test the
// dynamic string facilities.

var dstring Tcl_DString /* tclTest.c:87:20: */

// The command trace below is used by the "testcmdtraceCmd" command to test
// the command tracing facilities.

var cmdTrace Tcl_Trace /* tclTest.c:94:18: */

// One of the following structures exists for each command created by
// TestdelCmd:

type DelCmd1 = struct {
	interp    uintptr
	deleteCmd uintptr
} /* tclTest.c:101:9 */

// One of the following structures exists for each command created by
// TestdelCmd:

type DelCmd = DelCmd1 /* tclTest.c:105:3 */

// The following is used to keep track of an encoding that invokes a Tcl
// command.

type TclEncoding1 = struct {
	interp     uintptr
	toUtfCmd   uintptr
	fromUtfCmd uintptr
} /* tclTest.c:112:9 */

// The following is used to keep track of an encoding that invokes a Tcl
// command.

type TclEncoding = TclEncoding1 /* tclTest.c:116:3 */

// The counter below is used to determine if the TestsaveresultFree routine
// was called for a result.

var freeCount int32 /* tclTest.c:123:12: */

// Boolean flag used by the "testsetmainloop" and "testexitmainloop" commands.

var exitMainLoop int32 = 0 /* tclTest.c:129:12 */

// Event structure used in testing the event queue management procedures.

type TestEvent1 = struct {
	header  Tcl_Event
	interp  uintptr
	command uintptr
	tag     uintptr
} /* tclTest.c:135:9 */

// Event structure used in testing the event queue management procedures.

type TestEvent = TestEvent1 /* tclTest.c:140:3 */

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel1 = struct {
	__chan  Tcl_Channel
	nextPtr uintptr
} /* tclTest.c:147:9 */

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel = TestChannel1 /* tclTest.c:150:3 */

var firstDetached uintptr /* tclTest.c:152:20: */

var testReportingFilesystem = Tcl_Filesystem{
	typeName:             ts + 34, /* "reporting" */
	structureLength:      int32(unsafe.Sizeof(Tcl_Filesystem{})),
	version:              uintptr(0x1),
	pathInFilesystemProc: 0, // path in
	dupInternalRepProc:   0,
	freeInternalRepProc:  0, // convert to native
	normalizePathProc:    0, // separator
	statProc:             0,
	accessProc:           0,
	openFileChannelProc:  0,
	matchInDirectoryProc: 0,
	utimeProc:            0,
	linkProc:             0,
	fileAttrStringsProc:  0,
	fileAttrsGetProc:     0,
	fileAttrsSetProc:     0,
	createDirectoryProc:  0,
	removeDirectoryProc:  0,
	deleteFileProc:       0,
	copyFileProc:         0,
	renameFileProc:       0,
	copyDirectoryProc:    0,
	lstatProc:            0,
	loadFileProc:         0,
	chdirProc:            0,
} /* tclTest.c:442:29 */

var simpleFilesystem = Tcl_Filesystem{
	typeName:             ts + 44, /* "simple" */
	structureLength:      int32(unsafe.Sizeof(Tcl_Filesystem{})),
	version:              uintptr(0x1),
	pathInFilesystemProc: 0,
	statProc:             0,
	accessProc:           0,
	openFileChannelProc:  0,
	matchInDirectoryProc: 0,
	listVolumesProc:      0,
} /* tclTest.c:476:29 */

//----------------------------------------------------------------------
//
// Tcltest_Init --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:544:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var t3ArgTypes [2]Tcl_ValueType at bp, 8

	var listPtr uintptr
	// var objv uintptr at bp+16, 8

	// var objc int32 at bp+8, 4

	// var index int32 at bp+24, 4

	if tcl.XTcl_InitStubs(tls, interp, ts+51 /* "8.5" */, 0) == (uintptr(0)) {
		return TCL_ERROR
	}
	if (tcl.XTclTomMathInitializeStubs(tls, interp, ts+51 /* "8.5" */, TCLTOMMATH_EPOCH, TCLTOMMATH_REVISION)) == (uintptr(0)) {
		return TCL_ERROR
	}
	if tcl.XTclOOInitializeStubs(tls, interp, ts+55 /* "1.1.0" */) == (uintptr(0)) {
		return TCL_ERROR
	}
	// TIP #268: Full patchlevel instead of just major.minor

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgProvideEx})).f(tls, interp, ts /* "Tcltest" */, ts+61 /* "8.6.10" */, uintptr(0)) == TCL_ERROR {
		return TCL_ERROR
	}

	// Create additional commands and math functions for testing Tcl.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+68 /* "gettimes" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{GetTimesObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+77 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+77 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+82 /* "testpurebytesobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpurebytesobjObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+99 /* "testbytestring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbytestringObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+114 /* "testwrongnumargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestWrongNumArgsObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+131 /* "testfilesystem" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestFilesystemObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+146 /* "testsimplefilesy..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestSimpleFilesystemObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+167, /* "testgetindexfrom..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestGetIndexFromObjStructObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+193 /* "testasync" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestasyncCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+203, /* "testbumpinterpep..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestbumpinterpepochObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+223 /* "testchannel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+235 /* "testchannelevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelEventCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+252 /* "testcmdtoken" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtokenCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+265 /* "testcmdinfo" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdinfoCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+277 /* "testcmdtrace" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtraceCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+290 /* "testconcatobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestconcatobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+304 /* "testcreatecomman..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcreatecommandCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+322 /* "testdcall" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdcallCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+332 /* "testdel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+340 /* "testdelassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+357 /* "testdoubledigits" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubledigitsObjCmd})),
		uintptr(0), uintptr(0))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+374 /* "testdstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdstringCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+386 /* "testencoding" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestencodingObjCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+399 /* "testevalex" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalexObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+410 /* "testevalobjv" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalobjvObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+423 /* "testevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TesteventObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+433 /* "testexithandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexithandlerCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+449 /* "testexprlong" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+462 /* "testexprlongobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+478 /* "testexprdouble" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+493 /* "testexprdoubleob..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+511 /* "testexprparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprparserObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+526 /* "testexprstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprstringCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+541 /* "testfevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfeventCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+552 /* "testfilelink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilelinkCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+565 /* "testfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfileCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+574, /* "testhashsystemha..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestHashSystemHashCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+593 /* "testgetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+610 /* "testgetint" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetintCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+621 /* "testgetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetplatformCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+637, /* "testgetvarfullna..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestgetvarfullnameCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+656 /* "testinterpdelete" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestinterpdeleteCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+673 /* "testlink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlinkCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+682 /* "testlocale" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlocaleCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+693 /* "testpanic" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpanicCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+703 /* "testparseargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparseargsCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+717 /* "testparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparserObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+728 /* "testparsevar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+741 /* "testparsevarname" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarnameObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+758 /* "testregexp" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestregexpObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+769 /* "testreturn" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestreturnObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+780 /* "testsaveresult" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsaveresultCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+795 /* "testsetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+812 /* "testsetnoerr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+825 /* "testseterr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		ClientData(TCL_LEAVE_ERR_MSG), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+836 /* "testset2" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{Testset2Cmd})),
		ClientData(TCL_LEAVE_ERR_MSG), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+845 /* "testseterrorcode" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestseterrorcodeCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+862, /* "testsetobjerrorc..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestsetobjerrorcodeCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+882, /* "testnumutfchars" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestNumUtfCharsCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+898, /* "testfindfirst" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindFirstCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+912, /* "testfindlast" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindLastCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+925 /* "testsetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetplatformCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+941 /* "teststaticpkg" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststaticpkgCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+955, /* "testtranslatefil..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TesttranslatefilenameCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+977 /* "testupvar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestupvarCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+987 /* "T1" */, 0, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(123))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+990 /* "T2" */, 0, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(345))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+993 /* "testmainthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestmainthreadCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1008 /* "testsetmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetmainloopCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1024 /* "testexitmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexitmainloopCmd})),
		uintptr(0), uintptr(0))
	*(*Tcl_ValueType)(unsafe.Pointer(bp /* &t3ArgTypes[0] */)) = TCL_EITHER
	*(*Tcl_ValueType)(unsafe.Pointer(bp /* &t3ArgTypes[0] */ + 1*4)) = TCL_EITHER
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+1041 /* "T3" */, 2, bp /* &t3ArgTypes[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc2})),
		uintptr(0))

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1044 /* "testnreunwind" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNREUnwind})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1058 /* "testnrelevels" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNRELevels})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1072 /* "testinterpresolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestInterpResolverCmd})),
		uintptr(0), uintptr(0))

	if TclObjTest_Init(tls, interp) != TCL_OK {
		return TCL_ERROR
	}
	if Procbodytest_Init(tls, interp) != TCL_OK {
		return TCL_ERROR
	}
	if TclThread_Init(tls, interp) != TCL_OK {
		return TCL_ERROR
	}

	// Check for special options used in ../tests/main.test

	listPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2Ex})).f(tls, interp, ts+1091 /* "argv" */, uintptr(0), TCL_GLOBAL_ONLY)
	if listPtr != (uintptr(0)) {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjGetElements})).f(tls, interp, listPtr, bp+8 /* &objc */, bp+16 /* &objv */) != TCL_OK {
			return TCL_ERROR
		}
		if (*(*int32)(unsafe.Pointer(bp + 8 /* objc */)) != 0) && ((*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* objv */)))), uintptr(unsafe.Pointer(&specialOptions)), int32(unsafe.Sizeof(uintptr(0))), uintptr(0), TCL_EXACT, bp+24 /* &index */) == TCL_OK) {
			switch *(*int32)(unsafe.Pointer(bp + 24 /* index */)) {
			case 0:
				return TCL_ERROR
				fallthrough
			case 1:
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp)
				return TCL_ERROR
				fallthrough
			case 2:
				{
					// var mode int32 at bp+28, 4

					(*struct {
						f func(*libc.TLS, uintptr, Tcl_Channel) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, interp,
						(*struct {
							f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
						})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, ts+1096 /* "stderr" */, bp+28 /* &mode */))
					return TCL_ERROR

				}
				fallthrough
			case 3:
				if (*(*int32)(unsafe.Pointer(bp + 8 /* objc */)) - 1) != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2Ex})).f(tls, interp, ts+8 /* "tcl_rcFileName" */, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* objv */)) + 1*8)),
						TCL_GLOBAL_ONLY)
				}
				return TCL_ERROR
			}
		}
	}

	// And finally add any platform specific test commands.

	return TclplatformtestInit(tls, interp)
}

var specialOptions = [5]uintptr{
	ts + 1103 /* "-appinitprocerro..." */, ts + 1121, /* "-appinitprocdele..." */
	ts + 1146 /* "-appinitprocclos..." */, ts + 1170 /* "-appinitprocsetr..." */, uintptr(0),
} /* tclTest.c:552:23 */

//----------------------------------------------------------------------
//
// Tcltest_SafeInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:793:1: */
	if tcl.XTcl_InitStubs(tls, interp, ts+51 /* "8.5" */, 0) == (uintptr(0)) {
		return TCL_ERROR
	}
	return Procbodytest_SafeInit(tls, interp)
}

//----------------------------------------------------------------------
//
// TestasyncCmd --
//
//	This procedure implements the "testasync" command.  It is used
//	to test the asynchronous handler facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestasyncCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:821:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var asyncPtr uintptr
	var prevPtr uintptr
	// var id int32 at bp+32, 4

	// var code int32 at bp+36, 4

	// var threadID Tcl_ThreadId at bp+40, 8

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1192 /* "wrong # args" */, uintptr(0))
	return TCL_ERROR
__1:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0) {
		goto __2
	}
	if !(argc != 3) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	asyncPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestAsyncHandler{})))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))) + uint64(1))))
	libc.Xstrcpy(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id = nextId
	nextId++
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler = (*struct {
		f func(*libc.TLS, uintptr, ClientData) Tcl_AsyncHandler
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncCreate})).f(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32) int32
	}{AsyncHandlerProc})),
		uintptr(intptr_t((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id)))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr = firstHandler
	firstHandler = asyncPtr
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0) {
		goto __5
	}
	if !(argc == 2) {
		goto __7
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
__8:
	if !(firstHandler != (uintptr(0))) {
		goto __9
	}
	asyncPtr = firstHandler
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncDelete})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, asyncPtr)
	goto __8
__9:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	return TCL_OK
__7:
	;
	if !(argc != 3) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32 /* &id */) != TCL_OK) {
		goto __11
	}
	return TCL_ERROR
__11:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	prevPtr = uintptr(0)
	asyncPtr = firstHandler
__12:
	if !(asyncPtr != (uintptr(0))) {
		goto __14
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id != *(*int32)(unsafe.Pointer(bp + 32 /* id */))) {
		goto __15
	}
	goto __13
__15:
	;
	if !(prevPtr == (uintptr(0))) {
		goto __16
	}
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __17
__16:
	(*TestAsyncHandler)(unsafe.Pointer(prevPtr)).nextPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
__17:
	;
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncDelete})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, asyncPtr)
	goto __14
	goto __13
__13:
	prevPtr = asyncPtr
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __12
	goto __14
__14:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	goto __6
__5:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1219 /* "mark" */) == 0) {
		goto __18
	}
	if !(argc != 5) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !(((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32 /* &id */) != TCL_OK) ||
		((*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+36 /* &code */) != TCL_OK)) {
		goto __21
	}
	return TCL_ERROR
__21:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	asyncPtr = firstHandler
__22:
	if !(asyncPtr != (uintptr(0))) {
		goto __24
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == *(*int32)(unsafe.Pointer(bp + 32 /* id */))) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncMark})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	goto __24
__25:
	;
	goto __23
__23:
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __22
	goto __24
__24:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	return *(*int32)(unsafe.Pointer(bp + 36 /* code */))
	goto __19
__18:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1224 /* "marklater" */) == 0) {
		goto __26
	}
	if !(argc != 3) {
		goto __28
	}
	goto wrongNumArgs
__28:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32 /* &id */) != TCL_OK) {
		goto __29
	}
	return TCL_ERROR
__29:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	asyncPtr = firstHandler
__30:
	if !(asyncPtr != (uintptr(0))) {
		goto __32
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == *(*int32)(unsafe.Pointer(bp + 32 /* id */))) {
		goto __33
	}
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, ClientData, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateThread})).f(tls, bp+40 /* &threadID */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{AsyncThreadProc})),
		uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp + 32 /* id */)))), 0,
		0000) != TCL_OK) {
		goto __34
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1234 /* "can't create thr..." */, uintptr(0))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	return TCL_ERROR
__34:
	;
	goto __32
__33:
	;
	goto __31
__31:
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __30
	goto __32
__32:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	goto __27
__26:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
		ts+1267 /* "\": must be creat..." */, uintptr(0)))
	return TCL_ERROR
__27:
	;
__19:
	;
__6:
	;
__3:
	;
	return TCL_OK
}

var nextId int32 = 1 /* tclTest.c:829:16 */

func AsyncHandlerProc(tls *libc.TLS, clientData ClientData, interp uintptr, code int32) int32 { /* tclTest.c:946:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var asyncPtr uintptr
	var id int32 = int32(clientData)
	// var listArgv [4]uintptr at bp+24, 32

	var cmd uintptr
	// var string [24]int8 at bp, 24

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	for asyncPtr = firstHandler; asyncPtr != (uintptr(0)); asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr {
		if (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == id {
			break
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))

	if !(asyncPtr != 0) {
		// Woops - this one was deleted between the AsyncMark and now
		return TCL_OK
	}

	(*struct {
		f func(*libc.TLS, uintptr, int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp /* &string[0] */, int64(code))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv[0] */)) = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv[0] */ + 1*8)) = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv[0] */ + 2*8)) = bp /* &string[0] */
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv[0] */ + 3*8)) = uintptr(0)
	cmd = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Merge})).f(tls, 3, bp+24 /* &listArgv[0] */)
	if interp != (uintptr(0)) {
		code = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, cmd, -1, 0)
	} else {
		// this should not happen, but by definition of how async handlers are
		// invoked, it's possible.  Better error checking is needed here.
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, cmd)
	return code
}

//----------------------------------------------------------------------
//
// AsyncThreadProc --
//
//	Delivers an asynchronous event to a handler in another thread.
//
// Results:
//	None.
//
// Side effects:
//	Invokes Tcl_AsyncMark on the handler
//
//----------------------------------------------------------------------

func AsyncThreadProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1008:1: */
	var asyncPtr uintptr
	var id int32 = int32(clientData)

	(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Sleep})).f(tls, 1)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	for asyncPtr = firstHandler; asyncPtr != (uintptr(0)); asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr {
		if (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == id {
			(*struct {
				f func(*libc.TLS, Tcl_AsyncHandler)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncMark})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
			break
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&asyncTestMutex)))
	(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExitThread})).f(tls, TCL_OK)

}

func TestbumpinterpepochObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1031:1: */
	var iPtr uintptr = interp
	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1318 /* "" */)
		return TCL_ERROR
	}
	(*Interp)(unsafe.Pointer(iPtr)).compileEpoch++
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestcmdinfoCmd --
//
//	This procedure implements the "testcmdinfo" command.  It is used to
//	test Tcl_GetCommandInfo, Tcl_SetCommandInfo, and command creation and
//	deletion.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdinfoCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1066:1: */
	bp := tls.Alloc(344)
	defer tls.Free(344)

	// var info Tcl_CmdInfo at bp+280, 64

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1345 /* " option cmdName\"" */, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})), ts+1362, /* "original" */
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc1})))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&delString)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1371 /* "get" */) == 0 {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+280 /* &info */) == 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1375 /* "??" */, uintptr(0))
			return TCL_OK
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1378 /* "CmdProc1" */, ts+1387, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).clientData, uintptr(0)))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+1389 /* "CmdProc2" */, ts+1387, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).clientData, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+1398 /* "unknown" */, uintptr(0)))
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc1})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+112, ts+1406 /* " CmdDelProc1" */, ts+1387, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteData, uintptr(0)))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc2})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+144, ts+1419 /* " CmdDelProc2" */, ts+1387, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteData, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+176, ts+1432 /* " unknown" */, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+1387 /* " " */, (*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).namespacePtr)).fullName, uintptr(0)))
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).isNativeObjectProc != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+216, ts+1441 /* " nativeObjectPro..." */, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+232, ts+1459 /* " stringProc" */, uintptr(0)))
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1471 /* "modify" */) == 0 {
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).clientData = ts + 1478 /* "new_command_data" */
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).objProc = uintptr(0)
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).objClientData = uintptr(0)
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).deleteData = ts + 1495 /* "new_delete_data" */
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetCommandInfo})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+280 /* &info */) == 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 0))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 1))
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+248, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1511 /* "\": must be creat..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//ARGSUSED
func CmdProc1(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1137:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1553 /* "CmdProc1 " */, clientData, uintptr(0)))
	return TCL_OK
}

//ARGSUSED
func CmdProc2(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1149:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1563 /* "CmdProc2 " */, clientData, uintptr(0)))
	return TCL_OK
}

func CmdDelProc1(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1160:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+1573 /* "CmdDelProc1 " */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

func CmdDelProc2(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1169:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+1586 /* "CmdDelProc2 " */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

//----------------------------------------------------------------------
//
// TestcmdtokenCmd --
//
//	This procedure implements the "testcmdtoken" command. It is used to
//	test Tcl_Command tokens and procedures such as Tcl_GetCommandFullName.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdtokenCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1196:1: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var token Tcl_Command
	// var l uintptr at bp+144, 8

	// var buf [30]int8 at bp+112, 30

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1599 /* " option arg\"" */, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		token = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})),
			ts+1362 /* "original" */, uintptr(0))
		libc.Xsprintf(tls, bp+112 /* &buf[0] */, ts+1612 /* "%p" */, libc.VaList(bp+32, token))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, bp+112 /* &buf[0] */, uintptr(1))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1615 /* "name" */) == 0 {
		var objPtr uintptr

		if libc.Xsscanf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+1612 /* "%p" */, libc.VaList(bp+40, bp+144 /* &l */)) != 1 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+1620 /* "bad command toke..." */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
				ts+1640 /* "\"" */, uintptr(0)))
			return TCL_ERROR
		}

		objPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Command, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_GetCommandFullName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */)), objPtr)

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp,
			(*struct {
				f func(*libc.TLS, uintptr, Tcl_Command) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, objPtr))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = objPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1642 /* "\": must be creat..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestcmdtraceCmd --
//
//	This procedure implements the "testcmdtrace" command. It is used
//	to test Tcl_CreateTrace and Tcl_DeleteTrace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes a command trace, and tests the invocation of
//	a procedure by the command trace.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdtraceCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1260:1: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	// var buffer Tcl_DString at bp+112, 216

	var result int32

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1668 /* " option script\"" */, uintptr(0)))
		return TCL_ERROR
	}

	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1684 /* "tracetest" */) == 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1694 /* "deletetest" */) == 0 {
		// Create a command trace then eval a script to check whether it is
		// called. Note that this trace procedure removes itself as a further
		// check of the robustness of the trace proc calling code in
		// TclNRExecuteByteCode.

		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceDeleteProc})), uintptr(0))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1705 /* "leveltest" */) == 0 {
		var iPtr uintptr = interp
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, ((*Interp)(unsafe.Pointer(iPtr)).numLevels + 4), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})),
			bp+112 /* &buffer */)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1715 /* "resulttest" */) == 0 {

		deleteCalled = 0
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, uintptr, ClientData, uintptr) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjTrace})).f(tls, interp, 50000,
			TCL_ALLOW_INLINE_COMPILATION, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr, Tcl_Command, int32, uintptr) int32
			}{ObjTraceProc})),
			uintptr(unsafe.Pointer(&deleteCalled)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ObjTraceDeleteProc})))
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		if !(deleteCalled != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1726 /* "Delete wasn't ca..." */, uintptr(0))
			return TCL_ERROR
		} else {
			return result
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1747 /* "doubletest" */) == 0 {
		var t1 Tcl_Trace
		var t2 Tcl_Trace

		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		t1 = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 1, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		t2 = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, t2)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, t1)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1758 /* "\": must be trace..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var deleteCalled int32 /* tclTest.c:1312:13: */

func CmdTraceProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1349:1: */
	var bufPtr uintptr = clientData
	var i int32

	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bufPtr, command)

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, bufPtr)
	for i = 0; i < argc; i++ {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bufPtr, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, bufPtr)
}

func CmdTraceDeleteProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1376:1: */
	// Remove ourselves to test whether calling Tcl_DeleteTrace within a trace
	// callback causes the for loop in TclNRExecuteByteCode that calls traces to
	// reference freed memory.

	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Trace)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
}

func ObjTraceProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, token Tcl_Command, objc int32, objv uintptr) int32 { /* tclTest.c:1398:1: */
	var word uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv)))

	if !(libc.Xstrcmp(tls, word, ts+1817 /* "Error" */) != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, command, -1))
		return TCL_ERROR
	} else if !(libc.Xstrcmp(tls, word, ts+1823 /* "Break" */) != 0) {
		return TCL_BREAK
	} else if !(libc.Xstrcmp(tls, word, ts+1829 /* "Continue" */) != 0) {
		return TCL_CONTINUE
	} else if !(libc.Xstrcmp(tls, word, ts+1838 /* "Return" */) != 0) {
		return TCL_RETURN
	} else if !(libc.Xstrcmp(tls, word, ts+1845 /* "OtherStatus" */) != 0) {
		return 6
	} else {
		return TCL_OK
	}
	return int32(0)
}

func ObjTraceDeleteProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1426:1: */
	var intPtr uintptr = clientData
	*(*int32)(unsafe.Pointer(intPtr)) = 1 // Record that the trace was deleted
}

//----------------------------------------------------------------------
//
// TestcreatecommandCmd --
//
//	This procedure implements the "testcreatecommand" command. It is used
//	to test that the Tcl_CreateCommand creates a new command in the
//	namespace specified as part of its name, if any. It also checks that
//	the namespace code ignore single ":"s in the middle or end of a
//	command name.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes two commands ("test_ns_basic::createdcommand"
//	and "value:at:").
//
//----------------------------------------------------------------------

func TestcreatecommandCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1455:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1857 /* " option\"" */, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1866, /* "test_ns_basic::c..." */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc})), uintptr(0), uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, ts+1866 /* "test_ns_basic::c..." */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1896 /* "create2" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1904, /* "value:at:" */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc2})), uintptr(0), uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1914 /* "delete2" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, ts+1904 /* "value:at:" */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1922 /* "\": must be creat..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func CreatedCommandProc(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1485:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, ts+1866, /* "test_ns_basic::c..." */
		bp+40 /* &info */)
	if !(found != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1969, /* "CreatedCommandPr..." */
			uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+2049, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, uintptr(0)))
	return TCL_OK
}

func CreatedCommandProc2(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1507:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, ts+1904 /* "value:at:" */, bp+40 /* &info */)
	if !(found != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2072, /* "CreatedCommandPr..." */
			uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+2153, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestdcallCmd --
//
//	This procedure implements the "testdcall" command.  It is used
//	to test Tcl_CallWhenDeleted.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdcallCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1546:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	// var id int32 at bp, 4

	delInterp = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateInterp})).f(tls)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	for i = 1; i < argc; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp /* &id */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp /* id */)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DontCallWhenDeleted})).f(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				uintptr(intptr_t(-*(*int32)(unsafe.Pointer(bp /* id */)))))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CallWhenDeleted})).f(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp /* id */)))))
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, delInterp)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&delString)))
	return TCL_OK
}

// The deletion callback used by TestdcallCmd:

func DelCallbackProc(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:1578:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var id int32 = int32(clientData)
	// var buffer [24]int8 at bp, 24

	(*struct {
		f func(*libc.TLS, uintptr, int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp /* &buffer[0] */, int64(id))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&delString)), bp /* &buffer[0] */)
	if interp != delInterp {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+2177 /* "bogus interprete..." */)
	}
}

//----------------------------------------------------------------------
//
// TestdelCmd --
//
//	This procedure implements the "testdel" command.  It is used
//	to test calling of command deletion callbacks.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates a command.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdelCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1611:1: */
	var dPtr uintptr
	var slave uintptr

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1192 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	}

	slave = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if slave == (uintptr(0)) {
		return TCL_ERROR
	}

	dPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(DelCmd{})))
	(*DelCmd)(unsafe.Pointer(dPtr)).interp = interp
	(*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8))) + uint64(1))))
	libc.Xstrcpy(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, *(*uintptr)(unsafe.Pointer(argv + 3*8)))

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, slave, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{DelCmdProc})), dPtr,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{DelDeleteProc})))
	return TCL_OK
}

func DelCmdProc(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1641:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var dPtr uintptr = clientData

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, uintptr(0)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, dPtr)
	return TCL_OK
}

func DelDeleteProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1656:1: */
	var dPtr uintptr = clientData

	(*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, dPtr)
}

//----------------------------------------------------------------------
//
// TestdelassocdataCmd --
//
//	This procedure implements the "testdelassocdata" command. It is used
//	to test Tcl_DeleteAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes an association between a key and associated data from an
//	interpreter.
//
//----------------------------------------------------------------------

func TestdelassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1686:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+2236 /* " data_key\"" */, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	return TCL_OK
}

//-----------------------------------------------------------------------------
//
// TestdoubledigitsCmd --
//
//	This procedure implements the 'testdoubledigits' command. It is
//	used to test the low-level floating-point formatting primitives
//	in Tcl.
//
// Usage:
//	testdoubledigits fpval ndigits type ?shorten"
//
// Parameters:
//	fpval - Floating-point value to format.
//	ndigits - Digit count to request from Tcl_DoubleDigits
//	type - One of 'shortest', 'Steele', 'e', 'f'
//	shorten - Indicates that the 'shorten' flag should be passed in.
//
//-----------------------------------------------------------------------------

func TestdoubledigitsObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1723:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var doubleType uintptr
	// var d float64 at bp+8, 8

	var status int32
	// var ndigits int32 at bp+16, 4

	// var type1 int32 at bp+20, 4

	// var decpt int32 at bp+24, 4

	// var signum int32 at bp+28, 4

	var str uintptr
	// var endPtr uintptr at bp+32, 8

	// var strObj uintptr at bp+40, 8

	var retval uintptr

	if (objc < 4) || (objc > 5) {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+2247 /* "fpval ndigits ty..." */)
		return TCL_ERROR
	}
	status = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8 /* &d */)
	if status != TCL_OK {
		doubleType = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+2276 /* "double" */)
		if ((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)))).typePtr == doubleType) ||
			(libc.X__builtin_isnan(tls, *(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32 /* &.internalRep */))) != 0) {
			status = TCL_OK
			libc.Xmemcpy(tls, bp+8 /* &d */, (*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32 /* &.internalRep */ /* &.doubleValue */), uint64(unsafe.Sizeof(float64(0))))
		}
	}
	if ((status != TCL_OK) ||
		((*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16 /* &ndigits */) != TCL_OK)) ||
		((*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(unsafe.Pointer(&options)), int32(unsafe.Sizeof(uintptr(0))), ts+2283 /* "conversion type" */, TCL_EXACT, bp+20 /* &type1 */) != TCL_OK) {
		libc.Xfprintf(tls, libc.Xstderr, ts+2299 /* "bad value? %g\n" */, libc.VaList(bp, *(*float64)(unsafe.Pointer(bp + 8 /* d */))))
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) = types1[*(*int32)(unsafe.Pointer(bp + 20 /* type1 */))]
	if objc > 4 {
		if libc.Xstrcmp(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8))), ts+2314 /* "shorten" */) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+2322 /* "bad flag" */, -1))
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) |= TCL_DD_SHORTEN_FLAG
	}
	str = (*struct {
		f func(*libc.TLS, float64, int32, int32, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclDoubleDigits})).f(tls, *(*float64)(unsafe.Pointer(bp + 8 /* d */)), *(*int32)(unsafe.Pointer(bp + 16 /* ndigits */)), *(*int32)(unsafe.Pointer(bp + 20 /* type1 */)), bp+24 /* &decpt */, bp+28 /* &signum */, bp+32 /* &endPtr */)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, str, (int32((int64(*(*uintptr)(unsafe.Pointer(bp + 32 /* endPtr */))) - int64(str)) / 1)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, str)
	retval = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 1, bp+40 /* &strObj */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), retval, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 24 /* decpt */))))
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 28 /* signum */)) != 0 {
			return ts + 2331 /* "-" */
		}
		return ts + 2333 /* "+" */
	}(), 1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), retval, *(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, retval)
	return TCL_OK
}

var options = [5]uintptr{
	ts + 2335, /* "shortest" */
	ts + 2344, /* "Steele" */
	ts + 2351, /* "e" */
	ts + 2353, /* "f" */
	uintptr(0),
} /* tclTest.c:1732:22 */
var types1 = [4]int32{
	TCL_DD_SHORTEST,
	TCL_DD_STEELE,
	TCL_DD_E_FORMAT,
	TCL_DD_F_FORMAT,
} /* tclTest.c:1739:22 */

//----------------------------------------------------------------------
//
// TestdstringCmd --
//
//	This procedure implements the "testdstring" command.  It is used
//	to test the dynamic string facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdstringCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1816:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var count int32 at bp+64, 4

	var s uintptr
	var s1 uintptr

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1192 /* "wrong # args" */, uintptr(0))
	return TCL_ERROR
__1:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2355 /* "append" */) == 0) {
		goto __2
	}
	if !(argc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+64 /* &count */) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2362 /* "element" */) == 0) {
		goto __6
	}
	if !(argc != 3) {
		goto __8
	}
	goto wrongNumArgs
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	goto __7
__6:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2370 /* "end" */) == 0) {
		goto __9
	}
	if !(argc != 2) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2374 /* "free" */) == 0) {
		goto __12
	}
	if !(argc != 2) {
		goto __14
	}
	goto wrongNumArgs
__14:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __13
__12:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1371 /* "get" */) == 0) {
		goto __15
	}
	if !(argc != 2) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, (*Tcl_DString)(unsafe.Pointer(uintptr(unsafe.Pointer(&dstring)))).string, uintptr(1))
	goto __16
__15:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2379 /* "gresult" */) == 0) {
		goto __18
	}
	if !(argc != 3) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2387 /* "staticsmall" */) == 0) {
		goto __21
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+2399 /* "short" */, uintptr(0))
	goto __22
__21:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2405 /* "staticlarge" */) == 0) {
		goto __23
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+2417 /* "first0 first1 fi..." */, uintptr(0))
	goto __24
__23:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2374 /* "free" */) == 0) {
		goto __25
	}
	s = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(100))
	libc.Xstrcpy(tls, s, ts+2948 /* "This is a malloc..." */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, s, uintptr(3))
	goto __26
__25:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2975 /* "special" */) == 0) {
		goto __27
	}
	s1 = (((*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(100))) + uintptr(16))
	libc.Xstrcpy(tls, s1, ts+2983 /* "This is a specia..." */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, s1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{SpecialFree})))
	goto __28
__27:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3020 /* "bad gresult opti..." */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
		ts+3041, /* "\": must be stati..." */
		uintptr(0)))
	return TCL_ERROR
__28:
	;
__26:
	;
__24:
	;
__22:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringGetResult})).f(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __19
__18:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3095 /* "length" */) == 0) {
		goto __29
	}

	if !(argc != 2) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_DString)(unsafe.Pointer(uintptr(unsafe.Pointer(&dstring)))).length))
	goto __30
__29:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3102 /* "result" */) == 0) {
		goto __32
	}
	if !(argc != 2) {
		goto __34
	}
	goto wrongNumArgs
__34:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __33
__32:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3109 /* "trunc" */) == 0) {
		goto __35
	}
	if !(argc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+64 /* &count */) != TCL_OK) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringSetLength})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __36
__35:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3115 /* "start" */) == 0) {
		goto __39
	}
	if !(argc != 2) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __40
__39:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

		ts+3121 /* "\": must be appen..." */, uintptr(0)))
	return TCL_ERROR
__40:
	;
__36:
	;
__33:
	;
__30:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__7:
	;
__3:
	;
	return TCL_OK
}

// The procedure below is used as a special freeProc to test how well
// Tcl_DStringGetResult handles freeProc's other than free.

func SpecialFree(tls *libc.TLS, blockPtr uintptr) { /* tclTest.c:1918:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (blockPtr - uintptr(16)))
}

//----------------------------------------------------------------------
//
// TestencodingCmd --
//
//	This procedure implements the "testencoding" command.  It is used
//	to test the encoding package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Load encodings.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestencodingObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1943:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var encoding Tcl_Encoding
	// var index int32 at bp, 4

	// var length int32 at bp+4, 4

	var string uintptr
	var encodingPtr uintptr

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings)), int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp /* &index */) != TCL_OK {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* index */))) {
	case uint32(0) /* ENC_CREATE */ :
		{
			// var type1 Tcl_EncodingType at bp+8, 48

			if objc != 5 {
				return TCL_ERROR
			}
			encodingPtr = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TclEncoding{})))
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).interp = interp

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1)))
			libc.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, string, (uint64(uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */))) + uint32(1))))

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1)))
			libc.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, string, uint64((uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1))))

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */)

			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).encodingName = string
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).toUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingToUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).fromUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingFromUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).freeProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{EncodingFreeProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).clientData = encodingPtr
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).nullSize = 1

			(*struct {
				f func(*libc.TLS, uintptr) Tcl_Encoding
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateEncoding})).f(tls, bp+8 /* &type1 */)
			break

		}
	case uint32(1) /* ENC_DELETE */ :
		if objc != 3 {
			return TCL_ERROR
		}
		encoding = (*struct {
			f func(*libc.TLS, uintptr, uintptr) Tcl_Encoding
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetEncoding})).f(tls, uintptr(0), (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
		(*struct{ f func(*libc.TLS, Tcl_Encoding) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeEncoding})).f(tls, encoding)
		(*struct{ f func(*libc.TLS, Tcl_Encoding) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeEncoding})).f(tls, encoding)
		break
	}
	return TCL_OK
}

var optionStrings = [3]uintptr{
	ts + 1205 /* "create" */, ts + 1212 /* "delete" */, uintptr(0),
} /* tclTest.c:1953:23 */

func EncodingToUtfProc(tls *libc.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:2008:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, -1, TCL_EVAL_GLOBAL)

	len = int32(libc.Xstrlen(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)))
	if len > dstLen {
		len = dstLen
	}
	libc.Xmemcpy(tls, dst, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp), uint64(uint32(len)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return TCL_OK
}

func EncodingFromUtfProc(tls *libc.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:2040:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, -1, TCL_EVAL_GLOBAL)

	len = int32(libc.Xstrlen(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)))
	if len > dstLen {
		len = dstLen
	}
	libc.Xmemcpy(tls, dst, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp), uint64(uint32(len)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return TCL_OK
}

func EncodingFreeProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:2072:1: */
	var encodingPtr uintptr = clientData

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, encodingPtr)
}

//----------------------------------------------------------------------
//
// TestevalexObjCmd --
//
//	This procedure implements the "testevalex" command.  It is
//	used to test Tcl_EvalEx.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalexObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2100:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var length int32 at bp+32, 4

	var flags int32
	var script uintptr

	flags = 0
	if objc == 3 {
		var global uintptr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
		if libc.Xstrcmp(tls, global, ts+3204 /* "global" */) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3211 /* "bad value \"" */, global,
				ts+3223 /* "\": must be globa..." */, uintptr(0)))
			return TCL_ERROR
		}
		flags = TCL_EVAL_GLOBAL
	} else if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3241 /* "script ?global?" */)
		return TCL_ERROR
	}

	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32 /* &length */)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 32 /* length */)), flags)
}

//----------------------------------------------------------------------
//
// TestevalobjvObjCmd --
//
//	This procedure implements the "testevalobjv" command.  It is
//	used to test Tcl_EvalObjv.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalobjvObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2145:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var evalGlobal int32 at bp, 4

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3257 /* "global word ?wor..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &evalGlobal */) != TCL_OK {
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjv})).f(tls, interp, (objc - 2), (objv + uintptr(2)*8),
		func() int32 {
			if *(*int32)(unsafe.Pointer(bp /* evalGlobal */)) != 0 {
				return TCL_EVAL_GLOBAL
			}
			return 0
		}())
}

//----------------------------------------------------------------------
//
// TesteventObjCmd --
//
//	This procedure implements a 'testevent' command.  The command
//	is used to test event queue management.
//
// The command takes two forms:
//	- testevent queue name position script
//		Queues an event at the given position in the queue, and
//		associates a given name with it (the same name may be
//		associated with multiple events). When the event comes
//		to the head of the queue, executes the given script at
//		global level in the current interp. The position may be
//		one of 'head', 'tail' or 'mark'.
//	- testevent delete name
//		Deletes any events associated with the given name from
//		the queue.
//
// Return value:
//	Returns a standard Tcl result.
//
// Side effects:
//	Manipulates the event queue as directed.
//
//----------------------------------------------------------------------

func TesteventObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2194:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var subCmdIndex int32 at bp, 4

	// var posIndex int32 at bp+4, 4

	var ev uintptr // Event to be queued

	if objc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3280 /* "subcommand ?arg ..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&subcommands)), int32(unsafe.Sizeof(uintptr(0))), ts+3301 /* "subcommand" */, TCL_EXACT, bp /* &subCmdIndex */) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp /* subCmdIndex */)) {
	case 0: // queue
		if objc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+3312 /* "name position sc..." */)
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(unsafe.Pointer(&positions)), int32(unsafe.Sizeof(uintptr(0))), ts+3333 /* "position specifi..." */, TCL_EXACT, bp+4 /* &posIndex */) != TCL_OK {
			return TCL_ERROR
		}
		ev = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestEvent{})))
		(*TestEvent)(unsafe.Pointer(ev)).header.proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{TesteventProc}))
		(*TestEvent)(unsafe.Pointer(ev)).header.nextPtr = uintptr(0)
		(*TestEvent)(unsafe.Pointer(ev)).interp = interp
		(*TestEvent)(unsafe.Pointer(ev)).command = *(*uintptr)(unsafe.Pointer(objv + 4*8))
		(*Tcl_Obj)(unsafe.Pointer((*TestEvent)(unsafe.Pointer(ev)).command)).refCount++
		(*TestEvent)(unsafe.Pointer(ev)).tag = *(*uintptr)(unsafe.Pointer(objv + 2*8))
		(*Tcl_Obj)(unsafe.Pointer((*TestEvent)(unsafe.Pointer(ev)).tag)).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_QueuePosition)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_QueueEvent})).f(tls, ev, posNum[*(*int32)(unsafe.Pointer(bp + 4 /* posIndex */))])
		break

	case 1: // delete
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+1615 /* "name" */)
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteEvents})).f(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, ClientData) int32
		}{TesteventDeleteProc})), *(*uintptr)(unsafe.Pointer(objv + 2*8)))
		break
	}

	return TCL_OK
}

var subcommands = [3]uintptr{ // Possible subcommands
	ts + 3352 /* "queue" */, ts + 1212 /* "delete" */, uintptr(0),
}                           /* tclTest.c:2200:23 */
var positions = [4]uintptr{ // Possible queue positions
	ts + 3358 /* "head" */, ts + 3363 /* "tail" */, ts + 1219 /* "mark" */, uintptr(0),
} /* tclTest.c:2204:23 */
var posNum = [3]Tcl_QueuePosition{
	// Interpretation of the chosen position
	TCL_QUEUE_HEAD,
	TCL_QUEUE_TAIL,
	TCL_QUEUE_MARK,
} /* tclTest.c:2208:36 */

//----------------------------------------------------------------------
//
// TesteventProc --
//
//	Delivers a test event to the Tcl interpreter as part of event
//	queue testing.
//
// Results:
//	Returns 1 if the event has been serviced, 0 otherwise.
//
// Side effects:
//	Evaluates the event's callback script, so has whatever side effects
//	the callback has.  The return value of the callback script becomes the
//	return value of this function.  If the callback script reports an
//	error, it is reported as a background error.
//
//----------------------------------------------------------------------

func TesteventProc(tls *libc.TLS, event uintptr, flags int32) int32 { /* tclTest.c:2278:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var ev uintptr = event
	var interp uintptr = (*TestEvent)(unsafe.Pointer(ev)).interp
	var command uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
	var result int32 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjEx})).f(tls, interp, command,
		(TCL_EVAL_GLOBAL | TCL_EVAL_DIRECT))
	// var retval int32 at bp, 4

	if result != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp,
			ts+3368 /* "    (command bou..." */)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_BackgroundError})).f(tls, interp)
		return 1 // Avoid looping on errors
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		bp /* &retval */) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp,
			ts+3412 /* "    (return valu..." */)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_BackgroundError})).f(tls, interp)
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp /* retval */)) != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).tag
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* retval */))
}

//----------------------------------------------------------------------
//
// TesteventDeleteProc --
//
//	Removes some set of events from the queue.
//
// This procedure is used as part of testing event queue management.
//
// Results:
//	Returns 1 if a given event should be deleted, 0 otherwise.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesteventDeleteProc(tls *libc.TLS, event uintptr, clientData ClientData) int32 { /* tclTest.c:2329:1: */
	var ev uintptr // Event to examine
	var evNameStr uintptr
	var targetName uintptr // Name of the event(s) to delete
	var targetNameStr uintptr

	if (*Tcl_Event)(unsafe.Pointer(event)).proc != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{TesteventProc})) {
		return 0
	}
	targetName = clientData
	targetNameStr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, targetName)
	ev = event
	evNameStr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, (*TestEvent)(unsafe.Pointer(ev)).tag)
	if libc.Xstrcmp(tls, evNameStr, targetNameStr) == 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).tag
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return 1
	} else {
		return 0
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestexithandlerCmd --
//
//	This procedure implements the "testexithandler" command. It is
//	used to test Tcl_CreateExitHandler and Tcl_DeleteExitHandler.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexithandlerCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2373:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var value int32 at bp+64, 4

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3457 /* " create|delete v..." */, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+64 /* &value */) != TCL_OK {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateExitHandler})).f(tls, func() uintptr {
			if (*(*int32)(unsafe.Pointer(bp + 64 /* value */)) & 1) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcEven}))
		}(),
			uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp + 64 /* value */)))))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteExitHandler})).f(tls, func() uintptr {
			if (*(*int32)(unsafe.Pointer(bp + 64 /* value */)) & 1) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcEven}))
		}(),
			uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp + 64 /* value */)))))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+3479 /* "\": must be creat..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func ExitProcOdd(tls *libc.TLS, clientData ClientData) { /* tclTest.c:2404:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	libc.Xsprintf(tls, bp+8 /* &buf[0] */, ts+3507 /* "odd %d\n" */, libc.VaList(bp, int32(clientData)))
	len = int32(libc.Xstrlen(tls, bp+8 /* &buf[0] */))
	if len != int32(libc.Xwrite(tls, 1, bp+8 /* &buf[0] */, uint64(len))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+3515 /* "ExitProcOdd: una..." */, 0)
	}
}

func ExitProcEven(tls *libc.TLS, clientData ClientData) { /* tclTest.c:2418:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	libc.Xsprintf(tls, bp+8 /* &buf[0] */, ts+3554 /* "even %d\n" */, libc.VaList(bp, int32(clientData)))
	len = int32(libc.Xstrlen(tls, bp+8 /* &buf[0] */))
	if len != int32(libc.Xwrite(tls, 1, bp+8 /* &buf[0] */, uint64(len))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+3563 /* "ExitProcEven: un..." */, 0)
	}
}

//----------------------------------------------------------------------
//
// TestexprlongCmd --
//
//	This procedure verifies that Tcl_ExprLong does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2449:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	// var exprResult int64 at bp+56, 8

	// var buf [28]int8 at bp+64, 28

	var result int32

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3603 /* " expression\"" */, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3616 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprLong})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+56 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xsprintf(tls, bp+64 /* &buf[0] */, ts+3633 /* ": %ld" */, libc.VaList(bp+32, *(*int64)(unsafe.Pointer(bp + 56 /* exprResult */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+40, bp+64 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprlongobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2492:1: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	// var exprResult int64 at bp+24, 8

	// var buf [28]int8 at bp+32, 28

	var result int32

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3639 /* "expression" */)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3616 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprLongObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+24 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xsprintf(tls, bp+32 /* &buf[0] */, ts+3633 /* ": %ld" */, libc.VaList(bp, *(*int64)(unsafe.Pointer(bp + 24 /* exprResult */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, bp+32 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprdoubleCmd --
//
//	This procedure verifies that Tcl_ExprDouble does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2534:1: */
	bp := tls.Alloc(87)
	defer tls.Free(87)

	// var exprResult float64 at bp+48, 8

	// var buf [31]int8 at bp+56, 31

	var result int32

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3603 /* " expression\"" */, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3616 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xstrcpy(tls, bp+56 /* &buf[0] */, ts+3650 /* ": " */)
	(*struct {
		f func(*libc.TLS, uintptr, float64, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, interp, *(*float64)(unsafe.Pointer(bp + 48 /* exprResult */)), (bp + 56 /* &buf[0] */ + uintptr(2)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, bp+56 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprdoubleobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2578:1: */
	bp := tls.Alloc(55)
	defer tls.Free(55)

	// var exprResult float64 at bp+16, 8

	// var buf [31]int8 at bp+24, 31

	var result int32

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3639 /* "expression" */)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3616 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprDoubleObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xstrcpy(tls, bp+24 /* &buf[0] */, ts+3650 /* ": " */)
	(*struct {
		f func(*libc.TLS, uintptr, float64, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, interp, *(*float64)(unsafe.Pointer(bp + 16 /* exprResult */)), (bp + 24 /* &buf[0] */ + uintptr(2)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, bp+24 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprstringCmd --
//
//	This procedure tests the basic operation of Tcl_ExprString.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprstringCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2620:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3603 /* " expression\"" */, uintptr(0)))
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprString})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
}

//----------------------------------------------------------------------
//
// TestfilelinkCmd --
//
//	This procedure implements the "testfilelink" command.  It is used to
//	test the effects of creating and manipulating filesystem links in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	May create a link on disk.
//
//----------------------------------------------------------------------

func TestfilelinkCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2652:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var contents uintptr

	if (objc < 2) || (objc > 3) {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3653 /* "source ?target?" */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSConvertToPathType})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8))) != TCL_OK {
		return TCL_ERROR
	}

	if objc == 3 {
		// Create link from source to target
		contents = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), *(*uintptr)(unsafe.Pointer(objv + 2*8)),
			(TCL_CREATE_SYMBOLIC_LINK | TCL_CREATE_HARD_LINK))
		if contents == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3669, /* "could not create..." */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+3698, /* "\" to \"" */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), ts+3705, /* "\": " */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
			return TCL_ERROR
		}
	} else {
		// Read link
		contents = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0), 0)
		if contents == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+3709, /* "could not read l..." */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+3705, /* "\": " */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
			return TCL_ERROR
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, contents)
	if objc == 2 {
		// If we are creating a link, this will actually just
		// be objv[3], and we don't own it
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = contents
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetassocdataCmd --
//
//	This procedure implements the "testgetassocdata" command. It is
//	used to test Tcl_GetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2719:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+2236 /* " data_key\"" */, uintptr(0)))
		return TCL_ERROR
	}
	res = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if res != (uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, res, uintptr(0)))
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetplatformCmd --
//
//	This procedure implements the "testgetplatform" command. It is
//	used to retrievel the value of the tclPlatform global variable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetplatformCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2757:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var platform uintptr

	platform = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetPlatform})).f(tls)

	if argc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			uintptr(0)))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, platformStrings[*(*TclPlatformType)(unsafe.Pointer(platform))], uintptr(0)))
	return TCL_OK
}

var platformStrings = [3]uintptr{ts + 3731 /* "unix" */, ts + 3736 /* "mac" */, ts + 3740 /* "windows" */} /* tclTest.c:2763:23 */

//----------------------------------------------------------------------
//
// TestinterpdeleteCmd --
//
//	This procedure tests the code in tclInterp.c that deals with
//	interpreter deletion. It deletes a user-specified interpreter
//	from the hierarchy, and subsequent code checks integrity.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes one or more interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestinterpdeleteCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2798:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var slaveToDelete uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3748 /* " path\"" */, uintptr(0)))
		return TCL_ERROR
	}
	slaveToDelete = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if slaveToDelete == (uintptr(0)) {
		return TCL_ERROR
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, slaveToDelete)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestlinkCmd --
//
//	This procedure implements the "testlink" command.  It is used
//	to test Tcl_LinkVar and related library procedures.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various variable links, plus returns
//	values of the linked variables.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestlinkCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2839:1: */
	bp := tls.Alloc(312)
	defer tls.Free(312)

	// var buffer [54]int8 at bp+212, 54

	// var writable int32 at bp+208, 4

	var flag int32
	var tmp uintptr

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),

			ts+3755 /* " option ?arg arg..." */, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1319, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1387 /* " " */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+3822 /* " intRO realRO bo..." */, uintptr(0)))
			return TCL_ERROR
		}
		if created != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3930 /* "int" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3934 /* "real" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3939 /* "bool" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3944 /* "string" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3951 /* "wide" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3956 /* "char" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3961 /* "uchar" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+2399 /* "short" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3967 /* "ushort" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3974 /* "uint" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3979 /* "long" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3984 /* "ulong" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3990 /* "float" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3996 /* "uwide" */)
		}
		created = 1
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3930 /* "int" */, uintptr(unsafe.Pointer(&intVar)),
			(TCL_LINK_INT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3934 /* "real" */, uintptr(unsafe.Pointer(&realVar)),
			(TCL_LINK_DOUBLE|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3939 /* "bool" */, uintptr(unsafe.Pointer(&boolVar)),
			(TCL_LINK_BOOLEAN|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 5*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3944 /* "string" */, uintptr(unsafe.Pointer(&stringVar)),
			(TCL_LINK_STRING|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 6*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3951 /* "wide" */, uintptr(unsafe.Pointer(&wideVar)),
			(TCL_LINK_WIDE_INT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3956 /* "char" */, uintptr(unsafe.Pointer(&charVar)),
			(TCL_LINK_CHAR|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3961 /* "uchar" */, uintptr(unsafe.Pointer(&ucharVar)),
			(TCL_LINK_UCHAR|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+2399 /* "short" */, uintptr(unsafe.Pointer(&shortVar)),
			(TCL_LINK_SHORT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3967 /* "ushort" */, uintptr(unsafe.Pointer(&ushortVar)),
			(TCL_LINK_USHORT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3974 /* "uint" */, uintptr(unsafe.Pointer(&uintVar)),
			(TCL_LINK_UINT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3979 /* "long" */, uintptr(unsafe.Pointer(&longVar)),
			(TCL_LINK_LONG|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3984 /* "ulong" */, uintptr(unsafe.Pointer(&ulongVar)),
			(TCL_LINK_ULONG|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3990 /* "float" */, uintptr(unsafe.Pointer(&floatVar)),
			(TCL_LINK_FLOAT|flag)) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 15*8)), bp+208 /* &writable */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3996 /* "uwide" */, uintptr(unsafe.Pointer(&uwideVar)),
			(TCL_LINK_WIDE_UINT|flag)) != TCL_OK {
			return TCL_ERROR
		}

	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3930 /* "int" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3934 /* "real" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3939 /* "bool" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3944 /* "string" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3951 /* "wide" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3956 /* "char" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3961 /* "uchar" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+2399 /* "short" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3967 /* "ushort" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3974 /* "uint" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3979 /* "long" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3984 /* "ulong" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3990 /* "float" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3996 /* "uwide" */)
		created = 0
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1371 /* "get" */) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(intVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, float64, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, uintptr(0), realVar, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(boolVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
			if stringVar == (uintptr(0)) {
				return ts + 2331 /* "-" */
			}
			return stringVar
		}())
		// Wide ints only have an object-based interface.
		tmp = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, wideVar)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(charVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(ucharVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(shortVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(ushortVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(uintVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		tmp = (*struct {
			f func(*libc.TLS, int64) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, longVar)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		tmp = (*struct {
			f func(*libc.TLS, int64) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(ulongVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct {
			f func(*libc.TLS, uintptr, float64, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, uintptr(0), float64(floatVar), bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		tmp = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt(uwideVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4002 /* "set" */) == 0 {
		// var v int32 at bp+268, 4

		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1319, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1387 /* " " */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+4006 /* " intValue realVa..." */, uintptr(0)))
			return TCL_ERROR
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 2*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(unsafe.Pointer(&intVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(unsafe.Pointer(&realVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 4*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(unsafe.Pointer(&boolVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 5*8))))) != 0 {
			if stringVar != (uintptr(0)) {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, stringVar)
			}
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+2331 /* "-" */) == 0 {
				stringVar = uintptr(0)
			} else {
				stringVar = (*struct {
					f func(*libc.TLS, uint32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8))) + uint64(1))))
				libc.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 6*8))))) != 0 {
			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 6*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != TCL_OK {
				for ok4 := true; ok4; ok4 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok5 := true; ok5; ok5 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 7*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 8*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 9*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 10*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 11*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 12*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 13*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+268 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 14*8)))) != 0 {
			// var d float64 at bp+272, 8

			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+272 /* &d */) != TCL_OK {
				return TCL_ERROR
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 272 /* d */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 15*8)))) != 0 {
			// var w Tcl_WideInt at bp+280, 8

			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 15*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, bp+280 /* &w */) != TCL_OK {
				for ok6 := true; ok6; ok6 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok7 := true; ok7; ok7 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 280 /* w */)))
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4156 /* "update" */) == 0 {
		// var v int32 at bp+288, 4

		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+1319, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1387 /* " " */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+4006 /* " intValue realVa..." */, uintptr(0)))
			return TCL_ERROR
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 2*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(unsafe.Pointer(&intVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3930 /* "int" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(unsafe.Pointer(&realVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3934 /* "real" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 4*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(unsafe.Pointer(&boolVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3939 /* "bool" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 5*8))))) != 0 {
			if stringVar != (uintptr(0)) {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, stringVar)
			}
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+2331 /* "-" */) == 0 {
				stringVar = uintptr(0)
			} else {
				stringVar = (*struct {
					f func(*libc.TLS, uint32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8))) + uint64(1))))
				libc.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3944 /* "string" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 6*8))))) != 0 {
			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 6*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != TCL_OK {
				for ok8 := true; ok8; ok8 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok9 := true; ok9; ok9 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3951 /* "wide" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 7*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3956 /* "char" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 8*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3961 /* "uchar" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 9*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+2399 /* "short" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 10*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3967 /* "ushort" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 11*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3974 /* "uint" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 12*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3979 /* "long" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 13*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+288 /* &v */) != TCL_OK {
				return TCL_ERROR
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3984 /* "ulong" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 14*8)))) != 0 {
			// var d float64 at bp+296, 8

			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+296 /* &d */) != TCL_OK {
				return TCL_ERROR
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 296 /* d */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3990 /* "float" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 15*8)))) != 0 {
			// var w Tcl_WideInt at bp+304, 8

			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 15*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, bp+304 /* &w */) != TCL_OK {
				for ok10 := true; ok10; ok10 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 304 /* w */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3996 /* "uwide" */)
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+176, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+4163 /* "\": should be cre..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var intVar int32 = 43                                /* tclTest.c:2845:16 */
var boolVar int32 = 4                                /* tclTest.c:2846:16 */
var realVar float64 = 1.23                           /* tclTest.c:2847:19 */
var wideVar Tcl_WideInt = int64(79)                  /* tclTest.c:2848:24 */
var stringVar uintptr = uintptr(0)                   /* tclTest.c:2849:17 */
var charVar int8 = int8('@')                         /* tclTest.c:2850:17 */
var ucharVar uint8 = uint8(130)                      /* tclTest.c:2851:26 */
var shortVar int16 = int16(3000)                     /* tclTest.c:2852:18 */
var ushortVar uint16 = uint16(60000)                 /* tclTest.c:2853:27 */
var uintVar uint32 = 0xbeeffeed                      /* tclTest.c:2854:25 */
var longVar int64 = 123456789                        /* tclTest.c:2855:17 */
var ulongVar uint64 = 3456789012                     /* tclTest.c:2856:26 */
var floatVar float32 = 4.5                           /* tclTest.c:2857:18 */
var uwideVar Tcl_WideUInt = Tcl_WideUInt(int64(123)) /* tclTest.c:2858:25 */
var created int32 = 0                                /* tclTest.c:2859:16 */

//----------------------------------------------------------------------
//
// TestlocaleCmd --
//
//	This procedure implements the "testlocale" command.  It is used
//	to test the effects of setting different locales in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies the current C locale.
//
//----------------------------------------------------------------------

func TestlocaleCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3307:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	var locale uintptr

	// LC_CTYPE, etc. correspond to the indices for the strings.

	if (objc < 2) || (objc > 3) {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4212 /* "category ?locale..." */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings1)), int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp /* &index */) != TCL_OK {
		return TCL_ERROR
	}

	if objc == 3 {
		locale = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		locale = uintptr(0)
	}
	locale = libc.Xsetlocale(tls, lcTypes[*(*int32)(unsafe.Pointer(bp /* index */))], locale)
	if locale != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), locale, -1)
	}
	return TCL_OK
}

var optionStrings1 = [7]uintptr{
	ts + 4230 /* "ctype" */, ts + 4236 /* "numeric" */, ts + 4244 /* "time" */, ts + 4249 /* "collate" */, ts + 4257, /* "monetary" */
	ts + 4266 /* "all" */, uintptr(0),
} /* tclTest.c:3316:23 */
var lcTypes = [6]int32{
	0, 1, 2, 3, 4,
	6,
} /* tclTest.c:3320:22 */

//----------------------------------------------------------------------
//
// TestMathFunc --
//
//	This is a user-defined math procedure to test out math procedures
//	with no arguments.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestMathFunc(tls *libc.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3370:1: */
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_INT
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = int64(int32(clientData))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestMathFunc2 --
//
//	This is a user-defined math procedure to test out math procedures
//	that do have arguments, in this case 2.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestMathFunc2(tls *libc.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3400:1: */
	var result int32 = TCL_OK

	// Return the maximum of the two arguments with the correct type.

	if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_INT {
		var i0 int32 = int32((*Tcl_Value)(unsafe.Pointer(args)).intValue)

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var i1 int32 = int32((*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = func() int64 {
				if i0 > i1 {
					return int64(i0)
				}
				return int64(i1)
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d0 float64 = float64(i0)
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var w0 Tcl_WideInt = int64(i0)
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4270 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_DOUBLE {
		var d0 float64 = (*Tcl_Value)(unsafe.Pointer(args)).doubleValue

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var d1 float64 = float64((*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var d1 float64 = float64((*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4270 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_WIDE_INT {
		var w0 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args)).wideValue

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d0 float64 = float64(w0)
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4270 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4295 /* "T3: wrong type f..." */, uintptr(0))
		result = TCL_ERROR
	}
	return result
}

//----------------------------------------------------------------------
//
// CleanupTestSetassocdataTests --
//
//	This function is called when an interpreter is deleted to clean
//	up any data left over from running the testsetassocdata command.
//
// Results:
//	None.
//
// Side effects:
//	Releases storage.
//
//----------------------------------------------------------------------
// ARGSUSED
func CleanupTestSetassocdataTests(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:3507:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, clientData)
}

//----------------------------------------------------------------------
//
// TestparserObjCmd --
//
//	This procedure implements the "testparser" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparserObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3532:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4320 /* "script length" */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseCommand})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), 0, bp+8 /* &parse */) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4334 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4363 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8 /* &parse */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+8 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprparserObjCmd --
//
//	This procedure implements the "testexprparser" command.  It is
//	used for testing the new Tcl expression parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprparserObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3588:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4366 /* "expr length" */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentStart = uintptr(0)
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandStart = uintptr(0)
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandSize = 0
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseExpr})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), bp+8 /* &parse */) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4378 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4363 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8 /* &parse */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+8 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// PrintParse --
//
//	This procedure prints out the contents of a Tcl_Parse structure
//	in the result of an interpreter.
//
// Results:
//	Interp's result is set to a prettily formatted version of the
//	contents of parsePtr.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func PrintParse(tls *libc.TLS, interp uintptr, parsePtr uintptr) { /* tclTest.c:3649:1: */
	var objPtr uintptr
	var typeString uintptr
	var tokenPtr uintptr
	var i int32

	objPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
	if (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize > 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentStart,
				(*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+2331 /* "-" */, 1))
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numWords))
	for i = 0; i < (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numTokens; i++ {
		tokenPtr = ((*Tcl_Parse)(unsafe.Pointer(parsePtr)).tokenPtr + uintptr(i)*24)
		switch (*Tcl_Token)(unsafe.Pointer(tokenPtr)).__type {
		case TCL_TOKEN_EXPAND_WORD:
			typeString = ts + 4405 /* "expand" */
			break
		case TCL_TOKEN_WORD:
			typeString = ts + 4412 /* "word" */
			break
		case TCL_TOKEN_SIMPLE_WORD:
			typeString = ts + 44 /* "simple" */
			break
		case TCL_TOKEN_TEXT:
			typeString = ts + 4417 /* "text" */
			break
		case TCL_TOKEN_BS:
			typeString = ts + 4422 /* "backslash" */
			break
		case TCL_TOKEN_COMMAND:
			typeString = ts + 4432 /* "command" */
			break
		case TCL_TOKEN_VARIABLE:
			typeString = ts + 4440 /* "variable" */
			break
		case TCL_TOKEN_SUB_EXPR:
			typeString = ts + 4449 /* "subexpr" */
			break
		case TCL_TOKEN_OPERATOR:
			typeString = ts + 4457 /* "operator" */
			break
		default:
			typeString = ts + 1375 /* "??" */
			break
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, typeString, -1))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).start, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).size))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).numComponents))
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ((*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart+uintptr((*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize)),
			-1))
}

//----------------------------------------------------------------------
//
// TestparsevarObjCmd --
//
//	This procedure implements the "testparsevar" command.  It is
//	used for testing Tcl_ParseVar.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3735:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var value uintptr
	var name uintptr
	// var termPtr uintptr at bp, 8

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4466 /* "varName" */)
		return TCL_ERROR
	}
	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	value = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseVar})).f(tls, interp, name, bp /* &termPtr */)
	if value == (uintptr(0)) {
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp /* termPtr */)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestparsevarnameObjCmd --
//
//	This procedure implements the "testparsevarname" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarnameObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3776:1: */
	bp := tls.Alloc(592)
	defer tls.Free(592)

	var script uintptr
	// var append int32 at bp+8, 4

	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+16, 576

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4474 /* "script length ap..." */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8 /* &append */) != 0 {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseVarName})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), bp+16 /* &parse */, *(*int32)(unsafe.Pointer(bp + 8 /* append */))) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4334 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+16 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4363 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandStart = (script + uintptr((*Tcl_Token)(unsafe.Pointer((*Tcl_Parse)(unsafe.Pointer(bp+16 /* &parse */)).tokenPtr)).size))
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandSize = 0
	PrintParse(tls, interp, bp+16 /* &parse */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+16 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestregexpObjCmd --
//
//	This procedure implements the "testregexp" command. It is used to give
//	a direct interface for regexp flags. It's identical to
//	Tcl_RegexpObjCmd except for the -xflags option, and the consequences
//	thereof (including the REG_EXPECT kludge).
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestregexpObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3841:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	var i int32
	var ii int32
	var indices int32
	// var stringLength int32 at bp+92, 4

	var match int32
	var about int32
	var hasxflags int32
	// var cflags int32 at bp+96, 4

	// var eflags int32 at bp+100, 4

	var regExpr Tcl_RegExp
	var string uintptr
	var objPtr uintptr
	// var info Tcl_RegExpInfo at bp+160, 32

	var name uintptr
	// var index int32 at bp+88, 4

	var varName uintptr
	var value uintptr
	// var start int32 at bp+104, 4

	// var end int32 at bp+108, 4

	// var resinfo [48]int8 at bp+112, 48

	var varName1 uintptr
	var value1 uintptr
	// var resinfo1 [48]int8 at bp+192, 48

	// var objs [2]uintptr at bp+248, 16

	// var start1 int32 at bp+240, 4

	// var end1 int32 at bp+244, 4

	var newPtr uintptr
	var varPtr uintptr
	var valuePtr uintptr

	indices = 0
	about = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) = REG_ADVANCED
	*(*int32)(unsafe.Pointer(bp + 100 /* eflags */)) = 0
	hasxflags = 0

	i = 1
__1:
	if !(i < objc) {
		goto __3
	}

	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	if !(int32(*(*int8)(unsafe.Pointer(name))) != '-') {
		goto __4
	}
	goto __3
__4:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), uintptr(unsafe.Pointer(&options1)), int32(unsafe.Sizeof(uintptr(0))), ts+4495 /* "switch" */, TCL_EXACT, bp+88 /* &index */) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 88 /* index */))) {
	case uint32(0) /* REGEXP_INDICES */ :
		goto __7
	case uint32(1) /* REGEXP_NOCASE */ :
		goto __8
	case uint32(2) /* REGEXP_ABOUT */ :
		goto __9
	case uint32(3) /* REGEXP_EXPANDED */ :
		goto __10
	case uint32(4) /* REGEXP_MULTI */ :
		goto __11
	case uint32(5) /* REGEXP_NOCROSS */ :
		goto __12
	case uint32(6) /* REGEXP_NEWL */ :
		goto __13
	case uint32(7) /* REGEXP_XFLAGS */ :
		goto __14
	case uint32(8) /* REGEXP_LAST */ :
		goto __15
	}
	goto __6
__7:
	indices = 1
	goto __6
__8:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_ICASE
	goto __6
__9:
	about = 1
	goto __6
__10:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_EXPANDED
	goto __6
__11:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NEWLINE
	goto __6
__12:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NLSTOP
	goto __6
__13:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NLANCH
	goto __6
__14:
	hasxflags = 1
	goto __6
__15:
	i++
	goto endOfForLoop
__6:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;

endOfForLoop:
	if !((objc - i) < ((hasxflags + 2) - about)) {
		goto __16
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv,
		ts+4502 /* "?-switch ...? ex..." */)
	return TCL_ERROR
__16:
	;
	objc = objc - (i)
	objv += 8 * uintptr(i)

	if !(hasxflags != 0) {
		goto __17
	}
	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv)), bp+92 /* &stringLength */)
	TestregexpXflags(tls, string, *(*int32)(unsafe.Pointer(bp + 92 /* stringLength */)), bp+96 /* &cflags */, bp+100 /* &eflags */)
	objc--
	objv += 8
__17:
	;

	regExpr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) Tcl_RegExp
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRegExpFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv)), *(*int32)(unsafe.Pointer(bp + 96 /* cflags */)))
	if !(regExpr == (uintptr(0))) {
		goto __18
	}
	return TCL_ERROR
__18:
	;

	if !(about != 0) {
		goto __19
	}
	if !((*struct {
		f func(*libc.TLS, uintptr, Tcl_RegExp) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegAbout})).f(tls, interp, regExpr) < 0) {
		goto __20
	}
	return TCL_ERROR
__20:
	;
	return TCL_OK
__19:
	;

	objPtr = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	match = (*struct {
		f func(*libc.TLS, uintptr, Tcl_RegExp, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpExecObj})).f(tls, interp, regExpr, objPtr, 0,
		(objc - 2), *(*int32)(unsafe.Pointer(bp + 100 /* eflags */)))

	if !(match < 0) {
		goto __21
	}
	return TCL_ERROR
__21:
	;
	if !(match == 0) {
		goto __22
	}
	// Set the interpreter's object result to an integer object w/
	// value 0.

	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), 0)
	if !(((objc > 2) && ((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & REG_EXPECT) != 0)) && (indices != 0)) {
		goto __23
	}

	varName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, -1, bp+104 /* &start */, bp+108 /* &end */)
	libc.Xsprintf(tls, bp+112 /* &resinfo[0] */, ts+4556 /* "%d %d" */, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 104 /* start */)), (*(*int32)(unsafe.Pointer(bp + 108 /* end */))-1)))
	value = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, varName, uintptr(0), bp+112 /* &resinfo[0] */, 0)
	if !(value == (uintptr(0))) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+4562, /* "couldn't set var..." */
		varName, ts+1640 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__25:
	;
	goto __24
__23:
	if !((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & TCL_REG_CANMATCH) != 0) {
		goto __26
	}

	(*struct {
		f func(*libc.TLS, Tcl_RegExp, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpGetInfo})).f(tls, regExpr, bp+160 /* &info */)
	varName1 = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	libc.Xsprintf(tls, bp+192 /* &resinfo1[0] */, ts+4586 /* "%ld" */, libc.VaList(bp+48, (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).extendStart))
	value1 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, varName1, uintptr(0), bp+192 /* &resinfo1[0] */, 0)
	if !(value1 == (uintptr(0))) {
		goto __27
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+4562, /* "couldn't set var..." */
		varName1, ts+1640 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__27:
	;
__26:
	;
__24:
	;
	return TCL_OK
__22:
	;

	// If additional variable names have been specified, return
	// index information in those variables.

	objc = objc - (2)
	objv += 8 * uintptr(2)

	(*struct {
		f func(*libc.TLS, Tcl_RegExp, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpGetInfo})).f(tls, regExpr, bp+160 /* &info */)
	i = 0
__28:
	if !(i < objc) {
		goto __30
	}

	varPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
	if ((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & REG_EXPECT) != 0) && (i == (objc - 1)) {
		ii = -1
	} else {
		ii = i
	}
	if !(indices != 0) {
		goto __31
	}

	if !(ii == -1) {
		goto __33
	}
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	goto __34
__33:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).nsubs) {
		goto __35
	}
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = -1
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = -1
	goto __36
__35:
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).start)
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).end)
__36:
	;
__34:
	;

	// Adjust index so it refers to the last character in the match
	// instead of the first character after the match.

	if !(*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) >= 0) {
		goto __37
	}
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))--
__37:
	;

	*(*uintptr)(unsafe.Pointer(bp + 248 /* &objs[0] */)) = (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 240 /* start1 */))))
	*(*uintptr)(unsafe.Pointer(bp + 248 /* &objs[0] */ + 1*8)) = (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))))

	newPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 2, bp+248 /* &objs[0] */)
	goto __32
__31:
	if !(ii == -1) {
		goto __38
	}
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	newPtr = (*struct {
		f func(*libc.TLS, uintptr, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRange})).f(tls, objPtr, *(*int32)(unsafe.Pointer(bp + 240 /* start1 */)), *(*int32)(unsafe.Pointer(bp + 244 /* end1 */)))
	goto __39
__38:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).nsubs) {
		goto __40
	}
	newPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	goto __41
__40:
	newPtr = (*struct {
		f func(*libc.TLS, uintptr, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRange})).f(tls, objPtr, int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches+uintptr(ii)*16)).start),
		(int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches+uintptr(ii)*16)).end - int64(1))))
__41:
	;
__39:
	;
__32:
	;
	valuePtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ObjSetVar2})).f(tls, interp, varPtr, uintptr(0), newPtr, TCL_LEAVE_ERR_MSG)
	if !(valuePtr == (uintptr(0))) {
		goto __42
	}
	return TCL_ERROR
__42:
	;
	goto __29
__29:
	i++
	goto __28
	goto __30
__30:
	;

	// Set the interpreter's object result to an integer object w/ value 1.

	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), 1)
	return TCL_OK
}

var options1 = [10]uintptr{
	ts + 4590 /* "-indices" */, ts + 4599 /* "-nocase" */, ts + 4607 /* "-about" */, ts + 4614, /* "-expanded" */
	ts + 4624 /* "-line" */, ts + 4630 /* "-linestop" */, ts + 4640, /* "-lineanchor" */
	ts + 4652, /* "-xflags" */
	ts + 4660 /* "--" */, uintptr(0),
} /* tclTest.c:3853:23 */

//---------------------------------------------------------------------------
//
// TestregexpXflags --
//
//	Parse a string of extended regexp flag letters, for testing.
//
// Results:
//	No return value (you're on your own for errors here).
//
// Side effects:
//	Modifies *cflagsPtr, a regcomp flags word, and *eflagsPtr, a
//	regexec flags word, as appropriate.
//
//----------------------------------------------------------------------

func TestregexpXflags(tls *libc.TLS, string uintptr, length int32, cflagsPtr uintptr, eflagsPtr uintptr) { /* tclTest.c:4074:1: */
	var i int32
	var cflags int32
	var eflags int32

	cflags = *(*int32)(unsafe.Pointer(cflagsPtr))
	eflags = *(*int32)(unsafe.Pointer(eflagsPtr))
	for i = 0; i < length; i++ {
		switch int32(*(*int8)(unsafe.Pointer(string + uintptr(i)))) {
		case 'a':
			cflags = cflags | (REG_ADVF)
			break
		case 'b':
			cflags = cflags & (libc.CplInt32(REG_ADVANCED))
			break
		case 'c':
			cflags = cflags | (TCL_REG_CANMATCH)
			break
		case 'e':
			cflags = cflags & (libc.CplInt32(REG_ADVANCED))
			cflags = cflags | (REG_EXTENDED)
			break
		case 'q':
			cflags = cflags & (libc.CplInt32(REG_ADVANCED))
			cflags = cflags | (REG_QUOTE)
			break
		case 'o': // o for opaque
			cflags = cflags | (REG_NOSUB)
			break
		case 's': // s for start
			cflags = cflags | (REG_BOSONLY)
			break
		case '+':
			cflags = cflags | (REG_FAKE)
			break
		case ',':
			cflags = cflags | (REG_PROGRESS)
			break
		case '.':
			cflags = cflags | (REG_DUMP)
			break
		case ':':
			eflags = eflags | (REG_MTRACE)
			break
		case ';':
			eflags = eflags | (REG_FTRACE)
			break
		case '^':
			eflags = eflags | (REG_NOTBOL)
			break
		case '$':
			eflags = eflags | (REG_NOTEOL)
			break
		case 't':
			cflags = cflags | (REG_EXPECT)
			break
		case '%':
			eflags = eflags | (REG_SMALL)
			break
		}
	}

	*(*int32)(unsafe.Pointer(cflagsPtr)) = cflags
	*(*int32)(unsafe.Pointer(eflagsPtr)) = eflags
}

//----------------------------------------------------------------------
//
// TestreturnObjCmd --
//
//	This procedure implements the "testreturn" command. It is
//	used to verify that a
//		return TCL_RETURN;
//	has same behavior as
//		return Tcl_SetReturnOptions(interp, Tcl_NewObj());
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestreturnObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4165:1: */
	return TCL_RETURN
}

//----------------------------------------------------------------------
//
// TestsetassocdataCmd --
//
//	This procedure implements the "testsetassocdata" command. It is used
//	to test Tcl_SetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies or creates an association between a key and associated
//	data for this interpreter.
//
//----------------------------------------------------------------------

func TestsetassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4193:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var buf uintptr
	var oldData uintptr
	// var procPtr uintptr at bp+32, 8

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4663 /* " data_key data_i..." */, uintptr(0)))
		return TCL_ERROR
	}

	buf = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))) + uint64(1))))
	libc.Xstrcpy(tls, buf, *(*uintptr)(unsafe.Pointer(argv + 2*8)))

	// If we previously associated a malloced value with the variable,
	// free it before associating a new value.

	oldData = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32 /* &procPtr */)
	if (oldData != (uintptr(0))) && (*(*uintptr)(unsafe.Pointer(bp + 32 /* procPtr */)) == *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests}))) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, oldData)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests})),
		buf)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetplatformCmd --
//
//	This procedure implements the "testsetplatform" command. It is
//	used to change the tclPlatform global variable so all file
//	name conversions can be tested on a single platform.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Sets the tclPlatform global variable.
//
//----------------------------------------------------------------------

func TestsetplatformCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4245:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var length size_t
	var platform uintptr

	platform = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetPlatform})).f(tls)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4684 /* " platform\"" */, uintptr(0)))
		return TCL_ERROR
	}

	length = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3731 /* "unix" */, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TCL_PLATFORM_UNIX
	} else if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3740 /* "windows" */, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TCL_PLATFORM_WINDOWS
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+32, ts+4695 /* "unsupported plat..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TeststaticpkgCmd --
//
//	This procedure implements the "teststaticpkg" command.
//	It is used to test the procedure Tcl_StaticPackage.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	When the packge given by argv[1] is loaded into an interpeter,
//	variable "x" in that interpreter is set to "loaded".
//
//----------------------------------------------------------------------

func TeststaticpkgCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4294:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var safe int32 at bp+32, 4

	// var loaded int32 at bp+36, 4

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+4751 /* " pkgName safe lo..." */, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32 /* &safe */) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+36 /* &loaded */) != TCL_OK {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_StaticPackage})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 36 /* loaded */)) != 0 {
			return interp
		}
		return uintptr(0)
	}(), *(*uintptr)(unsafe.Pointer(argv + 1*8)),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{StaticInitProc})), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 32 /* safe */)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr) int32
				}{StaticInitProc}))
			}
			return uintptr(0)
		}())
	return TCL_OK
}

func StaticInitProc(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:4319:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, ts+4773 /* "x" */, uintptr(0), ts+4775 /* "loaded" */, TCL_GLOBAL_ONLY)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TesttranslatefilenameCmd --
//
//	This procedure implements the "testtranslatefilename" command.
//	It is used to test the Tcl_TranslateFileName command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesttranslatefilenameCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4345:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	// var buffer Tcl_DString at bp+48, 216

	var result uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+3748 /* " path\"" */, uintptr(0)))
		return TCL_ERROR
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_TranslateFileName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48 /* &buffer */)
	if result == (uintptr(0)) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, result, uintptr(0)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+48 /* &buffer */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestupvarCmd --
//
//	This procedure implements the "testupvar" command.  It is used
//	to test Tcl_UpVar and Tcl_UpVar2.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates or modifies an "upvar" reference.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestupvarCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4387:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = 0

	if (argc != 5) && (argc != 6) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+4782 /* " level name ?nam..." */, uintptr(0)))
		return TCL_ERROR
	}

	if argc == 5 {
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+3204 /* "global" */) == 0 {
			flags = TCL_GLOBAL_ONLY
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+4815 /* "namespace" */) == 0 {
			flags = TCL_NAMESPACE_ONLY
		}
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0), *(*uintptr)(unsafe.Pointer(argv + 3*8)), flags)
	} else {
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+3204 /* "global" */) == 0 {
			flags = TCL_GLOBAL_ONLY
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+4815 /* "namespace" */) == 0 {
			flags = TCL_NAMESPACE_ONLY
		}
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)),
			func() uintptr {
				if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) == 0 {
					return uintptr(0)
				}
				return *(*uintptr)(unsafe.Pointer(argv + 3*8))
			}(), *(*uintptr)(unsafe.Pointer(argv + 4*8)),
			flags)
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestseterrorcodeCmd --
//
//	This procedure implements the "testseterrorcodeCmd".  This tests up to
//	five elements passed to the Tcl_SetErrorCode command.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestseterrorcodeCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4440:1: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	if argc > 6 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4825 /* "too many args" */, uintptr(0))
		return TCL_ERROR
	}
	switch argc {
	case 1:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp, ts+4839 /* "NONE" */, uintptr(0)))
		break
	case 2:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0)))
		break
	case 3:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0)))
		break
	case 4:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(0)))
		break
	case 5:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+88, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(0)))
		break
	case 6:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+128, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), *(*uintptr)(unsafe.Pointer(argv + 4*8)),
			*(*uintptr)(unsafe.Pointer(argv + 5*8)), uintptr(0)))
	}
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestsetobjerrorcodeCmd --
//
//	This procedure implements the "testsetobjerrorcodeCmd".
//	This tests the Tcl_SetObjErrorCode function.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsetobjerrorcodeCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4493:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjErrorCode})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, (objc-1), (objv+uintptr(1)*8)))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestfeventCmd --
//
//	This procedure implements the "testfevent" command.  It is
//	used for testing the "fileevent" command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestfeventCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4522:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var code int32
	var chan1 Tcl_Channel

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4844 /* " option ?arg ......" */, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4862 /* "cmd" */) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+4866 /* " cmd script" */, uintptr(0)))
			return TCL_ERROR
		}
		if interp2 != (uintptr(0)) {
			code = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp2, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, TCL_EVAL_GLOBAL)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp2))
			return code
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
				libc.VaList(bp+64, ts+4878, /* "called \"testfeve..." */
					uintptr(0)))
			return TCL_ERROR
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		if interp2 != (uintptr(0)) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp2)
		}
		interp2 = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateInterp})).f(tls)
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Init})).f(tls, interp2)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1212 /* "delete" */) == 0 {
		if interp2 != (uintptr(0)) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp2)
		}
		interp2 = uintptr(0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4930 /* "share" */) == 0 {
		if interp2 != (uintptr(0)) {
			chan1 = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0))
			if chan1 == (uintptr(0)) {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, Tcl_Channel)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, interp2, chan1)
		}
	}

	return TCL_OK
}

var interp2 uintptr = uintptr(0) /* tclTest.c:4528:23 */

//----------------------------------------------------------------------
//
// TestpanicCmd --
//
//	Calls the panic routine.
//
// Results:
//	Always returns TCL_OK.
//
// Side effects:
//	May exit application.
//
//----------------------------------------------------------------------

func TestpanicCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4594:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var argString uintptr

	//  Put the arguments into a var args structure
	//  Append all of the arguments together separated by spaces

	argString = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Merge})).f(tls, (argc - 1), (argv + uintptr(1)*8))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+4936 /* "%s" */, libc.VaList(bp, argString))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, argString)

	return TCL_OK
}

func TestfileCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4615:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var force int32
	var i int32
	var j int32
	var result int32
	// var error uintptr at bp+40, 8

	var subcmd uintptr
	var _objPtr uintptr
	*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)) = uintptr(0)

	if !(argc < 3) {
		goto __1
	}
	return TCL_ERROR
__1:
	;

	force = 0
	i = 2
	if !(libc.Xstrcmp(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))), ts+4939 /* "-force" */) == 0) {
		goto __2
	}
	force = 1
	i = 3
__2:
	;

	if !((argc - i) > 2) {
		goto __3
	}
	return TCL_ERROR
__3:
	;

	j = i
__4:
	if !(j < argc) {
		goto __6
	}
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetNormalizedPath})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(j)*8))) == (uintptr(0))) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;

	subcmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))

	if !(libc.Xstrcmp(tls, subcmd, ts+4946 /* "mv" */) == 0) {
		goto __8
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjRenameFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
	goto __9
__8:
	if !(libc.Xstrcmp(tls, subcmd, ts+4949 /* "cp" */) == 0) {
		goto __10
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCopyFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
	goto __11
__10:
	if !(libc.Xstrcmp(tls, subcmd, ts+4952 /* "rm" */) == 0) {
		goto __12
	}
	result = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjDeleteFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __13
__12:
	if !(libc.Xstrcmp(tls, subcmd, ts+4955 /* "mkdir" */) == 0) {
		goto __14
	}
	result = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCreateDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __15
__14:
	if !(libc.Xstrcmp(tls, subcmd, ts+4961 /* "cpdir" */) == 0) {
		goto __16
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCopyDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)), bp+40 /* &error */)
	goto __17
__16:
	if !(libc.Xstrcmp(tls, subcmd, ts+4967 /* "rmdir" */) == 0) {
		goto __18
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjRemoveDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), force, bp+40 /* &error */)
	goto __19
__18:
	result = TCL_ERROR
	goto end
__19:
	;
__17:
	;
__15:
	;
__13:
	;
__11:
	;
__9:
	;

	if !(result != TCL_OK) {
		goto __20
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)) != (uintptr(0))) {
		goto __21
	}
	if !(int32(*(*int8)(unsafe.Pointer((*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* error */)))))) != 0) {
		goto __22
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* error */))), ts+1387 /* " " */, uintptr(0)))
__22:
	;
__23:
	_objPtr = *(*uintptr)(unsafe.Pointer(bp + 40 /* error */))
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1) {
		goto __26
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
__26:
	;
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
__21:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ErrnoId})).f(tls), uintptr(0)))
__20:
	;

end:
	return result
}

//----------------------------------------------------------------------
//
// TestgetvarfullnameCmd --
//
//	Implements the "testgetvarfullname" cmd that is used when testing
//	the Tcl_GetVariableFullName procedure.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetvarfullnameCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4697:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var name uintptr
	var arg uintptr
	var flags int32 = 0
	var namespacePtr uintptr
	// var framePtr uintptr at bp, 8

	var variable Tcl_Var

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4973 /* "name scope" */)
		return TCL_ERROR
	}

	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))

	arg = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if libc.Xstrcmp(tls, arg, ts+3204 /* "global" */) == 0 {
		flags = TCL_GLOBAL_ONLY
	} else if libc.Xstrcmp(tls, arg, ts+4815 /* "namespace" */) == 0 {
		flags = TCL_NAMESPACE_ONLY
	}

	// This command, like any other created with Tcl_Create[Obj]Command, runs
	// in the global namespace. As a "namespace-aware" command that needs to
	// run in a particular namespace, it must activate that namespace itself.

	if flags == TCL_NAMESPACE_ONLY {
		namespacePtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespace})).f(tls, interp, ts+4984 /* "::test_ns_var" */, uintptr(0),
			TCL_LEAVE_ERR_MSG)
		if namespacePtr == (uintptr(0)) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclPushStackFrame})).f(tls, interp, bp /* &framePtr */, namespacePtr,
			/*isProcCallFrame*/ 0)
	}

	variable = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Var
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespaceVar})).f(tls, interp, name, uintptr(0),
		(flags | TCL_LEAVE_ERR_MSG))

	if flags == TCL_NAMESPACE_ONLY {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclPopStackFrame})).f(tls, interp)
	}
	if variable == (uintptr(0)) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Var, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_GetVariableFullName})).f(tls, interp, variable, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// GetTimesObjCmd --
//
//	This procedure implements the "gettimes" command.  It is used for
//	computing the time needed for various basic operations such as reading
//	variables, allocating memory, sprintf, converting variables, etc.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Allocates and frees memory, sets a variable "a" in the interpreter.
//
//----------------------------------------------------------------------

func GetTimesObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, notused1 int32, notused2 uintptr) int32 { /* tclTest.c:4771:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var iPtr uintptr = interp
	var i int32
	// var n int32 at bp+136, 4

	var timePer float64
	// var start Tcl_Time at bp+104, 16

	// var stop Tcl_Time at bp+120, 16

	var objPtr uintptr
	var objv uintptr
	var s uintptr
	// var newString [24]int8 at bp+140, 24

	// alloc & free 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+4998 /* "alloc & free 100..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		objPtr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(Tcl_Obj{})))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, objPtr)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5032 /* "   %.3f usec per..." */, libc.VaList(bp, (timePer/float64(100000))))

	// alloc 5000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5061 /* "alloc 5000 6 wor..." */, 0)
	objv = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(uint64(5000) * uint64(unsafe.Sizeof(uintptr(0))))))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(Tcl_Obj{})))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5086 /* "   %.3f usec per..." */, libc.VaList(bp+8, (timePer/float64(5000))))

	// free 5000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5110 /* "free 5000 6 word..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5134 /* "   %.3f usec per..." */, libc.VaList(bp+16, (timePer/float64(5000))))

	// Tcl_NewObj 5000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5157 /* "Tcl_NewObj 5000 ..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5180 /* "   %.3f usec per..." */, libc.VaList(bp+24, (timePer/float64(5000))))

	// Tcl_DecrRefCount 5000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5209 /* "Tcl_DecrRefCount..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		objPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = objPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5238 /* "   %.3f usec per..." */, libc.VaList(bp+32, (timePer/float64(5000))))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, objv)

	// TclGetString 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5273 /* "TclGetStringFrom..." */, 0)
	objPtr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+5318 /* "12345" */, -1)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if !((*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes != 0) {
			(*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, objPtr)
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5324, /* "   %.3f usec per..." */
		libc.VaList(bp+40, (timePer/float64(100000))))

	// Tcl_GetIntFromObj 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5373 /* "Tcl_GetIntFromOb..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, objPtr, bp+136 /* &n */) != TCL_OK {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5416, /* "   %.3f usec per..." */
		libc.VaList(bp+48, (timePer/float64(100000))))
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = objPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Tcl_GetInt 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5463 /* "Tcl_GetInt of \"1..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, ts+5318 /* "12345" */, bp+136 /* &n */) != TCL_OK {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5499, /* "   %.3f usec per..." */
		libc.VaList(bp+56, (timePer/float64(100000))))

	// sprintf 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5539 /* "sprintf of 12345..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		libc.Xsprintf(tls, bp+140 /* &newString[0] */, ts+5570 /* "%d" */, libc.VaList(bp+64, 12345))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5573, /* "   %.3f usec per..." */
		libc.VaList(bp+72, (timePer/float64(100000))))

	// hashtable lookup 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5608 /* "hashtable lookup..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer(((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 160 /* &.cmdTable */))).findProc})).f(tls, ((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 160 /* &.cmdTable */), ts+68 /* "gettimes" */)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5653, /* "   %.3f usec per..." */
		libc.VaList(bp+80, (timePer/float64(100000))))

	// Tcl_SetVar 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5702 /* "Tcl_SetVar of \"1..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, ts+5738 /* "a" */, uintptr(0), ts+5318 /* "12345" */, TCL_LEAVE_ERR_MSG)
		if s == (uintptr(0)) {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5740, /* "   %.3f usec per..." */
		libc.VaList(bp+88, (timePer/float64(100000))))

	// Tcl_GetVar 100000 times
	libc.Xfprintf(tls, libc.Xstderr, ts+5785 /* "Tcl_GetVar of a=..." */, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, ts+5738 /* "a" */, uintptr(0), TCL_LEAVE_ERR_MSG)
		if s == (uintptr(0)) {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	libc.Xfprintf(tls, libc.Xstderr, ts+5824, /* "   %.3f usec per..." */
		libc.VaList(bp+96, (timePer/float64(100000))))

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// NoopCmd --
//
//	This procedure is just used to time the overhead involved in
//	parsing and invoking a command.
//
// Results:
//	None.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopCmd(tls *libc.TLS, unused ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4950:1: */
	return TCL_OK
}

//----------------------------------------------------------------------
//
// NoopObjCmd --
//
//	This object-based procedure is just used to time the overhead
//	involved in parsing and invoking a command.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4977:1: */
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestpurebytesobjObjCmd --
//
//	This object-based procedure constructs a pure bytes object
//	without type and with internal representation containing NULL's.
//
//	If no argument supplied it returns empty object with tclEmptyStringRep,
//	otherwise it returns this as pure bytes object with bytes value equal
//	string.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestpurebytesobjObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5008:1: */
	var objPtr uintptr

	if objc > 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5867 /* "?string?" */)
		return TCL_ERROR
	}
	objPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	//
	//     objPtr->internalRep.twoPtrValue.ptr1 = NULL;
	//     objPtr->internalRep.twoPtrValue.ptr2 = NULL;
	//
	libc.Xmemset(tls, (objPtr + 32 /* &.internalRep */), 0, uint64(unsafe.Sizeof(struct {
		longValue int64
		_         [8]byte
	}{})))
	if objc == 2 {
		var s uintptr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).length = (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)))).length
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32((*Tcl_Obj)(unsafe.Pointer(objPtr)).length + 1)))
		libc.Xmemcpy(tls, (*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes, s, uint64((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))
		*(*int8)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes + uintptr((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))) = int8(0)
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, objPtr)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbytestringObjCmd --
//
//	This object-based procedure constructs a string which can
//	possibly contain invalid UTF-8 bytes.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestbytestringObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5055:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var p uintptr

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5876 /* "bytearray" */)
		return TCL_ERROR
	}
	p = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetByteArrayFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &n */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, p, *(*int32)(unsafe.Pointer(bp /* n */))))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetCmd --
//
//	Implements the "testset{err,noerr}" cmds that are used when testing
//	Tcl_Set/GetVar C Api with/without TCL_LEAVE_ERR_MSG flag
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//     Variables may be set.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsetCmd(tls *libc.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5092:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = int32(data)
	var value uintptr

	if argc == 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5886 /* "before get" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0), flags)
		if value == (uintptr(0)) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else if argc == 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5897 /* "before set" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0), *(*uintptr)(unsafe.Pointer(argv + 2*8)), flags)
		if value == (uintptr(0)) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+5908 /* " varName ?newVal..." */, uintptr(0)))
		return TCL_ERROR
	}
	return int32(0)
}

func Testset2Cmd(tls *libc.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5124:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = int32(data)
	var value uintptr

	if argc == 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5886 /* "before get" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), flags)
		if value == (uintptr(0)) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else if argc == 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5897 /* "before set" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), flags)
		if value == (uintptr(0)) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+5929 /* " varName elemNam..." */, uintptr(0)))
		return TCL_ERROR
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestsaveresultCmd --
//
//	Implements the "testsaveresult" cmd that is used when testing the
//	Tcl_SaveResult, Tcl_RestoreResult, and Tcl_DiscardResult interfaces.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsaveresultCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5175:1: */
	bp := tls.Alloc(272)
	defer tls.Free(272)

	var iPtr uintptr = interp
	// var discard int32 at bp+20, 4

	var result int32
	// var index int32 at bp+16, 4

	// var state Tcl_SavedResult at bp+24, 248

	var objPtr uintptr

	// Parse arguments

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5959 /* "type script disc..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings2)), int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp+16 /* &index */) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+20 /* &discard */) != TCL_OK {
		return TCL_ERROR
	}

	objPtr = uintptr(0) // Lint.
	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case uint32(4) /* RESULT_SMALL */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5979 /* "small result" */, uintptr(1))
		break
	case uint32(0) /* RESULT_APPEND */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+5992 /* "append result" */, uintptr(0)))
		break
	case uint32(2) /* RESULT_FREE */ :
		{
			var buf uintptr = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(200))

			libc.Xstrcpy(tls, buf, ts+6006 /* "free result" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, buf, uintptr(3))
			break

		}
	case uint32(1) /* RESULT_DYNAMIC */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+6018 /* "dynamic result" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{TestsaveresultFree})))
		break
	case uint32(3) /* RESULT_OBJECT */ :
		objPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6033 /* "object result" */, -1)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, objPtr)
		break
	}

	freeCount = 0
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SaveResult})).f(tls, interp, bp+24 /* &state */)

	if (int32(uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))))) == 3 /* RESULT_OBJECT */ {
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), 0)
	} else {
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
	}

	if *(*int32)(unsafe.Pointer(bp + 20 /* discard */)) != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DiscardResult})).f(tls, bp+24 /* &state */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RestoreResult})).f(tls, interp, bp+24 /* &state */)
		result = TCL_OK
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case uint32(1) /* RESULT_DYNAMIC */ :
		{
			var present int32 = (libc.Bool32((*Interp)(unsafe.Pointer(iPtr)).freeProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{TestsaveresultFree}))))
			var called int32 = freeCount

			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if called != 0 {
					return ts + 6047 /* "called" */
				}
				return ts + 6054 /* "notCalled" */
			}())
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if present != 0 {
					return ts + 6064 /* "present" */
				}
				return ts + 6072 /* "missing" */
			}())
			break

		}
	case uint32(3) /* RESULT_OBJECT */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
			if (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp) == objPtr {
				return ts + 6080 /* "same" */
			}
			return ts + 6085 /* "different" */
		}())
		break
	default:
		break
	}
	return result
}

var optionStrings2 = [6]uintptr{
	ts + 2355 /* "append" */, ts + 6095 /* "dynamic" */, ts + 2374 /* "free" */, ts + 6103 /* "object" */, ts + 6110 /* "small" */, uintptr(0),
} /* tclTest.c:5185:23 */

//----------------------------------------------------------------------
//
// TestsaveresultFree --
//
//	Special purpose freeProc used by TestsaveresultCmd.
//
// Results:
//	None.
//
// Side effects:
//	Increments the freeCount.
//
//----------------------------------------------------------------------

func TestsaveresultFree(tls *libc.TLS, blockPtr uintptr) { /* tclTest.c:5284:1: */
	freeCount++
}

//----------------------------------------------------------------------
//
// TestmainthreadCmd  --
//
//	Implements the "testmainthread" cmd that is used to test the
//	'Tcl_GetCurrentThread' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestmainthreadCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5308:1: */
	if argc == 1 {
		var idObj uintptr = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt((*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, idObj)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1192 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// MainLoop --
//
//	A main loop set by TestsetmainloopCmd below.
//
// Results:
//	None.
//
// Side effects:
//	Event handlers could do anything.
//
//----------------------------------------------------------------------

func MainLoop(tls *libc.TLS) { /* tclTest.c:5342:1: */
	for !(exitMainLoop != 0) {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, 0)
	}
	libc.Xfprintf(tls, libc.Xstdout, ts+6116 /* "Exit MainLoop\n" */, 0)
	libc.Xfflush(tls, libc.Xstdout)
}

//----------------------------------------------------------------------
//
// TestsetmainloopCmd  --
//
//	Implements the "testsetmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetmainloopCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5369:1: */
	exitMainLoop = 0
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetMainLoop})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{MainLoop})))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexitmainloopCmd  --
//
//	Implements the "testexitmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexitmainloopCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5398:1: */
	exitMainLoop = 1
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestChannelCmd --
//
//	Implements the Tcl "testchannel" debugging command and its
//	subcommands. This is part of the testing environment.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestChannelCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5427:1: */
	bp := tls.Alloc(632)
	defer tls.Free(632)

	var cmdName uintptr // Sub command.
	var hTblPtr uintptr // Hash table of channels.
	// var hSearch Tcl_HashSearch at bp+608, 24
	// Search variable.
	var hPtr uintptr      // Search variable.
	var chanPtr uintptr   // The actual channel.
	var statePtr uintptr  // state info for channel
	var chan1 Tcl_Channel // The opaque type.
	var len size_t        // Length of subcommand string.
	var IOQueued int32    // How much IO is queued inside channel?
	// var buf [24]int8 at bp+584, 24
	// For sprintf.
	// var mode int32 at bp+560, 4
	// rw mode of the channel

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+6131 /* " subcommand ?add..." */, uintptr(0)))
		return TCL_ERROR
	}
	cmdName = *(*uintptr)(unsafe.Pointer(argv + 1*8))
	len = libc.Xstrlen(tls, cmdName)

	chanPtr = uintptr(0)

	if argc > 2 {
		if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 's') && (libc.Xstrncmp(tls, cmdName, ts+6164 /* "splice" */, len) == 0) {
			// For splice access the pool of detached channels.
			// Locate channel, remove from the list.

			var nextPtrPtr uintptr
			var curPtr uintptr

			chan1 = uintptr(0)
			nextPtrPtr = uintptr(unsafe.Pointer(&firstDetached))
			curPtr = firstDetached
		__1:
			if !(curPtr != (uintptr(0))) {
				goto __3
			}
			{

				if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), (*struct {
					f func(*libc.TLS, Tcl_Channel) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelName})).f(tls, (*TestChannel)(unsafe.Pointer(curPtr)).__chan)) == 0 {
					*(*uintptr)(unsafe.Pointer(nextPtrPtr)) = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
					(*TestChannel)(unsafe.Pointer(curPtr)).nextPtr = uintptr(0)
					chan1 = (*TestChannel)(unsafe.Pointer(curPtr)).__chan
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, curPtr)
					goto __3
				}

			}
			goto __2
		__2:
			nextPtrPtr = (curPtr + 8 /* &.nextPtr */)
			curPtr = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
			goto __1
			goto __3
		__3:
		} else {
			chan1 = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+560 /* &mode */)
		}
		if chan1 == (uintptr(0)) {
			return TCL_ERROR
		}
		chanPtr = chan1
		statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
		chanPtr = (*ChannelState)(unsafe.Pointer(statePtr)).topChanPtr
		chan1 = chanPtr
	} else {
		// lint
		statePtr = uintptr(0)
		chan1 = uintptr(0)
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 's') && (libc.Xstrncmp(tls, cmdName, ts+6171 /* "setchannelerror" */, len) == 0) {

		*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)) = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))).refCount++
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetChannelError})).f(tls, chan1, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}

		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelError})).f(tls, chan1, bp+568 /* &msg */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return TCL_OK
	}
	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 's') && (libc.Xstrncmp(tls, cmdName, ts+6187 /* "setchannelerrori..." */, len) == 0) {

		*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)) = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetChannelErrorInterp})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelErrorInterp})).f(tls, interp, bp+576 /* &msg */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return TCL_OK
	}

	// "cut" is actually more a simplified detach facility as provided by the
	// Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "splice", see below.

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'c') && (libc.Xstrncmp(tls, cmdName, ts+6209 /* "cut" */, len) == 0) {
		var det uintptr

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6213 /* " cut channelName..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, uintptr(0), chan1) // prevent closing
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, interp, chan1)

		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CutChannel})).f(tls, chan1)

		// Remember the channel in the pool of detached channels

		det = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestChannel{})))
		(*TestChannel)(unsafe.Pointer(det)).__chan = chan1
		(*TestChannel)(unsafe.Pointer(det)).nextPtr = firstDetached
		firstDetached = det

		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'c') && (libc.Xstrncmp(tls, cmdName, ts+6231 /* "clearchannelhand..." */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6252 /* " clearchannelhan..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ClearChannelHandlers})).f(tls, chan1)
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i') && (libc.Xstrncmp(tls, cmdName, ts+6287 /* "info" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6292 /* " info channelNam..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ChannelName})).f(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr))
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6311 /* "read" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6316 /* "write" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 3)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6322 /* "nonblocking" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6334 /* "blocking" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 4)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6343 /* "line" */)
		} else if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 5)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6348 /* "none" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6353 /* "full" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 7)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6358 /* "async_flush" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 9)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6370 /* "eof" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 11)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6374 /* "blocked" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6382 /* "unblocked" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_AUTO {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6392 /* "auto" */)
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6397 /* "saw_cr" */)
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
			}
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_LF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6404 /* "lf" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_CR {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6407 /* "cr" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_CRLF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6410 /* "crlf" */)
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6415 /* "queued_cr" */)
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
			}
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_AUTO {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6392 /* "auto" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_LF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6404 /* "lf" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_CR {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6407 /* "cr" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_CRLF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6410 /* "crlf" */)
		}
		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_OutputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(int32((*struct {
			f func(*libc.TLS, Tcl_Channel) Tcl_WideInt
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Tell})).f(tls, chan1))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i') && (libc.Xstrncmp(tls, cmdName, ts+6425 /* "inputbuffered" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+144, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i') && (libc.Xstrncmp(tls, cmdName, ts+6461 /* "isshared" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_IsChannelShared})).f(tls, chan1)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+176, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i') && (libc.Xstrncmp(tls, cmdName, ts+6470 /* "isstandard" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_IsStandardChannel})).f(tls, chan1)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+208, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'm') && (libc.Xstrncmp(tls, cmdName, ts+6481 /* "mode" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6311 /* "read" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6316 /* "write" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1318 /* "" */)
		}
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'm') && (libc.Xstrncmp(tls, cmdName, ts+6486 /* "mthread" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+240, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls,
			Tcl_WideInt((*struct {
				f func(*libc.TLS, Tcl_Channel) Tcl_ThreadId
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelThread})).f(tls, chan1))))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'n') && (libc.Xstrncmp(tls, cmdName, ts+1615 /* "name" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+272, (*ChannelState)(unsafe.Pointer(statePtr)).channelName, uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'o') && (libc.Xstrncmp(tls, cmdName, ts+6494 /* "open" */, len) == 0) {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6499 /* "tclIO" */, uintptr(0))
		if hTblPtr == (uintptr(0)) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
					return *(*uintptr)(unsafe.Pointer(hPtr + 32 /* &.key */))
				}
				return hPtr + 32 /* &.key */
			}())
		}
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'o') && (libc.Xstrncmp(tls, cmdName, ts+6505 /* "outputbuffered" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_OutputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+304, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'q') && (libc.Xstrncmp(tls, cmdName, ts+6520 /* "queuedcr" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+336, func() uintptr {
				if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
					return ts + 6529 /* "1" */
				}
				return ts + 6531 /* "0" */
			}(), uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'r') && (libc.Xstrncmp(tls, cmdName, ts+6533 /* "readable" */, len) == 0) {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6499 /* "tclIO" */, uintptr(0))
		if hTblPtr == (uintptr(0)) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			chanPtr = (*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer(hPtr + 32 /* &.key */))
					}
					return hPtr + 32 /* &.key */
				}())
			}
		}
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'r') && (libc.Xstrncmp(tls, cmdName, ts+6542 /* "refcount" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+368, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	// "splice" is actually more a simplified attach facility as provided by
	// the Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "cut", see above.

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 's') && (libc.Xstrncmp(tls, cmdName, ts+6164 /* "splice" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SpliceChannel})).f(tls, chan1)

		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, interp, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, uintptr(0), chan1)

		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 't') && (libc.Xstrncmp(tls, cmdName, ts+6551 /* "type" */, len) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+6439 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+416, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ChannelName})).f(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr), uintptr(0)))
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'w') && (libc.Xstrncmp(tls, cmdName, ts+6556 /* "writable" */, len) == 0) {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6499 /* "tclIO" */, uintptr(0))
		if hTblPtr == (uintptr(0)) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			chanPtr = (*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer(hPtr + 32 /* &.key */))
					}
					return hPtr + 32 /* &.key */
				}())
			}
		}
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 't') && (libc.Xstrncmp(tls, cmdName, ts+6565 /* "transform" */, len) == 0) {
		// Syntax: transform channel -command command

		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6575 /* " transform chann..." */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6610 /* "-command" */) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+6619 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6634 /* "\": should be \"-c..." */, uintptr(0)))
			return TCL_ERROR
		}

		return (*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelTransform})).f(tls, interp, chan1,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), -1))
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName))) == 'u') && (libc.Xstrncmp(tls, cmdName, ts+6658 /* "unstack" */, len) == 0) {
		// Syntax: unstack channel

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+496, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6666 /* " unstack channel..." */, uintptr(0)))
			return TCL_ERROR
		}
		return (*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnstackChannel})).f(tls, interp, chan1)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+528, ts+1254 /* "bad option \"" */, cmdName,

		ts+6684 /* "\": should be cut..." */, uintptr(0)))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestChannelEventCmd --
//
//	This procedure implements the "testchannelevent" command. It is used
//	to test the Tcl channel event mechanism.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes and returns channel event handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestChannelEventCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5896:1: */
	bp := tls.Alloc(420)
	defer tls.Free(420)

	var resultListPtr uintptr
	var chanPtr uintptr
	var statePtr uintptr // state info for channel
	var esPtr uintptr
	var prevEsPtr uintptr
	var nextEsPtr uintptr
	var cmd uintptr
	// var index int32 at bp+416, 4

	var i int32
	var mask int32
	var len int32

	if (argc < 3) || (argc > 5) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+6799 /* " channelName cmd..." */, uintptr(0)))
		return TCL_ERROR
	}
	chanPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if chanPtr == (uintptr(0)) {
		return TCL_ERROR
	}
	statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state

	cmd = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	len = int32(libc.Xstrlen(tls, cmd))
	if (int32(*(*int8)(unsafe.Pointer(cmd))) == 'a') && (libc.Xstrncmp(tls, cmd, ts+6831 /* "add" */, uint64(uint32(len))) == 0) {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6835 /* " channelName add..." */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6533 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6556 /* "writable" */) == 0 {
			mask = (int32(1) << 2)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6348 /* "none" */) == 0 {
			mask = 0
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+6870 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6887 /* "\": must be reada..." */, uintptr(0)))
			return TCL_ERROR
		}

		esPtr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(EventScriptRecord{})))
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = esPtr

		(*EventScriptRecord)(unsafe.Pointer(esPtr)).chanPtr = chanPtr
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).interp = interp
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), -1)
		(*Tcl_Obj)(unsafe.Pointer((*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)).refCount++

		(*struct {
			f func(*libc.TLS, Tcl_Channel, int32, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateChannelHandler})).f(tls, chanPtr, mask,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)

		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd))) == 'd') && (libc.Xstrncmp(tls, cmd, ts+1212 /* "delete" */, uint64(uint32(len))) == 0) {
		if argc != 4 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6926 /* " channelName del..." */, uintptr(0)))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+416 /* &index */) == TCL_ERROR {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 416 /* index */)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+6953 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6971 /* ": must be nonneg..." */, uintptr(0)))
			return TCL_ERROR
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__1:
		if !((i < *(*int32)(unsafe.Pointer(bp + 416 /* index */))) && (esPtr != (uintptr(0)))) {
			goto __3
		}
		{
			// Empty loop body.

		}
		goto __2
	__2:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __1
		goto __3
	__3:
		;
		if esPtr == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+6993 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7010 /* ": out of range" */, uintptr(0)))
			return TCL_ERROR
		}
		if esPtr == (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr {
			(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		} else {
			for prevEsPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; (prevEsPtr != (uintptr(0))) && ((*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr != esPtr); prevEsPtr = (*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr {
				// Empty loop body.
			}
			if prevEsPtr == (uintptr(0)) {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7025 /* "TestChannelEvent..." */, 0)
			}
			(*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		}
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteChannelHandler})).f(tls, chanPtr,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, esPtr)

		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd))) == 'l') && (libc.Xstrncmp(tls, cmd, ts+7072 /* "list" */, uint64(uint32(len))) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7077 /* " channelName lis..." */, uintptr(0)))
			return TCL_ERROR
		}
		resultListPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != (uintptr(0)); esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr {
			if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr, (*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
					func() uintptr {
						if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask == (int32(1) << 1) {
							return ts + 6533 /* "readable" */
						}
						return ts + 6556 /* "writable" */
					}(), -1))
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr,
					(*struct {
						f func(*libc.TLS, uintptr, int32) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6348 /* "none" */, -1))
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr, (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, resultListPtr)
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd))) == 'r') && (libc.Xstrncmp(tls, cmd, ts+7096 /* "removeall" */, uint64(uint32(len))) == 0) {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7106 /* " channelName rem..." */, uintptr(0)))
			return TCL_ERROR
		}
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != (uintptr(0)); esPtr = nextEsPtr {
			nextEsPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
			(*struct {
				f func(*libc.TLS, Tcl_Channel, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteChannelHandler})).f(tls, chanPtr,
				(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, esPtr)
		}
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = uintptr(0)
		return TCL_OK
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd))) == 's') && (libc.Xstrncmp(tls, cmd, ts+4002 /* "set" */, uint64(uint32(len))) == 0) {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7130 /* " channelName del..." */, uintptr(0)))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+416 /* &index */) == TCL_ERROR {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 416 /* index */)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+6953 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6971 /* ": must be nonneg..." */, uintptr(0)))
			return TCL_ERROR
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__4:
		if !((i < *(*int32)(unsafe.Pointer(bp + 416 /* index */))) && (esPtr != (uintptr(0)))) {
			goto __6
		}
		{
			// Empty loop body.

		}
		goto __5
	__5:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __4
		goto __6
	__6:
		;
		if esPtr == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+6993 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7010 /* ": out of range" */, uintptr(0)))
			return TCL_ERROR
		}

		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6533 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6556 /* "writable" */) == 0 {
			mask = (int32(1) << 2)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6348 /* "none" */) == 0 {
			mask = 0
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+6870 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + 4*8)),
				ts+6887 /* "\": must be reada..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*struct {
			f func(*libc.TLS, Tcl_Channel, int32, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateChannelHandler})).f(tls, chanPtr, mask,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
		return TCL_OK
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+7163 /* "bad command " */, cmd,
		ts+7176 /* ", must be one of..." */, uintptr(0)))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestWrongNumArgsObjCmd --
//
//	Test the Tcl_WrongNumArgs function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestWrongNumArgsObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6107:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var i int32 at bp, 4

	// var length int32 at bp+4, 4

	var msg uintptr

	if objc < 3 {
		// Don't use Tcl_WrongNumArgs here, as that is the function
		// we want to test!
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+7230 /* "insufficient arg..." */, uintptr(0))
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &i */) != TCL_OK {
		return TCL_ERROR
	}

	msg = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */)
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		msg = uintptr(0)
	}

	if *(*int32)(unsafe.Pointer(bp /* i */)) > (objc - 3) {
		// Asked for more arguments than were given.
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+7230 /* "insufficient arg..." */, uintptr(0))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, *(*int32)(unsafe.Pointer(bp /* i */)), (objv + 3*8), msg)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestGetIndexFromObjStructObjCmd --
//
//	Test the Tcl_GetIndexFromObjStruct function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestGetIndexFromObjStructObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6163:1: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	*(*[8]uintptr)(unsafe.Pointer(bp + 72 /* ary */)) = [8]uintptr{
		ts + 5738 /* "a" */, ts + 7253 /* "b" */, ts + 7255 /* "c" */, ts + 7257 /* "d" */, ts + 2351 /* "e" */, ts + 2353 /* "f" */, uintptr(0), uintptr(0),
	}
	// var idx int32 at bp+136, 4

	// var target int32 at bp+140, 4

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7259 /* "argument targetv..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+72 /* &ary[0] */, (int32(uint64(2)*uint64(unsafe.Sizeof(uintptr(0))))),
		ts+7280 /* "dummy" */, 0, bp+136 /* &idx */) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+140 /* &target */) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 136 /* idx */)) != *(*int32)(unsafe.Pointer(bp + 140 /* target */)) {
		// var buffer [64]int8 at bp+144, 64

		libc.Xsprintf(tls, bp+144 /* &buffer[0] */, ts+5570 /* "%d" */, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 136 /* idx */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, ts+7286, /* "index value comp..." */
			bp+144 /* &buffer[0] */, uintptr(0)))
		libc.Xsprintf(tls, bp+144 /* &buffer[0] */, ts+5570 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 140 /* target */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+40, ts+7322 /* " when " */, bp+144 /* &buffer[0] */, ts+7329 /* " expected" */, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 3, objv, uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestFilesystemObjCmd --
//
//	This procedure implements the "testfilesystem" command. It is used to
//	test Tcl_FSRegister, Tcl_FSUnregister, and can be used to test that
//	the pluggable filesystem works.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Inserts or removes a filesystem from Tcl's stack.
//
//----------------------------------------------------------------------

func TestFilesystemObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6217:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7339 /* "boolean" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &boolVal */) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp /* boolVal */)) != 0 {
		res = (*struct {
			f func(*libc.TLS, ClientData, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRegister})).f(tls, interp, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == TCL_OK {
			msg = ts + 7347 /* "registered" */
		} else {
			msg = ts + 7358 /* "failed" */
		}
	} else {
		res = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUnregister})).f(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == TCL_OK {
			msg = ts + 7365 /* "unregistered" */
		} else {
			msg = ts + 7358 /* "failed" */
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, msg, -1))
	return res
}

func TestReportInFilesystem(tls *libc.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6245:1: */
	var newPathPtr uintptr

	if pathPtr == lastPathPtr {
		// Reject all files second time around
		return -1
	}

	// Try to claim all files first time around

	newPathPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, pathPtr)
	lastPathPtr = newPathPtr
	(*Tcl_Obj)(unsafe.Pointer(newPathPtr)).refCount++
	if (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetFileSystemForPath})).f(tls, newPathPtr) == (uintptr(0)) {
		// Nothing claimed it. Therefore we don't either
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = newPathPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		lastPathPtr = uintptr(0)
		return -1
	}
	lastPathPtr = uintptr(0)
	*(*ClientData)(unsafe.Pointer(clientDataPtr)) = newPathPtr
	return TCL_OK
}

var lastPathPtr uintptr = uintptr(0) /* tclTest.c:6249:20 */

// Simple helper function to extract the native vfs representation of a path
// object, or NULL if no such representation exists.

func TestReportGetNativePath(tls *libc.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6278:16: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetInternalRep})).f(tls, pathPtr, uintptr(unsafe.Pointer(&testReportingFilesystem)))
}

func TestReportFreeInternalRep(tls *libc.TLS, clientData ClientData) { /* tclTest.c:6286:1: */
	var nativeRep uintptr = clientData

	if nativeRep != (uintptr(0)) {
		// Free the path
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = nativeRep
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
}

func TestReportDupInternalRep(tls *libc.TLS, clientData ClientData) ClientData { /* tclTest.c:6298:1: */
	var original uintptr = clientData

	(*Tcl_Obj)(unsafe.Pointer(original)).refCount++
	return clientData
}

func TestReport(tls *libc.TLS, cmd uintptr, path uintptr, arg2 uintptr) { /* tclTest.c:6308:1: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var interp uintptr = (*struct {
		f func(*libc.TLS, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSData})).f(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))

	if interp == (uintptr(0)) {
		// This is bad, but not much we can do about it
	} else {
		// No idea why I decided to program this up using the old string-based
		// API, but there you go. We should convert it to objects.

		var savedResult uintptr
		// var ds Tcl_DString at bp, 216

		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp /* &ds */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, bp /* &ds */, ts+7378 /* "lappend filesyst..." */, -1)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, bp /* &ds */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, cmd)
		if path != (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, path))
		}
		if arg2 != (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, arg2))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, bp /* &ds */)
		savedResult = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
		(*Tcl_Obj)(unsafe.Pointer(savedResult)).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp /* &ds */)).string)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp /* &ds */)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, savedResult)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = savedResult
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
}

func TestReportStat(tls *libc.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6349:1: */
	TestReport(tls, ts+7404 /* "stat" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSStat})).f(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportLstat(tls *libc.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6358:1: */
	TestReport(tls, ts+7409 /* "lstat" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLstat})).f(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportAccess(tls *libc.TLS, path uintptr, mode int32) int32 { /* tclTest.c:6367:1: */
	TestReport(tls, ts+7415 /* "access" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSAccess})).f(tls, TestReportGetNativePath(tls, path), mode)
}

func TestReportOpenFileChannel(tls *libc.TLS, interp uintptr, fileName uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6376:1: */
	TestReport(tls, ts+6494 /* "open" */, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpOpenFileChannel})).f(tls, interp, TestReportGetNativePath(tls, fileName),
		mode, permissions)
}

func TestReportMatchInDirectory(tls *libc.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types1 uintptr) int32 { /* tclTest.c:6390:1: */
	if (types1 != (uintptr(0))) && (((*Tcl_GlobTypeData)(unsafe.Pointer(types1)).__type & (int32(1) << 7)) != 0) {
		TestReport(tls, ts+7422 /* "matchmounts" */, dirPtr, uintptr(0))
		return TCL_OK
	} else {
		TestReport(tls, ts+7434 /* "matchindirectory" */, dirPtr, uintptr(0))
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSMatchInDirectory})).f(tls, interp, resultPtr,
			TestReportGetNativePath(tls, dirPtr), pattern, types1)
	}
	return int32(0)
}

func TestReportChdir(tls *libc.TLS, dirName uintptr) int32 { /* tclTest.c:6409:1: */
	TestReport(tls, ts+7451 /* "chdir" */, dirName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSChdir})).f(tls, TestReportGetNativePath(tls, dirName))
}

func TestReportLoadFile(tls *libc.TLS, interp uintptr, fileName uintptr, handlePtr uintptr, unloadProcPtr uintptr) int32 { /* tclTest.c:6417:1: */
	TestReport(tls, ts+7457 /* "loadfile" */, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLoadFile})).f(tls, interp, TestReportGetNativePath(tls, fileName), uintptr(0),
		uintptr(0), uintptr(0), uintptr(0), handlePtr, unloadProcPtr)
}

func TestReportLink(tls *libc.TLS, path uintptr, to uintptr, linkType int32) uintptr { /* tclTest.c:6434:16: */
	TestReport(tls, ts+7466 /* "link" */, path, to)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, TestReportGetNativePath(tls, path), to, linkType)
}

func TestReportRenameFile(tls *libc.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6445:1: */
	TestReport(tls, ts+7471 /* "renamefile" */, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRenameFile})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportCopyFile(tls *libc.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6457:1: */
	TestReport(tls, ts+7482 /* "copyfile" */, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCopyFile})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportDeleteFile(tls *libc.TLS, path uintptr) int32 { /* tclTest.c:6467:1: */
	TestReport(tls, ts+7491 /* "deletefile" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSDeleteFile})).f(tls, TestReportGetNativePath(tls, path))
}

func TestReportCreateDirectory(tls *libc.TLS, path uintptr) int32 { /* tclTest.c:6475:1: */
	TestReport(tls, ts+7502 /* "createdirectory" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCreateDirectory})).f(tls, TestReportGetNativePath(tls, path))
}

func TestReportCopyDirectory(tls *libc.TLS, src uintptr, dst uintptr, errorPtr uintptr) int32 { /* tclTest.c:6483:1: */
	TestReport(tls, ts+7518 /* "copydirectory" */, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCopyDirectory})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst), errorPtr)
}

func TestReportRemoveDirectory(tls *libc.TLS, path uintptr, recursive int32, errorPtr uintptr) int32 { /* tclTest.c:6496:1: */
	TestReport(tls, ts+7532 /* "removedirectory" */, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRemoveDirectory})).f(tls, TestReportGetNativePath(tls, path), recursive,
		errorPtr)
}

func TestReportFileAttrStrings(tls *libc.TLS, fileName uintptr, objPtrRef uintptr) uintptr { /* tclTest.c:6510:19: */
	TestReport(tls, ts+7548 /* "fileattributestr..." */, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrStrings})).f(tls, TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsGet(tls *libc.TLS, interp uintptr, index int32, fileName uintptr, objPtrRef uintptr) int32 { /* tclTest.c:6520:1: */
	TestReport(tls, ts+7569 /* "fileattributesge..." */, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrsGet})).f(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsSet(tls *libc.TLS, interp uintptr, index int32, fileName uintptr, objPtr uintptr) int32 { /* tclTest.c:6532:1: */
	TestReport(tls, ts+7587 /* "fileattributesse..." */, fileName, objPtr)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrsSet})).f(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtr)
}

func TestReportUtime(tls *libc.TLS, fileName uintptr, tval uintptr) int32 { /* tclTest.c:6544:1: */
	TestReport(tls, ts+7605 /* "utime" */, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUtime})).f(tls, TestReportGetNativePath(tls, fileName), tval)
}

func TestReportNormalizePath(tls *libc.TLS, interp uintptr, pathPtr uintptr, nextCheckpoint int32) int32 { /* tclTest.c:6553:1: */
	TestReport(tls, ts+7611 /* "normalizepath" */, pathPtr, uintptr(0))
	return nextCheckpoint
}

func SimplePathInFilesystem(tls *libc.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6563:1: */
	var str uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, pathPtr)

	if libc.Xstrncmp(tls, str, ts+7625 /* "simplefs:/" */, uint64(10)) != 0 {
		return -1
	}
	return TCL_OK
}

// This is a slightly 'hacky' filesystem which is used just to test a few
// important features of the vfs code: (1) that you can load a shared library
// from a vfs, (2) that when copying files from one fs to another, the 'mtime'
// is preserved. (3) that recursive cross-filesystem directory copies have the
// correct behaviour with/without -force.
//
// It treats any file in 'simplefs:/' as a file, which it routes to the
// current directory. The real file it uses is whatever follows the trailing
// '/' (e.g. 'foo' in 'simplefs:/foo'), and that file exists or not according
// to what is in the native pwd.
//
// Please do not consider this filesystem a model of how things are to be
// done. It is quite the opposite!  But, it does allow us to test some
// important features.

func TestSimpleFilesystemObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6593:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7339 /* "boolean" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &boolVal */) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp /* boolVal */)) != 0 {
		res = (*struct {
			f func(*libc.TLS, ClientData, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRegister})).f(tls, interp, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == TCL_OK {
			msg = ts + 7347 /* "registered" */
		} else {
			msg = ts + 7358 /* "failed" */
		}
	} else {
		res = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUnregister})).f(tls, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == TCL_OK {
			msg = ts + 7365 /* "unregistered" */
		} else {
			msg = ts + 7358 /* "failed" */
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, msg, -1))
	return res
}

// Treats a file name 'simplefs:/foo' by using the file 'foo' in the current
// (native) directory.

func SimpleRedirect(tls *libc.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6625:16: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var str uintptr
	var origPtr uintptr

	// We assume the same name in the current directory is ok.

	str = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, pathPtr, bp /* &len */)
	if (*(*int32)(unsafe.Pointer(bp /* len */)) < 10) || (libc.Xstrncmp(tls, str, ts+7625 /* "simplefs:/" */, uint64(10)) != 0) {
		// Probably shouldn't ever reach here
		(*Tcl_Obj)(unsafe.Pointer(pathPtr)).refCount++
		return pathPtr
	}
	origPtr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (str + uintptr(10)), -1)
	(*Tcl_Obj)(unsafe.Pointer(origPtr)).refCount++
	return origPtr
}

func SimpleMatchInDirectory(tls *libc.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types1 uintptr) int32 { /* tclTest.c:6649:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var res int32
	var origPtr uintptr
	var resPtr uintptr

	// We only provide a new volume, therefore no mounts at all
	if (types1 != (uintptr(0))) && (((*Tcl_GlobTypeData)(unsafe.Pointer(types1)).__type & (int32(1) << 7)) != 0) {
		return TCL_OK
	}

	// We assume the same name in the current directory is ok.
	resPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	(*Tcl_Obj)(unsafe.Pointer(resPtr)).refCount++
	origPtr = SimpleRedirect(tls, dirPtr)
	res = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSMatchInDirectory})).f(tls, interp, resPtr, origPtr, pattern, types1)
	if res == TCL_OK {
		// var gLength int32 at bp, 4

		var j int32
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), resPtr, bp /* &gLength */)
		for j = 0; j < *(*int32)(unsafe.Pointer(bp /* gLength */)); j++ {
			// var gElt uintptr at bp+8, 8

			var nElt uintptr
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjIndex})).f(tls, uintptr(0), resPtr, j, bp+8 /* &gElt */)
			nElt = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7625 /* "simplefs:/" */, 10)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendObjToObj})).f(tls, nElt, *(*uintptr)(unsafe.Pointer(bp + 8 /* gElt */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), resultPtr, nElt)
		}
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = origPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = resPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleOpenFileChannel(tls *libc.TLS, interp uintptr, pathPtr uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6691:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var tempPtr uintptr
	var chan1 Tcl_Channel

	if (mode != 0) && !((mode & O_RDONLY) != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+7636 /* "read-only" */, uintptr(0)))
		return uintptr(0)
	}

	tempPtr = SimpleRedirect(tls, pathPtr)
	chan1 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSOpenFileChannel})).f(tls, interp, tempPtr, ts+7646 /* "r" */, permissions)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return chan1
}

func SimpleAccess(tls *libc.TLS, pathPtr uintptr, mode int32) int32 { /* tclTest.c:6714:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSAccess})).f(tls, tempPtr, mode)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleStat(tls *libc.TLS, pathPtr uintptr, bufPtr uintptr) int32 { /* tclTest.c:6726:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSStat})).f(tls, tempPtr, bufPtr)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleListVolumes(tls *libc.TLS) uintptr { /* tclTest.c:6737:16: */
	// Add one new volume
	var retVal uintptr

	retVal = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7625 /* "simplefs:/" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(retVal)).refCount++
	return retVal
}

// Used to check correct string-length determining in Tcl_NumUtfChars

func TestNumUtfCharsCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6753:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &len */)
		}
		*(*int32)(unsafe.Pointer(bp /* len */)) = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NumUtfChars})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*int32)(unsafe.Pointer(bp /* len */)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp /* len */))))
	}
	return TCL_OK
}

// Used to check correct operation of Tcl_UtfFindFirst

func TestFindFirstCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6776:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &len */)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfFindFirst})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return TCL_OK
}

// Used to check correct operation of Tcl_UtfFindLast

func TestFindLastCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6798:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &len */)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfFindLast})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return TCL_OK
}

// Used to do basic checks of the TCL_HASH_KEY_SYSTEM_HASH flag

func TestHashSystemHashCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6876:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	// var hash Tcl_HashTable at bp+72, 88

	var hPtr uintptr
	var i int32
	// var isNew int32 at bp+160, 4

	*(*int32)(unsafe.Pointer(bp + 64 /* limit */)) = 100

	if (objc > 1) && ((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+64 /* &limit */) != TCL_OK) {
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InitCustomHashTable})).f(tls, bp+72 /* &hash */, -2, uintptr(unsafe.Pointer(&hkType)))

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+7648 /* "non-zero initial..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer((bp + 72 /* &hash */))).createProc})).f(tls, bp+72 /* &hash */, uintptr(intptr_t(i)), bp+160 /* &isNew */)
		if !(*(*int32)(unsafe.Pointer(bp + 160 /* isNew */)) != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+7670 /* " creation proble..." */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		(*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData = uintptr((intptr_t(i + 42)))
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != *(*int32)(unsafe.Pointer(bp + 64 /* limit */)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+7688 /* "unexpected maxim..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer((bp + 72 /* &hash */))).findProc})).f(tls, bp+72 /* &hash */, uintptr(intptr_t(i)))
		if hPtr == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+7712 /* " lookup problem" */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		if (int32((*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData)) != (i + 42) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+7728 /* " value problem" */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashEntry})).f(tls, hPtr)
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+7743 /* "non-zero final s..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+7763 /* "OK" */, uintptr(0)))
	return TCL_OK
}

var hkType = Tcl_HashKeyType{
	version: TCL_HASH_KEY_TYPE_VERSION, flags: TCL_HASH_KEY_SYSTEM_HASH,
} /* tclTest.c:6882:34 */

// Used for testing Tcl_GetInt which is no longer used directly by the
// core very much.
func TestgetintCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:6952:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1192 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	} else {
		// var val int32 at bp, 4

		var i int32
		var total int32 = 0

		for i = 1; i < argc; i++ {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp /* &val */) != TCL_OK {
				return TCL_ERROR
			}
			total = total + (*(*int32)(unsafe.Pointer(bp /* val */)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, total))
		return TCL_OK
	}
	return int32(0)
}

func NREUnwind_callback(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclTest.c:6976:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var none int32 at bp, 4

	if *(*ClientData)(unsafe.Pointer(data)) == (libc.UintptrFromInt64(int64(-1))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), bp /* &none */, libc.UintptrFromInt64(int64(-1)),
			libc.UintptrFromInt64(int64(-1)), uintptr(0))
	} else if *(*ClientData)(unsafe.Pointer(data + 1*8)) == (libc.UintptrFromInt64(int64(-1))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data)), bp, /* &none */
			libc.UintptrFromInt64(int64(-1)), uintptr(0))
	} else if *(*ClientData)(unsafe.Pointer(data + 2*8)) == (libc.UintptrFromInt64(int64(-1))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data)), *(*ClientData)(unsafe.Pointer(data + 1*8)),
			bp /* &none */, uintptr(0))
	} else {
		// var idata [3]uintptr at bp+8, 24

		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata[0] */)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (int32((int64(*(*ClientData)(unsafe.Pointer(data + 1*8))) - int64(*(*ClientData)(unsafe.Pointer(data)))) / 1)))
		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata[0] */ + 1*8)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (int32((int64(*(*ClientData)(unsafe.Pointer(data + 2*8))) - int64(*(*ClientData)(unsafe.Pointer(data)))) / 1)))
		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata[0] */ + 2*8)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (int32((int64(bp /* &none */) - int64(*(*ClientData)(unsafe.Pointer(data)))) / 1)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 3, bp+8 /* &idata[0] */))
	}
	return TCL_OK
}

func TestNREUnwind(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7003:1: */
	// Insure that callbacks effectively run at the proper level during the
	// unwinding of the NRE stack.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{NREUnwind_callback})), libc.UintptrFromInt64(int64(-1)), libc.UintptrFromInt64(int64(-1)),
		libc.UintptrFromInt64(int64(-1)), uintptr(0))
	return TCL_OK
}

func TestNRELevels(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7021:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var iPtr uintptr = interp
	// var depth ptrdiff_t at bp, 8

	// var levels [6]uintptr at bp+8, 48

	var i int32 = 0
	var cbPtr uintptr = (*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).callbackPtr

	if refDepth == (uintptr(0)) {
		refDepth = bp /* &depth */
	}

	*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */)) = ((int64(refDepth) - int64(bp /* &depth */)) / 8)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32(*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */))))
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */ + 1*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Interp)(unsafe.Pointer(iPtr)).numLevels)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */ + 2*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*CmdFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).cmdFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */ + 3*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*CallFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).varFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */ + 4*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (int32(int64(((*ExecStack)(unsafe.Pointer((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr)).tosPtr -
		((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr + 40 /* &.stackWords */)) / 8))))

	for cbPtr != 0 {
		i++
		cbPtr = (*NRE_callback)(unsafe.Pointer(cbPtr)).nextPtr
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels[0] */ + 5*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 6, bp+8 /* &levels[0] */))
	return TCL_OK
}

var refDepth uintptr = uintptr(0) /* tclTest.c:7028:22 */

//----------------------------------------------------------------------
//
// TestconcatobjCmd --
//
//	This procedure implements the "testconcatobj" command. It is used
//	to test that Tcl_ConcatObj does indeed return a fresh Tcl_Obj in all
//	cases and thet it never corrupts its arguments. In other words, that
//	[Bug 1447328] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestconcatobjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:7077:1: */
	bp := tls.Alloc(588)
	defer tls.Free(588)

	var list1Ptr uintptr
	var list2Ptr uintptr
	var emptyPtr uintptr
	var concatPtr uintptr
	var tmpPtr uintptr
	var result int32 = TCL_OK
	// var len int32 at bp+544, 4

	// var objv [3]uintptr at bp+552, 24

	// Set the start of the error message as obj result; it will be cleared at
	// the end if no errors were found.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7766 /* "Tcl_ConcatObj is..." */, -1))

	emptyPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)

	list1Ptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7791 /* "foo bar sum" */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), list1Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes != (uintptr(0)) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes)
		(*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes = uintptr(0)
	}

	list2Ptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7803 /* "eeny meeny" */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), list2Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes != (uintptr(0)) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes)
		(*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes = uintptr(0)
	}

	// Verify that concat'ing a list obj with one or more empty strings does
	// return a fresh Tcl_Obj (see also [Bug 2055782]).

	tmpPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = emptyPtr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp, ts+7814 /* "\n\t* (a) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+7857, /* "\n\t* (a) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+7893 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+7911 /* "(refCount added)" */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+7928 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+80, ts+8006 /* "\n\t* (b) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+8049, /* "\n\t* (b) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+112, ts+8085 /* "(refCount remove..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+7893 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 2:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+144, ts+7911 /* "(refCount added)" */, uintptr(0)))
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+7928 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = emptyPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 2*8)) = emptyPtr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 3, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+176, ts+8105 /* "\n\t* (c) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+8148, /* "\n\t* (c) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+208, ts+7893 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+7911 /* "(refCount added)" */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+240, ts+7928 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = tmpPtr
	}
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 3, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+256, ts+8184 /* "\n\t* (d) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+272, ts+8227, /* "\n\t* (d) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+8085 /* "(refCount remove..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+304, ts+7893 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 2:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+7911 /* "(refCount added)" */, uintptr(0)))
			for ok4 := true; ok4; ok4 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+336, ts+7928 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7960 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = tmpPtr
	}
	for ok5 := true; ok5; ok5 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Verify that an unshared list is not corrupted when concat'ing things to
	// it.

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = list2Ptr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+352, ts+8263 /* "\n\t* (e) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+576, 4

		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+368, ts+8306, /* "\n\t* (e) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+576 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+8342 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+8361 /* "(corrupted input..." */, uintptr(0)))
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok6 := true; ok6; ok6 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	}
	for ok7 := true; ok7; ok7 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+416, ts+8380 /* "\n\t* (f) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+580, 4

		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+8423, /* "\n\t* (f) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+580 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+448, ts+8342 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+8361 /* "(corrupted input..." */, uintptr(0)))
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok8 := true; ok8; ok8 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	}
	for ok9 := true; ok9; ok9 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */ + 1*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+480, ts+8459 /* "\n\t* (g) concatOb..." */, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+584, 4

		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+496, ts+8502, /* "\n\t* (g) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+584 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+512, ts+8342 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+528, ts+8361 /* "(corrupted input..." */, uintptr(0)))
		}
		for ok10 := true; ok10; ok10 = 0 != 0 {
			var _objPtr uintptr = tmpPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv[0] */)) = tmpPtr
	}
	for ok12 := true; ok12; ok12 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Clean everything up. Note that we don't actually know how many
	// references there are to tmpPtr here; in the no-error case, it should be
	// five... [Bug 2895367]

	for ok13 := true; ok13; ok13 = 0 != 0 {
		var _objPtr uintptr = list1Ptr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok14 := true; ok14; ok14 = 0 != 0 {
		var _objPtr uintptr = list2Ptr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok15 := true; ok15; ok15 = 0 != 0 {
		var _objPtr uintptr = emptyPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
		for ok16 := true; ok16; ok16 = 0 != 0 {
			var _objPtr uintptr = tmpPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	for ok17 := true; ok17; ok17 = 0 != 0 {
		var _objPtr uintptr = tmpPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	if result == TCL_OK {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	}
	return result
}

//----------------------------------------------------------------------
//
// TestparseargsCmd --
//
//	This procedure implements the "testparseargs" command. It is used to
//	test that Tcl_ParseArgsObjv does indeed return the right number of
//	arguments. In other words, that [Bug 3413857] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparseargsCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7380:1: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	*(*int32)(unsafe.Pointer(bp + 192 /* count */)) = objc
	// var remObjv uintptr at bp+200, 8

	// var result [3]uintptr at bp+208, 24

	*(*[4]Tcl_ArgvInfo)(unsafe.Pointer(bp /* argTable */)) = [4]Tcl_ArgvInfo{
		{__type: TCL_ARGV_CONSTANT, keyStr: ts + 8538 /* "-bool" */, srcPtr: uintptr(int64(1)), dstPtr: uintptr(unsafe.Pointer(&foo)), helpStr: ts + 8544 /* "booltest" */},
		{__type: TCL_ARGV_REST, keyStr: ts + 4660 /* "--" */, helpStr: ts + 8553 /* "Marks the end of..." */}, {__type: TCL_ARGV_HELP, keyStr: ts + 8582 /* "-help" */, helpStr: ts + 8588 /* "Print summary of..." */}, {__type: TCL_ARGV_END},
	}

	foo = 0
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseArgsObjv})).f(tls, interp, bp /* &argTable[0] */, bp+192 /* &count */, objv, bp+200 /* &remObjv */) != TCL_OK {
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result[0] */)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, foo)
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result[0] */ + 1*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)))
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result[0] */ + 2*8)) = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)), *(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 3, bp+208 /* &result[0] */))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */)))
	return TCL_OK
}

var foo int32 = 0 /* tclTest.c:7386:16 */

// *
// Test harness for command and variable resolvers.

func InterpCmdResolver(tls *libc.TLS, interp uintptr, name uintptr, context uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7411:1: */
	var iPtr uintptr = interp
	var varFramePtr uintptr = (*Interp)(unsafe.Pointer(iPtr)).varFramePtr
	var procPtr uintptr
	if ((*CallFrame)(unsafe.Pointer(varFramePtr)).isProcCallFrame & FRAME_IS_PROC) != 0 {
		procPtr = (*CallFrame)(unsafe.Pointer(varFramePtr)).procPtr
	} else {
		procPtr = uintptr(0)
	}
	var callerNsPtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).nsPtr
	var resolvedCmdPtr Tcl_Command = uintptr(0)

	// Just do something special on a cmd literal "z" in two cases:
	//  A)  when the caller is a proc "x", and the proc is either in "::" or in "::ns2".
	//  B) the caller's namespace is "ctx1" or "ctx2"
	if (int32(*(*int8)(unsafe.Pointer(name))) == 'z') && (int32(*(*int8)(unsafe.Pointer(name + 1))) == 0) {
		var ns2NsPtr uintptr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespace})).f(tls, interp, ts+8636 /* "::ns2" */, uintptr(0), 0)

		if (procPtr != (uintptr(0))) &&
			(((*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == (*Interp)(unsafe.Pointer(iPtr)).globalNsPtr) ||
				((ns2NsPtr != (uintptr(0))) && ((*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == ns2NsPtr))) {
			// Case A)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the caller proc, which has to be
			//      named "x".
			//
			//    - To determine the name of the caller proc, the proc is taken
			//      from the topmost stack frame.
			//
			//    - Note that the context is NOT provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y", which is taken from the
			//   the global namespace (for simplicity).

			var callingCmdName uintptr = (*struct {
				f func(*libc.TLS, uintptr, Tcl_Command) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandName})).f(tls, interp, (*Proc)(unsafe.Pointer(procPtr)).cmdPtr)

			if (int32(*(*int8)(unsafe.Pointer(callingCmdName))) == 'x') && (int32(*(*int8)(unsafe.Pointer(callingCmdName + 1))) == 0) {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8642 /* "y" */, uintptr(0), TCL_GLOBAL_ONLY)
			}
		} else if callerNsPtr != (uintptr(0)) {
			// Case B)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the parent namespace, which has
			//      to be named "ctx1" or "ctx2".
			//
			//    - To determine the name of the parent namesace, it is taken
			//      from the 2nd highest stack frame.
			//
			//    - Note that the context can be provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y" or "Y" depending on the
			//   context. The resolved procs are taken from the the global
			//   namespace (for simplicity).

			var parentFramePtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).callerPtr
			var context uintptr
			if parentFramePtr != (uintptr(0)) {
				context = (*Namespace)(unsafe.Pointer((*CallFrame)(unsafe.Pointer(parentFramePtr)).nsPtr)).name
			} else {
				context = ts + 8644 /* "(NULL)" */
			}

			if ((libc.Xstrcmp(tls, context, ts+8651 /* "ctx1" */) == 0) && (int32(*(*int8)(unsafe.Pointer(name))) == 'z')) && (int32(*(*int8)(unsafe.Pointer(name + 1))) == 0) {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8642 /* "y" */, uintptr(0), TCL_GLOBAL_ONLY)
				// fprintf(stderr, "... y ==> %p\n", resolvedCmdPtr);

			} else if ((libc.Xstrcmp(tls, context, ts+8656 /* "ctx2" */) == 0) && (int32(*(*int8)(unsafe.Pointer(name))) == 'z')) && (int32(*(*int8)(unsafe.Pointer(name + 1))) == 0) {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8661 /* "Y" */, uintptr(0), TCL_GLOBAL_ONLY)
				//fprintf(stderr, "... Y ==> %p\n", resolvedCmdPtr);
			}
		}

		if resolvedCmdPtr != (uintptr(0)) {
			*(*Tcl_Command)(unsafe.Pointer(rPtr)) = resolvedCmdPtr
			return TCL_OK
		}
	}
	return TCL_CONTINUE
}

func InterpVarResolver(tls *libc.TLS, interp uintptr, name uintptr, context uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7504:1: */
	// Don't resolve the variable; use standard rules.

	return TCL_CONTINUE
}

type MyResolvedVarInfo1 = struct {
	vInfo   Tcl_ResolvedVarInfo
	__var   Tcl_Var
	nameObj uintptr
} /* tclTest.c:7518:9 */

type MyResolvedVarInfo = MyResolvedVarInfo1 /* tclTest.c:7522:3 */

func HashVarFree(tls *libc.TLS, var1 Tcl_Var) { /* tclTest.c:7525:1: */
	if (*VarInHash)(unsafe.Pointer((var1))).refCount < 2 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, var1)
	} else {
		(*VarInHash)(unsafe.Pointer(var1)).refCount--
	}
}

func MyCompiledVarFree(tls *libc.TLS, vInfoPtr uintptr) { /* tclTest.c:7536:1: */
	var resVarInfo uintptr = vInfoPtr

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	if (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var != 0 {
		HashVarFree(tls, (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, vInfoPtr)
}

func MyCompiledVarFetch(tls *libc.TLS, interp uintptr, vinfoPtr uintptr) Tcl_Var { /* tclTest.c:7552:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var resVarInfo uintptr = vinfoPtr
	var var1 Tcl_Var = (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var
	// var isNewVar int32 at bp, 4

	var iPtr uintptr = interp
	var hPtr uintptr

	if var1 != (uintptr(0)) {
		if !(((*Var)(unsafe.Pointer((var1))).flags & VAR_DEAD_HASH) != 0) {
			// The cached variable is valid, return it.

			return var1
		}

		// The variable is not valid anymore. Clean it up.

		HashVarFree(tls, var1)
	}

	hPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer(((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 248 /* &.varTable */))).createProc})).f(tls, ((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 248 /* &.varTable */), (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj, bp /* &isNewVar */)
	if hPtr != 0 {
		var1 = (hPtr - uintptr((int32((uintptr(0) + 24 /* &.entry */)))))
	} else {
		var1 = uintptr(0)
	}
	(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = var1

	// Increment the reference counter to avoid ckfree() of the variable in
	// Tcl's FreeVarEntry(); for cleanup, we provide our own HashVarFree();

	(*VarInHash)(unsafe.Pointer(var1)).refCount++
	return var1
}

func InterpCompiledVarResolver(tls *libc.TLS, interp uintptr, name uintptr, length int32, context uintptr, rPtr uintptr) int32 { /* tclTest.c:7597:1: */
	if int32(*(*int8)(unsafe.Pointer(name))) == 'T' {
		var resVarInfo uintptr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(MyResolvedVarInfo{})))

		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.fetchProc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) Tcl_Var
		}{MyCompiledVarFetch}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{MyCompiledVarFree}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = uintptr(0)
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, name, -1)
		(*Tcl_Obj)(unsafe.Pointer((*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj)).refCount++
		*(*uintptr)(unsafe.Pointer(rPtr)) = (resVarInfo /* &.vInfo */)
		return TCL_OK
	}
	return TCL_CONTINUE
}

func TestInterpResolverCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7619:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var idx int32 at bp+32, 4

	if (objc < 2) || (objc > 3) {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+8663 /* "up|down ?interp?" */)
		return TCL_ERROR
	}
	if objc == 3 {
		interp = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
		if interp == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+8680 /* "provided interpr..." */, uintptr(0)))
			return TCL_ERROR
		}
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&table)), int32(unsafe.Sizeof(uintptr(0))), ts+8711 /* "operation" */, TCL_EXACT, bp+32 /* &idx */) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* idx */)) {
	case 1: // up
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_AddInterpResolvers})).f(tls, interp, ts+8721 /* "testInterpResolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		}{InterpCmdResolver})),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
			}{InterpVarResolver})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32
			}{InterpCompiledVarResolver})))
		break
	case 0: //down
		if !((*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_RemoveInterpResolvers})).f(tls, interp, ts+8721 /* "testInterpResolv..." */) != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+8740, /* "could not remove..." */
				uintptr(0)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

var table = [3]uintptr{
	ts + 8777 /* "down" */, ts + 8782 /* "up" */, uintptr(0),
} /* tclTest.c:7625:23 */

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// indent-tabs-mode: nil
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String1 = struct {
	numChars   int32
	allocated  int32
	maxChars   int32
	hasUnicode int32
	unicode    [1]Tcl_UniChar
	_          [2]byte
} /* tclStringRep.h:49:9 */

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String = String1 /* tclStringRep.h:65:3 */

func VarPtrDeleteProc(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTestObj.c:54:13: */
	var i int32
	var varPtr uintptr = clientData
	for i = 0; i < NUMBER_OF_OBJECT_VARS; i++ {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteAssocData})).f(tls, interp, ts+8785 /* "TCLOBJTEST_VARPT..." */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, varPtr)
}

func GetVarPtr(tls *libc.TLS, interp uintptr) uintptr { /* tclTestObj.c:65:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var proc uintptr at bp, 8

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+8785 /* "TCLOBJTEST_VARPT..." */, bp /* &proc */)
}

//----------------------------------------------------------------------
//
// TclObjTest_Init --
//
//	This function creates additional commands that are used to test the
//	Tcl object support.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error
//	message in the interp's result if an error occurs.
//
// Side effects:
//	Creates and registers several new testing commands.
//
//----------------------------------------------------------------------

func TclObjTest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTestObj.c:91:1: */
	var i int32
	// An array of Tcl_Obj pointers used in the commands that operate on or get
	// the values of Tcl object-valued variables. varPtr[i] is the i-th variable's
	// Tcl_Obj *.
	var varPtr uintptr

	varPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(uint64(NUMBER_OF_OBJECT_VARS) * uint64(unsafe.Sizeof(uintptr(0))))))
	if !(varPtr != 0) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetAssocData})).f(tls, interp, ts+8785 /* "TCLOBJTEST_VARPT..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{VarPtrDeleteProc})), varPtr)
	for i = 0; i < NUMBER_OF_OBJECT_VARS; i++ {
		*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = uintptr(0)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8803 /* "testbignumobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbignumobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8817 /* "testbooleanobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbooleanobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8832 /* "testdoubleobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubleobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8846 /* "testintobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestintobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8857 /* "testindexobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestindexobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8870 /* "testlistobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlistobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8882 /* "testobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestobjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+8890 /* "teststringobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststringobjCmd})),
		uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbignumobjCmd --
//
//	This function implements the "testbignumobj" command.  It is used
//	to exercise the bignum Tcl object type implementation.
//
// Results:
//	Returns a standard Tcl object result.
//
// Side effects:
//	Creates and frees bignum objects; converts objects to have bignum
//	type.
//
//----------------------------------------------------------------------

func TestbignumobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:148:1: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	*(*[7]uintptr)(unsafe.Pointer(bp /* subcmds */)) = [7]uintptr{
		ts + 4002 /* "set" */, ts + 1371 /* "get" */, ts + 8904 /* "mult10" */, ts + 8911 /* "div10" */, ts + 8917 /* "iseven" */, ts + 8924 /* "radixsize" */, uintptr(0),
	}
	// var index int32 at bp+56, 4

	// var varIndex int32 at bp+60, 4

	var string uintptr
	// var bignumValue mp_int at bp+64, 24

	// var newValue mp_int at bp+88, 24

	var varPtr uintptr

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+8934 /* "option ?arg ...?" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &subcmds[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp+56 /* &index */) != TCL_OK {
		return TCL_ERROR
	}
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if GetVariableIndex(tls, interp, string, bp+60 /* &varIndex */) != TCL_OK {
		return TCL_ERROR
	}
	varPtr = GetVarPtr(tls, interp)

	switch *(*int32)(unsafe.Pointer(bp + 56 /* index */)) {
	case 0 /* BIGNUM_SET */ :
		if objc != 4 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+8951 /* "var value" */)
			return TCL_ERROR
		}
		string = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
		if (*struct {
			f func(*libc.TLS, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_init})).f(tls, bp+64 /* &bignumValue */) != MP_OKAY {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+8961 /* "error in mp_init" */, -1))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_read_radix})).f(tls, bp+64 /* &bignumValue */, string, 10) != MP_OKAY {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+8978 /* "error in mp_read..." */, -1))
			return TCL_ERROR
		}

		// If the object currently bound to the variable with index varIndex
		// has ref count 1 (i.e. the object is unshared) we can modify that
		// object directly.  Otherwise, if RC>1 (i.e. the object is shared),
		// we must create a new object to modify/set and decrement the old
		// formerly-shared object's ref count. This is "copy on write".

		if (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+64 /* &bignumValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+64 /* &bignumValue */))
		}
		break

	case 1 /* BIGNUM_GET */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		break

	case 2 /* BIGNUM_MULT10 */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != TCL_OK {
			return TCL_ERROR
		}
		if ((*struct {
			f func(*libc.TLS, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_init})).f(tls, bp+88 /* &newValue */) != MP_OKAY) ||
			((*struct {
				f func(*libc.TLS, uintptr, mp_digit, uintptr) mp_err
			})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_mul_d})).f(tls, bp+64 /* &bignumValue */, uint32(10), bp+88 /* &newValue */) != MP_OKAY) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+88 /* &newValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9010 /* "error in mp_mul_..." */, -1))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+88 /* &newValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+88 /* &newValue */))
		}
		break

	case 3 /* BIGNUM_DIV10 */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != TCL_OK {
			return TCL_ERROR
		}
		if ((*struct {
			f func(*libc.TLS, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_init})).f(tls, bp+88 /* &newValue */) != MP_OKAY) ||
			((*struct {
				f func(*libc.TLS, uintptr, mp_digit, uintptr, uintptr) mp_err
			})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_div_d})).f(tls, bp+64 /* &bignumValue */, uint32(10), bp+88 /* &newValue */, uintptr(0)) != MP_OKAY) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+88 /* &newValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9028 /* "error in mp_div_..." */, -1))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+88 /* &newValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+88 /* &newValue */))
		}
		break

	case 4 /* BIGNUM_ISEVEN */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != TCL_OK {
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), libc.BoolInt32(!(func() int32 {
				if ((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).used != 0) && ((*(*mp_digit)(unsafe.Pointer((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).dp)) & mp_digit(1)) == mp_digit(1)) {
					return MP_YES
				}
				return MP_NO
			}() != 0)))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, libc.BoolInt32(!(func() int32 {
				if ((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).used != 0) && ((*(*mp_digit)(unsafe.Pointer((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).dp)) & mp_digit(1)) == mp_digit(1)) {
					return MP_YES
				}
				return MP_NO
			}() != 0))))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		break

	case 5 /* BIGNUM_RADIXSIZE */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_radix_size})).f(tls, bp+64 /* &bignumValue */, 10, bp+56 /* &index */) != MP_OKAY {
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 56 /* index */)))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 56 /* index */))))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		break
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbooleanobjCmd --
//
//	This function implements the "testbooleanobj" command.  It is used to
//	test the boolean Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees boolean objects, and also converts objects to
//	have boolean type.
//
//----------------------------------------------------------------------

func TestbooleanobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:347:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var varIndex int32 at bp+32, 4

	// var boolValue int32 at bp+36, 4

	var index uintptr
	var subCmd uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9046 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	varPtr = GetVarPtr(tls, interp)

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4002 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+36 /* &boolValue */) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared),
	// we must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (libc.Bool32((*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */))) != 0)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (libc.Bool32((*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */))) != 0))))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+1371 /* "get" */) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+9067 /* "not" */) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __16
	}
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+36 /* &boolValue */) != TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (libc.Bool32((libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0))) != 0)))
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (libc.Bool32((libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0))) != 0))))
__19:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1254 /* "bad option \"" */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9071 /* "\": must be set, ..." */, uintptr(0)))
	return TCL_ERROR
__14:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestdoubleobjCmd --
//
//	This function implements the "testdoubleobj" command.  It is used to
//	test the double-precision floating point Tcl object type
//	implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees double objects, and also converts objects to
//	have double type.
//
//----------------------------------------------------------------------

func TestdoubleobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:447:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var varIndex int32 at bp+32, 4

	// var doubleValue float64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9046 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)

	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4002 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, string, bp+40 /* &doubleValue */) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+1371 /* "get" */) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+8904 /* "mult10" */) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __16
	}
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+40 /* &doubleValue */) != TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)) * 10.0))
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))*10.0)))
__19:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	if !(libc.Xstrcmp(tls, subCmd, ts+8911 /* "div10" */) == 0) {
		goto __20
	}
	if !(objc != 3) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+40 /* &doubleValue */) != TCL_OK) {
		goto __24
	}
	return TCL_ERROR
__24:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)) / 10.0))
	goto __26
__25:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))/10.0)))
__26:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __21
__20:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1254 /* "bad option \"" */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9099 /* "\": must be set, ..." */, uintptr(0)))
	return TCL_ERROR
__21:
	;
__14:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestindexobjCmd --
//
//	This function implements the "testindexobj" command. It is used to
//	test the index Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestindexobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:565:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var allowAbbrev int32 at bp+12, 4

	// var index int32 at bp+4, 4

	// var index2 int32 at bp, 4

	// var setError int32 at bp+8, 4

	var i int32
	var result int32
	var argv uintptr
	var indexRep uintptr

	if (objc == 3) && (libc.Xstrcmp(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
		ts+9137 /* "check" */) == 0) {
		// This code checks to be sure that the results of Tcl_GetIndexFromObj
		// are properly cached in the object and returned on subsequent
		// lookups.

		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &index2 */) != TCL_OK {
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(unsafe.Sizeof(uintptr(0))), ts+9143 /* "token" */, 0, bp+4 /* &index */)
		indexRep = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32 /* &.internalRep */ /* &.twoPtrValue */ /* &.ptr1 */))
		(*IndexRep)(unsafe.Pointer(indexRep)).index = *(*int32)(unsafe.Pointer(bp /* index2 */))
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(unsafe.Sizeof(uintptr(0))), ts+9143 /* "token" */, 0, bp+4 /* &index */)
		if result == TCL_OK {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
		}
		return result
	}

	if objc < 5 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+1192 /* "wrong # args" */, -1)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8 /* &setError */) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+12 /* &allowAbbrev */) != TCL_OK {
		return TCL_ERROR
	}

	argv = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32((uint64(objc - 3)) * uint64(unsafe.Sizeof(uintptr(0))))))
	for i = 4; i < objc; i++ {
		*(*uintptr)(unsafe.Pointer(argv + uintptr((i-4))*8)) = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	}
	*(*uintptr)(unsafe.Pointer(argv + uintptr((objc-4))*8)) = uintptr(0)

	// Tcl_GetIndexFromObj assumes that the table is statically-allocated so
	// that its address is different for each index object. If we accidently
	// allocate a table at the same address as that cached in the index
	// object, clear out the object's cached state.

	if ((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr != (uintptr(0))) &&
		!(libc.Xstrcmp(tls, ts+9149 /* "index" */, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr)).name) != 0) {
		indexRep = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)) + 32 /* &.internalRep */ /* &.twoPtrValue */ /* &.ptr1 */))
		if (*IndexRep)(unsafe.Pointer(indexRep)).tablePtr == argv {
			if (*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + 3*8))))).typePtr != (uintptr(0)) {
				if (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + 3*8))))).typePtr)).freeIntRepProc != (uintptr(0)) {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + 3*8))))).typePtr)).freeIntRepProc})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
				}
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr = uintptr(0)
			}

		}
	}

	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 8 /* setError */)) != 0 {
			return interp
		}
		return uintptr(0)
	}(), *(*uintptr)(unsafe.Pointer(objv + 3*8)), argv, int32(unsafe.Sizeof(uintptr(0))), ts+9143 /* "token" */, func() int32 {
		if *(*int32)(unsafe.Pointer(bp + 12 /* allowAbbrev */)) != 0 {
			return 0
		}
		return TCL_EXACT
	}(), bp+4 /* &index */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, argv)
	if result == TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
	}
	return result
}

// Keep this structure declaration in sync with tclIndexObj.c
type IndexRep = struct {
	tablePtr uintptr
	offset   int32
	index    int32
} /* tclTestObj.c:577:5 */

var tablePtr = [4]uintptr{ts + 5738 /* "a" */, ts + 7253 /* "b" */, ts + 9137 /* "check" */, uintptr(0)} /* tclTestObj.c:573:23 */

//----------------------------------------------------------------------
//
// TestintobjCmd --
//
//	This function implements the "testintobj" command. It is used to
//	test the int Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestintobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:668:1: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var intValue int32 at bp+48, 4

	// var varIndex int32 at bp+32, 4

	// var i int32 at bp+36, 4

	// var longValue int64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr
	var maxLong int64

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9046 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4002 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36 /* &i */) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+9155 /* "set2" */) == 0) {
		goto __9
	} // doesn't set result
	if !(objc != 4) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36 /* &i */) != TCL_OK) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __13
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __14
__13:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__14:
	;
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+9160 /* "setlong" */) == 0) {
		goto __15
	}
	if !(objc != 4) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36 /* &i */) != TCL_OK) {
		goto __18
	}
	return TCL_ERROR
__18:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __19
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
	goto __20
__19:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))))
__20:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __16
__15:
	if !(libc.Xstrcmp(tls, subCmd, ts+9168 /* "setmaxlong" */) == 0) {
		goto __21
	}
	maxLong = 0x7fffffffffffffff
	if !(objc != 3) {
		goto __23
	}
	goto wrongNumArgs
__23:
	;
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __24
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), maxLong)
	goto __25
__24:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, maxLong))
__25:
	;
	goto __22
__21:
	if !(libc.Xstrcmp(tls, subCmd, ts+9179 /* "ismaxlong" */) == 0) {
		goto __26
	}
	if !(objc != 3) {
		goto __28
	}
	goto wrongNumArgs
__28:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __29
	}
	return TCL_ERROR
__29:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetLongFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), bp+40 /* &longValue */) != TCL_OK) {
		goto __30
	}
	return TCL_ERROR
__30:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		func() uintptr {
			if *(*int64)(unsafe.Pointer(bp + 40 /* longValue */)) == 0x7fffffffffffffff {
				return ts + 6529 /* "1" */
			}
			return ts + 6531 /* "0" */
		}(), -1)
	goto __27
__26:
	if !(libc.Xstrcmp(tls, subCmd, ts+1371 /* "get" */) == 0) {
		goto __31
	}
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __34
	}
	return TCL_ERROR
__34:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __32
__31:
	if !(libc.Xstrcmp(tls, subCmd, ts+9189 /* "get2" */) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), string, -1)
	goto __36
__35:
	if !(libc.Xstrcmp(tls, subCmd, ts+9194 /* "inttoobigtest" */) == 0) {
		goto __39
	}
	// If long ints have more bits than ints on this platform, verify that
	// Tcl_GetIntFromObj returns an error if the long int held in an
	// integer object's internal representation is too large to fit in an
	// int.

	if !(objc != 3) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __42
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), 0x7fffffffffffffff)
	goto __43
__42:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, 0x7fffffffffffffff))
__43:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), bp+36 /* &i */) != TCL_OK) {
		goto __44
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+6529 /* "1" */, -1)
	return TCL_OK
__44:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+6531 /* "0" */, -1)
	goto __40
__39:
	if !(libc.Xstrcmp(tls, subCmd, ts+8904 /* "mult10" */) == 0) {
		goto __45
	}
	if !(objc != 3) {
		goto __47
	}
	goto wrongNumArgs
__47:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __48
	}
	return TCL_ERROR
__48:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+48 /* &intValue */) != TCL_OK) {
		goto __49
	}
	return TCL_ERROR
__49:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __50
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) * 10))
	goto __51
__50:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))*10)))
__51:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __46
__45:
	if !(libc.Xstrcmp(tls, subCmd, ts+8911 /* "div10" */) == 0) {
		goto __52
	}
	if !(objc != 3) {
		goto __54
	}
	goto wrongNumArgs
__54:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __55
	}
	return TCL_ERROR
__55:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+48 /* &intValue */) != TCL_OK) {
		goto __56
	}
	return TCL_ERROR
__56:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __57
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) / 10))
	goto __58
__57:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))/10)))
__58:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __53
__52:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1254 /* "bad option \"" */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9208 /* "\": must be set, ..." */, uintptr(0)))
	return TCL_ERROR
__53:
	;
__46:
	;
__40:
	;
__36:
	;
__32:
	;
__27:
	;
__22:
	;
__16:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//-----------------------------------------------------------------------------
//
// TestlistobjCmd --
//
//	This function implements the 'testlistobj' command. It is used to
//	test a few possible corner cases in list object manipulation from
//	C code that cannot occur at the Tcl level.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates, manipulates and frees list objects.
//
//-----------------------------------------------------------------------------

func TestlistobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:872:1: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// Subcommands supported by this command
	*(*[3]uintptr)(unsafe.Pointer(bp + 8 /* subcommands */)) = [3]uintptr{
		ts + 4002, /* "set" */
		ts + 1371, /* "get" */
		ts + 9252, /* "replace" */
	}
	var index uintptr // Argument giving the variable number
	// var varIndex int32 at bp, 4
	// Variable number converted to binary
	// var cmdIndex int32 at bp+32, 4
	// Ordinal number of the subcommand
	// var first int32 at bp+36, 4
	// First index in the list
	// var count int32 at bp+40, 4
	// Count of elements in a list
	var varPtr uintptr

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9260 /* "option arg ?arg...." */)
		return TCL_ERROR
	}
	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if GetVariableIndex(tls, interp, index, bp /* &varIndex */) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8 /* &subcommands[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+4432 /* "command" */, 0, bp+32 /* &cmdIndex */) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* cmdIndex */)) {
	case 0 /* LISTOBJ_SET */ :
		if (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetListObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), (objc - 3), (objv + uintptr(3)*8))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*struct {
				f func(*libc.TLS, int32, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, (objc-3), (objv+uintptr(3)*8)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case 1 /* LISTOBJ_GET */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9001 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */))) != 0 {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case 2 /* LISTOBJ_REPLACE */ :
		if objc < 5 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv,
				ts+9280 /* "varIndex start c..." */)
			return TCL_ERROR
		}
		if ((*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+36 /* &first */) != TCL_OK) ||
			((*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+40 /* &count */) != TCL_OK) {
			return TCL_ERROR
		}
		if (*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))).refCount > 1 {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjReplace})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 36 /* first */)), *(*int32)(unsafe.Pointer(bp + 40 /* count */)),
			(objc - 5), (objv + uintptr(5)*8))
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestobjCmd --
//
//	This function implements the "testobj" command. It is used to test
//	the type-independent portions of the Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees objects.
//
//----------------------------------------------------------------------

func TestobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:969:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var varIndex int32 at bp+64, 4

	// var destIndex int32 at bp+68, 4

	var i int32
	var index uintptr
	var subCmd uintptr
	var string uintptr
	var targetType uintptr
	var varPtr uintptr
	var listObjPtr uintptr
	// var elemObjPtr uintptr at bp+72, 8

	var typeName uintptr
	var _objPtr uintptr
	var typeName1 uintptr

	if !(objc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9046 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+9314 /* "assign" */) == 0) {
		goto __2
	}
	if !(objc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68 /* &destIndex */) != TCL_OK) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, subCmd, ts+9321 /* "bug3598580" */) == 0) {
		goto __8
	}
	if !(objc != 2) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	*(*uintptr)(unsafe.Pointer(bp + 72 /* elemObjPtr */)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 123)
	listObjPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 1, bp+72 /* &elemObjPtr */)
	// Replace the single list element through itself, nonsense but legal.
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjReplace})).f(tls, interp, listObjPtr, 0, 1, 1, bp+72 /* &elemObjPtr */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, listObjPtr)
	return TCL_OK
	goto __9
__8:
	if !(libc.Xstrcmp(tls, subCmd, ts+9332 /* "convert" */) == 0) {
		goto __11
	}

	if !(objc != 4) {
		goto __13
	}
	goto wrongNumArgs
__13:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __14
	}
	return TCL_ERROR
__14:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __15
	}
	return TCL_ERROR
__15:
	;
	typeName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((libc.AssignUintptr(&targetType, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, typeName))) == (uintptr(0))) {
		goto __16
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+9340 /* "no type " */, typeName, ts+9349 /* " found" */, uintptr(0)))
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)), targetType) !=
		TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __12
__11:
	if !(libc.Xstrcmp(tls, subCmd, ts+9356 /* "duplicate" */) == 0) {
		goto __18
	}
	if !(objc != 4) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __21
	}
	return TCL_ERROR
__21:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __22
	}
	return TCL_ERROR
__22:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68 /* &destIndex */) != TCL_OK) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __19
__18:
	if !(libc.Xstrcmp(tls, subCmd, ts+9366 /* "freeallvars" */) == 0) {
		goto __24
	}
	if !(objc != 2) {
		goto __26
	}
	goto wrongNumArgs
__26:
	;
	i = 0
__27:
	if !(i < NUMBER_OF_OBJECT_VARS) {
		goto __29
	}
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != (uintptr(0))) {
		goto __30
	}
__31:
	_objPtr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8))
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1) {
		goto __34
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
__34:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = uintptr(0)
__30:
	;
	goto __28
__28:
	i++
	goto __27
	goto __29
__29:
	;
	goto __25
__24:
	if !(libc.Xstrcmp(tls, subCmd, ts+9378 /* "invalidateString..." */) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __39
	}
	return TCL_ERROR
__39:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InvalidateStringRep})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __36
__35:
	if !(libc.Xstrcmp(tls, subCmd, ts+9398 /* "newobj" */) == 0) {
		goto __40
	}
	if !(objc != 3) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __43
	}
	return TCL_ERROR
__43:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __41
__40:
	if !(libc.Xstrcmp(tls, subCmd, ts+9405 /* "objtype" */) == 0) {
		goto __44
	}

	// Return an object containing the name of the argument's type of
	// internal rep. If none exists, return "none".

	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 2*8)))).typePtr == (uintptr(0))) {
		goto __47
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6348 /* "none" */, -1))
	goto __48
__47:
	typeName1 = (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 2*8)))).typePtr)).name
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, typeName1, -1))
__48:
	;
	goto __45
__44:
	if !(libc.Xstrcmp(tls, subCmd, ts+6542 /* "refcount" */) == 0) {
		goto __49
	}
	if !(objc != 3) {
		goto __51
	}
	goto wrongNumArgs
__51:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __52
	}
	return TCL_ERROR
__52:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __53
	}
	return TCL_ERROR
__53:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).refCount))
	goto __50
__49:
	if !(libc.Xstrcmp(tls, subCmd, ts+6551 /* "type" */) == 0) {
		goto __54
	}
	if !(objc != 3) {
		goto __56
	}
	goto wrongNumArgs
__56:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != TCL_OK) {
		goto __57
	}
	return TCL_ERROR
__57:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __58
	}
	return TCL_ERROR
__58:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).typePtr == (uintptr(0))) {
		goto __59
	} // a string!
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+3944 /* "string" */, -1)
	goto __60
__59:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		(*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).typePtr)).name, -1)
__60:
	;
	goto __55
__54:
	if !(libc.Xstrcmp(tls, subCmd, ts+9413 /* "types" */) == 0) {
		goto __61
	}
	if !(objc != 2) {
		goto __63
	}
	goto wrongNumArgs
__63:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendAllObjTypes})).f(tls, interp,
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)) != TCL_OK) {
		goto __64
	}
	return TCL_ERROR
__64:
	;
	goto __62
__61:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp+32, ts+1254 /* "bad option \"" */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),

			ts+9419 /* "\": must be assig..." */, uintptr(0)))
	return TCL_ERROR
__62:
	;
__55:
	;
__50:
	;
__45:
	;
__41:
	;
__36:
	;
__25:
	;
__19:
	;
__12:
	;
__9:
	;
__3:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TeststringobjCmd --
//
//	This function implements the "teststringobj" command. It is used to
//	test the string Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees string objects, and also converts objects to
//	have string type.
//
//----------------------------------------------------------------------

func TeststringobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:1173:1: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var unicode uintptr
	// var varIndex int32 at bp+96, 4

	// var option int32 at bp+100, 4

	// var i int32 at bp+208, 4

	// var length int32 at bp+104, 4

	var index uintptr
	var string uintptr
	// var strings [12]uintptr at bp+112, 96

	var strPtr uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9046 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+96 /* &varIndex */) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&options2)), int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp+100 /* &option */) !=
		TCL_OK) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	switch *(*int32)(unsafe.Pointer(bp + 100 /* option */)) {
	case 0:
		goto __5
	case 1:
		goto __6
	case 2:
		goto __7
	case 3:
		goto __8
	case 4:
		goto __9
	case 5:
		goto __10
	case 6:
		goto __11
	case 7:
		goto __12
	case 8:
		goto __13
	case 9:
		goto __14
	case 10:
		goto __15
	case 11:
		goto __16
	case 12:
		goto __17
	}
	goto __4
__5: // append
	if !(objc != 5) {
		goto __18
	}
	goto wrongNumArgs
__18:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+104 /* &length */) != TCL_OK) {
		goto __19
	}
	return TCL_ERROR
__19:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __20
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__20:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __21
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__21:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__6: // appendstrings
	if !(objc > (MAX_STRINGS + 3)) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __23
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__23:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __24
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__24:
	;
	*(*int32)(unsafe.Pointer(bp + 208 /* i */)) = 3
__25:
	if !(*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < objc) {
		goto __27
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + uintptr((*(*int32)(unsafe.Pointer(bp + 208 /* i */))-3))*8)) = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*8)))
	goto __26
__26:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __25
	goto __27
__27:
	;
__28:
	if !(*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < (12 + 3)) {
		goto __30
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + uintptr((*(*int32)(unsafe.Pointer(bp + 208 /* i */))-3))*8)) = uintptr(0)
	goto __29
__29:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __28
	goto __30
__30:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 1*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 2*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 3*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 4*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 5*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 6*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 7*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 8*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 9*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 10*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 11*8))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__7: // get
	if !(objc != 3) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */))) != 0) {
		goto __32
	}
	return TCL_ERROR
__32:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__8: // get2
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */))) != 0) {
		goto __34
	}
	return TCL_ERROR
__34:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), string, -1)
	goto __4
__9: // length
	if !(objc != 3) {
		goto __35
	}
	goto wrongNumArgs
__35:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), func() int32 {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0)) {
			return (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))).length
		}
		return -1
	}())
	goto __4
__10: // length2
	if !(objc != 3) {
		goto __36
	}
	goto wrongNumArgs
__36:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __37
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+3944 /* "string" */))
	strPtr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) + 32 /* &.internalRep */ /* &.twoPtrValue */ /* &.ptr1 */))
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).allocated
	goto __38
__37:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__38:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__11: // set
	if !(objc != 4) {
		goto __39
	}
	goto wrongNumArgs
__39:
	;

	// If the object currently bound to the variable with index
	// varIndex has ref count 1 (i.e. the object is unshared) we can
	// modify that object directly. Otherwise, if RC>1 (i.e. the
	// object is shared), we must create a new object to modify/set
	// and decrement the old formerly-shared object's ref count. This
	// is "copy on write".

	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+104 /* &length */)
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) &&
		!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1)) {
		goto __40
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __41
__40:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, string, *(*int32)(unsafe.Pointer(bp + 104 /* length */))))
__41:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__12: // set2
	if !(objc != 4) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	goto __4
__13: // setlength
	if !(objc != 4) {
		goto __43
	}
	goto wrongNumArgs
__43:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+104 /* &length */) != TCL_OK) {
		goto __44
	}
	return TCL_ERROR
__44:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __45
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjLength})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
__45:
	;
	goto __4
__14: // maxchars
	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __47
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+3944 /* "string" */))
	strPtr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) + 32 /* &.internalRep */ /* &.twoPtrValue */ /* &.ptr1 */))
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).maxChars
	goto __48
__47:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__48:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__15: // getunicode
	if !(objc != 3) {
		goto __49
	}
	goto wrongNumArgs
__49:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetUnicodeFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), uintptr(0))
	goto __4
__16: // appendself
	if !(objc != 4) {
		goto __50
	}
	goto wrongNumArgs
__50:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __51
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__51:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __52
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__52:
	;

	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+208 /* &i */) != TCL_OK) {
		goto __53
	}
	return TCL_ERROR
__53:
	;
	if !((*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 208 /* i */)) > *(*int32)(unsafe.Pointer(bp + 104 /* length */)))) {
		goto __54
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
		ts+9523 /* "index value out ..." */, -1))
	return TCL_ERROR
__54:
	;

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), (string + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))), (*(*int32)(unsafe.Pointer(bp + 104 /* length */)) - *(*int32)(unsafe.Pointer(bp + 208 /* i */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__17: // appendself2
	if !(objc != 4) {
		goto __55
	}
	goto wrongNumArgs
__55:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __56
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__56:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __57
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__57:
	;

	unicode = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetUnicodeFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+208 /* &i */) != TCL_OK) {
		goto __58
	}
	return TCL_ERROR
__58:
	;
	if !((*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 208 /* i */)) > *(*int32)(unsafe.Pointer(bp + 104 /* length */)))) {
		goto __59
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
		ts+9523 /* "index value out ..." */, -1))
	return TCL_ERROR
__59:
	;

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendUnicodeToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), (unicode + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*2), (*(*int32)(unsafe.Pointer(bp + 104 /* length */)) - *(*int32)(unsafe.Pointer(bp + 208 /* i */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__4:
	;

	return TCL_OK
}

var options2 = [14]uintptr{
	ts + 2355 /* "append" */, ts + 9548 /* "appendstrings" */, ts + 1371 /* "get" */, ts + 9189 /* "get2" */, ts + 3095 /* "length" */, ts + 9562, /* "length2" */
	ts + 4002 /* "set" */, ts + 9155 /* "set2" */, ts + 9570 /* "setlength" */, ts + 9580 /* "maxchars" */, ts + 9589, /* "getunicode" */
	ts + 9600 /* "appendself" */, ts + 9611 /* "appendself2" */, uintptr(0),
} /* tclTestObj.c:1185:23 */

//----------------------------------------------------------------------
//
// SetVarToObj --
//
//	Utility routine to assign a Tcl_Obj* to a test variable. The
//	Tcl_Obj* can be NULL.
//
// Results:
//	None.
//
// Side effects:
//	This routine handles ref counting details for assignment: i.e. the old
//	value's ref count must be decremented (if not NULL) and the new one
//	incremented (also if not NULL).
//
//----------------------------------------------------------------------

func SetVarToObj(tls *libc.TLS, varPtr uintptr, varIndex int32, objPtr uintptr) { /* tclTestObj.c:1446:1: */
	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) != (uintptr(0)) {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) = objPtr
	if objPtr != (uintptr(0)) {
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).refCount++
	}
}

//----------------------------------------------------------------------
//
// GetVariableIndex --
//
//	Utility routine to get a test variable index from the command line.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func GetVariableIndex(tls *libc.TLS, interp uintptr, string uintptr, indexPtr uintptr) int32 { /* tclTestObj.c:1477:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp /* &index */) != TCL_OK {
		return TCL_ERROR
	}
	if (*(*int32)(unsafe.Pointer(bp /* index */)) < 0) || (*(*int32)(unsafe.Pointer(bp /* index */)) >= NUMBER_OF_OBJECT_VARS) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+9623 /* "bad variable ind..." */, -1)
		return TCL_ERROR
	}

	*(*int32)(unsafe.Pointer(indexPtr)) = *(*int32)(unsafe.Pointer(bp /* index */))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// CheckIfVarUnset --
//
//	Utility function that checks whether a test variable is readable:
//	i.e., that varPtr[varIndex] is non-NULL.
//
// Results:
//	1 if the test variable is unset (NULL); 0 otherwise.
//
// Side effects:
//	Sets the interpreter result to an error message if the variable is
//	unset (NULL).
//
//----------------------------------------------------------------------

func CheckIfVarUnset(tls *libc.TLS, interp uintptr, varPtr uintptr, varIndex int32) int32 { /* tclTestObj.c:1518:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) == (uintptr(0)) {
		// var buf [56]int8 at bp+8, 56

		libc.Xsprintf(tls, bp+8 /* &buf[0] */, ts+9642 /* "variable %d is u..." */, libc.VaList(bp, varIndex))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), bp+8 /* &buf[0] */, -1)
		return 1
	}
	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// name and version of this package

var packageName = *(*[13]int8)(unsafe.Pointer(ts + 9670 /* "procbodytest" */)) /* tclTestProcBodyObj.c:23:19 */
var packageVersion = *(*[4]int8)(unsafe.Pointer(ts + 9683 /* "1.1" */))        /* tclTestProcBodyObj.c:24:19 */

// Name of the commands exported by this package

var procCommand = *(*[5]int8)(unsafe.Pointer(ts + 9687 /* "proc" */))   /* tclTestProcBodyObj.c:30:19 */
var checkCommand = *(*[6]int8)(unsafe.Pointer(ts + 9137 /* "check" */)) /* tclTestProcBodyObj.c:31:19 */

// this struct describes an entry in the table of command names and command
// procs

type CmdTable1 = struct {
	cmdName  uintptr
	proc     uintptr
	exportIt int32
	_        [4]byte
} /* tclTestProcBodyObj.c:38:9 */

// this struct describes an entry in the table of command names and command
// procs

type CmdTable = CmdTable1 /* tclTestProcBodyObj.c:42:3 */

// List of commands to create when the package is loaded; must go after the
// declarations of the enable command procedure.

var commands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{},
} /* tclTestProcBodyObj.c:61:23 */

var safeCommands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{},
} /* tclTestProcBodyObj.c:67:23 */

//----------------------------------------------------------------------
//
// Procbodytest_Init --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:90:1: */
	return ProcBodyTestInitInternal(tls, interp, 0)
}

//----------------------------------------------------------------------
//
// Procbodytest_SafeInit --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:114:1: */
	return ProcBodyTestInitInternal(tls, interp, 1)
}

//----------------------------------------------------------------------
//
// RegisterCommand --
//
//	This function registers a command in the context of the given
//	namespace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func RegisterCommand(tls *libc.TLS, interp uintptr, namespace uintptr, cmdTablePtr uintptr) int32 { /* tclTestProcBodyObj.c:139:1: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	// var buf [128]int8 at bp+32, 128

	if (*CmdTable)(unsafe.Pointer(cmdTablePtr)).exportIt != 0 {
		libc.Xsprintf(tls, bp+32 /* &buf[0] */, ts+9692, /* "namespace eval %..." */
			libc.VaList(bp, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, bp+32 /* &buf[0] */, -1, 0) != TCL_OK {
			return TCL_ERROR
		}
	}

	libc.Xsprintf(tls, bp+32 /* &buf[0] */, ts+9734 /* "%s::%s" */, libc.VaList(bp+16, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, bp+32 /* &buf[0] */, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).proc, uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// ProcBodyTestInitInternal --
//
//  This function initializes the Loader package.
//  The isSafe flag is 1 if the interpreter is safe, 0 otherwise.
//
// Results:
//  A standard Tcl result.
//
// Side effects:
//  None.
//
//----------------------------------------------------------------------

func ProcBodyTestInitInternal(tls *libc.TLS, interp uintptr, isSafe int32) int32 { /* tclTestProcBodyObj.c:179:1: */
	var cmdTablePtr uintptr

	if isSafe != 0 {
		cmdTablePtr = (uintptr(unsafe.Pointer(&safeCommands)))
	} else {
		cmdTablePtr = (uintptr(unsafe.Pointer(&commands)))
	}
	for ; (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName != 0; cmdTablePtr += 24 {
		if RegisterCommand(tls, interp, uintptr(unsafe.Pointer(&packageName)), cmdTablePtr) != TCL_OK {
			return TCL_ERROR
		}
	}

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgProvideEx})).f(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), uintptr(0))
}

//----------------------------------------------------------------------
//
// ProcBodyTestProcObjCmd --
//
//  Implements the "procbodytest::proc" command. Here is the command
//  description:
//	procbodytest::proc newName argList bodyName
//  Looks up a procedure called $bodyName and, if the procedure exists,
//  constructs a Tcl_Obj of type "procbody" and calls Tcl_ProcObjCmd.
//  Arguments:
//    newName		the name of the procedure to be created
//    argList		the argument list for the procedure
//    bodyName		the name of an existing procedure from which the
//			body is to be copied.
//  This command can be used to trigger the branches in Tcl_ProcObjCmd that
//  construct a proc from a "procbody", for example:
//	proc a {x} {return $x}
//	a 123
//	procbodytest::proc b {x} a
//  Note the call to "a 123", which is necessary so that the Proc pointer
//  for "a" is filled in by the internal compiler; this is a hack.
//
// Results:
//  Returns a standard Tcl code.
//
// Side effects:
//  A new procedure is created.
//  Leaves an error message in the interp's result on error.
//
//----------------------------------------------------------------------

func ProcBodyTestProcObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:230:1: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var fullName uintptr
	var procCmd Tcl_Command
	var cmdPtr uintptr
	var procPtr uintptr = uintptr(0)
	var bodyObjPtr uintptr
	// var myobjv [5]uintptr at bp+96, 40

	var result int32

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9741 /* "newName argsList..." */)
		return TCL_ERROR
	}

	// Find the Command pointer to this procedure

	fullName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	procCmd = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, fullName, uintptr(0), TCL_LEAVE_ERR_MSG)
	if procCmd == (uintptr(0)) {
		return TCL_ERROR
	}

	cmdPtr = procCmd

	// check that this is a procedure and not a builtin command:
	// If a procedure, cmdPtr->objClientData is TclIsProc(cmdPtr).

	if (*Command)(unsafe.Pointer(cmdPtr)).objClientData != (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclIsProc})).f(tls, cmdPtr) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
			libc.VaList(bp, ts+9767 /* "command \"" */, fullName, ts+9777 /* "\" is not a Tcl p..." */, uintptr(0)))
		return TCL_ERROR
	}

	// it is a Tcl procedure: the client data is the Proc structure

	procPtr = (*Command)(unsafe.Pointer(cmdPtr)).objClientData
	if procPtr == (uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), libc.VaList(bp+32, ts+9802, /* "procedure \"" */
			fullName, ts+9814 /* "\" does not have ..." */, uintptr(0)))
		return TCL_ERROR
	}

	// create a new object, initialize our argument vector, call into Tcl

	bodyObjPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclNewProcBodyObj})).f(tls, procPtr)
	if bodyObjPtr == (uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
			libc.VaList(bp+64, ts+9845, /* "failed to create..." */
				fullName, ts+1640 /* "\"" */, uintptr(0)))
		return TCL_ERROR
	}
	(*Tcl_Obj)(unsafe.Pointer(bodyObjPtr)).refCount++

	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv[0] */)) = *(*uintptr)(unsafe.Pointer(objv))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv[0] */ + 1*8)) = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv[0] */ + 2*8)) = *(*uintptr)(unsafe.Pointer(objv + 2*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv[0] */ + 3*8)) = bodyObjPtr
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv[0] */ + 4*8)) = uintptr(0)

	result = (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ProcObjCmd})).f(tls, uintptr(0), interp, objc, bp+96 /* &myobjv[0] */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = bodyObjPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	return result
}

//----------------------------------------------------------------------
//
// ProcBodyTestCheckObjCmd --
//
//  Implements the "procbodytest::check" command. Here is the command
//  description:
//	procbodytest::check
//
//  Performs an internal check that the Tcl_PkgPresent() command returns
//  the same version number as was registered when the procbodytest package
//  was provided.  Places a boolean in the interp result indicating the
//  test outcome.
//
// Results:
//  Returns a standard Tcl code.
//
//----------------------------------------------------------------------

func ProcBodyTestCheckObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:329:1: */
	var version uintptr

	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1318 /* "" */)
		return TCL_ERROR
	}

	version = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgPresentEx})).f(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), 1, uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (libc.Bool32((libc.Bool32(libc.Xstrcmp(tls, version, uintptr(unsafe.Pointer(&packageVersion))) == 0)) != 0))))
	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Each thread has an single instance of the following structure. There is one
// instance of this structure per thread even if that thread contains multiple
// interpreters. The interpreter identified by this structure is the main
// interpreter for the thread.
//
// The main interpreter is the one that will process any messages received by
// a thread. Any thread can send messages but only the main interpreter can
// receive them.

type ThreadSpecificData1 = struct {
	threadId Tcl_ThreadId
	interp   uintptr
	flags    int32
	_        [4]byte
	nextPtr  uintptr
	prevPtr  uintptr
} /* tclThreadTest.c:33:9 */

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Each thread has an single instance of the following structure. There is one
// instance of this structure per thread even if that thread contains multiple
// interpreters. The interpreter identified by this structure is the main
// interpreter for the thread.
//
// The main interpreter is the one that will process any messages received by
// a thread. Any thread can send messages but only the main interpreter can
// receive them.

type ThreadSpecificData = ThreadSpecificData1 /* tclThreadTest.c:41:3 */
var dataKey Tcl_ThreadDataKey                 /* tclThreadTest.c:42:26: */

// This list is used to list all threads that have interpreters. This is
// protected by threadMutex.

var threadList uintptr = uintptr(0) /* tclThreadTest.c:49:27 */

// The following bit-values are legal for the "flags" field of the
// ThreadSpecificData structure.

// An instance of the following structure contains all information that is
// passed into a new thread when the thread is created using either the
// "thread create" Tcl command or the ThreadCreate() C function.

type ThreadCtrl1 = struct {
	script   uintptr
	flags    int32
	_        [4]byte
	condWait Tcl_Condition
} /* tclThreadTest.c:64:9 */

// The following bit-values are legal for the "flags" field of the
// ThreadSpecificData structure.

// An instance of the following structure contains all information that is
// passed into a new thread when the thread is created using either the
// "thread create" Tcl command or the ThreadCreate() C function.

type ThreadCtrl = ThreadCtrl1 /* tclThreadTest.c:77:3 */

// This is the event used to send scripts to other threads.

type ThreadEvent1 = struct {
	event     Tcl_Event
	script    uintptr
	resultPtr uintptr
} /* tclThreadTest.c:83:9 */

// This is the event used to send scripts to other threads.

type ThreadEventResult1 = struct {
	done        Tcl_Condition
	code        int32
	_           [4]byte
	result      uintptr
	errorInfo   uintptr
	errorCode   uintptr
	srcThreadId Tcl_ThreadId
	dstThreadId Tcl_ThreadId
	eventPtr    uintptr
	nextPtr     uintptr
	prevPtr     uintptr
} /* tclThreadTest.c:83:9 */

// This is the event used to send scripts to other threads.

type ThreadEvent = ThreadEvent1 /* tclThreadTest.c:89:3 */

type ThreadEventResult = ThreadEventResult1 /* tclThreadTest.c:103:3 */

var resultList uintptr /* tclThreadTest.c:105:26: */

// This is for simple error handling when a thread script exits badly.

var mainThreadId Tcl_ThreadId  /* tclThreadTest.c:111:21: */
var errorThreadId Tcl_ThreadId /* tclThreadTest.c:112:21: */
var errorProcString uintptr    /* tclThreadTest.c:113:13: */

// Access to the list of threads and to the thread send results is guarded by
// this mutex.

var threadMutex Tcl_Mutex /* tclThreadTest.c:120:1: */

//----------------------------------------------------------------------
//
// TclThread_Init --
//
//	Initialize the test thread command.
//
// Results:
//	TCL_OK if the package was properly initialized.
//
// Side effects:
//	Add the "testthread" command to the interp.
//
//----------------------------------------------------------------------

func TclThread_Init(tls *libc.TLS, interp uintptr) int32 { /* tclThreadTest.c:161:1: */
	// If the main thread Id has not been set, do it now.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	if mainThreadId == uintptr(0) {
		mainThreadId = (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9896 /* "testthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{ThreadObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// ThreadObjCmd --
//
//	This procedure is invoked to process the "testthread" Tcl command. See
//	the user documentation for details on what it does.
//
//	thread cancel ?-unwind? id ?result?
//	thread create ?-joinable? ?script?
//	thread send ?-async? id script
//	thread event
//	thread exit
//	thread id ?-main?
//	thread names
//	thread wait
//	thread errorproc proc
//	thread join id
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

// ARGSUSED
func ThreadObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclThreadTest.c:208:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	// var option int32 at bp+32, 4

	if objc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+8934 /* "option ?arg ...?" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&threadOptions)), int32(unsafe.Sizeof(uintptr(0))), ts+3197 /* "option" */, 0, bp+32 /* &option */) != TCL_OK {
		return TCL_ERROR
	}

	// Make sure the initial thread is on the list before doing anything.

	if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp == (uintptr(0)) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp = interp
		ListUpdateInner(tls, tsdPtr)
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateThreadExitHandler})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ThreadExitProc})), uintptr(0))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 32 /* option */))) {
	case uint32(0) /* THREAD_CANCEL */ :
		{
			// var id Tcl_WideInt at bp+40, 8

			var result uintptr
			var flags int32
			var arg int32

			if (objc < 3) || (objc > 5) {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9907 /* "?-unwind? id ?re..." */)
				return TCL_ERROR
			}
			flags = 0
			arg = 2
			if (objc == 4) || (objc == 5) {
				if libc.Xstrcmp(tls, ts+9929 /* "-unwind" */, (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(arg)*8)))) == 0 {
					flags = TCL_CANCEL_UNWIND
					arg++
				}
			}
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(arg)*8)), bp+40 /* &id */) != TCL_OK {
				return TCL_ERROR
			}
			arg++
			if arg < objc {
				result = (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(arg)*8)))
			} else {
				result = uintptr(0)
			}
			return ThreadCancel(tls, interp, Tcl_ThreadId(size_t(*(*Tcl_WideInt)(unsafe.Pointer(bp + 40 /* id */)))), result, flags)

		}
	case uint32(1) /* THREAD_CREATE */ :
		{
			var script uintptr
			var joinable int32
			// var len int32 at bp+48, 4

			if objc == 2 {
				// Neither joinable nor special script

				joinable = 0
				script = ts + 9937 /* "testthread wait" */ // Just enter event loop
			} else if objc == 3 {
				// Possibly -joinable, then no special script, no joinable, then
				// its a script.

				script = (*struct {
					f func(*libc.TLS, uintptr, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+48 /* &len */)

				if (((*(*int32)(unsafe.Pointer(bp + 48 /* len */)) > 1) && (int32(*(*int8)(unsafe.Pointer(script))) == '-')) && (int32(*(*int8)(unsafe.Pointer(script + 1))) == 'j')) && (0 == libc.Xstrncmp(tls, script, ts+9953 /* "-joinable" */, size_t(*(*int32)(unsafe.Pointer(bp + 48 /* len */))))) {
					joinable = 1
					script = ts + 9937 /* "testthread wait" */ // Just enter event loop
				} else {
					// Remember the script

					joinable = 0
				}
			} else if objc == 4 {
				// Definitely a script available, but is the flag -joinable?

				script = (*struct {
					f func(*libc.TLS, uintptr, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+48 /* &len */)
				joinable = (libc.Bool32((((*(*int32)(unsafe.Pointer(bp + 48 /* len */)) > 1) && (int32(*(*int8)(unsafe.Pointer(script))) == '-')) && (int32(*(*int8)(unsafe.Pointer(script + 1))) == 'j')) &&
					(0 == libc.Xstrncmp(tls, script, ts+9953 /* "-joinable" */, size_t(*(*int32)(unsafe.Pointer(bp + 48 /* len */)))))))
				script = (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9963 /* "?-joinable? ?scr..." */)
				return TCL_ERROR
			}
			return ThreadCreate(tls, interp, script, joinable)

		}
	case uint32(3) /* THREAD_EXIT */ :
		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, uintptr(0))
			return TCL_ERROR
		}
		ListRemove(tls, uintptr(0))
		(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExitThread})).f(tls, 0)
		return TCL_OK
	case uint32(4) /* THREAD_ID */ :
		if (objc == 2) || (objc == 3) {
			var idObj uintptr

			// Check if they want the main thread id or the current thread id.

			if objc == 2 {
				idObj = (*struct {
					f func(*libc.TLS, Tcl_WideInt) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt((*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)))
			} else if (objc == 3) &&
				(libc.Xstrcmp(tls, ts+9984 /* "-main" */, (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))) == 0) {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
				idObj = (*struct {
					f func(*libc.TLS, Tcl_WideInt) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt(mainThreadId))
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, uintptr(0))
				return TCL_ERROR
			}

			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, idObj)
			return TCL_OK
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, uintptr(0))
			return TCL_ERROR
		}
		fallthrough
	case uint32(5) /* THREAD_JOIN */ :
		{
			// var id Tcl_WideInt at bp+56, 8

			var result int32
			// var status int32 at bp+64, 4

			if objc != 3 {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9990 /* "id" */)
				return TCL_ERROR
			}
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+56 /* &id */) != TCL_OK {
				return TCL_ERROR
			}

			result = (*struct {
				f func(*libc.TLS, Tcl_ThreadId, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_JoinThread})).f(tls, Tcl_ThreadId(size_t(*(*Tcl_WideInt)(unsafe.Pointer(bp + 56 /* id */)))), bp+64 /* &status */)
			if result == TCL_OK {
				(*struct {
					f func(*libc.TLS, uintptr, int32)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 64 /* status */)))
			} else {
				// var buf [20]int8 at bp+68, 20

				libc.Xsprintf(tls, bp+68 /* &buf[0] */, ts+4586 /* "%ld" */, libc.VaList(bp, *(*Tcl_WideInt)(unsafe.Pointer(bp + 56 /* id */))))
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, ts+9993 /* "cannot join thre..." */, bp+68 /* &buf[0] */, uintptr(0)))
			}
			return result

		}
	case uint32(6) /* THREAD_NAMES */ :
		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, uintptr(0))
			return TCL_ERROR
		}
		return ThreadList(tls, interp)
	case uint32(7) /* THREAD_SEND */ :
		{
			// var id Tcl_WideInt at bp+88, 8

			var script uintptr
			var wait int32
			var arg int32

			if (objc != 4) && (objc != 5) {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+10013 /* "?-async? id scri..." */)
				return TCL_ERROR
			}
			if objc == 5 {
				if libc.Xstrcmp(tls, ts+10032 /* "-async" */, (*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))) != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+10013 /* "?-async? id scri..." */)
					return TCL_ERROR
				}
				wait = 0
				arg = 3
			} else {
				wait = 1
				arg = 2
			}
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(arg)*8)), bp+88 /* &id */) != TCL_OK {
				return TCL_ERROR
			}
			arg++
			script = (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(arg)*8)))
			return ThreadSend(tls, interp, Tcl_ThreadId(size_t(*(*Tcl_WideInt)(unsafe.Pointer(bp + 88 /* id */)))), script, wait)

		}
	case uint32(2) /* THREAD_EVENT */ :
		{
			if objc > 2 {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, uintptr(0))
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls,
				(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, ((libc.CplInt32((int32(1)<<1)))|(int32(1)<<1)))))
			return TCL_OK

		}
	case uint32(9) /* THREAD_ERRORPROC */ :
		{
			// Arrange for this proc to handle thread death errors.

			var proc uintptr

			if objc != 3 {
				(*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9687 /* "proc" */)
				return TCL_ERROR
			}
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
			errorThreadId = (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)
			if errorProcString != 0 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, errorProcString)
			}
			proc = (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			errorProcString = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, proc) + uint64(1))))
			libc.Xstrcpy(tls, errorProcString, proc)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
			return TCL_OK

		}
	case uint32(8) /* THREAD_WAIT */ :
		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+1318 /* "" */)
			return TCL_ERROR
		}
		for 1 != 0 {
			// If the script has been unwound, bail out immediately. This does
			// not follow the recommended guidelines for how extensions should
			// handle the script cancellation functionality because this is
			// not a "normal" extension. Most extensions do not have a command
			// that simply enters an infinite Tcl event loop. Normal
			// extensions should not specify the TCL_CANCEL_UNWIND when
			// calling Tcl_Canceled to check if the command has been canceled.

			if (*struct {
				f func(*libc.TLS, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Canceled})).f(tls, interp,
				(TCL_LEAVE_ERR_MSG|TCL_CANCEL_UNWIND)) == TCL_ERROR {
				break
			}
			(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, libc.CplInt32((int32(1) << 1)))
		}

		// If we get to this point, we have been canceled by another thread,
		// which is considered to be an "error".

		ThreadErrorProc(tls, interp)
		return TCL_OK
	}
	return TCL_OK
}

var threadOptions = [11]uintptr{
	ts + 10039 /* "cancel" */, ts + 1205 /* "create" */, ts + 10046 /* "event" */, ts + 10052 /* "exit" */, ts + 9990, /* "id" */
	ts + 10057 /* "join" */, ts + 10062 /* "names" */, ts + 10068 /* "send" */, ts + 10073 /* "wait" */, ts + 10078, /* "errorproc" */
	uintptr(0),
} /* tclThreadTest.c:216:23 */

//----------------------------------------------------------------------
//
// ThreadCreate --
//
//	This procedure is invoked to create a thread containing an interp to
//	run a script. This returns after the thread has started executing.
//
// Results:
//	A standard Tcl result, which is the thread ID.
//
// Side effects:
//	Create a thread.
//
//----------------------------------------------------------------------

// ARGSUSED
func ThreadCreate(tls *libc.TLS, interp uintptr, script uintptr, joinable int32) int32 { /* tclThreadTest.c:496:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var ctrl ThreadCtrl at bp+24, 24

	// var id Tcl_ThreadId at bp+16, 8

	(*ThreadCtrl)(unsafe.Pointer(bp + 24 /* &ctrl */)).script = script
	(*ThreadCtrl)(unsafe.Pointer(bp + 24 /* &ctrl */)).condWait = uintptr(0)
	(*ThreadCtrl)(unsafe.Pointer(bp + 24 /* &ctrl */)).flags = 0

	if joinable != 0 {
		joinable = 0001
	} else {
		joinable = 0000
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, ClientData, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateThread})).f(tls, bp+16 /* &id */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{NewTestThread})), bp+24, /* &ctrl */
		0, joinable) != TCL_OK {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+10088 /* "can't create a n..." */, uintptr(0)))
		return TCL_ERROR
	}

	// Wait for the thread to start because it is using something on our stack!

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionWait})).f(tls, (bp + 24 /* &ctrl */ + 16 /* &.condWait */), uintptr(unsafe.Pointer(&threadMutex)), uintptr(0))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionFinalize})).f(tls, (bp + 24 /* &ctrl */ + 16 /* &.condWait */))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, Tcl_WideInt) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt(*(*Tcl_ThreadId)(unsafe.Pointer(bp + 16 /* id */)))))
	return TCL_OK
}

//------------------------------------------------------------------------
//
// NewTestThread --
//
//	This routine is the "main()" for a new thread whose task is to execute
//	a single Tcl script. The argument to this function is a pointer to a
//	structure that contains the text of the TCL script to be executed.
//
//	Space to hold the script field of the ThreadControl structure passed
//	in as the only argument was obtained from malloc() and must be freed
//	by this function before it exits. Space to hold the ThreadControl
//	structure itself is released by the calling function, and the two
//	condition variables in the ThreadControl structure are destroyed by
//	the calling function. The calling function will destroy the
//	ThreadControl structure and the condition variable as soon as
//	ctrlPtr->condWait is signaled, so this routine must make copies of any
//	data it might need after that point.
//
// Results:
//	None
//
// Side effects:
//	A Tcl script is executed in a new thread.
//
//------------------------------------------------------------------------

func NewTestThread(tls *libc.TLS, clientData ClientData) { /* tclThreadTest.c:558:1: */
	var ctrlPtr uintptr = clientData
	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	var result int32
	var threadEvalScript uintptr

	// Initialize the interpreter. This should be more general.

	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateInterp})).f(tls)
	result = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Init})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	if result != TCL_OK {
		ThreadErrorProc(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	}

	// This is part of the test facility. Initialize _ALL_ test commands for
	// use by the new thread.

	result = Tcltest_Init(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	if result != TCL_OK {
		ThreadErrorProc(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	}

	// Update the list of threads.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	ListUpdateInner(tls, tsdPtr)

	// We need to keep a pointer to the alloc'ed mem of the script we are
	// eval'ing, for the case that we exit during evaluation

	threadEvalScript = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, (*ThreadCtrl)(unsafe.Pointer(ctrlPtr)).script) + uint64(1))))
	libc.Xstrcpy(tls, threadEvalScript, (*ThreadCtrl)(unsafe.Pointer(ctrlPtr)).script)

	(*struct {
		f func(*libc.TLS, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateThreadExitHandler})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ThreadExitProc})), threadEvalScript)

	// Notify the parent we are alive.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionNotify})).f(tls, (ctrlPtr + 16 /* &.condWait */))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))

	// Run the script.

	(*struct{ f func(*libc.TLS, ClientData) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Preserve})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp, threadEvalScript, -1, 0)
	if result != TCL_OK {
		ThreadErrorProc(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	}

	// Clean up.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	(*struct{ f func(*libc.TLS, ClientData) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Release})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp)
	ListRemove(tls, tsdPtr)
	(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExitThread})).f(tls, result)

}

//------------------------------------------------------------------------
//
// ThreadErrorProc --
//
//	Send a message to the thread willing to hear about errors.
//
// Results:
//	None
//
// Side effects:
//	Send an event.
//
//------------------------------------------------------------------------

func ThreadErrorProc(tls *libc.TLS, interp uintptr) { /* tclThreadTest.c:649:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var errChannel Tcl_Channel
	var errorInfo uintptr
	// var argv [3]uintptr at bp+40, 24

	var script uintptr
	// var buf [28]int8 at bp+8, 28

	libc.Xsprintf(tls, bp+8 /* &buf[0] */, ts+4586 /* "%ld" */, libc.VaList(bp, Tcl_WideInt((*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls))))

	errorInfo = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, ts+10114 /* "errorInfo" */, uintptr(0), TCL_GLOBAL_ONLY)
	if errorProcString == (uintptr(0)) {
		errChannel = (*struct {
			f func(*libc.TLS, int32) Tcl_Channel
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStdChannel})).f(tls, (int32(1) << 3))
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WriteChars})).f(tls, errChannel, ts+10124 /* "Error from threa..." */, -1)
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WriteChars})).f(tls, errChannel, bp+8 /* &buf[0] */, -1)
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WriteChars})).f(tls, errChannel, ts+10143 /* "\n" */, 1)
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WriteChars})).f(tls, errChannel, errorInfo, -1)
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WriteChars})).f(tls, errChannel, ts+10143 /* "\n" */, 1)
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 40 /* &argv[0] */)) = errorProcString
		*(*uintptr)(unsafe.Pointer(bp + 40 /* &argv[0] */ + 1*8)) = bp + 8 /* &buf[0] */
		*(*uintptr)(unsafe.Pointer(bp + 40 /* &argv[0] */ + 2*8)) = errorInfo
		script = (*struct {
			f func(*libc.TLS, int32, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Merge})).f(tls, 3, bp+40 /* &argv[0] */)
		ThreadSend(tls, interp, errorThreadId, script, 0)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, script)
	}
}

//------------------------------------------------------------------------
//
// ListUpdateInner --
//
//	Add the thread local storage to the list. This assumes the caller has
//	obtained the mutex.
//
// Results:
//	None
//
// Side effects:
//	Add the thread local storage to its list.
//
//------------------------------------------------------------------------

func ListUpdateInner(tls *libc.TLS, tsdPtr uintptr) { /* tclThreadTest.c:696:1: */
	if tsdPtr == (uintptr(0)) {
		tsdPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	}
	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).threadId = (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)
	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr = threadList
	if threadList != 0 {
		(*ThreadSpecificData)(unsafe.Pointer(threadList)).prevPtr = tsdPtr
	}
	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).prevPtr = uintptr(0)
	threadList = tsdPtr
}

//------------------------------------------------------------------------
//
// ListRemove --
//
//	Remove the thread local storage from its list. This grabs the mutex to
//	protect the list.
//
// Results:
//	None
//
// Side effects:
//	Remove the thread local storage from its list.
//
//------------------------------------------------------------------------

func ListRemove(tls *libc.TLS, tsdPtr uintptr) { /* tclThreadTest.c:729:1: */
	if tsdPtr == (uintptr(0)) {
		tsdPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).prevPtr != 0 {
		(*ThreadSpecificData1)(unsafe.Pointer((*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).prevPtr)).nextPtr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr
	} else {
		threadList = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr
	}
	if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr != 0 {
		(*ThreadSpecificData1)(unsafe.Pointer((*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr)).prevPtr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).prevPtr
	}
	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr = libc.AssignPtrUintptr(tsdPtr+32 /* &.prevPtr */, uintptr(0))
	(*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp = uintptr(0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
}

//------------------------------------------------------------------------
//
// ThreadList --
//
//    Return a list of threads running Tcl interpreters.
//
// Results:
//    A standard Tcl result.
//
// Side effects:
//    None.
//
//------------------------------------------------------------------------
func ThreadList(tls *libc.TLS, interp uintptr) int32 { /* tclThreadTest.c:765:1: */
	var tsdPtr uintptr
	var listPtr uintptr

	listPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 0, uintptr(0))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	for tsdPtr = threadList; tsdPtr != 0; tsdPtr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, listPtr,
			(*struct {
				f func(*libc.TLS, Tcl_WideInt) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt((*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).threadId)))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, listPtr)
	return TCL_OK
}

//------------------------------------------------------------------------
//
// ThreadSend --
//
//    Send a script to another thread.
//
// Results:
//    A standard Tcl result.
//
// Side effects:
//    None.
//
//------------------------------------------------------------------------

func ThreadSend(tls *libc.TLS, interp uintptr, id Tcl_ThreadId, script uintptr, wait int32) int32 { /* tclThreadTest.c:799:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	var threadEventPtr uintptr
	var resultPtr uintptr
	var found int32
	var code int32
	var threadId Tcl_ThreadId = id

	// Verify the thread exists.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	found = 0
	for tsdPtr = threadList; tsdPtr != 0; tsdPtr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr {
		if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).threadId == threadId {
			found = 1
			break
		}
	}
	if !(found != 0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+10145 /* "invalid thread i..." */, uintptr(0)))
		return TCL_ERROR
	}

	// Short circut sends to ourself. Ought to do something with -async, like
	// run in an idle handler.

	if threadId == (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, script, -1, TCL_EVAL_GLOBAL)
	}

	// Create the event for its event queue.

	threadEventPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(ThreadEvent{})))
	(*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, script) + uint64(1))))
	libc.Xstrcpy(tls, (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script, script)
	if !(wait != 0) {
		resultPtr = libc.AssignPtrUintptr(threadEventPtr+24 /* &.resultPtr */, uintptr(0))
	} else {
		resultPtr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(ThreadEventResult{})))
		(*ThreadEvent)(unsafe.Pointer(threadEventPtr)).resultPtr = resultPtr

		// Initialize the result fields.

		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).done = uintptr(0)
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).code = 0
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).result = uintptr(0)
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo = uintptr(0)
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode = uintptr(0)

		// Maintain the cleanup list.

		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).srcThreadId = (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).dstThreadId = threadId
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).eventPtr = threadEventPtr
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr = resultList
		if resultList != 0 {
			(*ThreadEventResult)(unsafe.Pointer(resultList)).prevPtr = resultPtr
		}
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr = uintptr(0)
		resultList = resultPtr
	}

	// Queue the event and poke the other thread's notifier.

	(*ThreadEvent)(unsafe.Pointer(threadEventPtr)).event.proc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{ThreadEventProc}))
	(*struct {
		f func(*libc.TLS, Tcl_ThreadId, uintptr, Tcl_QueuePosition)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ThreadQueueEvent})).f(tls, threadId, threadEventPtr,
		TCL_QUEUE_TAIL)
	(*struct{ f func(*libc.TLS, Tcl_ThreadId) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ThreadAlert})).f(tls, threadId)

	if !(wait != 0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		return TCL_OK
	}

	// Block on the results and then get them.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	for (*ThreadEventResult)(unsafe.Pointer(resultPtr)).result == (uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionWait})).f(tls, (resultPtr /* &.done */), uintptr(unsafe.Pointer(&threadMutex)), uintptr(0))
	}

	// Unlink result from the result list.

	if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr != 0 {
		(*ThreadEventResult1)(unsafe.Pointer((*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr)).nextPtr = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr
	} else {
		resultList = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr
	}
	if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr != 0 {
		(*ThreadEventResult1)(unsafe.Pointer((*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr)).prevPtr = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr
	}
	(*ThreadEventResult)(unsafe.Pointer(resultPtr)).eventPtr = uintptr(0)
	(*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr = uintptr(0)
	(*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr = uintptr(0)

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))

	if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).code != TCL_OK {
		if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+16, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode, uintptr(0)))
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode)
		}
		if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo)
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).result, uintptr(0)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionFinalize})).f(tls, (resultPtr /* &.done */))
	code = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).code

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).result)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, resultPtr)

	return code
}

//------------------------------------------------------------------------
//
// ThreadCancel --
//
//    Cancels a script in another thread.
//
// Results:
//    A standard Tcl result.
//
// Side effects:
//    None.
//
//------------------------------------------------------------------------

func ThreadCancel(tls *libc.TLS, interp uintptr, id Tcl_ThreadId, result uintptr, flags int32) int32 { /* tclThreadTest.c:955:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	var found int32
	var threadId Tcl_ThreadId = id

	// Verify the thread exists.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	found = 0
	for tsdPtr = threadList; tsdPtr != 0; tsdPtr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).nextPtr {
		if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).threadId == threadId {
			found = 1
			break
		}
	}
	if !(found != 0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+10145 /* "invalid thread i..." */, uintptr(0)))
		return TCL_ERROR
	}

	// Since Tcl_CancelEval can be safely called from any thread,
	// we do it now.

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, ClientData, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CancelEval})).f(tls, (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp,
		func() uintptr {
			if result != (uintptr(0)) {
				return (*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, result, -1)
			}
			return uintptr(0)
		}(), uintptr(0), flags)
}

//------------------------------------------------------------------------
//
// ThreadEventProc --
//
//    Handle the event in the target thread.
//
// Results:
//    Returns 1 to indicate that the event was processed.
//
// Side effects:
//    Fills out the ThreadEventResult struct.
//
//------------------------------------------------------------------------

func ThreadEventProc(tls *libc.TLS, evPtr uintptr, mask int32) int32 { /* tclThreadTest.c:1011:1: */
	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))
	var threadEventPtr uintptr = evPtr
	var resultPtr uintptr = (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).resultPtr
	var interp uintptr = (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp
	var code int32
	var result uintptr
	var errorCode uintptr
	var errorInfo uintptr

	if interp == (uintptr(0)) {
		code = TCL_ERROR
		result = ts + 10163    /* "no target interp..." */
		errorCode = ts + 10181 /* "THREAD" */
		errorInfo = ts + 1318  /* "" */
	} else {
		(*struct{ f func(*libc.TLS, ClientData) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Preserve})).f(tls, interp)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateThreadExitHandler})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ThreadFreeProc})), (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script)
		code = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script, -1, TCL_EVAL_GLOBAL)
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteThreadExitHandler})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ThreadFreeProc})), (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script)
		if code != TCL_OK {
			errorCode = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, ts+10188 /* "errorCode" */, uintptr(0), TCL_GLOBAL_ONLY)
			errorInfo = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, ts+10114 /* "errorInfo" */, uintptr(0), TCL_GLOBAL_ONLY)
		} else {
			errorCode = libc.AssignUintptr(&errorInfo, uintptr(0))
		}
		result = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, interp)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*ThreadEvent)(unsafe.Pointer(threadEventPtr)).script)
	if resultPtr != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).code = code
		(*ThreadEventResult)(unsafe.Pointer(resultPtr)).result = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, result) + uint64(1))))
		libc.Xstrcpy(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).result, result)
		if errorCode != (uintptr(0)) {
			(*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, errorCode) + uint64(1))))
			libc.Xstrcpy(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorCode, errorCode)
		}
		if errorInfo != (uintptr(0)) {
			(*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, errorInfo) + uint64(1))))
			libc.Xstrcpy(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).errorInfo, errorInfo)
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionNotify})).f(tls, (resultPtr /* &.done */))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
	}
	if interp != (uintptr(0)) {
		(*struct{ f func(*libc.TLS, ClientData) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Release})).f(tls, interp)
	}
	return 1
}

//------------------------------------------------------------------------
//
// ThreadFreeProc --
//
//    This is called from when we are exiting and memory needs
//    to be freed.
//
// Results:
//    None.
//
// Side effects:
//	Clears up mem specified in ClientData
//
//------------------------------------------------------------------------

// ARGSUSED
func ThreadFreeProc(tls *libc.TLS, clientData ClientData) { /* tclThreadTest.c:1083:1: */
	if clientData != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, clientData)
	}
}

//------------------------------------------------------------------------
//
// ThreadDeleteEvent --
//
//    This is called from the ThreadExitProc to delete memory related
//    to events that we put on the queue.
//
// Results:
//    1 it was our event and we want it removed, 0 otherwise.
//
// Side effects:
//	It cleans up our events in the event queue for this thread.
//
//------------------------------------------------------------------------

// ARGSUSED
func ThreadDeleteEvent(tls *libc.TLS, eventPtr uintptr, clientData ClientData) int32 { /* tclThreadTest.c:1110:1: */
	if (*Tcl_Event)(unsafe.Pointer(eventPtr)).proc == *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{ThreadEventProc})) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*ThreadEvent)(unsafe.Pointer(eventPtr)).script)
		return 1
	}

	// If it was NULL, we were in the middle of servicing the event and it
	// should be removed

	return (libc.Bool32((*Tcl_Event)(unsafe.Pointer(eventPtr)).proc == (uintptr(0))))
}

//------------------------------------------------------------------------
//
// ThreadExitProc --
//
//    This is called when the thread exits.
//
// Results:
//    None.
//
// Side effects:
//	It unblocks anyone that is waiting on a send to this thread. It cleans
//	up any events in the event queue for this thread.
//
//------------------------------------------------------------------------

// ARGSUSED
func ThreadExitProc(tls *libc.TLS, clientData ClientData) { /* tclThreadTest.c:1146:1: */
	var threadEvalScript uintptr = clientData
	var resultPtr uintptr
	var nextPtr uintptr
	var self Tcl_ThreadId = (*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)
	var tsdPtr uintptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetThreadData})).f(tls, uintptr(unsafe.Pointer(&dataKey)), int32(unsafe.Sizeof(ThreadSpecificData{})))

	if (*ThreadSpecificData)(unsafe.Pointer(tsdPtr)).interp != (uintptr(0)) {
		ListRemove(tls, tsdPtr)
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexLock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))

	if self == errorThreadId {
		if errorProcString != 0 { // Extra safety
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, errorProcString)
			errorProcString = uintptr(0)
		}
		errorThreadId = uintptr(0)
	}

	if threadEvalScript != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, threadEvalScript)
		threadEvalScript = uintptr(0)
	}
	(*struct {
		f func(*libc.TLS, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteEvents})).f(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, ClientData) int32
	}{ThreadDeleteEvent})), uintptr(0))

	for resultPtr = resultList; resultPtr != 0; resultPtr = nextPtr {
		nextPtr = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr
		if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).srcThreadId == self {
			// We are going away. By freeing up the result we signal to the
			// other thread we don't care about the result.

			if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr != 0 {
				(*ThreadEventResult1)(unsafe.Pointer((*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr)).nextPtr = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr
			} else {
				resultList = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr
			}
			if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr != 0 {
				(*ThreadEventResult1)(unsafe.Pointer((*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr)).prevPtr = (*ThreadEventResult)(unsafe.Pointer(resultPtr)).prevPtr
			}
			(*ThreadEventResult)(unsafe.Pointer(resultPtr)).nextPtr = libc.AssignPtrUintptr(resultPtr+72 /* &.prevPtr */, uintptr(0))
			(*ThreadEvent1)(unsafe.Pointer((*ThreadEventResult)(unsafe.Pointer(resultPtr)).eventPtr)).resultPtr = uintptr(0)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, resultPtr)
		} else if (*ThreadEventResult)(unsafe.Pointer(resultPtr)).dstThreadId == self {
			// Dang. The target is going away. Unblock the caller. The result
			// string must be dynamically allocated because the main thread is
			// going to call free on it.

			var msg uintptr = ts + 10198 /* "target thread di..." */

			(*ThreadEventResult)(unsafe.Pointer(resultPtr)).result = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, (uint32(libc.Xstrlen(tls, msg) + uint64(1))))
			libc.Xstrcpy(tls, (*ThreadEventResult)(unsafe.Pointer(resultPtr)).result, msg)
			(*ThreadEventResult)(unsafe.Pointer(resultPtr)).code = TCL_ERROR
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConditionNotify})).f(tls, (resultPtr /* &.done */))
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_MutexUnlock})).f(tls, uintptr(unsafe.Pointer(&threadMutex)))
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Value to indicate that there is no limit.

// We can represent all limits.

// Type for resource quantity measurement.
type rlim_t = uint64   /* resource.h:133:20 */
type rlim64_t = uint64 /* resource.h:136:20 */

type rlimit = struct {
	rlim_cur rlim_t
	rlim_max rlim_t
} /* resource.h:139:1 */

type rlimit64 = struct {
	rlim_cur rlim64_t
	rlim_max rlim64_t
} /* resource.h:148:1 */

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe1 = struct {
	readFile   TclFile
	writeFile  TclFile
	readCount  int32
	writeCount int32
} /* tclUnixTest.c:40:9 */

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe = Pipe1 /* tclUnixTest.c:50:3 */

var testPipes [10]Pipe /* tclUnixTest.c:53:13: */

// The stuff below is used by the testalarm and testgotsig ommands.

var gotsig uintptr = ts + 6531 /* "0" */ /* tclUnixTest.c:59:19 */

//----------------------------------------------------------------------
//
// TclplatformtestInit --
//
//	Defines commands that test platform specific functionality for Unix
//	platforms.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Defines new commands.
//
//----------------------------------------------------------------------

func TclplatformtestInit(tls *libc.TLS, interp uintptr) int32 { /* tclUnixTest.c:96:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+10217 /* "testchmod" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestchmodCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10227 /* "testfilehandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilehandlerCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10243 /* "testfilewait" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilewaitCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10256 /* "testfindexecutab..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfindexecutableCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+10275 /* "testfork" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestforkObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10284 /* "testgetopenfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetopenfileCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10300 /* "testgetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetdefencdirCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10314 /* "testsetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetdefencdirCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10328 /* "testalarm" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestalarmCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10338 /* "testgotsig" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgotsigCmd})),
		uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestfilehandlerCmd --
//
//	This function implements the "testfilehandler" command. It is used to
//	test Tcl_CreateFileHandler, Tcl_DeleteFileHandler, and TclWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilehandlerCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:140:1: */
	bp := tls.Alloc(4576)
	defer tls.Free(4576)

	var pipePtr uintptr
	// var i int32 at bp+496, 4

	var mask int32
	// var timeout int32 at bp+4572, 4

	// var buffer [4000]int8 at bp+548, 4000

	var file TclFile

	// NOTE: When we make this code work on Windows also, the following
	// variable needs to be made Unix-only.

	if !(initialized != 0) {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < MAX_PIPES; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = uintptr(0)
		}
		initialized = 1
	}

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10349 /* " option ... \"" */, uintptr(0)))
		return TCL_ERROR
	}
	pipePtr = uintptr(0)
	if argc >= 3 {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+496 /* &i */) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 496 /* i */)) >= MAX_PIPES {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+10363 /* "bad index " */, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0)))
			return TCL_ERROR
		}
		pipePtr = (uintptr(unsafe.Pointer(&testPipes)) + uintptr(*(*int32)(unsafe.Pointer(bp + 496 /* i */)))*24)
	}

	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10374 /* "close" */) == 0 {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < MAX_PIPES; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			if testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile != (uintptr(0)) {
				(*struct {
					f func(*libc.TLS, TclFile) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCloseFile})).f(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = uintptr(0)
				(*struct {
					f func(*libc.TLS, TclFile) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCloseFile})).f(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile = uintptr(0)
			}
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10380 /* "clear" */) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10386 /* " clear index\"" */, uintptr(0)))
			return TCL_ERROR
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = libc.AssignPtrInt32(pipePtr+20 /* &.writeCount */, 0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10400 /* "counts" */) == 0 {
		// var buf [48]int8 at bp+500, 48

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+88, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10407 /* " counts index\"" */, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xsprintf(tls, bp+500 /* &buf[0] */, ts+4556 /* "%d %d" */, libc.VaList(bp+120, (*Pipe)(unsafe.Pointer(pipePtr)).readCount, (*Pipe)(unsafe.Pointer(pipePtr)).writeCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+136, bp+500 /* &buf[0] */, uintptr(0)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1205 /* "create" */) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+152, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10422 /* " create index re..." */, uintptr(0)))
			return TCL_ERROR
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == (uintptr(0)) {
			if !((*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCreatePipe})).f(tls, (pipePtr /* &.readFile */), (pipePtr+8 /* &.writeFile */)) != 0) {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+184, ts+10456, /* "couldn't open pi..." */
					(*struct {
						f func(*libc.TLS, uintptr) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
				return TCL_ERROR
			}
			libc.Xfcntl(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)) - 1), F_SETFL, libc.VaList(bp+208, O_NONBLOCK))
			libc.Xfcntl(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)) - 1), F_SETFL, libc.VaList(bp+216, O_NONBLOCK))
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = 0
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount = 0

		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6533 /* "readable" */) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)) - 1), (int32(1) << 1),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+10477 /* "off" */) == 0 {
			(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)) - 1))
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+10481 /* "disabled" */) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)) - 1), 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+10490 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+1640 /* "\"" */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6556 /* "writable" */) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)) - 1), (int32(1) << 2),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+10477 /* "off" */) == 0 {
			(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)) - 1))
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+10481 /* "disabled" */) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)) - 1), 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+10490 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+1640 /* "\"" */, uintptr(0)))
			return TCL_ERROR
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10506 /* "empty" */) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10512 /* " empty index\"" */, uintptr(0)))
			return TCL_ERROR
		}

		for libc.Xread(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile))-1), bp+548 /* &buffer[0] */, uint64(4000)) > int64(0) {
			// Empty loop body.
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10526 /* "fill" */) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10531 /* " fill index\"" */, uintptr(0)))
			return TCL_ERROR
		}

		libc.Xmemset(tls, bp+548 /* &buffer[0] */, 'a', uint64(4000))
		for libc.Xwrite(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))-1), bp+548 /* &buffer[0] */, uint64(4000)) > int64(0) {
			// Empty loop body.
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10544 /* "fillpartial" */) == 0 {
		// var buf [24]int8 at bp+4548, 24

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10556 /* " fillpartial ind..." */, uintptr(0)))
			return TCL_ERROR
		}

		libc.Xmemset(tls, bp+548 /* &buffer[0] */, 'b', uint64(10))
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+4548 /* &buf[0] */, libc.Xwrite(tls, ((int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))-1), bp+548 /* &buffer[0] */, uint64(10)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, bp+4548 /* &buf[0] */, uintptr(0)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10576 /* "oneevent" */) == 0 {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, ((int32(1) << 3) | (int32(1) << 1)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10073 /* "wait" */) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+2205, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10585 /* " wait index read..." */, uintptr(0)))
			return TCL_ERROR
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == (uintptr(0)) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+10624 /* "pipe " */, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+10630 /* " doesn't exist" */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6533 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
			file = (*Pipe)(unsafe.Pointer(pipePtr)).readFile
		} else {
			mask = (int32(1) << 2)
			file = (*Pipe)(unsafe.Pointer(pipePtr)).writeFile
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+4572 /* &timeout */) != TCL_OK {
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 496 /* i */)) = (*struct {
			f func(*libc.TLS, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclUnixWaitForFile})).f(tls, ((int32(file)) - 1), mask, *(*int32)(unsafe.Pointer(bp + 4572 /* timeout */)))
		if (*(*int32)(unsafe.Pointer(bp + 496 /* i */)) & (int32(1) << 1)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6533 /* "readable" */)
		}
		if (*(*int32)(unsafe.Pointer(bp + 496 /* i */)) & (int32(1) << 2)) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6556 /* "writable" */)
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10645 /* "windowevent" */) == 0 {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, ((int32(1) << 2) | (int32(1) << 1)))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+1254 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

			ts+10657 /* "\": must be close..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var initialized int32 = 0 /* tclUnixTest.c:148:16 */

func TestFileHandlerProc(tls *libc.TLS, clientData ClientData, mask int32) { /* tclUnixTest.c:329:1: */
	var pipePtr uintptr = clientData

	if (mask & (int32(1) << 1)) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount++
	}
	if (mask & (int32(1) << 2)) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount++
	}
}

//----------------------------------------------------------------------
//
// TestfilewaitCmd --
//
//	This function implements the "testfilewait" command. It is used to
//	test TclUnixWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilewaitCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:362:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var mask int32
	var result int32
	// var timeout int32 at bp+88, 4

	var channel Tcl_Channel
	var fd int32
	// var data ClientData at bp+80, 8

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10755 /* " file readable|w..." */, uintptr(0)))
		return TCL_ERROR
	}
	channel = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if channel == (uintptr(0)) {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+6533 /* "readable" */) == 0 {
		mask = (int32(1) << 1)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+6556 /* "writable" */) == 0 {
		mask = (int32(1) << 2)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+10793 /* "both" */) == 0 {
		mask = ((int32(1) << 2) | (int32(1) << 1))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+6619 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
			ts+10798 /* "\": must be reada..." */, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, Tcl_Channel, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelHandle})).f(tls, channel,
		func() int32 {
			if (mask & (int32(1) << 1)) != 0 {
				return (int32(1) << 1)
			}
			return (int32(1) << 2)
		}(),
		bp+80 /* &data */) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+10837 /* "couldn't get cha..." */, uintptr(0)))
		return TCL_ERROR
	}
	fd = int32(*(*ClientData)(unsafe.Pointer(bp + 80 /* data */)))
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+88 /* &timeout */) != TCL_OK {
		return TCL_ERROR
	}
	result = (*struct {
		f func(*libc.TLS, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclUnixWaitForFile})).f(tls, fd, mask, *(*int32)(unsafe.Pointer(bp + 88 /* timeout */)))
	if (result & (int32(1) << 1)) != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6533 /* "readable" */)
	}
	if (result & (int32(1) << 2)) != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6556 /* "writable" */)
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestfindexecutableCmd --
//
//	This function implements the "testfindexecutable" command. It is used
//	to test TclpFindExecutable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfindexecutableCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:431:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var saveName uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2205 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10863 /* " argv0\"" */, uintptr(0)))
		return TCL_ERROR
	}

	saveName = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetObjNameOfExecutable})).f(tls)
	(*Tcl_Obj)(unsafe.Pointer(saveName)).refCount++

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpFindExecutable})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetObjNameOfExecutable})).f(tls))

	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Encoding)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclSetObjNameOfExecutable})).f(tls, saveName, uintptr(0))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = saveName
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetopenfileCmd --
//
//	This function implements the "testgetopenfile" command. It is used to
//	get a FILE * value from a registered channel.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetopenfileCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:474:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var filePtr ClientData at bp+48, 8

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10871 /* " channelName for..." */, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetOpenFile})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))), 1, bp+48 /* &filePtr */) ==
		TCL_ERROR {
		return TCL_ERROR
	}
	if *(*ClientData)(unsafe.Pointer(bp + 48 /* filePtr */)) == (uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+32, ts+10896 /* "Tcl_GetOpenFile ..." */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetdefencdirCmd --
//
//	This function implements the "testsetdefenc" command. It is used to
//	test Tcl_SetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetdefencdirCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:517:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10939 /* " defaultDir\"" */, uintptr(0)))
		return TCL_ERROR
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDefaultEncodingDir})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestforkObjCmd --
//
//	This function implements the "testfork" command. It is used to
//	fork the Tcl process for specific test cases.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestforkObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:551:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pid pid_t

	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1318 /* "" */)
		return TCL_ERROR
	}
	pid = libc.Xfork(tls)
	if pid == -1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp, ts+10952 /* "Cannot fork" */, uintptr(0)))
		return TCL_ERROR
	}
	// Only needed when pthread_atfork is not present,
	// should not hurt otherwise.
	if pid == 0 {
		(*struct{ f func(*libc.TLS) ClientData })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InitNotifier})).f(tls)
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, pid))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetdefencdirCmd --
//
//	This function implements the "testgetdefenc" command. It is used to
//	test Tcl_GetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetdefencdirCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:596:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1319 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), uintptr(0)))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDefaultEncodingDir})).f(tls), uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestalarmCmd --
//
//	Test that EINTR is handled correctly by generating and handling a
//	signal. This requires using the SA_RESTART flag when registering the
//	signal handler.
//
// Results:
//	None.
//
// Side Effects:
//	Sets up an signal and async handlers.
//
//----------------------------------------------------------------------

func TestalarmCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:630:1: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var sec uint32 at bp+24, 4

	// var action sigaction at bp+32, 152

	if argc > 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+24 /* &sec */)
	} else {
		*(*uint32)(unsafe.Pointer(bp + 24 /* sec */)) = uint32(1)
	}

	// Setup the signal handling that automatically retries any interrupted
	// I/O system calls.

	*(*uintptr)(unsafe.Pointer(bp + 32 /* &action */ /* &.__sigaction_handler */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) }{AlarmHandler}))
	libc.Xmemset(tls, (bp + 32 /* &action */ + 8 /* &.sa_mask */), 0, uint64(unsafe.Sizeof(sigset_t{})))
	(*sigaction)(unsafe.Pointer(bp + 32 /* &action */)).sa_flags = SA_RESTART

	if libc.Xsigaction(tls, SIGALRM, bp+32 /* &action */, uintptr(0)) < 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+10964 /* "sigaction: " */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
		return TCL_ERROR
	}
	libc.Xalarm(tls, *(*uint32)(unsafe.Pointer(bp + 24 /* sec */)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// AlarmHandler --
//
//	Signal handler for the alarm command.
//
// Results:
//	None.
//
// Side effects:
// 	Calls the Tcl Async handler.
//
//----------------------------------------------------------------------

func AlarmHandler(tls *libc.TLS, signum int32) { /* tclUnixTest.c:686:1: */
	gotsig = ts + 6529 /* "1" */
}

//----------------------------------------------------------------------
//
// TestgotsigCmd --
//
// 	Verify the signal was handled after the testalarm command.
//
// Results:
//	None.
//
// Side Effects:
//	Resets the value of gotsig back to '0'.
//
//----------------------------------------------------------------------

func TestgotsigCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:709:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, gotsig, uintptr(0)))
	gotsig = ts + 6531 /* "0" */
	return TCL_OK
}

//---------------------------------------------------------------------------
//
// TestchmodCmd --
//
//	Implements the "testchmod" cmd.  Used when testing "file" command.
//	The only attribute used by the Windows platform is the user write
//	flag; if this is not set, the file is made read-only.  Otehrwise, the
//	file is made read-write.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Changes permissions of specified files.
//
//---------------------------------------------------------------------------

func TestchmodCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:740:1: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var i int32
	// var mode int32 at bp+32, 4

	if objc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+10976 /* "mode file ?file ..." */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32 /* &mode */) != TCL_OK {
		return TCL_ERROR
	}

	for i = 2; i < objc; i++ {
		// var buffer Tcl_DString at bp+40, 216

		var translated uintptr

		translated = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_TranslateFileName})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))), bp+40 /* &buffer */)
		if translated == (uintptr(0)) {
			return TCL_ERROR
		}
		if libc.Xchmod(tls, translated, uint32(*(*int32)(unsafe.Pointer(bp + 32 /* mode */)))) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, translated, ts+3650 /* ": " */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp),
				uintptr(0)))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+40 /* &buffer */)
	}
	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// End:

func init() {
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                                                               // tclTestProcBodyObj.c:62:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 8 /* .proc */)) = ProcBodyTestProcObjCmd                                              // tclTestProcBodyObj.c:62:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                                                             // tclTestProcBodyObj.c:63:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 32 /* .proc */)) = ProcBodyTestCheckObjCmd                                            // tclTestProcBodyObj.c:63:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                                                           // tclTestProcBodyObj.c:68:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 8 /* .proc */)) = ProcBodyTestProcObjCmd                                          // tclTestProcBodyObj.c:68:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                                                         // tclTestProcBodyObj.c:69:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 32 /* .proc */)) = ProcBodyTestCheckObjCmd                                        // tclTestProcBodyObj.c:69:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 24 /* .pathInFilesystemProc */)) = SimplePathInFilesystem                                        // tclTest.c:480:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 88 /* .statProc */)) = SimpleStat                                                                // tclTest.c:494:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 96 /* .accessProc */)) = SimpleAccess                                                              // tclTest.c:495:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 104 /* .openFileChannelProc */)) = SimpleOpenFileChannel                     // tclTest.c:496:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 112 /* .matchInDirectoryProc */)) = SimpleMatchInDirectory            // tclTest.c:497:5:
	*(*func(*libc.TLS) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 136 /* .listVolumesProc */)) = SimpleListVolumes                                                                 // tclTest.c:501:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 24 /* .pathInFilesystemProc */)) = TestReportInFilesystem                                 // tclTest.c:446:5:
	*(*func(*libc.TLS, ClientData) ClientData)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 32 /* .dupInternalRepProc */)) = TestReportDupInternalRep                                  // tclTest.c:447:5:
	*(*func(*libc.TLS, ClientData))(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 40 /* .freeInternalRepProc */)) = TestReportFreeInternalRep                                           // tclTest.c:448:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 64 /* .normalizePathProc */)) = TestReportNormalizePath                            // tclTest.c:451:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 88 /* .statProc */)) = TestReportStat                                                     // tclTest.c:454:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 96 /* .accessProc */)) = TestReportAccess                                                   // tclTest.c:455:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 104 /* .openFileChannelProc */)) = TestReportOpenFileChannel          // tclTest.c:456:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 112 /* .matchInDirectoryProc */)) = TestReportMatchInDirectory // tclTest.c:457:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 120 /* .utimeProc */)) = TestReportUtime                                                  // tclTest.c:458:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 128 /* .linkProc */)) = TestReportLink                                           // tclTest.c:459:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 144 /* .fileAttrStringsProc */)) = TestReportFileAttrStrings                            // tclTest.c:461:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 152 /* .fileAttrsGetProc */)) = TestReportFileAttrsGet                    // tclTest.c:462:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 160 /* .fileAttrsSetProc */)) = TestReportFileAttrsSet                    // tclTest.c:463:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 168 /* .createDirectoryProc */)) = TestReportCreateDirectory                                       // tclTest.c:464:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 176 /* .removeDirectoryProc */)) = TestReportRemoveDirectory                       // tclTest.c:465:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 184 /* .deleteFileProc */)) = TestReportDeleteFile                                                 // tclTest.c:466:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 192 /* .copyFileProc */)) = TestReportCopyFile                                            // tclTest.c:467:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 200 /* .renameFileProc */)) = TestReportRenameFile                                        // tclTest.c:468:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 208 /* .copyDirectoryProc */)) = TestReportCopyDirectory                         // tclTest.c:469:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 216 /* .lstatProc */)) = TestReportLstat                                                  // tclTest.c:470:5:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 224 /* .loadFileProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	}{TestReportLoadFile})) // tclTest.c:471:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 240 /* .chdirProc */)) = TestReportChdir // tclTest.c:473:5:
}

var ts1 = "Tcltest\x00tcl_rcFileName\x00~/.tclshrc\x00reporting\x00simple\x008.5\x001.1.0\x008.6.10\x00gettimes\x00noop\x00testpurebytesobj\x00testbytestring\x00testwrongnumargs\x00testfilesystem\x00testsimplefilesystem\x00testgetindexfromobjstruct\x00testasync\x00testbumpinterpepoch\x00testchannel\x00testchannelevent\x00testcmdtoken\x00testcmdinfo\x00testcmdtrace\x00testconcatobj\x00testcreatecommand\x00testdcall\x00testdel\x00testdelassocdata\x00testdoubledigits\x00testdstring\x00testencoding\x00testevalex\x00testevalobjv\x00testevent\x00testexithandler\x00testexprlong\x00testexprlongobj\x00testexprdouble\x00testexprdoubleobj\x00testexprparser\x00testexprstring\x00testfevent\x00testfilelink\x00testfile\x00testhashsystemhash\x00testgetassocdata\x00testgetint\x00testgetplatform\x00testgetvarfullname\x00testinterpdelete\x00testlink\x00testlocale\x00testpanic\x00testparseargs\x00testparser\x00testparsevar\x00testparsevarname\x00testregexp\x00testreturn\x00testsaveresult\x00testsetassocdata\x00testsetnoerr\x00testseterr\x00testset2\x00testseterrorcode\x00testsetobjerrorcode\x00testnumutfchars\x00testfindfirst\x00testfindlast\x00testsetplatform\x00teststaticpkg\x00testtranslatefilename\x00testupvar\x00T1\x00T2\x00testmainthread\x00testsetmainloop\x00testexitmainloop\x00T3\x00testnreunwind\x00testnrelevels\x00testinterpresolver\x00argv\x00stderr\x00-appinitprocerror\x00-appinitprocdeleteinterp\x00-appinitprocclosestderr\x00-appinitprocsetrcfile\x00wrong # args\x00create\x00delete\x00mark\x00marklater\x00can't create thread\x00bad option \"\x00\": must be create, delete, int, mark, or marklater\x00\x00wrong # args: should be \"\x00 option cmdName\"\x00original\x00get\x00??\x00CmdProc1\x00 \x00CmdProc2\x00unknown\x00 CmdDelProc1\x00 CmdDelProc2\x00 unknown\x00 nativeObjectProc\x00 stringProc\x00modify\x00new_command_data\x00new_delete_data\x00\": must be create, delete, get, or modify\x00CmdProc1 \x00CmdProc2 \x00CmdDelProc1 \x00CmdDelProc2 \x00 option arg\"\x00%p\x00name\x00bad command token \"\x00\"\x00\": must be create or name\x00 option script\"\x00tracetest\x00deletetest\x00leveltest\x00resulttest\x00Delete wasn't called\x00doubletest\x00\": must be tracetest, deletetest, doubletest or resulttest\x00Error\x00Break\x00Continue\x00Return\x00OtherStatus\x00 option\"\x00test_ns_basic::createdcommand\x00create2\x00value:at:\x00delete2\x00\": must be create, delete, create2, or delete2\x00CreatedCommandProc could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc in \x00CreatedCommandProc2 could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc2 in \x00bogus interpreter argument!\x00wrong # arguments: should be \"\x00 data_key\"\x00fpval ndigits type ?shorten?\x00double\x00conversion type\x00bad value? %g\n\x00shorten\x00bad flag\x00-\x00+\x00shortest\x00Steele\x00e\x00f\x00append\x00element\x00end\x00free\x00gresult\x00staticsmall\x00short\x00staticlarge\x00first0 first1 first2 first3 first4 first5 first6 first7 first8 first9\nsecond0 second1 second2 second3 second4 second5 second6 second7 second8 second9\nthird0 third1 third2 third3 third4 third5 third6 third7 third8 third9\nfourth0 fourth1 fourth2 fourth3 fourth4 fourth5 fourth6 fourth7 fourth8 fourth9\nfifth0 fifth1 fifth2 fifth3 fifth4 fifth5 fifth6 fifth7 fifth8 fifth9\nsixth0 sixth1 sixth2 sixth3 sixth4 sixth5 sixth6 sixth7 sixth8 sixth9\nseventh0 seventh1 seventh2 seventh3 seventh4 seventh5 seventh6 seventh7 seventh8 seventh9\n\x00This is a malloc-ed string\x00special\x00This is a specially-allocated string\x00bad gresult option \"\x00\": must be staticsmall, staticlarge, free, or special\x00length\x00result\x00trunc\x00start\x00\": must be append, element, end, free, get, length, result, trunc, or start\x00option\x00global\x00bad value \"\x00\": must be global\x00script ?global?\x00global word ?word ...?\x00subcommand ?arg ...?\x00subcommand\x00name position script\x00position specifier\x00queue\x00head\x00tail\x00    (command bound to \"testevent\" callback)\x00    (return value from \"testevent\" callback)\x00 create|delete value\"\x00\": must be create or delete\x00odd %d\n\x00ExitProcOdd: unable to write to stdout\x00even %d\n\x00ExitProcEven: unable to write to stdout\x00 expression\"\x00This is a result\x00: %ld\x00expression\x00: \x00source ?target?\x00could not create link from \"\x00\" to \"\x00\": \x00could not read link \"\x00unix\x00mac\x00windows\x00 path\"\x00 option ?arg arg arg arg arg arg arg arg arg arg arg arg arg arg?\"\x00 intRO realRO boolRO stringRO wideRO charRO ucharRO shortRO ushortRO uintRO longRO ulongRO floatRO uwideRO\"\x00int\x00real\x00bool\x00string\x00wide\x00char\x00uchar\x00ushort\x00uint\x00long\x00ulong\x00float\x00uwide\x00set\x00 intValue realValue boolValue stringValue wideValue charValue ucharValue shortValue ushortValue uintValue longValue ulongValue floatValue uwideValue\"\x00update\x00\": should be create, delete, get, set, or update\x00category ?locale?\x00ctype\x00numeric\x00time\x00collate\x00monetary\x00all\x00T3: wrong type for arg 2\x00T3: wrong type for arg 1\x00script length\x00\n    (remainder of script: \"\x00\")\x00expr length\x00\n    (remainder of expr: \"\x00expand\x00word\x00text\x00backslash\x00command\x00variable\x00subexpr\x00operator\x00varName\x00script length append\x00switch\x00?-switch ...? exp string ?matchVar? ?subMatchVar ...?\x00%d %d\x00couldn't set variable \"\x00%ld\x00-indices\x00-nocase\x00-about\x00-expanded\x00-line\x00-linestop\x00-lineanchor\x00-xflags\x00--\x00 data_key data_item\"\x00 platform\"\x00unsupported platform: should be one of unix, or windows\x00 pkgName safe loaded\"\x00x\x00loaded\x00 level name ?name2? dest global\"\x00namespace\x00too many args\x00NONE\x00 option ?arg ...?\x00cmd\x00 cmd script\x00called \"testfevent code\" before \"testfevent create\"\x00share\x00%s\x00-force\x00mv\x00cp\x00rm\x00mkdir\x00cpdir\x00rmdir\x00name scope\x00::test_ns_var\x00alloc & free 100000 6 word items\n\x00   %.3f usec per alloc+free\n\x00alloc 5000 6 word items\n\x00   %.3f usec per alloc\n\x00free 5000 6 word items\n\x00   %.3f usec per free\n\x00Tcl_NewObj 5000 times\n\x00   %.3f usec per Tcl_NewObj\n\x00Tcl_DecrRefCount 5000 times\n\x00   %.3f usec per Tcl_DecrRefCount\n\x00TclGetStringFromObj of \"12345\" 100000 times\n\x0012345\x00   %.3f usec per TclGetStringFromObj of \"12345\"\n\x00Tcl_GetIntFromObj of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetIntFromObj of \"12345\"\n\x00Tcl_GetInt of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetInt of \"12345\"\n\x00sprintf of 12345 100000 times\n\x00%d\x00   %.3f usec per sprintf of 12345\n\x00hashtable lookup of \"gettimes\" 100000 times\n\x00   %.3f usec per hashtable lookup of \"gettimes\"\n\x00Tcl_SetVar of \"12345\" 100000 times\n\x00a\x00   %.3f usec per Tcl_SetVar of a to \"12345\"\n\x00Tcl_GetVar of a==\"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetVar of a==\"12345\"\n\x00?string?\x00bytearray\x00before get\x00before set\x00 varName ?newValue?\"\x00 varName elemName ?newValue?\"\x00type script discard\x00small result\x00append result\x00free result\x00dynamic result\x00object result\x00called\x00notCalled\x00present\x00missing\x00same\x00different\x00dynamic\x00object\x00small\x00Exit MainLoop\n\x00 subcommand ?additional args..?\"\x00splice\x00setchannelerror\x00setchannelerrorinterp\x00cut\x00 cut channelName\"\x00clearchannelhandlers\x00 clearchannelhandlers channelName\"\x00info\x00 info channelName\"\x00read\x00write\x00nonblocking\x00blocking\x00line\x00none\x00full\x00async_flush\x00eof\x00blocked\x00unblocked\x00auto\x00saw_cr\x00lf\x00cr\x00crlf\x00queued_cr\x00inputbuffered\x00channel name required\x00isshared\x00isstandard\x00mode\x00mthread\x00open\x00tclIO\x00outputbuffered\x00queuedcr\x001\x000\x00readable\x00refcount\x00type\x00writable\x00transform\x00 transform channelId -command cmd\"\x00-command\x00bad argument \"\x00\": should be \"-command\"\x00unstack\x00 unstack channel\"\x00\": should be cut, clearchannelhandlers, info, isshared, mode, open, readable, splice, writable, transform, unstack\x00 channelName cmd ?arg1? ?arg2?\"\x00add\x00 channelName add eventSpec script\"\x00bad event name \"\x00\": must be readable, writable, or none\x00 channelName delete index\"\x00bad event index: \x00: must be nonnegative\x00bad event index \x00: out of range\x00TestChannelEventCmd: damaged event script list\x00list\x00 channelName list\"\x00removeall\x00 channelName removeall\"\x00 channelName delete index event\"\x00bad command \x00, must be one of add, delete, list, set, or removeall\x00insufficient arguments\x00b\x00c\x00d\x00argument targetvalue\x00dummy\x00index value comparison failed: got \x00 when \x00 expected\x00boolean\x00registered\x00failed\x00unregistered\x00lappend filesystemReport \x00stat\x00lstat\x00access\x00matchmounts\x00matchindirectory\x00chdir\x00loadfile\x00link\x00renamefile\x00copyfile\x00deletefile\x00createdirectory\x00copydirectory\x00removedirectory\x00fileattributestrings\x00fileattributesget\x00fileattributesset\x00utime\x00normalizepath\x00simplefs:/\x00read-only\x00r\x00non-zero initial size\x00 creation problem\x00unexpected maximal size\x00 lookup problem\x00 value problem\x00non-zero final size\x00OK\x00Tcl_ConcatObj is unsafe:\x00foo bar sum\x00eeny meeny\x00\n\t* (a) concatObj does not have refCount 0\x00\n\t* (a) concatObj is not a new obj \x00(no new refCount)\x00(refCount added)\x00(more than one refCount added!)\x00extremely unsafe behaviour by Tcl_ConcatObj()\x00\n\t* (b) concatObj does not have refCount 0\x00\n\t* (b) concatObj is not a new obj \x00(refCount removed?)\x00\n\t* (c) concatObj does not have refCount 0\x00\n\t* (c) concatObj is not a new obj \x00\n\t* (d) concatObj does not have refCount 0\x00\n\t* (d) concatObj is not a new obj \x00\n\t* (e) concatObj does not have refCount 0\x00\n\t* (e) concatObj is not a new obj \x00(failed to concat)\x00(corrupted input!)\x00\n\t* (f) concatObj does not have refCount 0\x00\n\t* (f) concatObj is not a new obj \x00\n\t* (g) concatObj does not have refCount 0\x00\n\t* (g) concatObj is not a new obj \x00-bool\x00booltest\x00Marks the end of the options\x00-help\x00Print summary of command-line options and abort\x00::ns2\x00y\x00(NULL)\x00ctx1\x00ctx2\x00Y\x00up|down ?interp?\x00provided interpreter not found\x00operation\x00testInterpResolver\x00could not remove the resolver scheme\x00down\x00up\x00TCLOBJTEST_VARPTR\x00testbignumobj\x00testbooleanobj\x00testdoubleobj\x00testintobj\x00testindexobj\x00testlistobj\x00testobj\x00teststringobj\x00mult10\x00div10\x00iseven\x00radixsize\x00option ?arg ...?\x00var value\x00error in mp_init\x00error in mp_read_radix\x00varIndex\x00error in mp_mul_d\x00error in mp_div_d\x00option arg ?arg ...?\x00not\x00\": must be set, get, or not\x00\": must be set, get, mult10, or div10\x00check\x00token\x00index\x00set2\x00setlong\x00setmaxlong\x00ismaxlong\x00get2\x00inttoobigtest\x00\": must be set, get, get2, mult10, or div10\x00replace\x00option arg ?arg...?\x00varIndex start count ?element...?\x00assign\x00bug3598580\x00convert\x00no type \x00 found\x00duplicate\x00freeallvars\x00invalidateStringRep\x00newobj\x00objtype\x00types\x00\": must be assign, convert, duplicate, freeallvars, newobj, objcount, objtype, refcount, type, or types\x00index value out of range\x00appendstrings\x00length2\x00setlength\x00maxchars\x00getunicode\x00appendself\x00appendself2\x00bad variable index\x00variable %d is unset (NULL)\x00procbodytest\x001.1\x00proc\x00namespace eval %s { namespace export %s }\x00%s::%s\x00newName argsList bodyName\x00command \"\x00\" is not a Tcl procedure\x00procedure \"\x00\" does not have a Proc struct!\x00failed to create a procbody object for procedure \"\x00testthread\x00?-unwind? id ?result?\x00-unwind\x00testthread wait\x00-joinable\x00?-joinable? ?script?\x00-main\x00id\x00cannot join thread \x00?-async? id script\x00-async\x00cancel\x00event\x00exit\x00join\x00names\x00send\x00wait\x00errorproc\x00can't create a new thread\x00errorInfo\x00Error from thread \x00\n\x00invalid thread id\x00no target interp!\x00THREAD\x00errorCode\x00target thread died\x00testchmod\x00testfilehandler\x00testfilewait\x00testfindexecutable\x00testfork\x00testgetopenfile\x00testgetdefenc\x00testsetdefenc\x00testalarm\x00testgotsig\x00 option ... \"\x00bad index \x00close\x00clear\x00 clear index\"\x00counts\x00 counts index\"\x00 create index readMode writeMode\"\x00couldn't open pipe: \x00off\x00disabled\x00bad read mode \"\x00empty\x00 empty index\"\x00fill\x00 fill index\"\x00fillpartial\x00 fillpartial index\"\x00oneevent\x00 wait index readable|writable timeout\"\x00pipe \x00 doesn't exist\x00windowevent\x00\": must be close, clear, counts, create, empty, fill, fillpartial, oneevent, wait, or windowevent\x00 file readable|writable|both timeout\"\x00both\x00\": must be readable, writable, or both\x00couldn't get channel file\x00 argv0\"\x00 channelName forWriting\"\x00Tcl_GetOpenFile succeeded but FILE * NULL!\x00 defaultDir\"\x00Cannot fork\x00sigaction: \x00mode file ?file ...?\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
