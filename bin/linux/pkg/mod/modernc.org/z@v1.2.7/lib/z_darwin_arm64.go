// Code generated by 'ccgo -export-defines "" -export-enums "" -export-externs X -export-fields F -export-structs "" -export-typedefs "" -o lib/z_darwin_arm64.go -pkgname z -trace-translation-units /var/folders/cp/3cmnrnds4j72mrgplhz2wr0w0000gn/T/go-generate-zlib-143733576/cdb.json libz.a', DO NOT EDIT.

package z

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

const (
	ACCESSX_MAX_DESCRIPTORS                   = 100
	ACCESSX_MAX_TABLESIZE                     = 16384
	ARG_MAX                                   = 1048576
	BASE                                      = 65521
	BC_BASE_MAX                               = 99
	BC_DIM_MAX                                = 2048
	BC_SCALE_MAX                              = 99
	BC_STRING_MAX                             = 1000
	BIG_ENDIAN                                = 4321
	BUS_ADRALN                                = 1
	BUS_ADRERR                                = 2
	BUS_NOOP                                  = 0
	BUS_OBJERR                                = 3
	BYTE_ORDER                                = 1234
	CHARCLASS_NAME_MAX                        = 14
	CHAR_BIT                                  = 8
	CHAR_MAX                                  = 127
	CHAR_MIN                                  = -128
	CHILD_MAX                                 = 266
	CLD_CONTINUED                             = 6
	CLD_DUMPED                                = 3
	CLD_EXITED                                = 1
	CLD_KILLED                                = 2
	CLD_NOOP                                  = 0
	CLD_STOPPED                               = 5
	CLD_TRAPPED                               = 4
	CLK_TCK                                   = 100
	COLL_WEIGHTS_MAX                          = 2
	CPUMON_MAKE_FATAL                         = 0x1000
	DEF_MEM_LEVEL                             = 8
	DEF_WBITS                                 = 15
	DYN_TREES                                 = 2
	EQUIV_CLASS_MAX                           = 2
	EXIT_FAILURE                              = 1
	EXIT_SUCCESS                              = 0
	EXPR_NEST_MAX                             = 32
	FAR                                       = 0
	FD_SETSIZE                                = 1024
	FOOTPRINT_INTERVAL_RESET                  = 0x1
	FPE_FLTDIV                                = 1
	FPE_FLTINV                                = 5
	FPE_FLTOVF                                = 2
	FPE_FLTRES                                = 4
	FPE_FLTSUB                                = 6
	FPE_FLTUND                                = 3
	FPE_INTDIV                                = 7
	FPE_INTOVF                                = 8
	FPE_NOOP                                  = 0
	F_LOCK                                    = 1
	F_OK                                      = 0
	F_TEST                                    = 3
	F_TLOCK                                   = 2
	F_ULOCK                                   = 0
	GID_MAX                                   = 2147483647
	HAVE_HIDDEN                               = 1
	HAVE_MEMCPY                               = 0
	ILL_BADSTK                                = 8
	ILL_COPROC                                = 7
	ILL_ILLADR                                = 5
	ILL_ILLOPC                                = 1
	ILL_ILLOPN                                = 4
	ILL_ILLTRP                                = 2
	ILL_NOOP                                  = 0
	ILL_PRVOPC                                = 3
	ILL_PRVREG                                = 6
	INT16_MAX                                 = 32767
	INT16_MIN                                 = -32768
	INT32_MAX                                 = 2147483647
	INT32_MIN                                 = -2147483648
	INT64_MAX                                 = 9223372036854775807
	INT64_MIN                                 = -9223372036854775808
	INT8_MAX                                  = 127
	INT8_MIN                                  = -128
	INTMAX_MAX                                = 9223372036854775807
	INTMAX_MIN                                = -9223372036854775808
	INTPTR_MAX                                = 9223372036854775807
	INTPTR_MIN                                = -9223372036854775808
	INT_FAST16_MAX                            = 32767
	INT_FAST16_MIN                            = -32768
	INT_FAST32_MAX                            = 2147483647
	INT_FAST32_MIN                            = -2147483648
	INT_FAST64_MAX                            = 9223372036854775807
	INT_FAST64_MIN                            = -9223372036854775808
	INT_FAST8_MAX                             = 127
	INT_FAST8_MIN                             = -128
	INT_LEAST16_MAX                           = 32767
	INT_LEAST16_MIN                           = -32768
	INT_LEAST32_MAX                           = 2147483647
	INT_LEAST32_MIN                           = -2147483648
	INT_LEAST64_MAX                           = 9223372036854775807
	INT_LEAST64_MIN                           = -9223372036854775808
	INT_LEAST8_MAX                            = 127
	INT_LEAST8_MIN                            = -128
	INT_MAX                                   = 2147483647
	INT_MIN                                   = -2147483648
	IOPOL_APPLICATION                         = 5
	IOPOL_ATIME_UPDATES_DEFAULT               = 0
	IOPOL_ATIME_UPDATES_OFF                   = 1
	IOPOL_DEFAULT                             = 0
	IOPOL_IMPORTANT                           = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT  = 0
	IOPOL_MATERIALIZE_DATALESS_FILES_OFF      = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_ON       = 2
	IOPOL_NORMAL                              = 1
	IOPOL_PASSIVE                             = 2
	IOPOL_SCOPE_DARWIN_BG                     = 2
	IOPOL_SCOPE_PROCESS                       = 0
	IOPOL_SCOPE_THREAD                        = 1
	IOPOL_STANDARD                            = 5
	IOPOL_THROTTLE                            = 3
	IOPOL_TYPE_DISK                           = 0
	IOPOL_TYPE_VFS_ATIME_UPDATES              = 2
	IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION  = 6
	IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3
	IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME      = 4
	IOPOL_TYPE_VFS_TRIGGER_RESOLVE            = 5
	IOPOL_UTILITY                             = 4
	IOPOL_VFS_CONTENT_PROTECTION_DEFAULT      = 0
	IOPOL_VFS_CONTENT_PROTECTION_IGNORE       = 1
	IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME     = 1
	IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT   = 0
	IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT         = 0
	IOPOL_VFS_TRIGGER_RESOLVE_OFF             = 1
	IOV_MAX                                   = 1024
	LINE_MAX                                  = 2048
	LINK_MAX                                  = 32767
	LITTLE_ENDIAN                             = 1234
	LLONG_MAX                                 = 9223372036854775807
	LLONG_MIN                                 = -9223372036854775808
	LONG_BIT                                  = 64
	LONG_LONG_MAX                             = 9223372036854775807
	LONG_LONG_MIN                             = -9223372036854775808
	LONG_MAX                                  = 9223372036854775807
	LONG_MIN                                  = -9223372036854775808
	L_INCR                                    = 1
	L_SET                                     = 0
	L_XTND                                    = 2
	MAC_OS_VERSION_11_0                       = 110000
	MAC_OS_X_VERSION_10_0                     = 1000
	MAC_OS_X_VERSION_10_1                     = 1010
	MAC_OS_X_VERSION_10_10                    = 101000
	MAC_OS_X_VERSION_10_10_2                  = 101002
	MAC_OS_X_VERSION_10_10_3                  = 101003
	MAC_OS_X_VERSION_10_11                    = 101100
	MAC_OS_X_VERSION_10_11_2                  = 101102
	MAC_OS_X_VERSION_10_11_3                  = 101103
	MAC_OS_X_VERSION_10_11_4                  = 101104
	MAC_OS_X_VERSION_10_12                    = 101200
	MAC_OS_X_VERSION_10_12_1                  = 101201
	MAC_OS_X_VERSION_10_12_2                  = 101202
	MAC_OS_X_VERSION_10_12_4                  = 101204
	MAC_OS_X_VERSION_10_13                    = 101300
	MAC_OS_X_VERSION_10_13_1                  = 101301
	MAC_OS_X_VERSION_10_13_2                  = 101302
	MAC_OS_X_VERSION_10_13_4                  = 101304
	MAC_OS_X_VERSION_10_14                    = 101400
	MAC_OS_X_VERSION_10_14_1                  = 101401
	MAC_OS_X_VERSION_10_14_4                  = 101404
	MAC_OS_X_VERSION_10_14_6                  = 101406
	MAC_OS_X_VERSION_10_15                    = 101500
	MAC_OS_X_VERSION_10_15_1                  = 101501
	MAC_OS_X_VERSION_10_16                    = 101600
	MAC_OS_X_VERSION_10_2                     = 1020
	MAC_OS_X_VERSION_10_3                     = 1030
	MAC_OS_X_VERSION_10_4                     = 1040
	MAC_OS_X_VERSION_10_5                     = 1050
	MAC_OS_X_VERSION_10_6                     = 1060
	MAC_OS_X_VERSION_10_7                     = 1070
	MAC_OS_X_VERSION_10_8                     = 1080
	MAC_OS_X_VERSION_10_9                     = 1090
	MAX_CANON                                 = 1024
	MAX_INPUT                                 = 1024
	MAX_MATCH                                 = 258
	MAX_MEM_LEVEL                             = 9
	MAX_WBITS                                 = 15
	MB_LEN_MAX                                = 6
	MINSIGSTKSZ                               = 32768
	MIN_MATCH                                 = 3
	NAME_MAX                                  = 255
	NBBY                                      = 8
	NGROUPS_MAX                               = 16
	NL_ARGMAX                                 = 9
	NL_LANGMAX                                = 14
	NL_MSGMAX                                 = 32767
	NL_NMAX                                   = 1
	NL_SETMAX                                 = 255
	NL_TEXTMAX                                = 2048
	NMAX                                      = 5552
	NSIG                                      = 32
	NZERO                                     = 20
	OFF_MAX                                   = 9223372036854775807
	OFF_MIN                                   = -9223372036854775808
	OPEN_MAX                                  = 10240
	OS_CODE                                   = 19
	PASS_MAX                                  = 128
	PATH_MAX                                  = 1024
	PDP_ENDIAN                                = 3412
	PIPE_BUF                                  = 512
	POLL_ERR                                  = 4
	POLL_HUP                                  = 6
	POLL_IN                                   = 1
	POLL_MSG                                  = 3
	POLL_OUT                                  = 2
	POLL_PRI                                  = 5
	PRESET_DICT                               = 0x20
	PRIO_DARWIN_BG                            = 0x1000
	PRIO_DARWIN_NONUI                         = 0x1001
	PRIO_DARWIN_PROCESS                       = 4
	PRIO_DARWIN_THREAD                        = 3
	PRIO_MAX                                  = 20
	PRIO_MIN                                  = -20
	PRIO_PGRP                                 = 1
	PRIO_PROCESS                              = 0
	PRIO_USER                                 = 2
	PTHREAD_DESTRUCTOR_ITERATIONS             = 4
	PTHREAD_KEYS_MAX                          = 512
	PTHREAD_STACK_MIN                         = 16384
	PTRDIFF_MAX                               = 9223372036854775807
	PTRDIFF_MIN                               = -9223372036854775808
	QUAD_MAX                                  = 9223372036854775807
	QUAD_MIN                                  = -9223372036854775808
	RAND_MAX                                  = 0x7fffffff
	RE_DUP_MAX                                = 255
	RLIMIT_AS                                 = 5
	RLIMIT_CORE                               = 4
	RLIMIT_CPU                                = 0
	RLIMIT_CPU_USAGE_MONITOR                  = 0x2
	RLIMIT_DATA                               = 2
	RLIMIT_FOOTPRINT_INTERVAL                 = 0x4
	RLIMIT_FSIZE                              = 1
	RLIMIT_MEMLOCK                            = 6
	RLIMIT_NOFILE                             = 8
	RLIMIT_NPROC                              = 7
	RLIMIT_RSS                                = 5
	RLIMIT_STACK                              = 3
	RLIMIT_THREAD_CPULIMITS                   = 0x3
	RLIMIT_WAKEUPS_MONITOR                    = 0x1
	RLIM_NLIMITS                              = 9
	RSIZE_MAX                                 = 9223372036854775807
	RUSAGE_CHILDREN                           = -1
	RUSAGE_INFO_CURRENT                       = 5
	RUSAGE_INFO_V0                            = 0
	RUSAGE_INFO_V1                            = 1
	RUSAGE_INFO_V2                            = 2
	RUSAGE_INFO_V3                            = 3
	RUSAGE_INFO_V4                            = 4
	RUSAGE_INFO_V5                            = 5
	RUSAGE_SELF                               = 0
	RU_PROC_RUNS_RESLIDE                      = 0x00000001
	R_OK                                      = 4
	SA_64REGSET                               = 0x0200
	SA_NOCLDSTOP                              = 0x0008
	SA_NOCLDWAIT                              = 0x0020
	SA_NODEFER                                = 0x0010
	SA_ONSTACK                                = 0x0001
	SA_RESETHAND                              = 0x0004
	SA_RESTART                                = 0x0002
	SA_SIGINFO                                = 0x0040
	SA_USERSPACE_MASK                         = 127
	SA_USERTRAMP                              = 0x0100
	SCHAR_MAX                                 = 127
	SCHAR_MIN                                 = -128
	SEEK_CUR                                  = 1
	SEEK_DATA                                 = 4
	SEEK_END                                  = 2
	SEEK_HOLE                                 = 3
	SEEK_SET                                  = 0
	SEGV_ACCERR                               = 2
	SEGV_MAPERR                               = 1
	SEGV_NOOP                                 = 0
	SHRT_MAX                                  = 32767
	SHRT_MIN                                  = -32768
	SIGABRT                                   = 6
	SIGALRM                                   = 14
	SIGBUS                                    = 10
	SIGCHLD                                   = 20
	SIGCONT                                   = 19
	SIGEMT                                    = 7
	SIGEV_NONE                                = 0
	SIGEV_SIGNAL                              = 1
	SIGEV_THREAD                              = 3
	SIGFPE                                    = 8
	SIGHUP                                    = 1
	SIGILL                                    = 4
	SIGINFO                                   = 29
	SIGINT                                    = 2
	SIGIO                                     = 23
	SIGIOT                                    = 6
	SIGKILL                                   = 9
	SIGPIPE                                   = 13
	SIGPROF                                   = 27
	SIGQUIT                                   = 3
	SIGSEGV                                   = 11
	SIGSTKSZ                                  = 131072
	SIGSTOP                                   = 17
	SIGSYS                                    = 12
	SIGTERM                                   = 15
	SIGTRAP                                   = 5
	SIGTSTP                                   = 18
	SIGTTIN                                   = 21
	SIGTTOU                                   = 22
	SIGURG                                    = 16
	SIGUSR1                                   = 30
	SIGUSR2                                   = 31
	SIGVTALRM                                 = 26
	SIGWINCH                                  = 28
	SIGXCPU                                   = 24
	SIGXFSZ                                   = 25
	SIG_ATOMIC_MAX                            = 2147483647
	SIG_ATOMIC_MIN                            = -2147483648
	SIG_BLOCK                                 = 1
	SIG_SETMASK                               = 3
	SIG_UNBLOCK                               = 2
	SIZE_MAX                                  = 18446744073709551615
	SIZE_T_MAX                                = 18446744073709551615
	SI_ASYNCIO                                = 0x10004
	SI_MESGQ                                  = 0x10005
	SI_QUEUE                                  = 0x10002
	SI_TIMER                                  = 0x10003
	SI_USER                                   = 0x10001
	SSIZE_MAX                                 = 9223372036854775807
	SS_DISABLE                                = 0x0004
	SS_ONSTACK                                = 0x0001
	STATIC_TREES                              = 1
	STDC                                      = 0
	STDC99                                    = 0
	STDERR_FILENO                             = 2
	STDIN_FILENO                              = 0
	STDOUT_FILENO                             = 1
	STORED_BLOCK                              = 0
	SV_INTERRUPT                              = 2
	SV_NOCLDSTOP                              = 8
	SV_NODEFER                                = 16
	SV_ONSTACK                                = 1
	SV_RESETHAND                              = 4
	SV_SIGINFO                                = 64
	SYNC_VOLUME_FULLSYNC                      = 0x01
	SYNC_VOLUME_WAIT                          = 0x02
	TRAP_BRKPT                                = 1
	TRAP_TRACE                                = 2
	UCHAR_MAX                                 = 255
	UID_MAX                                   = 2147483647
	UINT16_MAX                                = 65535
	UINT32_MAX                                = 4294967295
	UINT64_MAX                                = 18446744073709551615
	UINT8_MAX                                 = 255
	UINTMAX_MAX                               = 18446744073709551615
	UINTPTR_MAX                               = 18446744073709551615
	UINT_FAST16_MAX                           = 65535
	UINT_FAST32_MAX                           = 4294967295
	UINT_FAST64_MAX                           = 18446744073709551615
	UINT_FAST8_MAX                            = 255
	UINT_LEAST16_MAX                          = 65535
	UINT_LEAST32_MAX                          = 4294967295
	UINT_LEAST64_MAX                          = 18446744073709551615
	UINT_LEAST8_MAX                           = 255
	UINT_MAX                                  = 4294967295
	ULLONG_MAX                                = 18446744073709551615
	ULONG_LONG_MAX                            = 18446744073709551615
	ULONG_MAX                                 = 18446744073709551615
	UQUAD_MAX                                 = 18446744073709551615
	USHRT_MAX                                 = 65535
	WAIT_ANY                                  = -1
	WAIT_MYPGRP                               = 0
	WAKEMON_DISABLE                           = 0x02
	WAKEMON_ENABLE                            = 0x01
	WAKEMON_GET_PARAMS                        = 0x04
	WAKEMON_MAKE_FATAL                        = 0x10
	WAKEMON_SET_DEFAULTS                      = 0x08
	WCHAR_MAX                                 = 2147483647
	WCHAR_MIN                                 = -2147483648
	WCONTINUED                                = 0x00000010
	WCOREFLAG                                 = 0200
	WEXITED                                   = 0x00000004
	WINT_MAX                                  = 2147483647
	WINT_MIN                                  = -2147483648
	WNOHANG                                   = 0x00000001
	WNOWAIT                                   = 0x00000020
	WORD_BIT                                  = 32
	WSTOPPED                                  = 0x00000008
	WUNTRACED                                 = 0x00000002
	W_OK                                      = 2
	X_OK                                      = 1
	ZCONF_H                                   = 0
	ZEXPORT                                   = 0
	ZEXPORTVA                                 = 0
	ZLIB_H                                    = 0
	ZLIB_VERNUM                               = 0x12b0
	ZLIB_VERSION                              = "1.2.11"
	ZLIB_VER_MAJOR                            = 1
	ZLIB_VER_MINOR                            = 2
	ZLIB_VER_REVISION                         = 11
	ZLIB_VER_SUBREVISION                      = 0
	ZUTIL_H                                   = 0
	Z_ASCII                                   = 1
	Z_BEST_COMPRESSION                        = 9
	Z_BEST_SPEED                              = 1
	Z_BINARY                                  = 0
	Z_BLOCK                                   = 5
	Z_BUF_ERROR                               = -5
	Z_DATA_ERROR                              = -3
	Z_DEFAULT_COMPRESSION                     = -1
	Z_DEFAULT_STRATEGY                        = 0
	Z_DEFLATED                                = 8
	Z_ERRNO                                   = -1
	Z_FILTERED                                = 1
	Z_FINISH                                  = 4
	Z_FIXED                                   = 4
	Z_FULL_FLUSH                              = 3
	Z_HAVE_STDARG_H                           = 0
	Z_HAVE_UNISTD_H                           = 0
	Z_HUFFMAN_ONLY                            = 2
	Z_MEM_ERROR                               = -4
	Z_NEED_DICT                               = 2
	Z_NO_COMPRESSION                          = 0
	Z_NO_FLUSH                                = 0
	Z_NULL                                    = 0
	Z_OK                                      = 0
	Z_PARTIAL_FLUSH                           = 1
	Z_RLE                                     = 3
	Z_STREAM_END                              = 1
	Z_STREAM_ERROR                            = -2
	Z_SYNC_FLUSH                              = 2
	Z_TEXT                                    = 1
	Z_TREES                                   = 6
	Z_UNKNOWN                                 = 2
	Z_VERSION_ERROR                           = -6
	X_ACCESS_EXTENDED_MASK                    = 4193792
	X_ALLOCA_H_                               = 0
	X_ANSI_STDARG_H_                          = 0
	X_ANSI_STDDEF_H                           = 0
	X_APPEND_OK                               = 8192
	X_ARM_ARCH_H                              = 0
	X_ARM_LIMITS_H_                           = 0
	X_ARM_SIGNAL_                             = 1
	X_ARM__ENDIAN_H_                          = 0
	X_ARM__LIMITS_H_                          = 0
	X_BLKCNT_T                                = 0
	X_BLKSIZE_T                               = 0
	X_BSD_ARM__TYPES_H_                       = 0
	X_BSD_MACHINE_ENDIAN_H_                   = 0
	X_BSD_MACHINE_SIGNAL_H_                   = 0
	X_BSD_MACHINE_TYPES_H_                    = 0
	X_BSD_MACHINE__TYPES_H_                   = 0
	X_BSD_PTRDIFF_T_                          = 0
	X_BSD_SIZE_T_                             = 0
	X_BSD_SIZE_T_DEFINED_                     = 0
	X_CADDR_T                                 = 0
	X_CDEFS_H_                                = 0
	X_CHOWN_OK                                = 2097152
	X_CLOCK_T                                 = 0
	X_CS_DARWIN_USER_CACHE_DIR                = 65538
	X_CS_DARWIN_USER_DIR                      = 65536
	X_CS_DARWIN_USER_TEMP_DIR                 = 65537
	X_CS_PATH                                 = 1
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS          = 2
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS         = 3
	X_CS_POSIX_V6_ILP32_OFF32_LIBS            = 4
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS         = 5
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS        = 6
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS           = 7
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS           = 8
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS          = 9
	X_CS_POSIX_V6_LP64_OFF64_LIBS             = 10
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS         = 11
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS        = 12
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS           = 13
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS       = 14
	X_CS_XBS5_ILP32_OFF32_CFLAGS              = 20
	X_CS_XBS5_ILP32_OFF32_LDFLAGS             = 21
	X_CS_XBS5_ILP32_OFF32_LIBS                = 22
	X_CS_XBS5_ILP32_OFF32_LINTFLAGS           = 23
	X_CS_XBS5_ILP32_OFFBIG_CFLAGS             = 24
	X_CS_XBS5_ILP32_OFFBIG_LDFLAGS            = 25
	X_CS_XBS5_ILP32_OFFBIG_LIBS               = 26
	X_CS_XBS5_ILP32_OFFBIG_LINTFLAGS          = 27
	X_CS_XBS5_LP64_OFF64_CFLAGS               = 28
	X_CS_XBS5_LP64_OFF64_LDFLAGS              = 29
	X_CS_XBS5_LP64_OFF64_LIBS                 = 30
	X_CS_XBS5_LP64_OFF64_LINTFLAGS            = 31
	X_CS_XBS5_LPBIG_OFFBIG_CFLAGS             = 32
	X_CS_XBS5_LPBIG_OFFBIG_LDFLAGS            = 33
	X_CS_XBS5_LPBIG_OFFBIG_LIBS               = 34
	X_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS          = 35
	X_CTERMID_H_                              = 0
	X_CT_RUNE_T                               = 0
	X_DARWIN_FEATURE_64_BIT_INODE             = 1
	X_DARWIN_FEATURE_ONLY_64_BIT_INODE        = 1
	X_DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE    = 1
	X_DARWIN_FEATURE_ONLY_VERS_1050           = 1
	X_DARWIN_FEATURE_UNIX_CONFORMANCE         = 3
	X_DELETE_OK                               = 4096
	X_DEV_T                                   = 0
	X_ERRNO_T                                 = 0
	X_EXECUTE_OK                              = 2048
	X_FD_SET                                  = 0
	X_FILE_OFFSET_BITS                        = 64
	X_FORTIFY_SOURCE                          = 2
	X_FSBLKCNT_T                              = 0
	X_FSFILCNT_T                              = 0
	X_GCC_LIMITS_H_                           = 0
	X_GCC_MAX_ALIGN_T                         = 0
	X_GCC_PTRDIFF_T                           = 0
	X_GCC_SIZE_T                              = 0
	X_GCC_WCHAR_T                             = 0
	X_GCC_WRAP_STDINT_H                       = 0
	X_GID_T                                   = 0
	X_ID_T                                    = 0
	X_INO64_T                                 = 0
	X_INO_T                                   = 0
	X_INT16_T                                 = 0
	X_INT32_T                                 = 0
	X_INT64_T                                 = 0
	X_INT8_T                                  = 0
	X_INTMAX_T                                = 0
	X_INTPTR_T                                = 0
	X_IN_ADDR_T                               = 0
	X_IN_PORT_T                               = 0
	X_KEY_T                                   = 0
	X_LIMITS_H_                               = 0
	X_LIMITS_H___                             = 0
	X_LP64                                    = 1
	X_MACHTYPES_H_                            = 0
	X_MACH_ARM__STRUCTS_H_                    = 0
	X_MACH_MACHINE__STRUCTS_H_                = 0
	X_MALLOC_UNDERSCORE_MALLOC_H_             = 0
	X_MCONTEXT_T                              = 0
	X_MODE_T                                  = 0
	X_NLINK_T                                 = 0
	X_Nonnull                                 = 0
	X_Null_unspecified                        = 0
	X_Nullable                                = 0
	X_OFF_T                                   = 0
	X_OS_OSBYTEORDERARM_H                     = 0
	X_OS__OSBYTEORDER_H                       = 0
	X_PC_2_SYMLINKS                           = 15
	X_PC_ALLOC_SIZE_MIN                       = 16
	X_PC_ASYNC_IO                             = 17
	X_PC_AUTH_OPAQUE_NP                       = 14
	X_PC_CASE_PRESERVING                      = 12
	X_PC_CASE_SENSITIVE                       = 11
	X_PC_CHOWN_RESTRICTED                     = 7
	X_PC_EXTENDED_SECURITY_NP                 = 13
	X_PC_FILESIZEBITS                         = 18
	X_PC_LINK_MAX                             = 1
	X_PC_MAX_CANON                            = 2
	X_PC_MAX_INPUT                            = 3
	X_PC_MIN_HOLE_SIZE                        = 27
	X_PC_NAME_CHARS_MAX                       = 10
	X_PC_NAME_MAX                             = 4
	X_PC_NO_TRUNC                             = 8
	X_PC_PATH_MAX                             = 5
	X_PC_PIPE_BUF                             = 6
	X_PC_PRIO_IO                              = 19
	X_PC_REC_INCR_XFER_SIZE                   = 20
	X_PC_REC_MAX_XFER_SIZE                    = 21
	X_PC_REC_MIN_XFER_SIZE                    = 22
	X_PC_REC_XFER_ALIGN                       = 23
	X_PC_SYMLINK_MAX                          = 24
	X_PC_SYNC_IO                              = 25
	X_PC_VDISABLE                             = 9
	X_PC_XATTR_SIZE_BITS                      = 26
	X_PID_T                                   = 0
	X_POSIX2_BC_BASE_MAX                      = 99
	X_POSIX2_BC_DIM_MAX                       = 2048
	X_POSIX2_BC_SCALE_MAX                     = 99
	X_POSIX2_BC_STRING_MAX                    = 1000
	X_POSIX2_CHARCLASS_NAME_MAX               = 14
	X_POSIX2_CHAR_TERM                        = 200112
	X_POSIX2_COLL_WEIGHTS_MAX                 = 2
	X_POSIX2_C_BIND                           = 200112
	X_POSIX2_C_DEV                            = 200112
	X_POSIX2_EQUIV_CLASS_MAX                  = 2
	X_POSIX2_EXPR_NEST_MAX                    = 32
	X_POSIX2_FORT_DEV                         = -1
	X_POSIX2_FORT_RUN                         = 200112
	X_POSIX2_LINE_MAX                         = 2048
	X_POSIX2_LOCALEDEF                        = 200112
	X_POSIX2_PBS                              = -1
	X_POSIX2_PBS_ACCOUNTING                   = -1
	X_POSIX2_PBS_CHECKPOINT                   = -1
	X_POSIX2_PBS_LOCATE                       = -1
	X_POSIX2_PBS_MESSAGE                      = -1
	X_POSIX2_PBS_TRACK                        = -1
	X_POSIX2_RE_DUP_MAX                       = 255
	X_POSIX2_SW_DEV                           = 200112
	X_POSIX2_UPE                              = 200112
	X_POSIX2_VERSION                          = 200112
	X_POSIX_ADVISORY_INFO                     = -1
	X_POSIX_AIO_LISTIO_MAX                    = 2
	X_POSIX_AIO_MAX                           = 1
	X_POSIX_ARG_MAX                           = 4096
	X_POSIX_ASYNCHRONOUS_IO                   = -1
	X_POSIX_BARRIERS                          = -1
	X_POSIX_CHILD_MAX                         = 25
	X_POSIX_CHOWN_RESTRICTED                  = 200112
	X_POSIX_CLOCKRES_MIN                      = 20000000
	X_POSIX_CLOCK_SELECTION                   = -1
	X_POSIX_CPUTIME                           = -1
	X_POSIX_DELAYTIMER_MAX                    = 32
	X_POSIX_FSYNC                             = 200112
	X_POSIX_HOST_NAME_MAX                     = 255
	X_POSIX_IPV6                              = 200112
	X_POSIX_JOB_CONTROL                       = 200112
	X_POSIX_LINK_MAX                          = 8
	X_POSIX_LOGIN_NAME_MAX                    = 9
	X_POSIX_MAPPED_FILES                      = 200112
	X_POSIX_MAX_CANON                         = 255
	X_POSIX_MAX_INPUT                         = 255
	X_POSIX_MEMLOCK                           = -1
	X_POSIX_MEMLOCK_RANGE                     = -1
	X_POSIX_MEMORY_PROTECTION                 = 200112
	X_POSIX_MESSAGE_PASSING                   = -1
	X_POSIX_MONOTONIC_CLOCK                   = -1
	X_POSIX_MQ_OPEN_MAX                       = 8
	X_POSIX_MQ_PRIO_MAX                       = 32
	X_POSIX_NAME_MAX                          = 14
	X_POSIX_NGROUPS_MAX                       = 8
	X_POSIX_NO_TRUNC                          = 200112
	X_POSIX_OPEN_MAX                          = 20
	X_POSIX_PATH_MAX                          = 256
	X_POSIX_PIPE_BUF                          = 512
	X_POSIX_PRIORITIZED_IO                    = -1
	X_POSIX_PRIORITY_SCHEDULING               = -1
	X_POSIX_RAW_SOCKETS                       = -1
	X_POSIX_READER_WRITER_LOCKS               = 200112
	X_POSIX_REALTIME_SIGNALS                  = -1
	X_POSIX_REGEXP                            = 200112
	X_POSIX_RE_DUP_MAX                        = 255
	X_POSIX_RTSIG_MAX                         = 8
	X_POSIX_SAVED_IDS                         = 200112
	X_POSIX_SEMAPHORES                        = -1
	X_POSIX_SEM_NSEMS_MAX                     = 256
	X_POSIX_SEM_VALUE_MAX                     = 32767
	X_POSIX_SHARED_MEMORY_OBJECTS             = -1
	X_POSIX_SHELL                             = 200112
	X_POSIX_SIGQUEUE_MAX                      = 32
	X_POSIX_SPAWN                             = -1
	X_POSIX_SPIN_LOCKS                        = -1
	X_POSIX_SPORADIC_SERVER                   = -1
	X_POSIX_SSIZE_MAX                         = 32767
	X_POSIX_SS_REPL_MAX                       = 4
	X_POSIX_STREAM_MAX                        = 8
	X_POSIX_SYMLINK_MAX                       = 255
	X_POSIX_SYMLOOP_MAX                       = 8
	X_POSIX_SYNCHRONIZED_IO                   = -1
	X_POSIX_THREADS                           = 200112
	X_POSIX_THREAD_ATTR_STACKADDR             = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE             = 200112
	X_POSIX_THREAD_CPUTIME                    = -1
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS      = 4
	X_POSIX_THREAD_KEYS_MAX                   = 128
	X_POSIX_THREAD_PRIORITY_SCHEDULING        = -1
	X_POSIX_THREAD_PRIO_INHERIT               = -1
	X_POSIX_THREAD_PRIO_PROTECT               = -1
	X_POSIX_THREAD_PROCESS_SHARED             = 200112
	X_POSIX_THREAD_SAFE_FUNCTIONS             = 200112
	X_POSIX_THREAD_SPORADIC_SERVER            = -1
	X_POSIX_THREAD_THREADS_MAX                = 64
	X_POSIX_TIMEOUTS                          = -1
	X_POSIX_TIMERS                            = -1
	X_POSIX_TIMER_MAX                         = 32
	X_POSIX_TRACE                             = -1
	X_POSIX_TRACE_EVENT_FILTER                = -1
	X_POSIX_TRACE_EVENT_NAME_MAX              = 30
	X_POSIX_TRACE_INHERIT                     = -1
	X_POSIX_TRACE_LOG                         = -1
	X_POSIX_TRACE_NAME_MAX                    = 8
	X_POSIX_TRACE_SYS_MAX                     = 8
	X_POSIX_TRACE_USER_EVENT_MAX              = 32
	X_POSIX_TTY_NAME_MAX                      = 9
	X_POSIX_TYPED_MEMORY_OBJECTS              = -1
	X_POSIX_TZNAME_MAX                        = 6
	X_POSIX_V6_ILP32_OFF32                    = -1
	X_POSIX_V6_ILP32_OFFBIG                   = -1
	X_POSIX_V6_LP64_OFF64                     = 1
	X_POSIX_V6_LPBIG_OFFBIG                   = 1
	X_POSIX_V7_ILP32_OFF32                    = -1
	X_POSIX_V7_ILP32_OFFBIG                   = -1
	X_POSIX_V7_LP64_OFF64                     = 1
	X_POSIX_V7_LPBIG_OFFBIG                   = 1
	X_POSIX_VERSION                           = 200112
	X_PTHREAD_ATTR_T                          = 0
	X_PTHREAD_CONDATTR_T                      = 0
	X_PTHREAD_COND_T                          = 0
	X_PTHREAD_KEY_T                           = 0
	X_PTHREAD_MUTEXATTR_T                     = 0
	X_PTHREAD_MUTEX_T                         = 0
	X_PTHREAD_ONCE_T                          = 0
	X_PTHREAD_RWLOCKATTR_T                    = 0
	X_PTHREAD_RWLOCK_T                        = 0
	X_PTHREAD_T                               = 0
	X_PTRDIFF_T                               = 0
	X_PTRDIFF_T_                              = 0
	X_PTRDIFF_T_DECLARED                      = 0
	X_QUAD_HIGHWORD                           = 1
	X_QUAD_LOWWORD                            = 0
	X_RATTR_OK                                = 32768
	X_READ_OK                                 = 512
	X_REXT_OK                                 = 131072
	X_RLIMIT_POSIX_FLAG                       = 0x1000
	X_RMFILE_OK                               = 16384
	X_RPERM_OK                                = 524288
	X_RSIZE_T                                 = 0
	X_RUNE_T                                  = 0
	X_SC_2_CHAR_TERM                          = 20
	X_SC_2_C_BIND                             = 18
	X_SC_2_C_DEV                              = 19
	X_SC_2_FORT_DEV                           = 21
	X_SC_2_FORT_RUN                           = 22
	X_SC_2_LOCALEDEF                          = 23
	X_SC_2_PBS                                = 59
	X_SC_2_PBS_ACCOUNTING                     = 60
	X_SC_2_PBS_CHECKPOINT                     = 61
	X_SC_2_PBS_LOCATE                         = 62
	X_SC_2_PBS_MESSAGE                        = 63
	X_SC_2_PBS_TRACK                          = 64
	X_SC_2_SW_DEV                             = 24
	X_SC_2_UPE                                = 25
	X_SC_2_VERSION                            = 17
	X_SC_ADVISORY_INFO                        = 65
	X_SC_AIO_LISTIO_MAX                       = 42
	X_SC_AIO_MAX                              = 43
	X_SC_AIO_PRIO_DELTA_MAX                   = 44
	X_SC_ARG_MAX                              = 1
	X_SC_ASYNCHRONOUS_IO                      = 28
	X_SC_ATEXIT_MAX                           = 107
	X_SC_BARRIERS                             = 66
	X_SC_BC_BASE_MAX                          = 9
	X_SC_BC_DIM_MAX                           = 10
	X_SC_BC_SCALE_MAX                         = 11
	X_SC_BC_STRING_MAX                        = 12
	X_SC_CHILD_MAX                            = 2
	X_SC_CLK_TCK                              = 3
	X_SC_CLOCK_SELECTION                      = 67
	X_SC_COLL_WEIGHTS_MAX                     = 13
	X_SC_CPUTIME                              = 68
	X_SC_DELAYTIMER_MAX                       = 45
	X_SC_EXPR_NEST_MAX                        = 14
	X_SC_FILE_LOCKING                         = 69
	X_SC_FSYNC                                = 38
	X_SC_GETGR_R_SIZE_MAX                     = 70
	X_SC_GETPW_R_SIZE_MAX                     = 71
	X_SC_HOST_NAME_MAX                        = 72
	X_SC_IOV_MAX                              = 56
	X_SC_IPV6                                 = 118
	X_SC_JOB_CONTROL                          = 6
	X_SC_LINE_MAX                             = 15
	X_SC_LOGIN_NAME_MAX                       = 73
	X_SC_MAPPED_FILES                         = 47
	X_SC_MEMLOCK                              = 30
	X_SC_MEMLOCK_RANGE                        = 31
	X_SC_MEMORY_PROTECTION                    = 32
	X_SC_MESSAGE_PASSING                      = 33
	X_SC_MONOTONIC_CLOCK                      = 74
	X_SC_MQ_OPEN_MAX                          = 46
	X_SC_MQ_PRIO_MAX                          = 75
	X_SC_NGROUPS_MAX                          = 4
	X_SC_NPROCESSORS_CONF                     = 57
	X_SC_NPROCESSORS_ONLN                     = 58
	X_SC_OPEN_MAX                             = 5
	X_SC_PAGESIZE                             = 29
	X_SC_PAGE_SIZE                            = 29
	X_SC_PASS_MAX                             = 131
	X_SC_PHYS_PAGES                           = 200
	X_SC_PRIORITIZED_IO                       = 34
	X_SC_PRIORITY_SCHEDULING                  = 35
	X_SC_RAW_SOCKETS                          = 119
	X_SC_READER_WRITER_LOCKS                  = 76
	X_SC_REALTIME_SIGNALS                     = 36
	X_SC_REGEXP                               = 77
	X_SC_RE_DUP_MAX                           = 16
	X_SC_RTSIG_MAX                            = 48
	X_SC_SAVED_IDS                            = 7
	X_SC_SEMAPHORES                           = 37
	X_SC_SEM_NSEMS_MAX                        = 49
	X_SC_SEM_VALUE_MAX                        = 50
	X_SC_SHARED_MEMORY_OBJECTS                = 39
	X_SC_SHELL                                = 78
	X_SC_SIGQUEUE_MAX                         = 51
	X_SC_SPAWN                                = 79
	X_SC_SPIN_LOCKS                           = 80
	X_SC_SPORADIC_SERVER                      = 81
	X_SC_SS_REPL_MAX                          = 126
	X_SC_STREAM_MAX                           = 26
	X_SC_SYMLOOP_MAX                          = 120
	X_SC_SYNCHRONIZED_IO                      = 40
	X_SC_THREADS                              = 96
	X_SC_THREAD_ATTR_STACKADDR                = 82
	X_SC_THREAD_ATTR_STACKSIZE                = 83
	X_SC_THREAD_CPUTIME                       = 84
	X_SC_THREAD_DESTRUCTOR_ITERATIONS         = 85
	X_SC_THREAD_KEYS_MAX                      = 86
	X_SC_THREAD_PRIORITY_SCHEDULING           = 89
	X_SC_THREAD_PRIO_INHERIT                  = 87
	X_SC_THREAD_PRIO_PROTECT                  = 88
	X_SC_THREAD_PROCESS_SHARED                = 90
	X_SC_THREAD_SAFE_FUNCTIONS                = 91
	X_SC_THREAD_SPORADIC_SERVER               = 92
	X_SC_THREAD_STACK_MIN                     = 93
	X_SC_THREAD_THREADS_MAX                   = 94
	X_SC_TIMEOUTS                             = 95
	X_SC_TIMERS                               = 41
	X_SC_TIMER_MAX                            = 52
	X_SC_TRACE                                = 97
	X_SC_TRACE_EVENT_FILTER                   = 98
	X_SC_TRACE_EVENT_NAME_MAX                 = 127
	X_SC_TRACE_INHERIT                        = 99
	X_SC_TRACE_LOG                            = 100
	X_SC_TRACE_NAME_MAX                       = 128
	X_SC_TRACE_SYS_MAX                        = 129
	X_SC_TRACE_USER_EVENT_MAX                 = 130
	X_SC_TTY_NAME_MAX                         = 101
	X_SC_TYPED_MEMORY_OBJECTS                 = 102
	X_SC_TZNAME_MAX                           = 27
	X_SC_V6_ILP32_OFF32                       = 103
	X_SC_V6_ILP32_OFFBIG                      = 104
	X_SC_V6_LP64_OFF64                        = 105
	X_SC_V6_LPBIG_OFFBIG                      = 106
	X_SC_VERSION                              = 8
	X_SC_XBS5_ILP32_OFF32                     = 122
	X_SC_XBS5_ILP32_OFFBIG                    = 123
	X_SC_XBS5_LP64_OFF64                      = 124
	X_SC_XBS5_LPBIG_OFFBIG                    = 125
	X_SC_XOPEN_CRYPT                          = 108
	X_SC_XOPEN_ENH_I18N                       = 109
	X_SC_XOPEN_LEGACY                         = 110
	X_SC_XOPEN_REALTIME                       = 111
	X_SC_XOPEN_REALTIME_THREADS               = 112
	X_SC_XOPEN_SHM                            = 113
	X_SC_XOPEN_STREAMS                        = 114
	X_SC_XOPEN_UNIX                           = 115
	X_SC_XOPEN_VERSION                        = 116
	X_SC_XOPEN_XCU_VERSION                    = 121
	X_SECURE__COMMON_H_                       = 0
	X_SECURE__STRINGS_H_                      = 0
	X_SECURE__STRING_H_                       = 0
	X_SIGSET_T                                = 0
	X_SIZET_                                  = 0
	X_SIZE_T                                  = 0
	X_SIZE_T_                                 = 0
	X_SIZE_T_DECLARED                         = 0
	X_SIZE_T_DEFINED                          = 0
	X_SIZE_T_DEFINED_                         = 0
	X_SSIZE_T                                 = 0
	X_STDARG_H                                = 0
	X_STDDEF_H                                = 0
	X_STDDEF_H_                               = 0
	X_STDINT_H_                               = 0
	X_STDLIB_H_                               = 0
	X_STRINGS_H_                              = 0
	X_STRING_H_                               = 0
	X_SUSECONDS_T                             = 0
	X_SYS_RESOURCE_H_                         = 0
	X_SYS_SELECT_H_                           = 0
	X_SYS_SIGNAL_H_                           = 0
	X_SYS_SIZE_T_H                            = 0
	X_SYS_SYSLIMITS_H_                        = 0
	X_SYS_TYPES_H_                            = 0
	X_SYS_UNISTD_H_                           = 0
	X_SYS_WAIT_H_                             = 0
	X_SYS__ENDIAN_H_                          = 0
	X_SYS__PTHREAD_TYPES_H_                   = 0
	X_SYS__SELECT_H_                          = 0
	X_SYS__TYPES_H_                           = 0
	X_TIME_T                                  = 0
	X_T_PTRDIFF                               = 0
	X_T_PTRDIFF_                              = 0
	X_T_SIZE                                  = 0
	X_T_SIZE_                                 = 0
	X_T_WCHAR                                 = 0
	X_T_WCHAR_                                = 0
	X_UID_T                                   = 0
	X_UINT16_T                                = 0
	X_UINT32_T                                = 0
	X_UINT64_T                                = 0
	X_UINT8_T                                 = 0
	X_UINTMAX_T                               = 0
	X_UINTPTR_T                               = 0
	X_UNISTD_H_                               = 0
	X_USECONDS_T                              = 0
	X_USE_FORTIFY_LEVEL                       = 2
	X_UUID_T                                  = 0
	X_U_CHAR                                  = 0
	X_U_INT                                   = 0
	X_U_INT16_T                               = 0
	X_U_INT32_T                               = 0
	X_U_INT64_T                               = 0
	X_U_INT8_T                                = 0
	X_U_LONG                                  = 0
	X_U_SHORT                                 = 0
	X_V6_ILP32_OFF32                          = -1
	X_V6_ILP32_OFFBIG                         = -1
	X_V6_LP64_OFF64                           = 1
	X_V6_LPBIG_OFFBIG                         = 1
	X_VA_LIST                                 = 0
	X_VA_LIST_                                = 0
	X_VA_LIST_DEFINED                         = 0
	X_VA_LIST_T_H                             = 0
	X_WATTR_OK                                = 65536
	X_WCHAR_T                                 = 0
	X_WCHAR_T_                                = 0
	X_WCHAR_T_DECLARED                        = 0
	X_WCHAR_T_DEFINED                         = 0
	X_WCHAR_T_DEFINED_                        = 0
	X_WCHAR_T_H                               = 0
	X_WEXT_OK                                 = 262144
	X_WPERM_OK                                = 1048576
	X_WRITE_OK                                = 1024
	X_WSTOPPED                                = 0177
	X_XBS5_ILP32_OFF32                        = -1
	X_XBS5_ILP32_OFFBIG                       = -1
	X_XBS5_LP64_OFF64                         = 1
	X_XBS5_LPBIG_OFFBIG                       = 1
	X_XOPEN_CRYPT                             = 1
	X_XOPEN_ENH_I18N                          = 1
	X_XOPEN_IOV_MAX                           = 16
	X_XOPEN_LEGACY                            = -1
	X_XOPEN_NAME_MAX                          = 255
	X_XOPEN_PATH_MAX                          = 1024
	X_XOPEN_REALTIME                          = -1
	X_XOPEN_REALTIME_THREADS                  = -1
	X_XOPEN_SHM                               = 1
	X_XOPEN_STREAMS                           = -1
	X_XOPEN_UNIX                              = 1
	X_XOPEN_VERSION                           = 600
	X_XOPEN_XCU_VERSION                       = 4
	Z_const                                   = 0
	BYFOUR                                    = 0
	GF2_DIM                                   = 32
	TBLS                                      = 8
	BL_CODES                                  = 19
	BUSY_STATE                                = 113
	Buf_size                                  = 16
	COMMENT_STATE                             = 91
	DEFLATE_H                                 = 0
	D_CODES                                   = 30
	EXTRA_STATE                               = 69
	FINISH_STATE                              = 666
	GZIP                                      = 0
	GZIP_STATE                                = 57
	HCRC_STATE                                = 103
	HEAP_SIZE                                 = 573
	INIT_STATE                                = 42
	LENGTH_CODES                              = 29
	LITERALS                                  = 256
	L_CODES                                   = 286
	MAX_BITS                                  = 15
	MAX_STORED                                = 65535
	MIN_LOOKAHEAD                             = 262
	NAME_STATE                                = 73
	NIL                                       = 0
	TOO_FAR                                   = 4096
	WIN_INIT                                  = 258
	AT_EACCESS                                = 0x0010
	AT_FDCWD                                  = -2
	AT_FDONLY                                 = 0x0400
	AT_REALDEV                                = 0x0200
	AT_REMOVEDIR                              = 0x0080
	AT_SYMLINK_FOLLOW                         = 0x0040
	AT_SYMLINK_NOFOLLOW                       = 0x0020
	BUFSIZ                                    = 1024
	COPY1                                     = 1
	CPF_IGNORE_MODE                           = 0x0002
	CPF_MASK                                  = 3
	CPF_OVERWRITE                             = 0x0001
	E2BIG                                     = 7
	EACCES                                    = 13
	EADDRINUSE                                = 48
	EADDRNOTAVAIL                             = 49
	EAFNOSUPPORT                              = 47
	EAGAIN                                    = 35
	EALREADY                                  = 37
	EAUTH                                     = 80
	EBADARCH                                  = 86
	EBADEXEC                                  = 85
	EBADF                                     = 9
	EBADMACHO                                 = 88
	EBADMSG                                   = 94
	EBADRPC                                   = 72
	EBUSY                                     = 16
	ECANCELED                                 = 89
	ECHILD                                    = 10
	ECONNABORTED                              = 53
	ECONNREFUSED                              = 61
	ECONNRESET                                = 54
	EDEADLK                                   = 11
	EDESTADDRREQ                              = 39
	EDEVERR                                   = 83
	EDOM                                      = 33
	EDQUOT                                    = 69
	EEXIST                                    = 17
	EFAULT                                    = 14
	EFBIG                                     = 27
	EFTYPE                                    = 79
	EHOSTDOWN                                 = 64
	EHOSTUNREACH                              = 65
	EIDRM                                     = 90
	EILSEQ                                    = 92
	EINPROGRESS                               = 36
	EINTR                                     = 4
	EINVAL                                    = 22
	EIO                                       = 5
	EISCONN                                   = 56
	EISDIR                                    = 21
	ELAST                                     = 106
	ELOOP                                     = 62
	EMFILE                                    = 24
	EMLINK                                    = 31
	EMSGSIZE                                  = 40
	EMULTIHOP                                 = 95
	ENAMETOOLONG                              = 63
	ENEEDAUTH                                 = 81
	ENETDOWN                                  = 50
	ENETRESET                                 = 52
	ENETUNREACH                               = 51
	ENFILE                                    = 23
	ENOATTR                                   = 93
	ENOBUFS                                   = 55
	ENODATA                                   = 96
	ENODEV                                    = 19
	ENOENT                                    = 2
	ENOEXEC                                   = 8
	ENOLCK                                    = 77
	ENOLINK                                   = 97
	ENOMEM                                    = 12
	ENOMSG                                    = 91
	ENOPOLICY                                 = 103
	ENOPROTOOPT                               = 42
	ENOSPC                                    = 28
	ENOSR                                     = 98
	ENOSTR                                    = 99
	ENOSYS                                    = 78
	ENOTBLK                                   = 15
	ENOTCONN                                  = 57
	ENOTDIR                                   = 20
	ENOTEMPTY                                 = 66
	ENOTRECOVERABLE                           = 104
	ENOTSOCK                                  = 38
	ENOTSUP                                   = 45
	ENOTTY                                    = 25
	ENXIO                                     = 6
	EOF                                       = -1
	EOPNOTSUPP                                = 102
	EOVERFLOW                                 = 84
	EOWNERDEAD                                = 105
	EPERM                                     = 1
	EPFNOSUPPORT                              = 46
	EPIPE                                     = 32
	EPROCLIM                                  = 67
	EPROCUNAVAIL                              = 76
	EPROGMISMATCH                             = 75
	EPROGUNAVAIL                              = 74
	EPROTO                                    = 100
	EPROTONOSUPPORT                           = 43
	EPROTOTYPE                                = 41
	EPWROFF                                   = 82
	EQFULL                                    = 106
	ERANGE                                    = 34
	EREMOTE                                   = 71
	EROFS                                     = 30
	ERPCMISMATCH                              = 73
	ESHLIBVERS                                = 87
	ESHUTDOWN                                 = 58
	ESOCKTNOSUPPORT                           = 44
	ESPIPE                                    = 29
	ESRCH                                     = 3
	ESTALE                                    = 70
	ETIME                                     = 101
	ETIMEDOUT                                 = 60
	ETOOMANYREFS                              = 59
	ETXTBSY                                   = 26
	EUSERS                                    = 68
	EWOULDBLOCK                               = 35
	EXDEV                                     = 18
	FAPPEND                                   = 8
	FASYNC                                    = 64
	FCNTL_FS_SPECIFIC_BASE                    = 0x00010000
	FD_CLOEXEC                                = 1
	FFDSYNC                                   = 4194304
	FFSYNC                                    = 128
	FILENAME_MAX                              = 1024
	FIXINC_WRAP_STDIO_H_STDIO_STDARG_H        = 1
	FNDELAY                                   = 4
	FNONBLOCK                                 = 4
	FOPEN_MAX                                 = 20
	FREAD                                     = 0x00000001
	FWRITE                                    = 0x00000002
	F_ADDFILESIGS                             = 61
	F_ADDFILESIGS_FOR_DYLD_SIM                = 83
	F_ADDFILESIGS_INFO                        = 103
	F_ADDFILESIGS_RETURN                      = 97
	F_ADDFILESUPPL                            = 104
	F_ADDSIGS                                 = 59
	F_ALLOCATEALL                             = 0x00000004
	F_ALLOCATECONTIG                          = 0x00000002
	F_BARRIERFSYNC                            = 85
	F_CHECK_LV                                = 98
	F_CHKCLEAN                                = 41
	F_DUPFD                                   = 0
	F_DUPFD_CLOEXEC                           = 67
	F_FINDSIGS                                = 78
	F_FLUSH_DATA                              = 40
	F_FREEZE_FS                               = 53
	F_FULLFSYNC                               = 51
	F_GETCODEDIR                              = 72
	F_GETFD                                   = 1
	F_GETFL                                   = 3
	F_GETLK                                   = 7
	F_GETLKPID                                = 66
	F_GETNOSIGPIPE                            = 74
	F_GETOWN                                  = 5
	F_GETPATH                                 = 50
	F_GETPATH_MTMINFO                         = 71
	F_GETPATH_NOFIRMLINK                      = 102
	F_GETPROTECTIONCLASS                      = 63
	F_GETPROTECTIONLEVEL                      = 77
	F_GETSIGSINFO                             = 105
	F_GLOBAL_NOCACHE                          = 55
	F_LOG2PHYS                                = 49
	F_LOG2PHYS_EXT                            = 65
	F_NOCACHE                                 = 48
	F_NODIRECT                                = 62
	F_PATHPKG_CHECK                           = 52
	F_PEOFPOSMODE                             = 3
	F_PREALLOCATE                             = 42
	F_PUNCHHOLE                               = 99
	F_RDADVISE                                = 44
	F_RDAHEAD                                 = 45
	F_RDLCK                                   = 1
	F_SETBACKINGSTORE                         = 70
	F_SETFD                                   = 2
	F_SETFL                                   = 4
	F_SETLK                                   = 8
	F_SETLKW                                  = 9
	F_SETLKWTIMEOUT                           = 10
	F_SETNOSIGPIPE                            = 73
	F_SETOWN                                  = 6
	F_SETPROTECTIONCLASS                      = 64
	F_SETSIZE                                 = 43
	F_SINGLE_WRITER                           = 76
	F_SPECULATIVE_READ                        = 101
	F_THAW_FS                                 = 54
	F_TRANSCODEKEY                            = 75
	F_TRIM_ACTIVE_FILE                        = 100
	F_UNLCK                                   = 2
	F_VOLPOSMODE                              = 4
	F_WRLCK                                   = 3
	GETSIGSINFO_PLATFORM_BINARY               = 1
	GZBUFSIZE                                 = 8192
	GZ_APPEND                                 = 1
	GZ_NONE                                   = 0
	GZ_READ                                   = 7247
	GZ_WRITE                                  = 31153
	HAVE_VSNPRINTF                            = 0
	LOCK_EX                                   = 0x02
	LOCK_NB                                   = 0x04
	LOCK_SH                                   = 0x01
	LOCK_UN                                   = 0x08
	LOOK                                      = 0
	L_ctermid                                 = 1024
	L_tmpnam                                  = 1024
	O_ACCMODE                                 = 0x0003
	O_ALERT                                   = 0x20000000
	O_APPEND                                  = 0x00000008
	O_ASYNC                                   = 0x00000040
	O_CLOEXEC                                 = 0x01000000
	O_CREAT                                   = 0x00000200
	O_DIRECTORY                               = 0x00100000
	O_DP_GETRAWENCRYPTED                      = 0x0001
	O_DP_GETRAWUNENCRYPTED                    = 0x0002
	O_DSYNC                                   = 0x400000
	O_EVTONLY                                 = 0x00008000
	O_EXCL                                    = 0x00000800
	O_EXLOCK                                  = 0x00000020
	O_FSYNC                                   = 128
	O_NDELAY                                  = 4
	O_NOCTTY                                  = 0x00020000
	O_NOFOLLOW                                = 0x00000100
	O_NOFOLLOW_ANY                            = 0x20000000
	O_NONBLOCK                                = 0x00000004
	O_POPUP                                   = 0x80000000
	O_RDONLY                                  = 0x0000
	O_RDWR                                    = 0x0002
	O_SHLOCK                                  = 0x00000010
	O_SYMLINK                                 = 0x00200000
	O_SYNC                                    = 0x0080
	O_TRUNC                                   = 0x00000400
	O_WRONLY                                  = 0x0001
	P_tmpdir                                  = "/var/tmp/"
	RENAME_EXCL                               = 0x00000004
	RENAME_SECLUDE                            = 0x00000001
	RENAME_SWAP                               = 0x00000002
	S_IEXEC                                   = 64
	S_IFBLK                                   = 0060000
	S_IFCHR                                   = 0020000
	S_IFDIR                                   = 0040000
	S_IFIFO                                   = 0010000
	S_IFLNK                                   = 0120000
	S_IFMT                                    = 0170000
	S_IFREG                                   = 0100000
	S_IFSOCK                                  = 0140000
	S_IFWHT                                   = 0160000
	S_IREAD                                   = 256
	S_IRGRP                                   = 0000040
	S_IROTH                                   = 0000004
	S_IRUSR                                   = 0000400
	S_IRWXG                                   = 0000070
	S_IRWXO                                   = 0000007
	S_IRWXU                                   = 0000700
	S_ISGID                                   = 0002000
	S_ISTXT                                   = 512
	S_ISUID                                   = 0004000
	S_ISVTX                                   = 0001000
	S_IWGRP                                   = 0000020
	S_IWOTH                                   = 0000002
	S_IWRITE                                  = 128
	S_IWUSR                                   = 0000200
	S_IXGRP                                   = 0000010
	S_IXOTH                                   = 0000001
	S_IXUSR                                   = 0000100
	TMP_MAX                                   = 308915776
	USER_FSIGNATURES_CDHASH_LEN               = 20
	X_FILESEC_T                               = 0
	X_FSTDIO                                  = 0
	X_IOFBF                                   = 0
	X_IOLBF                                   = 1
	X_IONBF                                   = 2
	X_POSIX_SOURCE                            = 0
	X_SECURE__STDIO_H_                        = 0
	X_STDIO_H_                                = 0
	X_SYS_ERRNO_H_                            = 0
	X_SYS_FCNTL_H_                            = 0
	X_SYS_STDIO_H_                            = 0
	X_VA_LIST_T                               = 0
	ENOUGH                                    = 1444
	ENOUGH_DISTS                              = 592
	ENOUGH_LENS                               = 852
	GUNZIP                                    = 0
	MAXBITS                                   = 15
	DIST_CODE_LEN                             = 512
	END_BLOCK                                 = 256
	MAX_BL_BITS                               = 7
	REPZ_11_138                               = 18
	REPZ_3_10                                 = 17
	REP_3_6                                   = 16
	SMALLEST                                  = 1
)

const ( /* fcntl.h:536:1: */
	FILESEC_OWNER   = 1
	FILESEC_GROUP   = 2
	FILESEC_UUID    = 3
	FILESEC_MODE    = 4
	FILESEC_ACL     = 5
	FILESEC_GRPUUID = 6

	// XXX these are private to the implementation
	FILESEC_ACL_RAW       = 100
	FILESEC_ACL_ALLOCSIZE = 101
)

// Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93

// Security checking functions.
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// bcopy and bzero

// Removed in Issue 7

// void	bcopy(const void *src, void *dst, size_t len)

// void	bzero(void *s, size_t n)

// Security checking functions.
// Copyright (c) 2007,2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// <rdar://problem/12622659>

// memccpy, memcpy, mempcpy, memmove, memset, strcpy, strlcpy, stpcpy,
//    strncpy, stpncpy, strcat, strlcat, and strncat

// void *memcpy(void *dst, const void *src, size_t n)

// void *memmove(void *dst, const void *src, size_t len)

// void *memset(void *b, int c, size_t len)

// char *strcpy(char *dst, const char *src)

// char *stpcpy(char *dst, const char *src)

// char *stpncpy(char *dst, const char *src, size_t n)

// char *strncpy(char *dst, const char *src, size_t n)

// char *strcat(char *s1, const char *s2)

// char *strncat(char *s1, const char *s2, size_t n)

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
const ( /* wait.h:79:1: */
	P_ALL  = 0
	P_PID  = 1
	P_PGID = 2
)

//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

// ===========================================================================
//  Function prototypes.
const ( /* deflate.c:66:1: */
	Need_more      = 0 // block not completed, need more input or more output
	Block_done     = 1 // block flush performed
	Finish_started = 2 // finish started, need only more output at next deflate
	Finish_done    = 3
)

// inflate.h -- internal inflate state definition
// Copyright (C) 1995-2016 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip decoding
//    should be left enabled.

// Possible inflate modes between inflate() calls
const ( /* inflate.h:20:1: */
	HEAD     = 16180 // i: waiting for magic header
	FLAGS    = 16181 // i: waiting for method and flags (gzip)
	TIME     = 16182 // i: waiting for modification time (gzip)
	OS       = 16183 // i: waiting for extra flags and operating system (gzip)
	EXLEN    = 16184 // i: waiting for extra length (gzip)
	EXTRA    = 16185 // i: waiting for extra bytes (gzip)
	NAME     = 16186 // i: waiting for end of file name (gzip)
	COMMENT  = 16187 // i: waiting for end of comment (gzip)
	HCRC     = 16188 // i: waiting for header crc (gzip)
	DICTID   = 16189 // i: waiting for dictionary check value
	DICT     = 16190 // waiting for inflateSetDictionary() call
	TYPE     = 16191 // i: waiting for type bits, including last-flag bit
	TYPEDO   = 16192 // i: same, but skip check to exit inflate on new block
	STORED   = 16193 // i: waiting for stored size (length and complement)
	COPY_    = 16194 // i/o: same as COPY below, but only first time in
	COPY     = 16195 // i/o: waiting for input or output to copy stored block
	TABLE    = 16196 // i: waiting for dynamic block table lengths
	LENLENS  = 16197 // i: waiting for code length code lengths
	CODELENS = 16198 // i: waiting for length/lit and distance code lengths
	LEN_     = 16199 // i: same as LEN below, but only first time in
	LEN      = 16200 // i: waiting for length/lit/eob code
	LENEXT   = 16201 // i: waiting for length extra bits
	DIST     = 16202 // i: waiting for distance code
	DISTEXT  = 16203 // i: waiting for distance extra bits
	MATCH    = 16204 // o: waiting for output space to copy string
	LIT      = 16205 // o: waiting for output space to write literal
	CHECK    = 16206 // i: waiting for 32-bit check value
	LENGTH   = 16207 // i: waiting for 32-bit length (gzip)
	DONE     = 16208 // finished check, done -- remain here until reset
	BAD      = 16209 // got a data error -- remain here until reset
	MEM      = 16210 // got an inflate() memory error -- remain here until reset
	SYNC     = 16211
)

// op values as set by inflate_table():
//     00000000 - literal
//     0000tttt - table link, tttt != 0 is the number of table index bits
//     0001eeee - length or distance, eeee is the number of extra bits
//     01100000 - end of block
//     01000000 - invalid code
//

// Maximum size of the dynamic table.  The maximum number of code structures is
//    1444, which is the sum of 852 for literal/length codes and 592 for distance
//    codes.  These values were found by exhaustive searches using the program
//    examples/enough.c found in the zlib distribtution.  The arguments to that
//    program are the number of symbols, the initial root table size, and the
//    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
//    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
//    The initial root table size (9 or 6) is found in the fifth argument of the
//    inflate_table() calls in inflate.c and infback.c.  If the root table size is
//    changed, then these maximum sizes would be need to be recalculated and
//    updated.

// Type of code to build for inflate_table()
const ( /* inftrees.h:54:1: */
	CODES = 0
	LENS  = 1
	DISTS = 2
)

type Ptrdiff_t = int64 /* <builtin>:3:26 */

type Size_t = uint64 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type X__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type Max_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
} /* stddef.h:426:3 */

type Z_size_t = Size_t /* zconf.h:248:21 */

// Maximum value for memLevel in deflateInit2

// Maximum value for windowBits in deflateInit2 and inflateInit2.
// WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
// created by gzip. (Files created by minigzip can still be extracted by
// gzip.)

// The memory requirements for deflate are (in bytes):
//             (1 << (windowBits+2)) +  (1 << (memLevel+9))
//  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
//  plus a few kilobytes for small objects. For example, if you want to reduce
//  the default memory requirements from 256K to 128K, compile with
//      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
//  Of course this will generally degrade compression (there's no free lunch).
//
//    The memory requirements for inflate are (in bytes) 1 << windowBits
//  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
//  for small objects.

// Type declarations

// The following definitions for FAR are needed only for MSDOS mixed
// model programming (small or medium model with some far allocations).
// This was tested only with MSC; for other MSDOS compilers you may have
// to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
// just define FAR to be empty.

type Byte = uint8   /* zconf.h:391:24 */ // 8 bits
type UInt = uint32  /* zconf.h:393:24 */ // 16 bits or more
type ULong = uint64 /* zconf.h:394:24 */ // 32 bits or more

type Bytef = Byte   /* zconf.h:400:22 */
type Charf = int8   /* zconf.h:402:19 */
type Intf = int32   /* zconf.h:403:19 */
type UIntf = UInt   /* zconf.h:404:19 */
type ULongf = ULong /* zconf.h:405:19 */

type Voidpc = uintptr /* zconf.h:408:23 */
type Voidpf = uintptr /* zconf.h:409:23 */
type Voidp = uintptr  /* zconf.h:410:23 */

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (c) 2000, 2004-2007, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
//	$NetBSD: limits.h,v 1.8 1996/10/21 05:10:50 jtc Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// This SDK is designed to work with clang and specific versions of
// gcc >= 4.0 with Apple's patch sets

// Compatibility with compilers and environments that don't support compiler
// feature checking function-like macros.

// The __CONCAT macro is used to concatenate parts of symbol names, e.g.
// with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
// The __CONCAT macro is a bit tricky -- make sure you don't put spaces
// in between its arguments.  __CONCAT can also concatenate double-quoted
// strings produced by the __STRING macro, but this only works with ANSI C.

// __unused denotes variables and functions that may not be used, preventing
// the compiler from warning about it if not used.

// __used forces variables and functions to be included even if it appears
// to the compiler that they are not used (and would thust be discarded).

// __cold marks code used for debugging or that is rarely taken
// and tells the compiler to optimize for size and outline code.

// __exported denotes symbols that should be exported even when symbols
// are hidden by default.
// __exported_push/_exported_pop are pragmas used to delimit a range of
//  symbols that should be exported even when symbols are hidden by default.

// __deprecated causes the compiler to produce a warning when encountering
// code using the deprecated functionality.
// __deprecated_msg() does the same, and compilers that support it will print
// a message along with the deprecation warning.
// This may require turning on such warning with the -Wdeprecated flag.
// __deprecated_enum_msg() should be used on enums, and compilers that support
// it will print the deprecation warning.
// __kpi_deprecated() specifically indicates deprecation of kernel programming
// interfaces in Kernel.framework used by KEXTs.

// __unavailable causes the compiler to error out when encountering
// code using the tagged function

// Delete pseudo-keywords wherever they are not available or needed.

// We use `__restrict' as a way to define the `restrict' type qualifier
// without disturbing older software that is unaware of C99 keywords.

// Compatibility with compilers and environments that don't support the
// nullability feature.

// __disable_tail_calls causes the compiler to not perform tail call
// optimization inside the marked function.

// __not_tail_called causes the compiler to prevent tail call optimization
// on statically bound calls to the function.  It has no effect on indirect
// calls.  Virtual functions, objective-c methods, and functions marked as
// "always_inline" cannot be marked as __not_tail_called.

// __result_use_check warns callers of a function that not using the function
// return value is a bug, i.e. dismissing malloc() return value results in a
// memory leak.

// __swift_unavailable causes the compiler to mark a symbol as specifically
// unavailable in Swift, regardless of any other availability in C.

// __abortlike is the attribute to put on functions like abort() that are
// typically used to mark assertions. These optimize the codegen
// for outlining while still maintaining debugability.

// Declaring inline functions within headers is error-prone due to differences
// across various versions of the C language and extensions.  __header_inline
// can be used to declare inline functions within system headers.  In cases
// where you want to force inlining instead of letting the compiler make
// the decision, you can use __header_always_inline.
//
// Be aware that using inline for functions which compilers may also provide
// builtins can behave differently under various compilers.  If you intend to
// provide an inline version of such a function, you may want to use a macro
// instead.
//
// The check for !__GNUC__ || __clang__ is because gcc doesn't correctly
// support c99 inline in some cases:
// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55965

// Compiler-dependent macros that bracket portions of code where the
// "-Wunreachable-code" warning should be ignored. Please use sparingly.

// Compiler-dependent macros to declare that functions take printf-like
// or scanf-like arguments.  They are null except for versions of gcc
// that are known to support the features properly.  Functions declared
// with these attributes will cause compilation warnings if there is a
// mismatch between the format string and subsequent function parameter
// types.

// Source compatibility only, ID string not emitted in object file

// __alloc_size can be used to label function arguments that represent the
// size of memory that the function allocates and returns. The one-argument
// form labels a single argument that gives the allocation size (where the
// arguments are numbered from 1):
//
// void	*malloc(size_t __size) __alloc_size(1);
//
// The two-argument form handles the case where the size is calculated as the
// product of two arguments:
//
// void	*calloc(size_t __count, size_t __size) __alloc_size(1,2);

// COMPILATION ENVIRONMENTS -- see compat(5) for additional detail
//
// DEFAULT	By default newly complied code will get POSIX APIs plus
//		Apple API extensions in scope.
//
//		Most users will use this compilation environment to avoid
//		behavioral differences between 32 and 64 bit code.
//
// LEGACY	Defining _NONSTD_SOURCE will get pre-POSIX APIs plus Apple
//		API extensions in scope.
//
//		This is generally equivalent to the Tiger release compilation
//		environment, except that it cannot be applied to 64 bit code;
//		its use is discouraged.
//
//		We expect this environment to be deprecated in the future.
//
// STRICT	Defining _POSIX_C_SOURCE or _XOPEN_SOURCE restricts the
//		available APIs to exactly the set of APIs defined by the
//		corresponding standard, based on the value defined.
//
//		A correct, portable definition for _POSIX_C_SOURCE is 200112L.
//		A correct, portable definition for _XOPEN_SOURCE is 600L.
//
//		Apple API extensions are not visible in this environment,
//		which can cause Apple specific code to fail to compile,
//		or behave incorrectly if prototypes are not in scope or
//		warnings about missing prototypes are not enabled or ignored.
//
// In any compilation environment, for correct symbol resolution to occur,
// function prototypes must be in scope.  It is recommended that all Apple
// tools users add either the "-Wall" or "-Wimplicit-function-declaration"
// compiler flags to their projects to be warned when a function is being
// used without a prototype in scope.

// These settings are particular to each product.
// Platform: MacOSX

// The __DARWIN_ALIAS macros are used to do symbol renaming; they allow
// legacy code to use the old symbol, thus maintaining binary compatibility
// while new code can use a standards compliant version of the same function.
//
// __DARWIN_ALIAS is used by itself if the function signature has not
// changed, it is used along with a #ifdef check for __DARWIN_UNIX03
// if the signature has changed.  Because the __LP64__ environment
// only supports UNIX03 semantics it causes __DARWIN_UNIX03 to be
// defined, but causes __DARWIN_ALIAS to do no symbol mangling.
//
// As a special case, when XCode is used to target a specific version of the
// OS, the manifest constant __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
// will be defined by the compiler, with the digits representing major version
// time 100 + minor version times 10 (e.g. 10.5 := 1050).  If we are targeting
// pre-10.5, and it is the default compilation environment, revert the
// compilation environment to pre-__DARWIN_UNIX03.

// symbol suffixes used for symbol versioning

// symbol versioning macros

// symbol release macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// POSIX.1 requires that the macros we test be defined before any standard
// header file is included.  This permits us to convert values for feature
// testing, as necessary, using only _POSIX_C_SOURCE.
//
// Here's a quick run-down of the versions:
//  defined(_POSIX_SOURCE)		1003.1-1988
//  _POSIX_C_SOURCE == 1L		1003.1-1990
//  _POSIX_C_SOURCE == 2L		1003.2-1992 C Language Binding Option
//  _POSIX_C_SOURCE == 199309L		1003.1b-1993
//  _POSIX_C_SOURCE == 199506L		1003.1c-1995, 1003.1i-1995,
//					and the omnibus ISO/IEC 9945-1: 1996
//  _POSIX_C_SOURCE == 200112L		1003.1-2001
//  _POSIX_C_SOURCE == 200809L		1003.1-2008
//
// In addition, the X/Open Portability Guide, which is now the Single UNIX
// Specification, defines a feature-test macro which indicates the version of
// that specification, and which subsumes _POSIX_C_SOURCE.

// Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1L.

// Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2L.

// Deal with various X/Open Portability Guides and Single UNIX Spec.

// Deal with all versions of POSIX.  The ordering relative to the tests above is
// important.

// POSIX C deprecation macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Set a single macro which will always be defined and can be used to determine
// the appropriate namespace.  For POSIX, these values will correspond to
// _POSIX_C_SOURCE value.  Currently there are two additional levels corresponding
// to ANSI (_ANSI_SOURCE) and Darwin extensions (_DARWIN_C_SOURCE)

// If the developer has neither requested a strict language mode nor a version
// of POSIX, turn on functionality provided by __STDC_WANT_LIB_EXT1__ as part
// of __DARWIN_C_FULL.

// long long is not supported in c89 (__STRICT_ANSI__), but g++ -ansi and
// c99 still want long longs.  While not perfect, we allow long longs for
// g++.

// ****************************************
//
//  Public darwin-specific feature macros
//

// _DARWIN_FEATURE_64_BIT_INODE indicates that the ino_t type is 64-bit, and
// structures modified for 64-bit inodes (like struct stat) will be used.

// _DARWIN_FEATURE_64_ONLY_BIT_INODE indicates that the ino_t type may only
// be 64-bit; there is no support for 32-bit ino_t when this macro is defined
// (and non-zero).  There is no struct stat64 either, as the regular
// struct stat will already be the 64-bit version.

// _DARWIN_FEATURE_ONLY_VERS_1050 indicates that only those APIs updated
// in 10.5 exists; no pre-10.5 variants are available.

// _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE indicates only UNIX conforming API
// are available (the legacy BSD APIs are not available)

// _DARWIN_FEATURE_UNIX_CONFORMANCE indicates whether UNIX conformance is on,
// and specifies the conformance level (3 is SUSv3)

// This macro casts away the qualifier from the variable
//
// Note: use at your own risk, removing qualifiers can result in
// catastrophic run-time failures.

// __XNU_PRIVATE_EXTERN is a linkage decoration indicating that a symbol can be
// used from other compilation units, but not other libraries or executables.

// Architecture validation for current SDK

// Similar to OS_ENUM/OS_CLOSED_ENUM/OS_OPTIONS/OS_CLOSED_OPTIONS
//
// This provides more advanced type checking on compilers supporting
// the proper extensions, even in C.

// This is the `system' limits.h, independent of any particular
//  compiler.  GCC provides its own limits.h which can be found in
//  /usr/lib/gcc, although it is not very informative.
//  This file is public domain.
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004-2007 Apple Inc. All rights reserved.

// According to ANSI (section 2.2.4.2), the values below must be usable by
// #if preprocessing directives.  Additionally, the expression must have the
// same type as would an expression that is an object of the corresponding
// type converted according to the integral promotions.  The subtraction for
// INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
// unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
// These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
// are written as hex so that GCC will be quiet about large integer constants.

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
//	$NetBSD: syslimits.h,v 1.15 1997/06/25 00:48:09 lukem Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)syslimits.h	8.1 (Berkeley) 6/2/93

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// max bytes for an exec function

// Note: CHILD_MAX *must* be less than hard_maxproc, which is set at
// compile time; you *cannot* set it higher than the hard limit!!

// = ((PRIO_MAX - PRIO_MIN) / 2) + 1
// range: 0 - 39 [(2 * NZERO) - 1]
// 0 is not actually used

// Actually for XSI Visible

// Removed in Issue 6

// NZERO to be defined here. TBD. See also sys/param.h

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

type Z_crc_t = uint32 /* zconf.h:429:17 */

// Copyright (c) 2000-2008 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.4 (Berkeley) 1/21/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Machine type dependent parameters.
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Copyright (c) 2000-2008 Apple Inc. All rights reserved.
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.3 (Berkeley) 1/5/94

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.

// This header file contains integer types.  It's intended to also contain
// flotaing point and other arithmetic types, as needed, later.

type X__int8_t = int8     /* _types.h:13:33 */
type X__uint8_t = uint8   /* _types.h:17:33 */
type X__int16_t = int16   /* _types.h:18:33 */
type X__uint16_t = uint16 /* _types.h:19:33 */
type X__int32_t = int32   /* _types.h:20:33 */
type X__uint32_t = uint32 /* _types.h:21:33 */
type X__int64_t = int64   /* _types.h:22:33 */
type X__uint64_t = uint64 /* _types.h:23:33 */

type X__darwin_intptr_t = int64   /* _types.h:25:33 */
type X__darwin_natural_t = uint32 /* _types.h:26:33 */

// The rune type below is declared to be an ``int'' instead of the more natural
// ``unsigned long'' or ``long''.  Two things are happening here.  It is not
// unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
// it looks like 10646 will be a 31 bit standard.  This means that if your
// ints cannot hold 32 bits, you will be in trouble.  The reason an int was
// chosen over a long is that the is*() and to*() routines take ints (says
// ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
// here, you lose a bit of ANSI conformance, but your programs will still
// work.
//
// NOTE: rune_t is not covered by ANSI nor other standards, and should not
// be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
// rune_t must be the same type.  Also wint_t must be no narrower than
// wchar_t, and should also be able to hold all members of the largest
// character set plus one extra value (WEOF). wint_t must be at least 16 bits.

type X__darwin_ct_rune_t = int32 /* _types.h:46:33 */ // ct_rune_t

// mbstate_t is an opaque object to keep conversion state, during multibyte
// stream conversions.  The content must not be referenced by user programs.
type X__mbstate_t = struct {
	_           [0]uint64
	F__mbstate8 [128]int8
} /* _types.h:55:3 */

type X__darwin_mbstate_t = X__mbstate_t /* _types.h:57:33 */ // mbstate_t

type X__darwin_ptrdiff_t = int64 /* _types.h:60:33 */ // ptr1 - ptr2

type X__darwin_size_t = uint64 /* _types.h:68:33 */ // sizeof()

type X__darwin_va_list = X__builtin_va_list /* _types.h:74:33 */ // va_list

type X__darwin_wchar_t = int32 /* _types.h:80:33 */ // wchar_t

type X__darwin_rune_t = X__darwin_wchar_t /* _types.h:85:33 */ // rune_t

type X__darwin_wint_t = int32 /* _types.h:88:33 */ // wint_t

type X__darwin_clock_t = uint64        /* _types.h:93:33 */ // clock()
type X__darwin_socklen_t = X__uint32_t /* _types.h:94:33 */ // socklen_t (duh)
type X__darwin_ssize_t = int64         /* _types.h:95:33 */ // byte count or error
type X__darwin_time_t = int64          /* _types.h:96:33 */ // time()

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Basic integral types.  Omit the typedef if
// not possible for a machine/compiler combination.
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int8_t = int8 /* _int8_t.h:30:31 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int16_t = int16 /* _int16_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int32_t = int32 /* _int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int64_t = int64 /* _int64_t.h:30:33 */

// Copyright (c) 2016 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int8_t = uint8 /* _u_int8_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int16_t = uint16 /* _u_int16_t.h:30:41 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int32_t = uint32 /* _u_int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int64_t = uint64 /* _u_int64_t.h:30:33 */

type Register_t = Int64_t /* types.h:63:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type Intptr_t = X__darwin_intptr_t /* _intptr_t.h:32:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Uintptr_t = uint64 /* _uintptr_t.h:30:33 */

// These types are used for reserving the largest possible size.
type User_addr_t = U_int64_t  /* types.h:74:33 */
type User_size_t = U_int64_t  /* types.h:75:33 */
type User_ssize_t = Int64_t   /* types.h:76:33 */
type User_long_t = Int64_t    /* types.h:77:33 */
type User_ulong_t = U_int64_t /* types.h:78:33 */
type User_time_t = Int64_t    /* types.h:79:33 */
type User_off_t = Int64_t     /* types.h:80:33 */

// This defines the size of syscall arguments after copying into the kernel:
type Syscall_arg_t = U_int64_t /* types.h:101:33 */

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.

// Type definitions; takes common type definitions that must be used
// in multiple header files due to [XSI], removes them from the system
// space, and puts them in the implementation space.

type X__darwin_blkcnt_t = X__int64_t                    /* _types.h:55:25 */ // total blocks
type X__darwin_blksize_t = X__int32_t                   /* _types.h:56:25 */ // preferred block size
type X__darwin_dev_t = X__int32_t                       /* _types.h:57:25 */ // dev_t
type X__darwin_fsblkcnt_t = uint32                      /* _types.h:58:25 */ // Used by statvfs and fstatvfs
type X__darwin_fsfilcnt_t = uint32                      /* _types.h:59:25 */ // Used by statvfs and fstatvfs
type X__darwin_gid_t = X__uint32_t                      /* _types.h:60:25 */ // [???] process and group IDs
type X__darwin_id_t = X__uint32_t                       /* _types.h:61:25 */ // [XSI] pid_t, uid_t, or gid_t
type X__darwin_ino64_t = X__uint64_t                    /* _types.h:62:25 */ // [???] Used for 64 bit inodes
type X__darwin_ino_t = X__darwin_ino64_t                /* _types.h:64:26 */ // [???] Used for inodes
type X__darwin_mach_port_name_t = X__darwin_natural_t   /* _types.h:68:28 */ // Used by mach
type X__darwin_mach_port_t = X__darwin_mach_port_name_t /* _types.h:69:35 */ // Used by mach
type X__darwin_mode_t = X__uint16_t                     /* _types.h:70:25 */ // [???] Some file attributes
type X__darwin_off_t = X__int64_t                       /* _types.h:71:25 */ // [???] Used for file sizes
type X__darwin_pid_t = X__int32_t                       /* _types.h:72:25 */ // [???] process and group IDs
type X__darwin_sigset_t = X__uint32_t                   /* _types.h:73:25 */ // [???] signal set
type X__darwin_suseconds_t = X__int32_t                 /* _types.h:74:25 */ // [???] microseconds
type X__darwin_uid_t = X__uint32_t                      /* _types.h:75:25 */ // [???] user IDs
type X__darwin_useconds_t = X__uint32_t                 /* _types.h:76:25 */ // [???] microseconds
type X__darwin_uuid_t = [16]uint8                       /* _types.h:77:25 */
type X__darwin_uuid_string_t = [37]int8                 /* _types.h:78:17 */

// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// pthread opaque structures

type X__darwin_pthread_handler_rec = struct {
	F__routine uintptr
	F__arg     uintptr
	F__next    uintptr
} /* _pthread_types.h:57:1 */

type X_opaque_pthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
} /* _pthread_types.h:63:1 */

type X_opaque_pthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
} /* _pthread_types.h:68:1 */

type X_opaque_pthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
} /* _pthread_types.h:73:1 */

type X_opaque_pthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
} /* _pthread_types.h:78:1 */

type X_opaque_pthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
} /* _pthread_types.h:83:1 */

type X_opaque_pthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
} /* _pthread_types.h:88:1 */

type X_opaque_pthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
} /* _pthread_types.h:93:1 */

type X_opaque_pthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
} /* _pthread_types.h:98:1 */

type X_opaque_pthread_t = struct {
	F__sig           int64
	F__cleanup_stack uintptr
	F__opaque        [8176]int8
} /* _pthread_types.h:103:1 */

type X__darwin_pthread_attr_t = X_opaque_pthread_attr_t             /* _pthread_types.h:109:39 */
type X__darwin_pthread_cond_t = X_opaque_pthread_cond_t             /* _pthread_types.h:110:39 */
type X__darwin_pthread_condattr_t = X_opaque_pthread_condattr_t     /* _pthread_types.h:111:43 */
type X__darwin_pthread_key_t = uint64                               /* _pthread_types.h:112:23 */
type X__darwin_pthread_mutex_t = X_opaque_pthread_mutex_t           /* _pthread_types.h:113:40 */
type X__darwin_pthread_mutexattr_t = X_opaque_pthread_mutexattr_t   /* _pthread_types.h:114:44 */
type X__darwin_pthread_once_t = X_opaque_pthread_once_t             /* _pthread_types.h:115:39 */
type X__darwin_pthread_rwlock_t = X_opaque_pthread_rwlock_t         /* _pthread_types.h:116:41 */
type X__darwin_pthread_rwlockattr_t = X_opaque_pthread_rwlockattr_t /* _pthread_types.h:117:45 */
type X__darwin_pthread_t = uintptr                                  /* _pthread_types.h:118:34 */

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1987, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)endian.h	8.1 (Berkeley) 6/11/93

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Define _NOQUAD if the compiler does NOT support 64-bit integers.
// #define _NOQUAD

// Define the order of 32-bit words in 64-bit words.

// Definitions for byte order, according to byte significance from low
// address to high.

// Copyright (c) 2004, 2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1987, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Macros for network/external number representation conversion.

// Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This header is normally included from <libkern/OSByteOrder.h>.  However,
// <sys/_endian.h> also includes this in the case of little-endian
// architectures, so that we can map OSByteOrder routines to the hton* and ntoh*
// macros.  This results in the asymmetry below; we only include
// <libkern/arch/_OSByteOrder.h> for little-endian architectures.

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Macros for swapping constant values in the preprocessing stage.

// Copyright (c) 1999-2007 Apple Inc. All rights reserved.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2000-2010 Apple Inc.
// All rights reserved.

// from ISO/IEC 988:1999 spec

// 7.18.1.1 Exact-width integer types
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint8_t = uint8 /* _uint8_t.h:31:23 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint16_t = uint16 /* _uint16_t.h:31:24 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint32_t = uint32 /* _uint32_t.h:31:22 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint64_t = uint64 /* _uint64_t.h:31:28 */

// 7.18.1.2 Minimum-width integer types
type Int_least8_t = Int8_t     /* stdint.h:38:26 */
type Int_least16_t = Int16_t   /* stdint.h:39:25 */
type Int_least32_t = Int32_t   /* stdint.h:40:25 */
type Int_least64_t = Int64_t   /* stdint.h:41:25 */
type Uint_least8_t = Uint8_t   /* stdint.h:42:25 */
type Uint_least16_t = Uint16_t /* stdint.h:43:24 */
type Uint_least32_t = Uint32_t /* stdint.h:44:24 */
type Uint_least64_t = Uint64_t /* stdint.h:45:24 */

// 7.18.1.3 Fastest-width integer types
type Int_fast8_t = Int8_t     /* stdint.h:49:27 */
type Int_fast16_t = Int16_t   /* stdint.h:50:26 */
type Int_fast32_t = Int32_t   /* stdint.h:51:26 */
type Int_fast64_t = Int64_t   /* stdint.h:52:26 */
type Uint_fast8_t = Uint8_t   /* stdint.h:53:26 */
type Uint_fast16_t = Uint16_t /* stdint.h:54:25 */
type Uint_fast32_t = Uint32_t /* stdint.h:55:25 */
type Uint_fast64_t = Uint64_t /* stdint.h:56:25 */

// 7.18.1.4 Integer types capable of holding object pointers

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// 7.18.1.5 Greatest-width integer types
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Intmax_t = int64 /* _intmax_t.h:32:25 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uintmax_t = uint64 /* _uintmax_t.h:32:26 */

// 7.18.4 Macros for integer constants

// 7.18.2 Limits of specified-width integer types:
//   These #defines specify the minimum and maximum limits
//   of each of the types declared above.
//
//   They must have "the same type as would an expression that is an
//   object of the corresponding type converted according to the integer
//   promotion".

// 7.18.2.1 Limits of exact-width integer types

//
//       Note:  the literal "most negative int" cannot be written in C --
//       the rules in the standard (section 6.4.4.1 in C99) will give it
//       an unsigned type, so INT32_MIN (and the most negative member of
//       any larger signed type) must be written via a constant expression.
//

// 7.18.2.2 Limits of minimum-width integer types

// 7.18.2.3 Limits of fastest minimum-width integer types

// 7.18.2.4 Limits of integer types capable of holding object pointers

// 7.18.2.5 Limits of greatest-width integer types

// 7.18.3 "Other"

// WCHAR_MIN should be 0 if wchar_t is an unsigned type and
//    (-WCHAR_MAX-1) if wchar_t is a signed type.  Unfortunately,
//    it turns out that -fshort-wchar changes the signedness of
//    the type.

// Copyright (c) 2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Collect the __ARM_ARCH_*__ compiler flags into something easier to use.

// Generic byte swapping functions.

func _OSSwapInt16(tls *libc.TLS, _data Uint16_t) Uint16_t { /* OSByteOrder.h:15:1: */
	// Reduces to 'rev16' with clang
	return (Uint16_t((int32(_data) << 8) | (int32(_data) >> 8)))
}

func _OSSwapInt32(tls *libc.TLS, _data Uint32_t) Uint32_t { /* OSByteOrder.h:25:1: */
	// This actually generates the best code
	_data = ((((_data ^ ((_data >> 16) | (_data << 16))) & 0xFF00FFFF) >> 8) ^ ((_data >> 8) | (_data << 24)))

	return _data
}

func _OSSwapInt64(tls *libc.TLS, _data Uint64_t) Uint64_t { /* OSByteOrder.h:41:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var _u struct {F_ull Uint64_t;} at bp, 8

	// This actually generates the best code
	*(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */))) = (Uint32_t(_data >> 32))
	*(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */) + 1*4)) = (Uint32_t(_data & uint64(0xffffffff)))
	*(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */))) = _OSSwapInt32(tls, *(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */))))
	*(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */) + 1*4)) = _OSSwapInt32(tls, *(*Uint32_t)(unsafe.Pointer((bp /* &_u */ /* &._ul */) + 1*4)))
	return *(*Uint64_t)(unsafe.Pointer(bp /* &_u */))
}

// Functions for byte reversed loads.

type X_OSUnalignedU16 = struct{ F__val Uint16_t } /* OSByteOrder.h:64:1 */

type X_OSUnalignedU32 = struct{ F__val Uint32_t } /* OSByteOrder.h:68:1 */

type X_OSUnalignedU64 = struct{ F__val Uint64_t } /* OSByteOrder.h:72:1 */

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_char = uint8 /* _u_char.h:30:25 */
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_short = uint16 /* _u_short.h:30:25 */
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int = uint32  /* _u_int.h:30:25 */
type U_long = uint64 /* types.h:88:33 */
type Ushort = uint16 /* types.h:91:33 */ // Sys V compatibility
type Uint = uint32   /* types.h:92:33 */ // Sys V compatibility

type U_quad_t = U_int64_t /* types.h:95:33 */ // quads
type Quad_t = Int64_t     /* types.h:96:33 */
type Qaddr_t = uintptr    /* types.h:97:16 */

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Caddr_t = uintptr /* _caddr_t.h:30:14 */

type Daddr_t = Int32_t /* types.h:101:33 */ // disk address

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Dev_t = X__darwin_dev_t /* _dev_t.h:31:31 */ // device number

type Fixpt_t = U_int32_t /* types.h:105:33 */ // fixed point number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Blkcnt_t = X__darwin_blkcnt_t /* _blkcnt_t.h:31:34 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Blksize_t = X__darwin_blksize_t /* _blksize_t.h:31:35 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Gid_t = X__darwin_gid_t /* _gid_t.h:31:25 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type In_addr_t = X__uint32_t /* _in_addr_t.h:31:25 */ // base type for internet address
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type In_port_t = X__uint16_t /* _in_port_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Ino_t = X__darwin_ino_t /* _ino_t.h:31:33 */ // inode number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Ino64_t = X__darwin_ino64_t /* _ino64_t.h:31:33 */ // 64bit inode number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Key_t = X__int32_t /* _key_t.h:31:26 */ // IPC key (for Sys V IPC)
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Mode_t = X__darwin_mode_t /* _mode_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Nlink_t = X__uint16_t /* _nlink_t.h:31:27 */ // link count
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Id_t = X__darwin_id_t /* _id_t.h:31:25 */ // can hold pid_t, gid_t, or uid_t
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pid_t = X__darwin_pid_t /* _pid_t.h:31:31 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Off_t = X__darwin_off_t /* _off_t.h:31:33 */

type Segsz_t = Int32_t /* types.h:125:33 */ // segment size
type Swblk_t = Int32_t /* types.h:126:33 */ // swap offset

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uid_t = X__darwin_uid_t /* _uid_t.h:31:31 */

// Major, minor numbers, dev_t's.

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Clock_t = X__darwin_clock_t /* _clock_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Ssize_t = X__darwin_ssize_t /* _ssize_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Time_t = X__darwin_time_t /* _time_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Useconds_t = X__darwin_useconds_t /* _useconds_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Suseconds_t = X__darwin_suseconds_t /* _suseconds_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Rsize_t = X__darwin_size_t /* _rsize_t.h:31:32 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Errno_t = int32 /* _errno_t.h:30:32 */

// This code is present here in order to maintain historical backward
// compatability, and is intended to be removed at some point in the
// future; please include <sys/select.h> instead.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     These macros are for use in OS header files. They enable function prototypes
//     and Objective-C methods to be tagged with the OS version in which they
//     were first available; and, if applicable, the OS version in which they
//     became deprecated.
//
//     The desktop Mac OS X and iOS each have different version numbers.
//     The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
//     and iOS version numbers.  For instance:
//         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
//     means the function/method was first available on Mac OS X 10.2 on the desktop
//     and first available in iOS 2.0 on the iPhone.
//
//     If a function is available on one platform, but not the other a _NA (not
//     applicable) parameter is used.  For instance:
//             __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
//     means that the function/method was first available on Mac OS X 10.3, and it
//     currently not implemented on the iPhone.
//
//     At some point, a function/method may be deprecated.  That means Apple
//     recommends applications stop using the function, either because there is a
//     better replacement or the functionality is being phased out.  Deprecated
//     functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
//     macro which specifies the OS version where the function became available
//     as well as the OS version in which it became deprecated.  For instance:
//         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
//     means that the function/method was introduced in Mac OS X 10.0, then
//     became deprecated beginning in Mac OS X 10.5.  On iOS the function
//     has never been available.
//
//     For these macros to function properly, a program must specify the OS version range
//     it is targeting.  The min OS version is specified as an option to the compiler:
//     -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
//     when building for the iPhone.  The upper bound for the OS version is rarely needed,
//     but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
//     Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.
//
//     Examples:
//
//         A function available in Mac OS X 10.5 and later, but not on the phone:
//
//             extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//
//
//         An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
//
//             @interface MyClass : NSObject
//             -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//             @end
//
//
//         An enum available on the phone, but not available on Mac OS X:
//
//             #if __IPHONE_OS_VERSION_MIN_REQUIRED
//                 enum { myEnum = 1 };
//             #endif
//            Note: this works when targeting the Mac OS X platform because
//            __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero.
//
//
//         An enum with values added in different iPhoneOS versions:
//
// 			enum {
// 			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
// 			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
// 			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
// 				...
// 		      Note: you do not want to use #if with enumeration values
// 			  when a client needs to see all values at compile time
// 			  and use runtime logic to only use the viable values.
//
//
//     It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
//     source base that can be compiled to target a range of OS versions.  It is best
//     to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
//     That is because you might get compiled on an old OS that does not define a later
//     OS version macro, and in the C preprocessor undefined values evaluate to zero
//     in expresssions, which could cause the #if expression to evaluate in an unexpected
//     way.
//
//         #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
//             // code only compiled when targeting Mac OS X and not iPhone
//             // note use of 1050 instead of __MAC_10_5
//             #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
//                 // code in here might run on pre-Leopard OS
//             #else
//                 // code here can assume Leopard or later
//             #endif
//         #endif
//
//

// __API_TO_BE_DEPRECATED is used as a version number in API that will be deprecated
// in an upcoming release. This soft deprecation is an intermediate step before formal
// deprecation to notify developers about the API before compiler warnings are generated.
// You can find all places in your code that use soft deprecated API by redefining the
// value of this macro to your current minimum deployment target, for example:
// (macOS)
//   clang -D__API_TO_BE_DEPRECATED=10.12 <other compiler flags>
// (iOS)
//   clang -D__API_TO_BE_DEPRECATED=11.0 <other compiler flags>

// Copyright (c) 2019 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// __MAC_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// __IPHONE_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// Set up standard Mac OS X versions

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     File:       AvailabilityInternal.h
//
//     Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>
//

// compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__

// make sure a default max version is set

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//

// Evaluate to nothing for compilers that don't support availability.

// Swift compiler version
// Allows for project-agnostic epochs for frameworks imported into Swift via the Clang importer, like #if _compiler_version for Swift
// Example:
//
//  #if __swift_compiler_version_at_least(800, 2, 20)
//  - (nonnull NSString *)description;
//  #else
//  - (NSString *)description;
//  #endif

// If __SPI_AVAILABLE has not been defined elsewhere, disable it.

// for use to document app extension usage

// for use marking APIs available info for Mac OSX

// for use marking APIs available info for iOS

// for use marking APIs available info for tvOS

// for use marking APIs available info for Watch OS

// for use marking APIs unavailable for swift

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//
//  * Note that these macros are only compatible with clang compilers that
//  * support the following target selection options:
//  *
//  * -mmacosx-version-min
//  * -miphoneos-version-min
//  * -mwatchos-version-min
//  * -mtvos-version-min
//

// Evaluate to nothing for compilers that don't support availability.

// If SPI decorations have not been defined elsewhere, disable them.

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.

type Fd_set1 = struct{ Ffds_bits [32]X__int32_t } /* _fd_def.h:50:9 */

// This code is present here in order to maintain historical backward
// compatability, and is intended to be removed at some point in the
// future; please include <sys/select.h> instead.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     These macros are for use in OS header files. They enable function prototypes
//     and Objective-C methods to be tagged with the OS version in which they
//     were first available; and, if applicable, the OS version in which they
//     became deprecated.
//
//     The desktop Mac OS X and iOS each have different version numbers.
//     The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
//     and iOS version numbers.  For instance:
//         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
//     means the function/method was first available on Mac OS X 10.2 on the desktop
//     and first available in iOS 2.0 on the iPhone.
//
//     If a function is available on one platform, but not the other a _NA (not
//     applicable) parameter is used.  For instance:
//             __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
//     means that the function/method was first available on Mac OS X 10.3, and it
//     currently not implemented on the iPhone.
//
//     At some point, a function/method may be deprecated.  That means Apple
//     recommends applications stop using the function, either because there is a
//     better replacement or the functionality is being phased out.  Deprecated
//     functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
//     macro which specifies the OS version where the function became available
//     as well as the OS version in which it became deprecated.  For instance:
//         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
//     means that the function/method was introduced in Mac OS X 10.0, then
//     became deprecated beginning in Mac OS X 10.5.  On iOS the function
//     has never been available.
//
//     For these macros to function properly, a program must specify the OS version range
//     it is targeting.  The min OS version is specified as an option to the compiler:
//     -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
//     when building for the iPhone.  The upper bound for the OS version is rarely needed,
//     but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
//     Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.
//
//     Examples:
//
//         A function available in Mac OS X 10.5 and later, but not on the phone:
//
//             extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//
//
//         An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
//
//             @interface MyClass : NSObject
//             -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//             @end
//
//
//         An enum available on the phone, but not available on Mac OS X:
//
//             #if __IPHONE_OS_VERSION_MIN_REQUIRED
//                 enum { myEnum = 1 };
//             #endif
//            Note: this works when targeting the Mac OS X platform because
//            __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero.
//
//
//         An enum with values added in different iPhoneOS versions:
//
// 			enum {
// 			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
// 			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
// 			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
// 				...
// 		      Note: you do not want to use #if with enumeration values
// 			  when a client needs to see all values at compile time
// 			  and use runtime logic to only use the viable values.
//
//
//     It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
//     source base that can be compiled to target a range of OS versions.  It is best
//     to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
//     That is because you might get compiled on an old OS that does not define a later
//     OS version macro, and in the C preprocessor undefined values evaluate to zero
//     in expresssions, which could cause the #if expression to evaluate in an unexpected
//     way.
//
//         #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
//             // code only compiled when targeting Mac OS X and not iPhone
//             // note use of 1050 instead of __MAC_10_5
//             #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
//                 // code in here might run on pre-Leopard OS
//             #else
//                 // code here can assume Leopard or later
//             #endif
//         #endif
//
//

// __API_TO_BE_DEPRECATED is used as a version number in API that will be deprecated
// in an upcoming release. This soft deprecation is an intermediate step before formal
// deprecation to notify developers about the API before compiler warnings are generated.
// You can find all places in your code that use soft deprecated API by redefining the
// value of this macro to your current minimum deployment target, for example:
// (macOS)
//   clang -D__API_TO_BE_DEPRECATED=10.12 <other compiler flags>
// (iOS)
//   clang -D__API_TO_BE_DEPRECATED=11.0 <other compiler flags>

// Copyright (c) 2019 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// __MAC_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// __IPHONE_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// Set up standard Mac OS X versions

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     File:       AvailabilityInternal.h
//
//     Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>
//

// compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__

// make sure a default max version is set

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//

// Evaluate to nothing for compilers that don't support availability.

// Swift compiler version
// Allows for project-agnostic epochs for frameworks imported into Swift via the Clang importer, like #if _compiler_version for Swift
// Example:
//
//  #if __swift_compiler_version_at_least(800, 2, 20)
//  - (nonnull NSString *)description;
//  #else
//  - (NSString *)description;
//  #endif

// If __SPI_AVAILABLE has not been defined elsewhere, disable it.

// for use to document app extension usage

// for use marking APIs available info for Mac OSX

// for use marking APIs available info for iOS

// for use marking APIs available info for tvOS

// for use marking APIs available info for Watch OS

// for use marking APIs unavailable for swift

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//
//  * Note that these macros are only compatible with clang compilers that
//  * support the following target selection options:
//  *
//  * -mmacosx-version-min
//  * -miphoneos-version-min
//  * -mwatchos-version-min
//  * -mtvos-version-min
//

// Evaluate to nothing for compilers that don't support availability.

// If SPI decorations have not been defined elsewhere, disable them.

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.

type Fd_set = Fd_set1 /* _fd_def.h:52:3 */

// Use the built-in bzero function instead of the library version so that
// we do not pollute the namespace or introduce prototype warnings.

type Fd_mask = X__int32_t /* types.h:189:25 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_attr_t = X__darwin_pthread_attr_t /* _pthread_attr_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_cond_t = X__darwin_pthread_cond_t /* _pthread_cond_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_condattr_t = X__darwin_pthread_condattr_t /* _pthread_condattr_t.h:31:37 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_mutex_t = X__darwin_pthread_mutex_t /* _pthread_mutex_t.h:31:34 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_mutexattr_t = X__darwin_pthread_mutexattr_t /* _pthread_mutexattr_t.h:31:38 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_once_t = X__darwin_pthread_once_t /* _pthread_once_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_rwlock_t = X__darwin_pthread_rwlock_t /* _pthread_rwlock_t.h:31:35 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_rwlockattr_t = X__darwin_pthread_rwlockattr_t /* _pthread_rwlockattr_t.h:31:39 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_t = X__darwin_pthread_t /* _pthread_t.h:31:28 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_key_t = X__darwin_pthread_key_t /* _pthread_key_t.h:31:32 */

// statvfs and fstatvfs

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Fsblkcnt_t = X__darwin_fsblkcnt_t /* _fsblkcnt_t.h:31:41 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Fsfilcnt_t = X__darwin_fsfilcnt_t /* _fsfilcnt_t.h:31:41 */

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type X__gnuc_va_list = X__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//    stdio.h, because ANSI C says that stdio.h is not supposed to define
//    va_list.  stdio.h needs to have access to that data type,
//    but must not use that name.  It should use the name __gnuc_va_list,
//    which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//    But on BSD NET2 we must not test or define or undef it.
//    (Note that the comments in NET 2's ansi.h
//    are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type Va_list = X__gnuc_va_list /* stdarg.h:99:24 */

// a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
// "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
// though the former does not conform to the LFS document), but considering
// both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
// equivalently requesting no 64-bit operations

// Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved
// Copyright (c) 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)unistd.h	8.12 (Berkeley) 4/27/95
//
//  Copyright (c)  1998 Apple Compter, Inc.
//  All Rights Reserved

// History:
//         7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr
//         3/26/98 CHW at Apple added real interface to searchfs call
//   	3/5/98  CHW at Apple added hfs semantic system calls headers

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type X__darwin_nl_item = int32        /* _types.h:40:14 */
type X__darwin_wctrans_t = int32      /* _types.h:41:14 */
type X__darwin_wctype_t = X__uint32_t /* _types.h:43:20 */

// Copyright (c) 2000-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)unistd.h	8.2 (Berkeley) 1/7/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Although we have saved user/group IDs, we do not use them in setuid
// as described in POSIX 1003.1, because the feature does not work for
// root.  We use the saved IDs in seteuid/setegid, which are not currently
// part of the POSIX 1003.1 specification.

// execution-time symbolic constants
// may disable terminal special characters
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// access function

// Extended access functions.
// Note that we depend on these matching the definitions in sys/kauth.h,
// but with the bits shifted left by 8.

// whence values for lseek(2)
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// whence values for lseek(2)

// whence values for lseek(2); renamed by POSIX 1003.1

type Accessx_descriptor = struct {
	Fad_name_offset uint32
	Fad_flags       int32
	Fad_pad         [2]int32
} /* unistd.h:132:1 */

// Darwin extensions

// Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)select.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// [XSI] The <sys/select.h> header shall define the fd_set type as a structure.
// The timespec structure shall be defined as described in <time.h>
// The <sys/select.h> header shall define the timeval structure.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type Timespec = struct {
	Ftv_sec  X__darwin_time_t
	Ftv_nsec int64
} /* _timespec.h:33:1 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Timeval = struct {
	Ftv_sec  X__darwin_time_t
	Ftv_usec X__darwin_suseconds_t
	_        [4]byte
} /* _timeval.h:34:1 */

// The time_t and suseconds_t types shall be defined as described in
// <sys/types.h>
// The sigset_t type shall be defined as described in <signal.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Sigset_t = X__darwin_sigset_t /* _sigset_t.h:31:41 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uuid_t = X__darwin_uuid_t /* _uuid_t.h:31:25 */

// MVS linker does not support external names larger than 8 bytes

//
//     The 'zlib' compression library provides in-memory compression and
//   decompression functions, including integrity checks of the uncompressed data.
//   This version of the library supports only one compression method (deflation)
//   but other algorithms will be added later and will have the same stream
//   interface.
//
//     Compression can be done in a single step if the buffers are large enough,
//   or can be done by repeated calls of the compression function.  In the latter
//   case, the application must provide more input and/or consume the output
//   (providing more output space) before each call.
//
//     The compressed data format used by default by the in-memory functions is
//   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
//   around a deflate stream, which is itself documented in RFC 1951.
//
//     The library also supports reading and writing files in gzip (.gz) format
//   with an interface similar to that of stdio using the functions that start
//   with "gz".  The gzip format is different from the zlib format.  gzip is a
//   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
//
//     This library can optionally read and write gzip and raw deflate streams in
//   memory as well.
//
//     The zlib format was designed to be compact and fast for use in memory
//   and on communications channels.  The gzip format was designed for single-
//   file compression on file systems, has a larger header than zlib to maintain
//   directory information, and uses a different, slower check method than zlib.
//
//     The library does not install any signal handler.  The decoder checks
//   the consistency of the compressed data, so the library should never crash
//   even in the case of corrupted input.

type Alloc_func = uintptr /* zlib.h:81:16 */
type Free_func = uintptr  /* zlib.h:82:16 */

type Internal_state = struct {
	Fstrm             Z_streamp
	Fstatus           int32
	_                 [4]byte
	Fpending_buf      uintptr
	Fpending_buf_size Ulg
	Fpending_out      uintptr
	Fpending          Ulg
	Fwrap             int32
	_                 [4]byte
	Fgzhead           Gz_headerp
	Fgzindex          Ulg
	Fmethod           Byte
	_                 [3]byte
	Flast_flush       int32
	Fw_size           UInt
	Fw_bits           UInt
	Fw_mask           UInt
	_                 [4]byte
	Fwindow           uintptr
	Fwindow_size      Ulg
	Fprev             uintptr
	Fhead             uintptr
	Fins_h            UInt
	Fhash_size        UInt
	Fhash_bits        UInt
	Fhash_mask        UInt
	Fhash_shift       UInt
	_                 [4]byte
	Fblock_start      int64
	Fmatch_length     UInt
	Fprev_match       IPos
	Fmatch_available  int32
	Fstrstart         UInt
	Fmatch_start      UInt
	Flookahead        UInt
	Fprev_length      UInt
	Fmax_chain_length UInt
	Fmax_lazy_match   UInt
	Flevel            int32
	Fstrategy         int32
	Fgood_match       UInt
	Fnice_match       int32
	Fdyn_ltree        [573]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fdyn_dtree [61]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fbl_tree [39]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fl_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		_          [4]byte
		Fstat_desc uintptr
	}
	Fd_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		_          [4]byte
		Fstat_desc uintptr
	}
	Fbl_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		_          [4]byte
		Fstat_desc uintptr
	}
	Fbl_count    [16]Ush
	Fheap        [573]int32
	Fheap_len    int32
	Fheap_max    int32
	Fdepth       [573]Uch
	_            [7]byte
	Fl_buf       uintptr
	Flit_bufsize UInt
	Flast_lit    UInt
	Fd_buf       uintptr
	Fopt_len     Ulg
	Fstatic_len  Ulg
	Fmatches     UInt
	Finsert      UInt
	Fbi_buf      Ush
	_            [2]byte
	Fbi_valid    int32
	Fhigh_water  Ulg
} /* zlib.h:84:1 */

type Z_stream_s = struct {
	Fnext_in   uintptr
	Favail_in  UInt
	_          [4]byte
	Ftotal_in  ULong
	Fnext_out  uintptr
	Favail_out UInt
	_          [4]byte
	Ftotal_out ULong
	Fmsg       uintptr
	Fstate     uintptr
	Fzalloc    Alloc_func
	Fzfree     Free_func
	Fopaque    Voidpf
	Fdata_type int32
	_          [4]byte
	Fadler     ULong
	Freserved  ULong
} /* zlib.h:86:9 */

type Z_stream = Z_stream_s /* zlib.h:106:3 */

type Z_streamp = uintptr /* zlib.h:108:22 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type Gz_header_s = struct {
	Ftext      int32
	_          [4]byte
	Ftime      ULong
	Fxflags    int32
	Fos        int32
	Fextra     uintptr
	Fextra_len UInt
	Fextra_max UInt
	Fname      uintptr
	Fname_max  UInt
	_          [4]byte
	Fcomment   uintptr
	Fcomm_max  UInt
	Fhcrc      int32
	Fdone      int32
	_          [4]byte
} /* zlib.h:114:9 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type Gz_header = Gz_header_s /* zlib.h:129:3 */

type Gz_headerp = uintptr /* zlib.h:131:23 */
//
//      inflateGetHeader() requests that gzip header information be stored in the
//    provided gz_header structure.  inflateGetHeader() may be called after
//    inflateInit2() or inflateReset(), and before the first call of inflate().
//    As inflate() processes the gzip stream, head->done is zero until the header
//    is completed, at which time head->done is set to one.  If a zlib stream is
//    being decoded, then head->done is set to -1 to indicate that there will be
//    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
//    used to force inflate() to return immediately after header processing is
//    complete and before any actual data is decompressed.
//
//      The text, time, xflags, and os fields are filled in with the gzip header
//    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
//    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
//    contains the maximum number of bytes to write to extra.  Once done is true,
//    extra_len contains the actual extra field length, and extra contains the
//    extra field, or that field truncated if extra_max is less than extra_len.
//    If name is not Z_NULL, then up to name_max characters are written there,
//    terminated with a zero unless the length is greater than name_max.  If
//    comment is not Z_NULL, then up to comm_max characters are written there,
//    terminated with a zero unless the length is greater than comm_max.  When any
//    of extra, name, or comment are not Z_NULL and the respective field is not
//    present in the header, then that field is set to Z_NULL to signal its
//    absence.  This allows the use of deflateSetHeader() with the returned
//    structure to duplicate the header.  However if those fields are set to
//    allocated memory, then the application will need to save those pointers
//    elsewhere so that they can be eventually freed.
//
//      If inflateGetHeader is not used, then the header information is simply
//    discarded.  The header is always checked for validity, including the header
//    CRC if present.  inflateReset() will reset the process to discard the header
//    information.  The application would need to call inflateGetHeader() again to
//    retrieve the header from the next gzip stream.
//
//      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
//    stream state was inconsistent.

//
// ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
//                                         unsigned char FAR *window));
//
//      Initialize the internal stream state for decompression using inflateBack()
//    calls.  The fields zalloc, zfree and opaque in strm must be initialized
//    before the call.  If zalloc and zfree are Z_NULL, then the default library-
//    derived memory allocation routines are used.  windowBits is the base two
//    logarithm of the window size, in the range 8..15.  window is a caller
//    supplied buffer of that size.  Except for special applications where it is
//    assured that deflate was used with small window sizes, windowBits must be 15
//    and a 32K byte window must be supplied to be able to decompress general
//    deflate streams.
//
//      See inflateBack() for the usage of these routines.
//
//      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
//    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
//    allocated, or Z_VERSION_ERROR if the version of the library does not match
//    the version of the header file.

type In_func = uintptr  /* zlib.h:1092:18 */
type Out_func = uintptr /* zlib.h:1094:13 */
//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type GzFile_s = struct {
	Fhave uint32
	_     [4]byte
	Fnext uintptr
	Fpos  Off_t
} /* zlib.h:1300:9 */

//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type GzFile = uintptr /* zlib.h:1300:25 */

// Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93

// Security checking functions.
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// bcopy and bzero

// Removed in Issue 7

// void	bcopy(const void *src, void *dst, size_t len)

// void	bzero(void *s, size_t n)

// Security checking functions.
// Copyright (c) 2007,2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// <rdar://problem/12622659>

// memccpy, memcpy, mempcpy, memmove, memset, strcpy, strlcpy, stpcpy,
//    strncpy, stpncpy, strcat, strlcat, and strncat

// void *memcpy(void *dst, const void *src, size_t n)

// void *memmove(void *dst, const void *src, size_t len)

// void *memset(void *b, int c, size_t len)

// char *strcpy(char *dst, const char *src)

// char *stpcpy(char *dst, const char *src)

// char *stpncpy(char *dst, const char *src, size_t n)

// char *strncpy(char *dst, const char *src, size_t n)

// char *strcat(char *s1, const char *s2)

// char *strncat(char *s1, const char *s2, size_t n)

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
type Idtype_t = uint32 /* wait.h:83:3 */

// [XSI] The id_t and pid_t types shall be defined as described
// in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// [XSI] The siginfo_t type shall be defined as described in <signal.h>
// [XSI] The rusage structure shall be defined as described in <sys/resource.h>
// [XSI] Inclusion of the <sys/wait.h> header may also make visible all
// symbols from <signal.h> and <sys/resource.h>
//
// NOTE:	This requirement is currently being satisfied by the direct
//		inclusion of <sys/signal.h> and <sys/resource.h>, below.
//
//		Software should not depend on the exposure of anything other
//		than the types siginfo_t and struct rusage as a result of
//		this inclusion.  If you depend on any types or manifest
//		values othe than siginfo_t and struct rusage from either of
//		those files, you should explicitly include them yourself, as
//		well, or in future releases your stware may not compile
//		without modification.
// Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.2 (Berkeley) 1/21/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2009 Apple, Inc. All rights reserved.
// Copyright (c) 1992 NeXT Computer, Inc.
//

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

type Sig_atomic_t = int32 /* signal.h:15:13 */

// Language spec sez we must list exactly one parameter, even though we
// actually supply three.  Ugh!
// SIG_HOLD is chosen to avoid KERN_SIG_* values in <sys/signalvar.h>

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2004-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// @OSF_COPYRIGHT@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type X__darwin_arm_exception_state = struct {
	F__exception X__uint32_t
	F__fsr       X__uint32_t
	F__far       X__uint32_t
} /* _structs.h:39:1 */

type X__darwin_arm_exception_state64 = struct {
	F__far       X__uint64_t
	F__esr       X__uint32_t
	F__exception X__uint32_t
} /* _structs.h:57:1 */

type X__darwin_arm_thread_state = struct {
	F__r    [13]X__uint32_t
	F__sp   X__uint32_t
	F__lr   X__uint32_t
	F__pc   X__uint32_t
	F__cpsr X__uint32_t
} /* _structs.h:75:1 */

// By default, the pointer fields in the arm_thread_state64_t structure are
// opaque on the arm64e architecture and require the use of accessor macros.
// This mode can also be enabled on the arm64 architecture by building with
// -D__DARWIN_OPAQUE_ARM_THREAD_STATE64=1.

type X__darwin_arm_thread_state64 = struct {
	F__x    [29]X__uint64_t
	F__fp   X__uint64_t
	F__lr   X__uint64_t
	F__sp   X__uint64_t
	F__pc   X__uint64_t
	F__cpsr X__uint32_t
	F__pad  X__uint32_t
} /* _structs.h:134:1 */

// Accessor macros for arm_thread_state64_t pointer fields

// Return pc field of arm_thread_state64_t as a data pointer value
// Return pc field of arm_thread_state64_t as a function pointer
// Set pc field of arm_thread_state64_t to a function pointer
// Return lr field of arm_thread_state64_t as a data pointer value
// Return lr field of arm_thread_state64_t as a function pointer
// Set lr field of arm_thread_state64_t to a function pointer
// Return sp field of arm_thread_state64_t as a data pointer value
// Set sp field of arm_thread_state64_t to a data pointer value
// Return fp field of arm_thread_state64_t as a data pointer value
// Set fp field of arm_thread_state64_t to a data pointer value
// Strip ptr auth bits from pc, lr, sp and fp field of arm_thread_state64_t

type X__darwin_arm_vfp_state = struct {
	F__r     [64]X__uint32_t
	F__fpscr X__uint32_t
} /* _structs.h:422:1 */

type X__darwin_arm_neon_state64 = struct {
	F__v    [32]X__uint128_t
	F__fpsr X__uint32_t
	F__fpcr X__uint32_t
} /* _structs.h:441:1 */

type X__darwin_arm_neon_state = struct {
	F__v    [16]X__uint128_t
	F__fpsr X__uint32_t
	F__fpcr X__uint32_t
} /* _structs.h:448:1 */

type X__darwin_arm_amx_state_v1 = struct {
	F__x               [8][64]X__uint8_t
	F__y               [8][64]X__uint8_t
	F__z               [64][64]X__uint8_t
	F__amx_state_t_el1 X__uint64_t
} /* _structs.h:512:1 */

type X__arm_pagein_state = struct{ F__pagein_error int32 } /* _structs.h:531:1 */

// Debug State

// ARM's arm_debug_state is ARM64's arm_legacy_debug_state

type X__arm_legacy_debug_state = struct {
	F__bvr [16]X__uint32_t
	F__bcr [16]X__uint32_t
	F__wvr [16]X__uint32_t
	F__wcr [16]X__uint32_t
} /* _structs.h:568:1 */

type X__darwin_arm_debug_state32 = struct {
	F__bvr       [16]X__uint32_t
	F__bcr       [16]X__uint32_t
	F__wvr       [16]X__uint32_t
	F__wcr       [16]X__uint32_t
	F__mdscr_el1 X__uint64_t
} /* _structs.h:591:1 */

type X__darwin_arm_debug_state64 = struct {
	F__bvr       [16]X__uint64_t
	F__bcr       [16]X__uint64_t
	F__wvr       [16]X__uint64_t
	F__wcr       [16]X__uint64_t
	F__mdscr_el1 X__uint64_t
} /* _structs.h:601:1 */

type X__darwin_arm_cpmu_state64 = struct{ F__ctrs [16]X__uint64_t } /* _structs.h:633:1 */

type X__darwin_mcontext32 = struct {
	F__es struct {
		F__exception X__uint32_t
		F__fsr       X__uint32_t
		F__far       X__uint32_t
	}
	F__ss struct {
		F__r    [13]X__uint32_t
		F__sp   X__uint32_t
		F__lr   X__uint32_t
		F__pc   X__uint32_t
		F__cpsr X__uint32_t
	}
	F__fs struct {
		F__r     [64]X__uint32_t
		F__fpscr X__uint32_t
	}
} /* _mcontext.h:39:1 */

type X__darwin_mcontext64 = struct {
	F__es struct {
		F__far       X__uint64_t
		F__esr       X__uint32_t
		F__exception X__uint32_t
	}
	F__ss struct {
		F__x    [29]X__uint64_t
		F__fp   X__uint64_t
		F__lr   X__uint64_t
		F__sp   X__uint64_t
		F__pc   X__uint64_t
		F__cpsr X__uint32_t
		F__pad  X__uint32_t
	}
	F__ns struct {
		F__v    [32]X__uint128_t
		F__fpsr X__uint32_t
		F__fpcr X__uint32_t
	}
} /* _mcontext.h:62:1 */

type Mcontext_t = uintptr /* _mcontext.h:83:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type X__darwin_sigaltstack = struct {
	Fss_sp    uintptr
	Fss_size  X__darwin_size_t
	Fss_flags int32
	_         [4]byte
} /* _sigaltstack.h:42:1 */

type Stack_t = X__darwin_sigaltstack /* _sigaltstack.h:48:33 */ // [???] signal stack

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

type X__darwin_ucontext = struct {
	Fuc_onstack int32
	Fuc_sigmask X__darwin_sigset_t
	Fuc_stack   struct {
		Fss_sp    uintptr
		Fss_size  X__darwin_size_t
		Fss_flags int32
		_         [4]byte
	}
	Fuc_link     uintptr
	Fuc_mcsize   X__darwin_size_t
	Fuc_mcontext uintptr
} /* _ucontext.h:43:1 */

// user context
type Ucontext_t = X__darwin_ucontext /* _ucontext.h:57:33 */ // [???] user context

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Sigval = struct {
	_          [0]uint64
	Fsival_int int32
	_          [4]byte
} /* signal.h:158:1 */

type Sigevent = struct {
	Fsigev_notify int32
	Fsigev_signo  int32
	Fsigev_value  struct {
		_          [0]uint64
		Fsival_int int32
		_          [4]byte
	}
	Fsigev_notify_function   uintptr
	Fsigev_notify_attributes uintptr
} /* signal.h:168:1 */

type X__siginfo = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    Pid_t
	Fsi_uid    Uid_t
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  struct {
		_          [0]uint64
		Fsival_int int32
		_          [4]byte
	}
	Fsi_band int64
	F__pad   [7]uint64
} /* signal.h:177:9 */

type Siginfo_t = X__siginfo /* signal.h:188:3 */

// When the signal is SIGILL or SIGFPE, si_addr contains the address of
// the faulting instruction.
// When the signal is SIGSEGV or SIGBUS, si_addr contains the address of
// the faulting memory reference. Although for x86 there are cases of SIGSEGV
// for which si_addr cannot be determined and is NULL.
// If the signal is SIGCHLD, the si_pid field will contain the child process ID,
//  si_status contains the exit value or signal and
//  si_uid contains the real user ID of the process that sent the signal.

// Values for si_code

// Codes for SIGILL

// Codes for SIGFPE

// Codes for SIGSEGV

// Codes for SIGBUS

// Codes for SIGTRAP

// Codes for SIGCHLD

// Codes for SIGPOLL

// union for signal handlers
type X__sigaction_u = struct{ F__sa_handler uintptr } /* signal.h:269:1 */

// Signal vector template for Kernel user boundary
type X__sigaction = struct {
	F__sigaction_u struct{ F__sa_handler uintptr }
	Fsa_tramp      uintptr
	Fsa_mask       Sigset_t
	Fsa_flags      int32
} /* signal.h:276:1 */

// Signal vector "template" used in sigaction call.
type Sigaction = struct {
	F__sigaction_u struct{ F__sa_handler uintptr }
	Fsa_mask       Sigset_t
	Fsa_flags      int32
} /* signal.h:286:1 */

// if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler.

// This will provide 64bit register set in a 32bit user address space

// the following are the only bits we support from user space, the
// rest are for kernel use only.

// Flags for sigprocmask:

// POSIX 1003.1b required values.

type Sig_t = uintptr /* signal.h:331:14 */ // type of signal function

// Structure used in sigaltstack call.

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type Sigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
} /* signal.h:348:1 */

// Structure used in sigstack call.
type Sigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
	_           [4]byte
} /* signal.h:367:1 */

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)resource.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// [XSI] The timeval structure shall be defined as described in
// <sys/time.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// The id_t type shall be defined as described in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Resource limit type (low 63 bits, excluding the sign bit)
type Rlim_t = X__uint64_t /* resource.h:89:25 */

// ****
//
// PRIORITY

// Possible values of the first parameter to getpriority()/setpriority(),
// used to indicate the type of the second parameter.

// Range limitations for the value of the third parameter to setpriority().

// use PRIO_DARWIN_BG to set the current thread into "background" state
// which lowers CPU, disk IO, and networking priorites until thread terminates
// or "background" state is revoked

// use PRIO_DARWIN_NONUI to restrict a process's ability to make calls to
// the GPU. (deprecated)

// ****
//
// RESOURCE USAGE

// Possible values of the first parameter to getrusage(), used to indicate
// the scope of the information to be returned.

// A structure representing an accounting of resource utilization.  The
// address of an instance of this structure is the second parameter to
// getrusage().
//
// Note: All values other than ru_utime and ru_stime are implementaiton
//       defined and subject to change in a future release.  Their use
//       is discouraged for standards compliant programs.
type Rusage = struct {
	Fru_utime struct {
		Ftv_sec  X__darwin_time_t
		Ftv_usec X__darwin_suseconds_t
		_        [4]byte
	}
	Fru_stime struct {
		Ftv_sec  X__darwin_time_t
		Ftv_usec X__darwin_suseconds_t
		_        [4]byte
	}
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
} /* resource.h:152:1 */

// Flavors for proc_pid_rusage().

// Flags for RUSAGE_INFO_V5

type Rusage_info_t = uintptr /* resource.h:199:14 */

type Rusage_info_v0 = struct {
	Fri_uuid               [16]Uint8_t
	Fri_user_time          Uint64_t
	Fri_system_time        Uint64_t
	Fri_pkg_idle_wkups     Uint64_t
	Fri_interrupt_wkups    Uint64_t
	Fri_pageins            Uint64_t
	Fri_wired_size         Uint64_t
	Fri_resident_size      Uint64_t
	Fri_phys_footprint     Uint64_t
	Fri_proc_start_abstime Uint64_t
	Fri_proc_exit_abstime  Uint64_t
} /* resource.h:201:1 */

type Rusage_info_v1 = struct {
	Fri_uuid                  [16]Uint8_t
	Fri_user_time             Uint64_t
	Fri_system_time           Uint64_t
	Fri_pkg_idle_wkups        Uint64_t
	Fri_interrupt_wkups       Uint64_t
	Fri_pageins               Uint64_t
	Fri_wired_size            Uint64_t
	Fri_resident_size         Uint64_t
	Fri_phys_footprint        Uint64_t
	Fri_proc_start_abstime    Uint64_t
	Fri_proc_exit_abstime     Uint64_t
	Fri_child_user_time       Uint64_t
	Fri_child_system_time     Uint64_t
	Fri_child_pkg_idle_wkups  Uint64_t
	Fri_child_interrupt_wkups Uint64_t
	Fri_child_pageins         Uint64_t
	Fri_child_elapsed_abstime Uint64_t
} /* resource.h:215:1 */

type Rusage_info_v2 = struct {
	Fri_uuid                  [16]Uint8_t
	Fri_user_time             Uint64_t
	Fri_system_time           Uint64_t
	Fri_pkg_idle_wkups        Uint64_t
	Fri_interrupt_wkups       Uint64_t
	Fri_pageins               Uint64_t
	Fri_wired_size            Uint64_t
	Fri_resident_size         Uint64_t
	Fri_phys_footprint        Uint64_t
	Fri_proc_start_abstime    Uint64_t
	Fri_proc_exit_abstime     Uint64_t
	Fri_child_user_time       Uint64_t
	Fri_child_system_time     Uint64_t
	Fri_child_pkg_idle_wkups  Uint64_t
	Fri_child_interrupt_wkups Uint64_t
	Fri_child_pageins         Uint64_t
	Fri_child_elapsed_abstime Uint64_t
	Fri_diskio_bytesread      Uint64_t
	Fri_diskio_byteswritten   Uint64_t
} /* resource.h:235:1 */

type Rusage_info_v3 = struct {
	Fri_uuid                          [16]Uint8_t
	Fri_user_time                     Uint64_t
	Fri_system_time                   Uint64_t
	Fri_pkg_idle_wkups                Uint64_t
	Fri_interrupt_wkups               Uint64_t
	Fri_pageins                       Uint64_t
	Fri_wired_size                    Uint64_t
	Fri_resident_size                 Uint64_t
	Fri_phys_footprint                Uint64_t
	Fri_proc_start_abstime            Uint64_t
	Fri_proc_exit_abstime             Uint64_t
	Fri_child_user_time               Uint64_t
	Fri_child_system_time             Uint64_t
	Fri_child_pkg_idle_wkups          Uint64_t
	Fri_child_interrupt_wkups         Uint64_t
	Fri_child_pageins                 Uint64_t
	Fri_child_elapsed_abstime         Uint64_t
	Fri_diskio_bytesread              Uint64_t
	Fri_diskio_byteswritten           Uint64_t
	Fri_cpu_time_qos_default          Uint64_t
	Fri_cpu_time_qos_maintenance      Uint64_t
	Fri_cpu_time_qos_background       Uint64_t
	Fri_cpu_time_qos_utility          Uint64_t
	Fri_cpu_time_qos_legacy           Uint64_t
	Fri_cpu_time_qos_user_initiated   Uint64_t
	Fri_cpu_time_qos_user_interactive Uint64_t
	Fri_billed_system_time            Uint64_t
	Fri_serviced_system_time          Uint64_t
} /* resource.h:257:1 */

type Rusage_info_v4 = struct {
	Fri_uuid                          [16]Uint8_t
	Fri_user_time                     Uint64_t
	Fri_system_time                   Uint64_t
	Fri_pkg_idle_wkups                Uint64_t
	Fri_interrupt_wkups               Uint64_t
	Fri_pageins                       Uint64_t
	Fri_wired_size                    Uint64_t
	Fri_resident_size                 Uint64_t
	Fri_phys_footprint                Uint64_t
	Fri_proc_start_abstime            Uint64_t
	Fri_proc_exit_abstime             Uint64_t
	Fri_child_user_time               Uint64_t
	Fri_child_system_time             Uint64_t
	Fri_child_pkg_idle_wkups          Uint64_t
	Fri_child_interrupt_wkups         Uint64_t
	Fri_child_pageins                 Uint64_t
	Fri_child_elapsed_abstime         Uint64_t
	Fri_diskio_bytesread              Uint64_t
	Fri_diskio_byteswritten           Uint64_t
	Fri_cpu_time_qos_default          Uint64_t
	Fri_cpu_time_qos_maintenance      Uint64_t
	Fri_cpu_time_qos_background       Uint64_t
	Fri_cpu_time_qos_utility          Uint64_t
	Fri_cpu_time_qos_legacy           Uint64_t
	Fri_cpu_time_qos_user_initiated   Uint64_t
	Fri_cpu_time_qos_user_interactive Uint64_t
	Fri_billed_system_time            Uint64_t
	Fri_serviced_system_time          Uint64_t
	Fri_logical_writes                Uint64_t
	Fri_lifetime_max_phys_footprint   Uint64_t
	Fri_instructions                  Uint64_t
	Fri_cycles                        Uint64_t
	Fri_billed_energy                 Uint64_t
	Fri_serviced_energy               Uint64_t
	Fri_interval_max_phys_footprint   Uint64_t
	Fri_runnable_time                 Uint64_t
} /* resource.h:288:1 */

type Rusage_info_v5 = struct {
	Fri_uuid                          [16]Uint8_t
	Fri_user_time                     Uint64_t
	Fri_system_time                   Uint64_t
	Fri_pkg_idle_wkups                Uint64_t
	Fri_interrupt_wkups               Uint64_t
	Fri_pageins                       Uint64_t
	Fri_wired_size                    Uint64_t
	Fri_resident_size                 Uint64_t
	Fri_phys_footprint                Uint64_t
	Fri_proc_start_abstime            Uint64_t
	Fri_proc_exit_abstime             Uint64_t
	Fri_child_user_time               Uint64_t
	Fri_child_system_time             Uint64_t
	Fri_child_pkg_idle_wkups          Uint64_t
	Fri_child_interrupt_wkups         Uint64_t
	Fri_child_pageins                 Uint64_t
	Fri_child_elapsed_abstime         Uint64_t
	Fri_diskio_bytesread              Uint64_t
	Fri_diskio_byteswritten           Uint64_t
	Fri_cpu_time_qos_default          Uint64_t
	Fri_cpu_time_qos_maintenance      Uint64_t
	Fri_cpu_time_qos_background       Uint64_t
	Fri_cpu_time_qos_utility          Uint64_t
	Fri_cpu_time_qos_legacy           Uint64_t
	Fri_cpu_time_qos_user_initiated   Uint64_t
	Fri_cpu_time_qos_user_interactive Uint64_t
	Fri_billed_system_time            Uint64_t
	Fri_serviced_system_time          Uint64_t
	Fri_logical_writes                Uint64_t
	Fri_lifetime_max_phys_footprint   Uint64_t
	Fri_instructions                  Uint64_t
	Fri_cycles                        Uint64_t
	Fri_billed_energy                 Uint64_t
	Fri_serviced_energy               Uint64_t
	Fri_interval_max_phys_footprint   Uint64_t
	Fri_runnable_time                 Uint64_t
	Fri_flags                         Uint64_t
} /* resource.h:327:1 */

type Rusage_info_current = Rusage_info_v5 /* resource.h:367:31 */

// ****
//
// RESOURCE LIMITS

// Symbolic constants for resource limits; since all limits are representable
// as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
// RLIM_INFINITY.

// Possible values of the first parameter to getrlimit()/setrlimit(), to
// indicate for which resource the operation is being performed.

// A structure representing a resource limit.  The address of an instance
// of this structure is the second parameter to getrlimit()/setrlimit().
type Rlimit = struct {
	Frlim_cur Rlim_t
	Frlim_max Rlim_t
} /* resource.h:411:1 */

// proc_rlimit_control()
//
// Resource limit flavors

// Flags for wakeups monitor control.

// Flags for CPU usage monitor control.

// Flags for memory footprint interval tracking.

type Proc_rlimit_control_wakeupmon = struct {
	Fwm_flags Uint32_t
	Fwm_rate  Int32_t
} /* resource.h:446:1 */

// Option bits for the third argument of wait4.  WNOHANG causes the
// wait to not hang if there are no stopped or terminated processes, rather
// returning an error indication in this case (pid==0).  WUNTRACED
// indicates that the caller should receive status about untraced children
// which stop due to signals.  If children are stopped and a wait without
// this option is done, it is as though they were still running... nothing
// about them is returned.

// Macros to test the exit status returned by wait
// and extract the relevant values.

// These macros are permited, as they are in the implementation namespace

// [XSI] The <sys/wait.h> header shall define the following macros for
// analysis of process status values
// 0x13 == SIGCONT

// [XSI] The following symbolic constants shall be defined as possible
// values for the fourth argument to waitid().
// WNOHANG already defined for wait4()
// WUNTRACED defined for wait4() but not for waitid()
// waitid() parameter

// POSIX extensions and 4.2/4.3 compatability:

// Tokens for special values of the "pid" parameter to wait4.

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Deprecated:
// Structure of the information in the status word returned by wait4.
// If w_stopval==_WSTOPPED, then the second structure describes
// the information returned, else the first.
type Wait = struct{ Fw_status int32 } /* wait.h:194:1 */

// built-in for gcc

// built-in for gcc 3

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// _GCC_SIZE_T
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Ct_rune_t = X__darwin_ct_rune_t /* _ct_rune_t.h:32:28 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Rune_t = X__darwin_rune_t /* _rune_t.h:31:25 */

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// wchar_t is a built-in type in C++

type Div_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:86:3 */

type Ldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:91:3 */

type Lldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:97:3 */ // getsubopt(3) external variable
// valloc is now declared in _malloc.h

// Poison the following routines if -fshort-wchar is set

// since "static" is used to mean two completely different things in C, we
//    define "local" for the non-static meaning of "static", for readability
//    (compile with -Dlocal if your debugger can't find static symbols)

type Uch = uint8  /* zutil.h:43:24 */
type Uchf = Uch   /* zutil.h:44:17 */
type Ush = uint16 /* zutil.h:45:24 */
type Ushf = Ush   /* zutil.h:46:17 */
type Ulg = uint64 /* zutil.h:47:24 */

// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1

// use NO_DIVIDE if your processor does not do division in hardware --
//    try it both ways to see which is faster

// =========================================================================
func Xadler32_z(tls *libc.TLS, adler ULong, buf uintptr, len Z_size_t) ULong { /* adler32.c:63:15: */
	var sum2 uint64
	var n uint32

	// split Adler-32 into component sums
	sum2 = ((adler >> 16) & uint64(0xffff))
	adler = adler & (uint64(0xffff))

	// in case user likes doing a byte at a time, keep it fast
	if len == uint64(1) {
		adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(buf))))
		if adler >= BASE {
			adler = adler - (BASE)
		}
		sum2 = sum2 + (adler)
		if sum2 >= BASE {
			sum2 = sum2 - (BASE)
		}
		return (adler | (sum2 << 16))
	}

	// initial Adler-32 value (deferred check for len == 1 speed)
	if buf == Z_NULL {
		return uint64(1)
	}

	// in case short lengths are provided, keep it somewhat fast
	if len < uint64(16) {
		for libc.PostDecUint64(&len, 1) != 0 {
			adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))
			sum2 = sum2 + (adler)
		}
		if adler >= BASE {
			adler = adler - (BASE)
		}
		sum2 = sum2 % (BASE) // only added so many BASE's
		return (adler | (sum2 << 16))
	}

	// do length NMAX blocks -- requires just one modulo operation
	for len >= NMAX {
		len = len - (NMAX)
		n = (uint32(NMAX / 16)) // NMAX is divisible by 16
		for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf)))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 1))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 2))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 3))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 4))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 5))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 6))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 7))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 8))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 9))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 10))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 11))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 12))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 13))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 14))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 15))))
				sum2 = sum2 + (adler)
			}

			// 16 sums unrolled
			buf += uintptr(16)
		}
		adler = adler % (BASE)
		sum2 = sum2 % (BASE)
	}

	// do remaining bytes (less than NMAX, still just one modulo)
	if len != 0 { // avoid modulos if none remaining
		for len >= uint64(16) {
			len = len - (uint64(16))
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf)))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 1))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 2))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 3))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 4))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 5))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 6))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 7))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 8))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 9))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 10))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 11))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 12))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 13))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 14))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 15))))
				sum2 = sum2 + (adler)
			}

			buf += uintptr(16)
		}
		for libc.PostDecUint64(&len, 1) != 0 {
			adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))
			sum2 = sum2 + (adler)
		}
		adler = adler % (BASE)
		sum2 = sum2 % (BASE)
	}

	// return recombined sums
	return (adler | (sum2 << 16))
}

// =========================================================================
func Xadler32(tls *libc.TLS, adler ULong, buf uintptr, len UInt) ULong { /* adler32.c:134:15: */
	return Xadler32_z(tls, adler, buf, uint64(len))
}

// =========================================================================
func adler32_combine_(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off_t) ULong { /* adler32.c:143:13: */
	var sum1 uint64
	var sum2 uint64
	var rem uint32

	// for negative len, return invalid adler32 as a clue for debugging
	if len2 < int64(0) {
		return 0xffffffff
	}

	// the derivation of this formula is left as an exercise for the reader
	len2 = len2 % (BASE) // assumes len2 >= 0
	rem = uint32(len2)
	sum1 = (adler1 & uint64(0xffff))
	sum2 = (uint64(rem) * sum1)
	sum2 = sum2 % (BASE)
	sum1 = sum1 + (((adler2 & uint64(0xffff)) + BASE) - uint64(1))
	sum2 = sum2 + (((((adler1 >> 16) & uint64(0xffff)) + ((adler2 >> 16) & uint64(0xffff))) + BASE) - ULong(rem))
	if sum1 >= BASE {
		sum1 = sum1 - (BASE)
	}
	if sum1 >= BASE {
		sum1 = sum1 - (BASE)
	}
	if sum2 >= (uint64(BASE) << 1) {
		sum2 = sum2 - (uint64(BASE) << 1)
	}
	if sum2 >= BASE {
		sum2 = sum2 - (BASE)
	}
	return (sum1 | (sum2 << 16))
}

// =========================================================================
func Xadler32_combine(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off_t) ULong { /* adler32.c:172:15: */
	return adler32_combine_(tls, adler1, adler2, len2)
}

func Xadler32_combine64(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off_t) ULong { /* adler32.c:180:15: */
	return adler32_combine_(tls, adler1, adler2, len2)
}

// ===========================================================================
//      Compresses the source buffer into the destination buffer. The level
//    parameter has the same meaning as in deflateInit.  sourceLen is the byte
//    length of the source buffer. Upon entry, destLen is the total size of the
//    destination buffer, which must be at least 0.1% larger than sourceLen plus
//    12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
//
//      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
//    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
//    Z_STREAM_ERROR if the level parameter is invalid.
func Xcompress2(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong, level int32) int32 { /* compress.c:22:13: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var stream Z_stream at bp, 112

	var err int32
	var max UInt = libc.Uint32(libc.Uint32FromInt32(-1))
	var left ULong

	left = *(*ULongf)(unsafe.Pointer(destLen))
	*(*ULongf)(unsafe.Pointer(destLen)) = uint64(0)

	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fzalloc = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fzfree = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fopaque = uintptr(0)

	err = XdeflateInit_(tls, bp /* &stream */, level, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
	if err != Z_OK {
		return err
	}

	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fnext_out = dest
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out = UInt(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fnext_in = source
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in = UInt(0)

	for ok := true; ok; ok = (err == Z_OK) {
		if (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out = func() uint32 {
				if left > ULong(max) {
					return max
				}
				return UInt(left)
			}()
			left = left - (ULong((*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out))
		}
		if (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in = func() uint32 {
				if sourceLen > ULong(max) {
					return max
				}
				return UInt(sourceLen)
			}()
			sourceLen = sourceLen - (ULong((*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in))
		}
		err = Xdeflate(tls, bp /* &stream */, func() int32 {
			if sourceLen != 0 {
				return Z_NO_FLUSH
			}
			return Z_FINISH
		}())
	}

	*(*ULongf)(unsafe.Pointer(destLen)) = (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Ftotal_out
	XdeflateEnd(tls, bp /* &stream */)
	if err == Z_STREAM_END {
		return Z_OK
	}
	return err
}

// ===========================================================================
func Xcompress(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong) int32 { /* compress.c:68:13: */
	return Xcompress2(tls, dest, destLen, source, sourceLen, -1)
}

// ===========================================================================
//      If the default memLevel or windowBits for deflateInit() is changed, then
//    this function needs to be updated.
//
func XcompressBound(tls *libc.TLS, sourceLen ULong) ULong { /* compress.c:81:15: */
	return ((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + uint64(13))
}

// ========================================================================
// Tables of CRC-32s of all single-byte values, made by make_crc_table().
// crc32.h -- tables for rapid CRC calculation
// Generated automatically by crc32.c

var crc_table = [8][256]Z_crc_t{
	{
		uint32(0x00000000), uint32(0x77073096), uint32(0xee0e612c), uint32(0x990951ba), uint32(0x076dc419),
		uint32(0x706af48f), uint32(0xe963a535), uint32(0x9e6495a3), uint32(0x0edb8832), uint32(0x79dcb8a4),
		uint32(0xe0d5e91e), uint32(0x97d2d988), uint32(0x09b64c2b), uint32(0x7eb17cbd), uint32(0xe7b82d07),
		uint32(0x90bf1d91), uint32(0x1db71064), uint32(0x6ab020f2), uint32(0xf3b97148), uint32(0x84be41de),
		uint32(0x1adad47d), uint32(0x6ddde4eb), uint32(0xf4d4b551), uint32(0x83d385c7), uint32(0x136c9856),
		uint32(0x646ba8c0), uint32(0xfd62f97a), uint32(0x8a65c9ec), uint32(0x14015c4f), uint32(0x63066cd9),
		uint32(0xfa0f3d63), uint32(0x8d080df5), uint32(0x3b6e20c8), uint32(0x4c69105e), uint32(0xd56041e4),
		uint32(0xa2677172), uint32(0x3c03e4d1), uint32(0x4b04d447), uint32(0xd20d85fd), uint32(0xa50ab56b),
		uint32(0x35b5a8fa), uint32(0x42b2986c), uint32(0xdbbbc9d6), uint32(0xacbcf940), uint32(0x32d86ce3),
		uint32(0x45df5c75), uint32(0xdcd60dcf), uint32(0xabd13d59), uint32(0x26d930ac), uint32(0x51de003a),
		uint32(0xc8d75180), uint32(0xbfd06116), uint32(0x21b4f4b5), uint32(0x56b3c423), uint32(0xcfba9599),
		uint32(0xb8bda50f), uint32(0x2802b89e), uint32(0x5f058808), uint32(0xc60cd9b2), uint32(0xb10be924),
		uint32(0x2f6f7c87), uint32(0x58684c11), uint32(0xc1611dab), uint32(0xb6662d3d), uint32(0x76dc4190),
		uint32(0x01db7106), uint32(0x98d220bc), uint32(0xefd5102a), uint32(0x71b18589), uint32(0x06b6b51f),
		uint32(0x9fbfe4a5), uint32(0xe8b8d433), uint32(0x7807c9a2), uint32(0x0f00f934), uint32(0x9609a88e),
		uint32(0xe10e9818), uint32(0x7f6a0dbb), uint32(0x086d3d2d), uint32(0x91646c97), uint32(0xe6635c01),
		uint32(0x6b6b51f4), uint32(0x1c6c6162), uint32(0x856530d8), uint32(0xf262004e), uint32(0x6c0695ed),
		uint32(0x1b01a57b), uint32(0x8208f4c1), uint32(0xf50fc457), uint32(0x65b0d9c6), uint32(0x12b7e950),
		uint32(0x8bbeb8ea), uint32(0xfcb9887c), uint32(0x62dd1ddf), uint32(0x15da2d49), uint32(0x8cd37cf3),
		uint32(0xfbd44c65), uint32(0x4db26158), uint32(0x3ab551ce), uint32(0xa3bc0074), uint32(0xd4bb30e2),
		uint32(0x4adfa541), uint32(0x3dd895d7), uint32(0xa4d1c46d), uint32(0xd3d6f4fb), uint32(0x4369e96a),
		uint32(0x346ed9fc), uint32(0xad678846), uint32(0xda60b8d0), uint32(0x44042d73), uint32(0x33031de5),
		uint32(0xaa0a4c5f), uint32(0xdd0d7cc9), uint32(0x5005713c), uint32(0x270241aa), uint32(0xbe0b1010),
		uint32(0xc90c2086), uint32(0x5768b525), uint32(0x206f85b3), uint32(0xb966d409), uint32(0xce61e49f),
		uint32(0x5edef90e), uint32(0x29d9c998), uint32(0xb0d09822), uint32(0xc7d7a8b4), uint32(0x59b33d17),
		uint32(0x2eb40d81), uint32(0xb7bd5c3b), uint32(0xc0ba6cad), uint32(0xedb88320), uint32(0x9abfb3b6),
		uint32(0x03b6e20c), uint32(0x74b1d29a), uint32(0xead54739), uint32(0x9dd277af), uint32(0x04db2615),
		uint32(0x73dc1683), uint32(0xe3630b12), uint32(0x94643b84), uint32(0x0d6d6a3e), uint32(0x7a6a5aa8),
		uint32(0xe40ecf0b), uint32(0x9309ff9d), uint32(0x0a00ae27), uint32(0x7d079eb1), uint32(0xf00f9344),
		uint32(0x8708a3d2), uint32(0x1e01f268), uint32(0x6906c2fe), uint32(0xf762575d), uint32(0x806567cb),
		uint32(0x196c3671), uint32(0x6e6b06e7), uint32(0xfed41b76), uint32(0x89d32be0), uint32(0x10da7a5a),
		uint32(0x67dd4acc), uint32(0xf9b9df6f), uint32(0x8ebeeff9), uint32(0x17b7be43), uint32(0x60b08ed5),
		uint32(0xd6d6a3e8), uint32(0xa1d1937e), uint32(0x38d8c2c4), uint32(0x4fdff252), uint32(0xd1bb67f1),
		uint32(0xa6bc5767), uint32(0x3fb506dd), uint32(0x48b2364b), uint32(0xd80d2bda), uint32(0xaf0a1b4c),
		uint32(0x36034af6), uint32(0x41047a60), uint32(0xdf60efc3), uint32(0xa867df55), uint32(0x316e8eef),
		uint32(0x4669be79), uint32(0xcb61b38c), uint32(0xbc66831a), uint32(0x256fd2a0), uint32(0x5268e236),
		uint32(0xcc0c7795), uint32(0xbb0b4703), uint32(0x220216b9), uint32(0x5505262f), uint32(0xc5ba3bbe),
		uint32(0xb2bd0b28), uint32(0x2bb45a92), uint32(0x5cb36a04), uint32(0xc2d7ffa7), uint32(0xb5d0cf31),
		uint32(0x2cd99e8b), uint32(0x5bdeae1d), uint32(0x9b64c2b0), uint32(0xec63f226), uint32(0x756aa39c),
		uint32(0x026d930a), uint32(0x9c0906a9), uint32(0xeb0e363f), uint32(0x72076785), uint32(0x05005713),
		uint32(0x95bf4a82), uint32(0xe2b87a14), uint32(0x7bb12bae), uint32(0x0cb61b38), uint32(0x92d28e9b),
		uint32(0xe5d5be0d), uint32(0x7cdcefb7), uint32(0x0bdbdf21), uint32(0x86d3d2d4), uint32(0xf1d4e242),
		uint32(0x68ddb3f8), uint32(0x1fda836e), uint32(0x81be16cd), uint32(0xf6b9265b), uint32(0x6fb077e1),
		uint32(0x18b74777), uint32(0x88085ae6), uint32(0xff0f6a70), uint32(0x66063bca), uint32(0x11010b5c),
		uint32(0x8f659eff), uint32(0xf862ae69), uint32(0x616bffd3), uint32(0x166ccf45), uint32(0xa00ae278),
		uint32(0xd70dd2ee), uint32(0x4e048354), uint32(0x3903b3c2), uint32(0xa7672661), uint32(0xd06016f7),
		uint32(0x4969474d), uint32(0x3e6e77db), uint32(0xaed16a4a), uint32(0xd9d65adc), uint32(0x40df0b66),
		uint32(0x37d83bf0), uint32(0xa9bcae53), uint32(0xdebb9ec5), uint32(0x47b2cf7f), uint32(0x30b5ffe9),
		uint32(0xbdbdf21c), uint32(0xcabac28a), uint32(0x53b39330), uint32(0x24b4a3a6), uint32(0xbad03605),
		uint32(0xcdd70693), uint32(0x54de5729), uint32(0x23d967bf), uint32(0xb3667a2e), uint32(0xc4614ab8),
		uint32(0x5d681b02), uint32(0x2a6f2b94), uint32(0xb40bbe37), uint32(0xc30c8ea1), uint32(0x5a05df1b),
		uint32(0x2d02ef8d),
	},
	{
		uint32(0x00000000), uint32(0x191b3141), uint32(0x32366282), uint32(0x2b2d53c3), uint32(0x646cc504),
		uint32(0x7d77f445), uint32(0x565aa786), uint32(0x4f4196c7), uint32(0xc8d98a08), uint32(0xd1c2bb49),
		uint32(0xfaefe88a), uint32(0xe3f4d9cb), uint32(0xacb54f0c), uint32(0xb5ae7e4d), uint32(0x9e832d8e),
		uint32(0x87981ccf), uint32(0x4ac21251), uint32(0x53d92310), uint32(0x78f470d3), uint32(0x61ef4192),
		uint32(0x2eaed755), uint32(0x37b5e614), uint32(0x1c98b5d7), uint32(0x05838496), uint32(0x821b9859),
		uint32(0x9b00a918), uint32(0xb02dfadb), uint32(0xa936cb9a), uint32(0xe6775d5d), uint32(0xff6c6c1c),
		uint32(0xd4413fdf), uint32(0xcd5a0e9e), uint32(0x958424a2), uint32(0x8c9f15e3), uint32(0xa7b24620),
		uint32(0xbea97761), uint32(0xf1e8e1a6), uint32(0xe8f3d0e7), uint32(0xc3de8324), uint32(0xdac5b265),
		uint32(0x5d5daeaa), uint32(0x44469feb), uint32(0x6f6bcc28), uint32(0x7670fd69), uint32(0x39316bae),
		uint32(0x202a5aef), uint32(0x0b07092c), uint32(0x121c386d), uint32(0xdf4636f3), uint32(0xc65d07b2),
		uint32(0xed705471), uint32(0xf46b6530), uint32(0xbb2af3f7), uint32(0xa231c2b6), uint32(0x891c9175),
		uint32(0x9007a034), uint32(0x179fbcfb), uint32(0x0e848dba), uint32(0x25a9de79), uint32(0x3cb2ef38),
		uint32(0x73f379ff), uint32(0x6ae848be), uint32(0x41c51b7d), uint32(0x58de2a3c), uint32(0xf0794f05),
		uint32(0xe9627e44), uint32(0xc24f2d87), uint32(0xdb541cc6), uint32(0x94158a01), uint32(0x8d0ebb40),
		uint32(0xa623e883), uint32(0xbf38d9c2), uint32(0x38a0c50d), uint32(0x21bbf44c), uint32(0x0a96a78f),
		uint32(0x138d96ce), uint32(0x5ccc0009), uint32(0x45d73148), uint32(0x6efa628b), uint32(0x77e153ca),
		uint32(0xbabb5d54), uint32(0xa3a06c15), uint32(0x888d3fd6), uint32(0x91960e97), uint32(0xded79850),
		uint32(0xc7cca911), uint32(0xece1fad2), uint32(0xf5facb93), uint32(0x7262d75c), uint32(0x6b79e61d),
		uint32(0x4054b5de), uint32(0x594f849f), uint32(0x160e1258), uint32(0x0f152319), uint32(0x243870da),
		uint32(0x3d23419b), uint32(0x65fd6ba7), uint32(0x7ce65ae6), uint32(0x57cb0925), uint32(0x4ed03864),
		uint32(0x0191aea3), uint32(0x188a9fe2), uint32(0x33a7cc21), uint32(0x2abcfd60), uint32(0xad24e1af),
		uint32(0xb43fd0ee), uint32(0x9f12832d), uint32(0x8609b26c), uint32(0xc94824ab), uint32(0xd05315ea),
		uint32(0xfb7e4629), uint32(0xe2657768), uint32(0x2f3f79f6), uint32(0x362448b7), uint32(0x1d091b74),
		uint32(0x04122a35), uint32(0x4b53bcf2), uint32(0x52488db3), uint32(0x7965de70), uint32(0x607eef31),
		uint32(0xe7e6f3fe), uint32(0xfefdc2bf), uint32(0xd5d0917c), uint32(0xcccba03d), uint32(0x838a36fa),
		uint32(0x9a9107bb), uint32(0xb1bc5478), uint32(0xa8a76539), uint32(0x3b83984b), uint32(0x2298a90a),
		uint32(0x09b5fac9), uint32(0x10aecb88), uint32(0x5fef5d4f), uint32(0x46f46c0e), uint32(0x6dd93fcd),
		uint32(0x74c20e8c), uint32(0xf35a1243), uint32(0xea412302), uint32(0xc16c70c1), uint32(0xd8774180),
		uint32(0x9736d747), uint32(0x8e2de606), uint32(0xa500b5c5), uint32(0xbc1b8484), uint32(0x71418a1a),
		uint32(0x685abb5b), uint32(0x4377e898), uint32(0x5a6cd9d9), uint32(0x152d4f1e), uint32(0x0c367e5f),
		uint32(0x271b2d9c), uint32(0x3e001cdd), uint32(0xb9980012), uint32(0xa0833153), uint32(0x8bae6290),
		uint32(0x92b553d1), uint32(0xddf4c516), uint32(0xc4eff457), uint32(0xefc2a794), uint32(0xf6d996d5),
		uint32(0xae07bce9), uint32(0xb71c8da8), uint32(0x9c31de6b), uint32(0x852aef2a), uint32(0xca6b79ed),
		uint32(0xd37048ac), uint32(0xf85d1b6f), uint32(0xe1462a2e), uint32(0x66de36e1), uint32(0x7fc507a0),
		uint32(0x54e85463), uint32(0x4df36522), uint32(0x02b2f3e5), uint32(0x1ba9c2a4), uint32(0x30849167),
		uint32(0x299fa026), uint32(0xe4c5aeb8), uint32(0xfdde9ff9), uint32(0xd6f3cc3a), uint32(0xcfe8fd7b),
		uint32(0x80a96bbc), uint32(0x99b25afd), uint32(0xb29f093e), uint32(0xab84387f), uint32(0x2c1c24b0),
		uint32(0x350715f1), uint32(0x1e2a4632), uint32(0x07317773), uint32(0x4870e1b4), uint32(0x516bd0f5),
		uint32(0x7a468336), uint32(0x635db277), uint32(0xcbfad74e), uint32(0xd2e1e60f), uint32(0xf9ccb5cc),
		uint32(0xe0d7848d), uint32(0xaf96124a), uint32(0xb68d230b), uint32(0x9da070c8), uint32(0x84bb4189),
		uint32(0x03235d46), uint32(0x1a386c07), uint32(0x31153fc4), uint32(0x280e0e85), uint32(0x674f9842),
		uint32(0x7e54a903), uint32(0x5579fac0), uint32(0x4c62cb81), uint32(0x8138c51f), uint32(0x9823f45e),
		uint32(0xb30ea79d), uint32(0xaa1596dc), uint32(0xe554001b), uint32(0xfc4f315a), uint32(0xd7626299),
		uint32(0xce7953d8), uint32(0x49e14f17), uint32(0x50fa7e56), uint32(0x7bd72d95), uint32(0x62cc1cd4),
		uint32(0x2d8d8a13), uint32(0x3496bb52), uint32(0x1fbbe891), uint32(0x06a0d9d0), uint32(0x5e7ef3ec),
		uint32(0x4765c2ad), uint32(0x6c48916e), uint32(0x7553a02f), uint32(0x3a1236e8), uint32(0x230907a9),
		uint32(0x0824546a), uint32(0x113f652b), uint32(0x96a779e4), uint32(0x8fbc48a5), uint32(0xa4911b66),
		uint32(0xbd8a2a27), uint32(0xf2cbbce0), uint32(0xebd08da1), uint32(0xc0fdde62), uint32(0xd9e6ef23),
		uint32(0x14bce1bd), uint32(0x0da7d0fc), uint32(0x268a833f), uint32(0x3f91b27e), uint32(0x70d024b9),
		uint32(0x69cb15f8), uint32(0x42e6463b), uint32(0x5bfd777a), uint32(0xdc656bb5), uint32(0xc57e5af4),
		uint32(0xee530937), uint32(0xf7483876), uint32(0xb809aeb1), uint32(0xa1129ff0), uint32(0x8a3fcc33),
		uint32(0x9324fd72),
	},
	{
		uint32(0x00000000), uint32(0x01c26a37), uint32(0x0384d46e), uint32(0x0246be59), uint32(0x0709a8dc),
		uint32(0x06cbc2eb), uint32(0x048d7cb2), uint32(0x054f1685), uint32(0x0e1351b8), uint32(0x0fd13b8f),
		uint32(0x0d9785d6), uint32(0x0c55efe1), uint32(0x091af964), uint32(0x08d89353), uint32(0x0a9e2d0a),
		uint32(0x0b5c473d), uint32(0x1c26a370), uint32(0x1de4c947), uint32(0x1fa2771e), uint32(0x1e601d29),
		uint32(0x1b2f0bac), uint32(0x1aed619b), uint32(0x18abdfc2), uint32(0x1969b5f5), uint32(0x1235f2c8),
		uint32(0x13f798ff), uint32(0x11b126a6), uint32(0x10734c91), uint32(0x153c5a14), uint32(0x14fe3023),
		uint32(0x16b88e7a), uint32(0x177ae44d), uint32(0x384d46e0), uint32(0x398f2cd7), uint32(0x3bc9928e),
		uint32(0x3a0bf8b9), uint32(0x3f44ee3c), uint32(0x3e86840b), uint32(0x3cc03a52), uint32(0x3d025065),
		uint32(0x365e1758), uint32(0x379c7d6f), uint32(0x35dac336), uint32(0x3418a901), uint32(0x3157bf84),
		uint32(0x3095d5b3), uint32(0x32d36bea), uint32(0x331101dd), uint32(0x246be590), uint32(0x25a98fa7),
		uint32(0x27ef31fe), uint32(0x262d5bc9), uint32(0x23624d4c), uint32(0x22a0277b), uint32(0x20e69922),
		uint32(0x2124f315), uint32(0x2a78b428), uint32(0x2bbade1f), uint32(0x29fc6046), uint32(0x283e0a71),
		uint32(0x2d711cf4), uint32(0x2cb376c3), uint32(0x2ef5c89a), uint32(0x2f37a2ad), uint32(0x709a8dc0),
		uint32(0x7158e7f7), uint32(0x731e59ae), uint32(0x72dc3399), uint32(0x7793251c), uint32(0x76514f2b),
		uint32(0x7417f172), uint32(0x75d59b45), uint32(0x7e89dc78), uint32(0x7f4bb64f), uint32(0x7d0d0816),
		uint32(0x7ccf6221), uint32(0x798074a4), uint32(0x78421e93), uint32(0x7a04a0ca), uint32(0x7bc6cafd),
		uint32(0x6cbc2eb0), uint32(0x6d7e4487), uint32(0x6f38fade), uint32(0x6efa90e9), uint32(0x6bb5866c),
		uint32(0x6a77ec5b), uint32(0x68315202), uint32(0x69f33835), uint32(0x62af7f08), uint32(0x636d153f),
		uint32(0x612bab66), uint32(0x60e9c151), uint32(0x65a6d7d4), uint32(0x6464bde3), uint32(0x662203ba),
		uint32(0x67e0698d), uint32(0x48d7cb20), uint32(0x4915a117), uint32(0x4b531f4e), uint32(0x4a917579),
		uint32(0x4fde63fc), uint32(0x4e1c09cb), uint32(0x4c5ab792), uint32(0x4d98dda5), uint32(0x46c49a98),
		uint32(0x4706f0af), uint32(0x45404ef6), uint32(0x448224c1), uint32(0x41cd3244), uint32(0x400f5873),
		uint32(0x4249e62a), uint32(0x438b8c1d), uint32(0x54f16850), uint32(0x55330267), uint32(0x5775bc3e),
		uint32(0x56b7d609), uint32(0x53f8c08c), uint32(0x523aaabb), uint32(0x507c14e2), uint32(0x51be7ed5),
		uint32(0x5ae239e8), uint32(0x5b2053df), uint32(0x5966ed86), uint32(0x58a487b1), uint32(0x5deb9134),
		uint32(0x5c29fb03), uint32(0x5e6f455a), uint32(0x5fad2f6d), uint32(0xe1351b80), uint32(0xe0f771b7),
		uint32(0xe2b1cfee), uint32(0xe373a5d9), uint32(0xe63cb35c), uint32(0xe7fed96b), uint32(0xe5b86732),
		uint32(0xe47a0d05), uint32(0xef264a38), uint32(0xeee4200f), uint32(0xeca29e56), uint32(0xed60f461),
		uint32(0xe82fe2e4), uint32(0xe9ed88d3), uint32(0xebab368a), uint32(0xea695cbd), uint32(0xfd13b8f0),
		uint32(0xfcd1d2c7), uint32(0xfe976c9e), uint32(0xff5506a9), uint32(0xfa1a102c), uint32(0xfbd87a1b),
		uint32(0xf99ec442), uint32(0xf85cae75), uint32(0xf300e948), uint32(0xf2c2837f), uint32(0xf0843d26),
		uint32(0xf1465711), uint32(0xf4094194), uint32(0xf5cb2ba3), uint32(0xf78d95fa), uint32(0xf64fffcd),
		uint32(0xd9785d60), uint32(0xd8ba3757), uint32(0xdafc890e), uint32(0xdb3ee339), uint32(0xde71f5bc),
		uint32(0xdfb39f8b), uint32(0xddf521d2), uint32(0xdc374be5), uint32(0xd76b0cd8), uint32(0xd6a966ef),
		uint32(0xd4efd8b6), uint32(0xd52db281), uint32(0xd062a404), uint32(0xd1a0ce33), uint32(0xd3e6706a),
		uint32(0xd2241a5d), uint32(0xc55efe10), uint32(0xc49c9427), uint32(0xc6da2a7e), uint32(0xc7184049),
		uint32(0xc25756cc), uint32(0xc3953cfb), uint32(0xc1d382a2), uint32(0xc011e895), uint32(0xcb4dafa8),
		uint32(0xca8fc59f), uint32(0xc8c97bc6), uint32(0xc90b11f1), uint32(0xcc440774), uint32(0xcd866d43),
		uint32(0xcfc0d31a), uint32(0xce02b92d), uint32(0x91af9640), uint32(0x906dfc77), uint32(0x922b422e),
		uint32(0x93e92819), uint32(0x96a63e9c), uint32(0x976454ab), uint32(0x9522eaf2), uint32(0x94e080c5),
		uint32(0x9fbcc7f8), uint32(0x9e7eadcf), uint32(0x9c381396), uint32(0x9dfa79a1), uint32(0x98b56f24),
		uint32(0x99770513), uint32(0x9b31bb4a), uint32(0x9af3d17d), uint32(0x8d893530), uint32(0x8c4b5f07),
		uint32(0x8e0de15e), uint32(0x8fcf8b69), uint32(0x8a809dec), uint32(0x8b42f7db), uint32(0x89044982),
		uint32(0x88c623b5), uint32(0x839a6488), uint32(0x82580ebf), uint32(0x801eb0e6), uint32(0x81dcdad1),
		uint32(0x8493cc54), uint32(0x8551a663), uint32(0x8717183a), uint32(0x86d5720d), uint32(0xa9e2d0a0),
		uint32(0xa820ba97), uint32(0xaa6604ce), uint32(0xaba46ef9), uint32(0xaeeb787c), uint32(0xaf29124b),
		uint32(0xad6fac12), uint32(0xacadc625), uint32(0xa7f18118), uint32(0xa633eb2f), uint32(0xa4755576),
		uint32(0xa5b73f41), uint32(0xa0f829c4), uint32(0xa13a43f3), uint32(0xa37cfdaa), uint32(0xa2be979d),
		uint32(0xb5c473d0), uint32(0xb40619e7), uint32(0xb640a7be), uint32(0xb782cd89), uint32(0xb2cddb0c),
		uint32(0xb30fb13b), uint32(0xb1490f62), uint32(0xb08b6555), uint32(0xbbd72268), uint32(0xba15485f),
		uint32(0xb853f606), uint32(0xb9919c31), uint32(0xbcde8ab4), uint32(0xbd1ce083), uint32(0xbf5a5eda),
		uint32(0xbe9834ed),
	},
	{
		uint32(0x00000000), uint32(0xb8bc6765), uint32(0xaa09c88b), uint32(0x12b5afee), uint32(0x8f629757),
		uint32(0x37def032), uint32(0x256b5fdc), uint32(0x9dd738b9), uint32(0xc5b428ef), uint32(0x7d084f8a),
		uint32(0x6fbde064), uint32(0xd7018701), uint32(0x4ad6bfb8), uint32(0xf26ad8dd), uint32(0xe0df7733),
		uint32(0x58631056), uint32(0x5019579f), uint32(0xe8a530fa), uint32(0xfa109f14), uint32(0x42acf871),
		uint32(0xdf7bc0c8), uint32(0x67c7a7ad), uint32(0x75720843), uint32(0xcdce6f26), uint32(0x95ad7f70),
		uint32(0x2d111815), uint32(0x3fa4b7fb), uint32(0x8718d09e), uint32(0x1acfe827), uint32(0xa2738f42),
		uint32(0xb0c620ac), uint32(0x087a47c9), uint32(0xa032af3e), uint32(0x188ec85b), uint32(0x0a3b67b5),
		uint32(0xb28700d0), uint32(0x2f503869), uint32(0x97ec5f0c), uint32(0x8559f0e2), uint32(0x3de59787),
		uint32(0x658687d1), uint32(0xdd3ae0b4), uint32(0xcf8f4f5a), uint32(0x7733283f), uint32(0xeae41086),
		uint32(0x525877e3), uint32(0x40edd80d), uint32(0xf851bf68), uint32(0xf02bf8a1), uint32(0x48979fc4),
		uint32(0x5a22302a), uint32(0xe29e574f), uint32(0x7f496ff6), uint32(0xc7f50893), uint32(0xd540a77d),
		uint32(0x6dfcc018), uint32(0x359fd04e), uint32(0x8d23b72b), uint32(0x9f9618c5), uint32(0x272a7fa0),
		uint32(0xbafd4719), uint32(0x0241207c), uint32(0x10f48f92), uint32(0xa848e8f7), uint32(0x9b14583d),
		uint32(0x23a83f58), uint32(0x311d90b6), uint32(0x89a1f7d3), uint32(0x1476cf6a), uint32(0xaccaa80f),
		uint32(0xbe7f07e1), uint32(0x06c36084), uint32(0x5ea070d2), uint32(0xe61c17b7), uint32(0xf4a9b859),
		uint32(0x4c15df3c), uint32(0xd1c2e785), uint32(0x697e80e0), uint32(0x7bcb2f0e), uint32(0xc377486b),
		uint32(0xcb0d0fa2), uint32(0x73b168c7), uint32(0x6104c729), uint32(0xd9b8a04c), uint32(0x446f98f5),
		uint32(0xfcd3ff90), uint32(0xee66507e), uint32(0x56da371b), uint32(0x0eb9274d), uint32(0xb6054028),
		uint32(0xa4b0efc6), uint32(0x1c0c88a3), uint32(0x81dbb01a), uint32(0x3967d77f), uint32(0x2bd27891),
		uint32(0x936e1ff4), uint32(0x3b26f703), uint32(0x839a9066), uint32(0x912f3f88), uint32(0x299358ed),
		uint32(0xb4446054), uint32(0x0cf80731), uint32(0x1e4da8df), uint32(0xa6f1cfba), uint32(0xfe92dfec),
		uint32(0x462eb889), uint32(0x549b1767), uint32(0xec277002), uint32(0x71f048bb), uint32(0xc94c2fde),
		uint32(0xdbf98030), uint32(0x6345e755), uint32(0x6b3fa09c), uint32(0xd383c7f9), uint32(0xc1366817),
		uint32(0x798a0f72), uint32(0xe45d37cb), uint32(0x5ce150ae), uint32(0x4e54ff40), uint32(0xf6e89825),
		uint32(0xae8b8873), uint32(0x1637ef16), uint32(0x048240f8), uint32(0xbc3e279d), uint32(0x21e91f24),
		uint32(0x99557841), uint32(0x8be0d7af), uint32(0x335cb0ca), uint32(0xed59b63b), uint32(0x55e5d15e),
		uint32(0x47507eb0), uint32(0xffec19d5), uint32(0x623b216c), uint32(0xda874609), uint32(0xc832e9e7),
		uint32(0x708e8e82), uint32(0x28ed9ed4), uint32(0x9051f9b1), uint32(0x82e4565f), uint32(0x3a58313a),
		uint32(0xa78f0983), uint32(0x1f336ee6), uint32(0x0d86c108), uint32(0xb53aa66d), uint32(0xbd40e1a4),
		uint32(0x05fc86c1), uint32(0x1749292f), uint32(0xaff54e4a), uint32(0x322276f3), uint32(0x8a9e1196),
		uint32(0x982bbe78), uint32(0x2097d91d), uint32(0x78f4c94b), uint32(0xc048ae2e), uint32(0xd2fd01c0),
		uint32(0x6a4166a5), uint32(0xf7965e1c), uint32(0x4f2a3979), uint32(0x5d9f9697), uint32(0xe523f1f2),
		uint32(0x4d6b1905), uint32(0xf5d77e60), uint32(0xe762d18e), uint32(0x5fdeb6eb), uint32(0xc2098e52),
		uint32(0x7ab5e937), uint32(0x680046d9), uint32(0xd0bc21bc), uint32(0x88df31ea), uint32(0x3063568f),
		uint32(0x22d6f961), uint32(0x9a6a9e04), uint32(0x07bda6bd), uint32(0xbf01c1d8), uint32(0xadb46e36),
		uint32(0x15080953), uint32(0x1d724e9a), uint32(0xa5ce29ff), uint32(0xb77b8611), uint32(0x0fc7e174),
		uint32(0x9210d9cd), uint32(0x2aacbea8), uint32(0x38191146), uint32(0x80a57623), uint32(0xd8c66675),
		uint32(0x607a0110), uint32(0x72cfaefe), uint32(0xca73c99b), uint32(0x57a4f122), uint32(0xef189647),
		uint32(0xfdad39a9), uint32(0x45115ecc), uint32(0x764dee06), uint32(0xcef18963), uint32(0xdc44268d),
		uint32(0x64f841e8), uint32(0xf92f7951), uint32(0x41931e34), uint32(0x5326b1da), uint32(0xeb9ad6bf),
		uint32(0xb3f9c6e9), uint32(0x0b45a18c), uint32(0x19f00e62), uint32(0xa14c6907), uint32(0x3c9b51be),
		uint32(0x842736db), uint32(0x96929935), uint32(0x2e2efe50), uint32(0x2654b999), uint32(0x9ee8defc),
		uint32(0x8c5d7112), uint32(0x34e11677), uint32(0xa9362ece), uint32(0x118a49ab), uint32(0x033fe645),
		uint32(0xbb838120), uint32(0xe3e09176), uint32(0x5b5cf613), uint32(0x49e959fd), uint32(0xf1553e98),
		uint32(0x6c820621), uint32(0xd43e6144), uint32(0xc68bceaa), uint32(0x7e37a9cf), uint32(0xd67f4138),
		uint32(0x6ec3265d), uint32(0x7c7689b3), uint32(0xc4caeed6), uint32(0x591dd66f), uint32(0xe1a1b10a),
		uint32(0xf3141ee4), uint32(0x4ba87981), uint32(0x13cb69d7), uint32(0xab770eb2), uint32(0xb9c2a15c),
		uint32(0x017ec639), uint32(0x9ca9fe80), uint32(0x241599e5), uint32(0x36a0360b), uint32(0x8e1c516e),
		uint32(0x866616a7), uint32(0x3eda71c2), uint32(0x2c6fde2c), uint32(0x94d3b949), uint32(0x090481f0),
		uint32(0xb1b8e695), uint32(0xa30d497b), uint32(0x1bb12e1e), uint32(0x43d23e48), uint32(0xfb6e592d),
		uint32(0xe9dbf6c3), uint32(0x516791a6), uint32(0xccb0a91f), uint32(0x740cce7a), uint32(0x66b96194),
		uint32(0xde0506f1),
	},
	{
		uint32(0x00000000), uint32(0x96300777), uint32(0x2c610eee), uint32(0xba510999), uint32(0x19c46d07),
		uint32(0x8ff46a70), uint32(0x35a563e9), uint32(0xa395649e), uint32(0x3288db0e), uint32(0xa4b8dc79),
		uint32(0x1ee9d5e0), uint32(0x88d9d297), uint32(0x2b4cb609), uint32(0xbd7cb17e), uint32(0x072db8e7),
		uint32(0x911dbf90), uint32(0x6410b71d), uint32(0xf220b06a), uint32(0x4871b9f3), uint32(0xde41be84),
		uint32(0x7dd4da1a), uint32(0xebe4dd6d), uint32(0x51b5d4f4), uint32(0xc785d383), uint32(0x56986c13),
		uint32(0xc0a86b64), uint32(0x7af962fd), uint32(0xecc9658a), uint32(0x4f5c0114), uint32(0xd96c0663),
		uint32(0x633d0ffa), uint32(0xf50d088d), uint32(0xc8206e3b), uint32(0x5e10694c), uint32(0xe44160d5),
		uint32(0x727167a2), uint32(0xd1e4033c), uint32(0x47d4044b), uint32(0xfd850dd2), uint32(0x6bb50aa5),
		uint32(0xfaa8b535), uint32(0x6c98b242), uint32(0xd6c9bbdb), uint32(0x40f9bcac), uint32(0xe36cd832),
		uint32(0x755cdf45), uint32(0xcf0dd6dc), uint32(0x593dd1ab), uint32(0xac30d926), uint32(0x3a00de51),
		uint32(0x8051d7c8), uint32(0x1661d0bf), uint32(0xb5f4b421), uint32(0x23c4b356), uint32(0x9995bacf),
		uint32(0x0fa5bdb8), uint32(0x9eb80228), uint32(0x0888055f), uint32(0xb2d90cc6), uint32(0x24e90bb1),
		uint32(0x877c6f2f), uint32(0x114c6858), uint32(0xab1d61c1), uint32(0x3d2d66b6), uint32(0x9041dc76),
		uint32(0x0671db01), uint32(0xbc20d298), uint32(0x2a10d5ef), uint32(0x8985b171), uint32(0x1fb5b606),
		uint32(0xa5e4bf9f), uint32(0x33d4b8e8), uint32(0xa2c90778), uint32(0x34f9000f), uint32(0x8ea80996),
		uint32(0x18980ee1), uint32(0xbb0d6a7f), uint32(0x2d3d6d08), uint32(0x976c6491), uint32(0x015c63e6),
		uint32(0xf4516b6b), uint32(0x62616c1c), uint32(0xd8306585), uint32(0x4e0062f2), uint32(0xed95066c),
		uint32(0x7ba5011b), uint32(0xc1f40882), uint32(0x57c40ff5), uint32(0xc6d9b065), uint32(0x50e9b712),
		uint32(0xeab8be8b), uint32(0x7c88b9fc), uint32(0xdf1ddd62), uint32(0x492dda15), uint32(0xf37cd38c),
		uint32(0x654cd4fb), uint32(0x5861b24d), uint32(0xce51b53a), uint32(0x7400bca3), uint32(0xe230bbd4),
		uint32(0x41a5df4a), uint32(0xd795d83d), uint32(0x6dc4d1a4), uint32(0xfbf4d6d3), uint32(0x6ae96943),
		uint32(0xfcd96e34), uint32(0x468867ad), uint32(0xd0b860da), uint32(0x732d0444), uint32(0xe51d0333),
		uint32(0x5f4c0aaa), uint32(0xc97c0ddd), uint32(0x3c710550), uint32(0xaa410227), uint32(0x10100bbe),
		uint32(0x86200cc9), uint32(0x25b56857), uint32(0xb3856f20), uint32(0x09d466b9), uint32(0x9fe461ce),
		uint32(0x0ef9de5e), uint32(0x98c9d929), uint32(0x2298d0b0), uint32(0xb4a8d7c7), uint32(0x173db359),
		uint32(0x810db42e), uint32(0x3b5cbdb7), uint32(0xad6cbac0), uint32(0x2083b8ed), uint32(0xb6b3bf9a),
		uint32(0x0ce2b603), uint32(0x9ad2b174), uint32(0x3947d5ea), uint32(0xaf77d29d), uint32(0x1526db04),
		uint32(0x8316dc73), uint32(0x120b63e3), uint32(0x843b6494), uint32(0x3e6a6d0d), uint32(0xa85a6a7a),
		uint32(0x0bcf0ee4), uint32(0x9dff0993), uint32(0x27ae000a), uint32(0xb19e077d), uint32(0x44930ff0),
		uint32(0xd2a30887), uint32(0x68f2011e), uint32(0xfec20669), uint32(0x5d5762f7), uint32(0xcb676580),
		uint32(0x71366c19), uint32(0xe7066b6e), uint32(0x761bd4fe), uint32(0xe02bd389), uint32(0x5a7ada10),
		uint32(0xcc4add67), uint32(0x6fdfb9f9), uint32(0xf9efbe8e), uint32(0x43beb717), uint32(0xd58eb060),
		uint32(0xe8a3d6d6), uint32(0x7e93d1a1), uint32(0xc4c2d838), uint32(0x52f2df4f), uint32(0xf167bbd1),
		uint32(0x6757bca6), uint32(0xdd06b53f), uint32(0x4b36b248), uint32(0xda2b0dd8), uint32(0x4c1b0aaf),
		uint32(0xf64a0336), uint32(0x607a0441), uint32(0xc3ef60df), uint32(0x55df67a8), uint32(0xef8e6e31),
		uint32(0x79be6946), uint32(0x8cb361cb), uint32(0x1a8366bc), uint32(0xa0d26f25), uint32(0x36e26852),
		uint32(0x95770ccc), uint32(0x03470bbb), uint32(0xb9160222), uint32(0x2f260555), uint32(0xbe3bbac5),
		uint32(0x280bbdb2), uint32(0x925ab42b), uint32(0x046ab35c), uint32(0xa7ffd7c2), uint32(0x31cfd0b5),
		uint32(0x8b9ed92c), uint32(0x1daede5b), uint32(0xb0c2649b), uint32(0x26f263ec), uint32(0x9ca36a75),
		uint32(0x0a936d02), uint32(0xa906099c), uint32(0x3f360eeb), uint32(0x85670772), uint32(0x13570005),
		uint32(0x824abf95), uint32(0x147ab8e2), uint32(0xae2bb17b), uint32(0x381bb60c), uint32(0x9b8ed292),
		uint32(0x0dbed5e5), uint32(0xb7efdc7c), uint32(0x21dfdb0b), uint32(0xd4d2d386), uint32(0x42e2d4f1),
		uint32(0xf8b3dd68), uint32(0x6e83da1f), uint32(0xcd16be81), uint32(0x5b26b9f6), uint32(0xe177b06f),
		uint32(0x7747b718), uint32(0xe65a0888), uint32(0x706a0fff), uint32(0xca3b0666), uint32(0x5c0b0111),
		uint32(0xff9e658f), uint32(0x69ae62f8), uint32(0xd3ff6b61), uint32(0x45cf6c16), uint32(0x78e20aa0),
		uint32(0xeed20dd7), uint32(0x5483044e), uint32(0xc2b30339), uint32(0x612667a7), uint32(0xf71660d0),
		uint32(0x4d476949), uint32(0xdb776e3e), uint32(0x4a6ad1ae), uint32(0xdc5ad6d9), uint32(0x660bdf40),
		uint32(0xf03bd837), uint32(0x53aebca9), uint32(0xc59ebbde), uint32(0x7fcfb247), uint32(0xe9ffb530),
		uint32(0x1cf2bdbd), uint32(0x8ac2baca), uint32(0x3093b353), uint32(0xa6a3b424), uint32(0x0536d0ba),
		uint32(0x9306d7cd), uint32(0x2957de54), uint32(0xbf67d923), uint32(0x2e7a66b3), uint32(0xb84a61c4),
		uint32(0x021b685d), uint32(0x942b6f2a), uint32(0x37be0bb4), uint32(0xa18e0cc3), uint32(0x1bdf055a),
		uint32(0x8def022d),
	},
	{
		uint32(0x00000000), uint32(0x41311b19), uint32(0x82623632), uint32(0xc3532d2b), uint32(0x04c56c64),
		uint32(0x45f4777d), uint32(0x86a75a56), uint32(0xc796414f), uint32(0x088ad9c8), uint32(0x49bbc2d1),
		uint32(0x8ae8effa), uint32(0xcbd9f4e3), uint32(0x0c4fb5ac), uint32(0x4d7eaeb5), uint32(0x8e2d839e),
		uint32(0xcf1c9887), uint32(0x5112c24a), uint32(0x1023d953), uint32(0xd370f478), uint32(0x9241ef61),
		uint32(0x55d7ae2e), uint32(0x14e6b537), uint32(0xd7b5981c), uint32(0x96848305), uint32(0x59981b82),
		uint32(0x18a9009b), uint32(0xdbfa2db0), uint32(0x9acb36a9), uint32(0x5d5d77e6), uint32(0x1c6c6cff),
		uint32(0xdf3f41d4), uint32(0x9e0e5acd), uint32(0xa2248495), uint32(0xe3159f8c), uint32(0x2046b2a7),
		uint32(0x6177a9be), uint32(0xa6e1e8f1), uint32(0xe7d0f3e8), uint32(0x2483dec3), uint32(0x65b2c5da),
		uint32(0xaaae5d5d), uint32(0xeb9f4644), uint32(0x28cc6b6f), uint32(0x69fd7076), uint32(0xae6b3139),
		uint32(0xef5a2a20), uint32(0x2c09070b), uint32(0x6d381c12), uint32(0xf33646df), uint32(0xb2075dc6),
		uint32(0x715470ed), uint32(0x30656bf4), uint32(0xf7f32abb), uint32(0xb6c231a2), uint32(0x75911c89),
		uint32(0x34a00790), uint32(0xfbbc9f17), uint32(0xba8d840e), uint32(0x79dea925), uint32(0x38efb23c),
		uint32(0xff79f373), uint32(0xbe48e86a), uint32(0x7d1bc541), uint32(0x3c2ade58), uint32(0x054f79f0),
		uint32(0x447e62e9), uint32(0x872d4fc2), uint32(0xc61c54db), uint32(0x018a1594), uint32(0x40bb0e8d),
		uint32(0x83e823a6), uint32(0xc2d938bf), uint32(0x0dc5a038), uint32(0x4cf4bb21), uint32(0x8fa7960a),
		uint32(0xce968d13), uint32(0x0900cc5c), uint32(0x4831d745), uint32(0x8b62fa6e), uint32(0xca53e177),
		uint32(0x545dbbba), uint32(0x156ca0a3), uint32(0xd63f8d88), uint32(0x970e9691), uint32(0x5098d7de),
		uint32(0x11a9ccc7), uint32(0xd2fae1ec), uint32(0x93cbfaf5), uint32(0x5cd76272), uint32(0x1de6796b),
		uint32(0xdeb55440), uint32(0x9f844f59), uint32(0x58120e16), uint32(0x1923150f), uint32(0xda703824),
		uint32(0x9b41233d), uint32(0xa76bfd65), uint32(0xe65ae67c), uint32(0x2509cb57), uint32(0x6438d04e),
		uint32(0xa3ae9101), uint32(0xe29f8a18), uint32(0x21cca733), uint32(0x60fdbc2a), uint32(0xafe124ad),
		uint32(0xeed03fb4), uint32(0x2d83129f), uint32(0x6cb20986), uint32(0xab2448c9), uint32(0xea1553d0),
		uint32(0x29467efb), uint32(0x687765e2), uint32(0xf6793f2f), uint32(0xb7482436), uint32(0x741b091d),
		uint32(0x352a1204), uint32(0xf2bc534b), uint32(0xb38d4852), uint32(0x70de6579), uint32(0x31ef7e60),
		uint32(0xfef3e6e7), uint32(0xbfc2fdfe), uint32(0x7c91d0d5), uint32(0x3da0cbcc), uint32(0xfa368a83),
		uint32(0xbb07919a), uint32(0x7854bcb1), uint32(0x3965a7a8), uint32(0x4b98833b), uint32(0x0aa99822),
		uint32(0xc9fab509), uint32(0x88cbae10), uint32(0x4f5def5f), uint32(0x0e6cf446), uint32(0xcd3fd96d),
		uint32(0x8c0ec274), uint32(0x43125af3), uint32(0x022341ea), uint32(0xc1706cc1), uint32(0x804177d8),
		uint32(0x47d73697), uint32(0x06e62d8e), uint32(0xc5b500a5), uint32(0x84841bbc), uint32(0x1a8a4171),
		uint32(0x5bbb5a68), uint32(0x98e87743), uint32(0xd9d96c5a), uint32(0x1e4f2d15), uint32(0x5f7e360c),
		uint32(0x9c2d1b27), uint32(0xdd1c003e), uint32(0x120098b9), uint32(0x533183a0), uint32(0x9062ae8b),
		uint32(0xd153b592), uint32(0x16c5f4dd), uint32(0x57f4efc4), uint32(0x94a7c2ef), uint32(0xd596d9f6),
		uint32(0xe9bc07ae), uint32(0xa88d1cb7), uint32(0x6bde319c), uint32(0x2aef2a85), uint32(0xed796bca),
		uint32(0xac4870d3), uint32(0x6f1b5df8), uint32(0x2e2a46e1), uint32(0xe136de66), uint32(0xa007c57f),
		uint32(0x6354e854), uint32(0x2265f34d), uint32(0xe5f3b202), uint32(0xa4c2a91b), uint32(0x67918430),
		uint32(0x26a09f29), uint32(0xb8aec5e4), uint32(0xf99fdefd), uint32(0x3accf3d6), uint32(0x7bfde8cf),
		uint32(0xbc6ba980), uint32(0xfd5ab299), uint32(0x3e099fb2), uint32(0x7f3884ab), uint32(0xb0241c2c),
		uint32(0xf1150735), uint32(0x32462a1e), uint32(0x73773107), uint32(0xb4e17048), uint32(0xf5d06b51),
		uint32(0x3683467a), uint32(0x77b25d63), uint32(0x4ed7facb), uint32(0x0fe6e1d2), uint32(0xccb5ccf9),
		uint32(0x8d84d7e0), uint32(0x4a1296af), uint32(0x0b238db6), uint32(0xc870a09d), uint32(0x8941bb84),
		uint32(0x465d2303), uint32(0x076c381a), uint32(0xc43f1531), uint32(0x850e0e28), uint32(0x42984f67),
		uint32(0x03a9547e), uint32(0xc0fa7955), uint32(0x81cb624c), uint32(0x1fc53881), uint32(0x5ef42398),
		uint32(0x9da70eb3), uint32(0xdc9615aa), uint32(0x1b0054e5), uint32(0x5a314ffc), uint32(0x996262d7),
		uint32(0xd85379ce), uint32(0x174fe149), uint32(0x567efa50), uint32(0x952dd77b), uint32(0xd41ccc62),
		uint32(0x138a8d2d), uint32(0x52bb9634), uint32(0x91e8bb1f), uint32(0xd0d9a006), uint32(0xecf37e5e),
		uint32(0xadc26547), uint32(0x6e91486c), uint32(0x2fa05375), uint32(0xe836123a), uint32(0xa9070923),
		uint32(0x6a542408), uint32(0x2b653f11), uint32(0xe479a796), uint32(0xa548bc8f), uint32(0x661b91a4),
		uint32(0x272a8abd), uint32(0xe0bccbf2), uint32(0xa18dd0eb), uint32(0x62defdc0), uint32(0x23efe6d9),
		uint32(0xbde1bc14), uint32(0xfcd0a70d), uint32(0x3f838a26), uint32(0x7eb2913f), uint32(0xb924d070),
		uint32(0xf815cb69), uint32(0x3b46e642), uint32(0x7a77fd5b), uint32(0xb56b65dc), uint32(0xf45a7ec5),
		uint32(0x370953ee), uint32(0x763848f7), uint32(0xb1ae09b8), uint32(0xf09f12a1), uint32(0x33cc3f8a),
		uint32(0x72fd2493),
	},
	{
		uint32(0x00000000), uint32(0x376ac201), uint32(0x6ed48403), uint32(0x59be4602), uint32(0xdca80907),
		uint32(0xebc2cb06), uint32(0xb27c8d04), uint32(0x85164f05), uint32(0xb851130e), uint32(0x8f3bd10f),
		uint32(0xd685970d), uint32(0xe1ef550c), uint32(0x64f91a09), uint32(0x5393d808), uint32(0x0a2d9e0a),
		uint32(0x3d475c0b), uint32(0x70a3261c), uint32(0x47c9e41d), uint32(0x1e77a21f), uint32(0x291d601e),
		uint32(0xac0b2f1b), uint32(0x9b61ed1a), uint32(0xc2dfab18), uint32(0xf5b56919), uint32(0xc8f23512),
		uint32(0xff98f713), uint32(0xa626b111), uint32(0x914c7310), uint32(0x145a3c15), uint32(0x2330fe14),
		uint32(0x7a8eb816), uint32(0x4de47a17), uint32(0xe0464d38), uint32(0xd72c8f39), uint32(0x8e92c93b),
		uint32(0xb9f80b3a), uint32(0x3cee443f), uint32(0x0b84863e), uint32(0x523ac03c), uint32(0x6550023d),
		uint32(0x58175e36), uint32(0x6f7d9c37), uint32(0x36c3da35), uint32(0x01a91834), uint32(0x84bf5731),
		uint32(0xb3d59530), uint32(0xea6bd332), uint32(0xdd011133), uint32(0x90e56b24), uint32(0xa78fa925),
		uint32(0xfe31ef27), uint32(0xc95b2d26), uint32(0x4c4d6223), uint32(0x7b27a022), uint32(0x2299e620),
		uint32(0x15f32421), uint32(0x28b4782a), uint32(0x1fdeba2b), uint32(0x4660fc29), uint32(0x710a3e28),
		uint32(0xf41c712d), uint32(0xc376b32c), uint32(0x9ac8f52e), uint32(0xada2372f), uint32(0xc08d9a70),
		uint32(0xf7e75871), uint32(0xae591e73), uint32(0x9933dc72), uint32(0x1c259377), uint32(0x2b4f5176),
		uint32(0x72f11774), uint32(0x459bd575), uint32(0x78dc897e), uint32(0x4fb64b7f), uint32(0x16080d7d),
		uint32(0x2162cf7c), uint32(0xa4748079), uint32(0x931e4278), uint32(0xcaa0047a), uint32(0xfdcac67b),
		uint32(0xb02ebc6c), uint32(0x87447e6d), uint32(0xdefa386f), uint32(0xe990fa6e), uint32(0x6c86b56b),
		uint32(0x5bec776a), uint32(0x02523168), uint32(0x3538f369), uint32(0x087faf62), uint32(0x3f156d63),
		uint32(0x66ab2b61), uint32(0x51c1e960), uint32(0xd4d7a665), uint32(0xe3bd6464), uint32(0xba032266),
		uint32(0x8d69e067), uint32(0x20cbd748), uint32(0x17a11549), uint32(0x4e1f534b), uint32(0x7975914a),
		uint32(0xfc63de4f), uint32(0xcb091c4e), uint32(0x92b75a4c), uint32(0xa5dd984d), uint32(0x989ac446),
		uint32(0xaff00647), uint32(0xf64e4045), uint32(0xc1248244), uint32(0x4432cd41), uint32(0x73580f40),
		uint32(0x2ae64942), uint32(0x1d8c8b43), uint32(0x5068f154), uint32(0x67023355), uint32(0x3ebc7557),
		uint32(0x09d6b756), uint32(0x8cc0f853), uint32(0xbbaa3a52), uint32(0xe2147c50), uint32(0xd57ebe51),
		uint32(0xe839e25a), uint32(0xdf53205b), uint32(0x86ed6659), uint32(0xb187a458), uint32(0x3491eb5d),
		uint32(0x03fb295c), uint32(0x5a456f5e), uint32(0x6d2fad5f), uint32(0x801b35e1), uint32(0xb771f7e0),
		uint32(0xeecfb1e2), uint32(0xd9a573e3), uint32(0x5cb33ce6), uint32(0x6bd9fee7), uint32(0x3267b8e5),
		uint32(0x050d7ae4), uint32(0x384a26ef), uint32(0x0f20e4ee), uint32(0x569ea2ec), uint32(0x61f460ed),
		uint32(0xe4e22fe8), uint32(0xd388ede9), uint32(0x8a36abeb), uint32(0xbd5c69ea), uint32(0xf0b813fd),
		uint32(0xc7d2d1fc), uint32(0x9e6c97fe), uint32(0xa90655ff), uint32(0x2c101afa), uint32(0x1b7ad8fb),
		uint32(0x42c49ef9), uint32(0x75ae5cf8), uint32(0x48e900f3), uint32(0x7f83c2f2), uint32(0x263d84f0),
		uint32(0x115746f1), uint32(0x944109f4), uint32(0xa32bcbf5), uint32(0xfa958df7), uint32(0xcdff4ff6),
		uint32(0x605d78d9), uint32(0x5737bad8), uint32(0x0e89fcda), uint32(0x39e33edb), uint32(0xbcf571de),
		uint32(0x8b9fb3df), uint32(0xd221f5dd), uint32(0xe54b37dc), uint32(0xd80c6bd7), uint32(0xef66a9d6),
		uint32(0xb6d8efd4), uint32(0x81b22dd5), uint32(0x04a462d0), uint32(0x33cea0d1), uint32(0x6a70e6d3),
		uint32(0x5d1a24d2), uint32(0x10fe5ec5), uint32(0x27949cc4), uint32(0x7e2adac6), uint32(0x494018c7),
		uint32(0xcc5657c2), uint32(0xfb3c95c3), uint32(0xa282d3c1), uint32(0x95e811c0), uint32(0xa8af4dcb),
		uint32(0x9fc58fca), uint32(0xc67bc9c8), uint32(0xf1110bc9), uint32(0x740744cc), uint32(0x436d86cd),
		uint32(0x1ad3c0cf), uint32(0x2db902ce), uint32(0x4096af91), uint32(0x77fc6d90), uint32(0x2e422b92),
		uint32(0x1928e993), uint32(0x9c3ea696), uint32(0xab546497), uint32(0xf2ea2295), uint32(0xc580e094),
		uint32(0xf8c7bc9f), uint32(0xcfad7e9e), uint32(0x9613389c), uint32(0xa179fa9d), uint32(0x246fb598),
		uint32(0x13057799), uint32(0x4abb319b), uint32(0x7dd1f39a), uint32(0x3035898d), uint32(0x075f4b8c),
		uint32(0x5ee10d8e), uint32(0x698bcf8f), uint32(0xec9d808a), uint32(0xdbf7428b), uint32(0x82490489),
		uint32(0xb523c688), uint32(0x88649a83), uint32(0xbf0e5882), uint32(0xe6b01e80), uint32(0xd1dadc81),
		uint32(0x54cc9384), uint32(0x63a65185), uint32(0x3a181787), uint32(0x0d72d586), uint32(0xa0d0e2a9),
		uint32(0x97ba20a8), uint32(0xce0466aa), uint32(0xf96ea4ab), uint32(0x7c78ebae), uint32(0x4b1229af),
		uint32(0x12ac6fad), uint32(0x25c6adac), uint32(0x1881f1a7), uint32(0x2feb33a6), uint32(0x765575a4),
		uint32(0x413fb7a5), uint32(0xc429f8a0), uint32(0xf3433aa1), uint32(0xaafd7ca3), uint32(0x9d97bea2),
		uint32(0xd073c4b5), uint32(0xe71906b4), uint32(0xbea740b6), uint32(0x89cd82b7), uint32(0x0cdbcdb2),
		uint32(0x3bb10fb3), uint32(0x620f49b1), uint32(0x55658bb0), uint32(0x6822d7bb), uint32(0x5f4815ba),
		uint32(0x06f653b8), uint32(0x319c91b9), uint32(0xb48adebc), uint32(0x83e01cbd), uint32(0xda5e5abf),
		uint32(0xed3498be),
	},
	{
		uint32(0x00000000), uint32(0x6567bcb8), uint32(0x8bc809aa), uint32(0xeeafb512), uint32(0x5797628f),
		uint32(0x32f0de37), uint32(0xdc5f6b25), uint32(0xb938d79d), uint32(0xef28b4c5), uint32(0x8a4f087d),
		uint32(0x64e0bd6f), uint32(0x018701d7), uint32(0xb8bfd64a), uint32(0xddd86af2), uint32(0x3377dfe0),
		uint32(0x56106358), uint32(0x9f571950), uint32(0xfa30a5e8), uint32(0x149f10fa), uint32(0x71f8ac42),
		uint32(0xc8c07bdf), uint32(0xada7c767), uint32(0x43087275), uint32(0x266fcecd), uint32(0x707fad95),
		uint32(0x1518112d), uint32(0xfbb7a43f), uint32(0x9ed01887), uint32(0x27e8cf1a), uint32(0x428f73a2),
		uint32(0xac20c6b0), uint32(0xc9477a08), uint32(0x3eaf32a0), uint32(0x5bc88e18), uint32(0xb5673b0a),
		uint32(0xd00087b2), uint32(0x6938502f), uint32(0x0c5fec97), uint32(0xe2f05985), uint32(0x8797e53d),
		uint32(0xd1878665), uint32(0xb4e03add), uint32(0x5a4f8fcf), uint32(0x3f283377), uint32(0x8610e4ea),
		uint32(0xe3775852), uint32(0x0dd8ed40), uint32(0x68bf51f8), uint32(0xa1f82bf0), uint32(0xc49f9748),
		uint32(0x2a30225a), uint32(0x4f579ee2), uint32(0xf66f497f), uint32(0x9308f5c7), uint32(0x7da740d5),
		uint32(0x18c0fc6d), uint32(0x4ed09f35), uint32(0x2bb7238d), uint32(0xc518969f), uint32(0xa07f2a27),
		uint32(0x1947fdba), uint32(0x7c204102), uint32(0x928ff410), uint32(0xf7e848a8), uint32(0x3d58149b),
		uint32(0x583fa823), uint32(0xb6901d31), uint32(0xd3f7a189), uint32(0x6acf7614), uint32(0x0fa8caac),
		uint32(0xe1077fbe), uint32(0x8460c306), uint32(0xd270a05e), uint32(0xb7171ce6), uint32(0x59b8a9f4),
		uint32(0x3cdf154c), uint32(0x85e7c2d1), uint32(0xe0807e69), uint32(0x0e2fcb7b), uint32(0x6b4877c3),
		uint32(0xa20f0dcb), uint32(0xc768b173), uint32(0x29c70461), uint32(0x4ca0b8d9), uint32(0xf5986f44),
		uint32(0x90ffd3fc), uint32(0x7e5066ee), uint32(0x1b37da56), uint32(0x4d27b90e), uint32(0x284005b6),
		uint32(0xc6efb0a4), uint32(0xa3880c1c), uint32(0x1ab0db81), uint32(0x7fd76739), uint32(0x9178d22b),
		uint32(0xf41f6e93), uint32(0x03f7263b), uint32(0x66909a83), uint32(0x883f2f91), uint32(0xed589329),
		uint32(0x546044b4), uint32(0x3107f80c), uint32(0xdfa84d1e), uint32(0xbacff1a6), uint32(0xecdf92fe),
		uint32(0x89b82e46), uint32(0x67179b54), uint32(0x027027ec), uint32(0xbb48f071), uint32(0xde2f4cc9),
		uint32(0x3080f9db), uint32(0x55e74563), uint32(0x9ca03f6b), uint32(0xf9c783d3), uint32(0x176836c1),
		uint32(0x720f8a79), uint32(0xcb375de4), uint32(0xae50e15c), uint32(0x40ff544e), uint32(0x2598e8f6),
		uint32(0x73888bae), uint32(0x16ef3716), uint32(0xf8408204), uint32(0x9d273ebc), uint32(0x241fe921),
		uint32(0x41785599), uint32(0xafd7e08b), uint32(0xcab05c33), uint32(0x3bb659ed), uint32(0x5ed1e555),
		uint32(0xb07e5047), uint32(0xd519ecff), uint32(0x6c213b62), uint32(0x094687da), uint32(0xe7e932c8),
		uint32(0x828e8e70), uint32(0xd49eed28), uint32(0xb1f95190), uint32(0x5f56e482), uint32(0x3a31583a),
		uint32(0x83098fa7), uint32(0xe66e331f), uint32(0x08c1860d), uint32(0x6da63ab5), uint32(0xa4e140bd),
		uint32(0xc186fc05), uint32(0x2f294917), uint32(0x4a4ef5af), uint32(0xf3762232), uint32(0x96119e8a),
		uint32(0x78be2b98), uint32(0x1dd99720), uint32(0x4bc9f478), uint32(0x2eae48c0), uint32(0xc001fdd2),
		uint32(0xa566416a), uint32(0x1c5e96f7), uint32(0x79392a4f), uint32(0x97969f5d), uint32(0xf2f123e5),
		uint32(0x05196b4d), uint32(0x607ed7f5), uint32(0x8ed162e7), uint32(0xebb6de5f), uint32(0x528e09c2),
		uint32(0x37e9b57a), uint32(0xd9460068), uint32(0xbc21bcd0), uint32(0xea31df88), uint32(0x8f566330),
		uint32(0x61f9d622), uint32(0x049e6a9a), uint32(0xbda6bd07), uint32(0xd8c101bf), uint32(0x366eb4ad),
		uint32(0x53090815), uint32(0x9a4e721d), uint32(0xff29cea5), uint32(0x11867bb7), uint32(0x74e1c70f),
		uint32(0xcdd91092), uint32(0xa8beac2a), uint32(0x46111938), uint32(0x2376a580), uint32(0x7566c6d8),
		uint32(0x10017a60), uint32(0xfeaecf72), uint32(0x9bc973ca), uint32(0x22f1a457), uint32(0x479618ef),
		uint32(0xa939adfd), uint32(0xcc5e1145), uint32(0x06ee4d76), uint32(0x6389f1ce), uint32(0x8d2644dc),
		uint32(0xe841f864), uint32(0x51792ff9), uint32(0x341e9341), uint32(0xdab12653), uint32(0xbfd69aeb),
		uint32(0xe9c6f9b3), uint32(0x8ca1450b), uint32(0x620ef019), uint32(0x07694ca1), uint32(0xbe519b3c),
		uint32(0xdb362784), uint32(0x35999296), uint32(0x50fe2e2e), uint32(0x99b95426), uint32(0xfcdee89e),
		uint32(0x12715d8c), uint32(0x7716e134), uint32(0xce2e36a9), uint32(0xab498a11), uint32(0x45e63f03),
		uint32(0x208183bb), uint32(0x7691e0e3), uint32(0x13f65c5b), uint32(0xfd59e949), uint32(0x983e55f1),
		uint32(0x2106826c), uint32(0x44613ed4), uint32(0xaace8bc6), uint32(0xcfa9377e), uint32(0x38417fd6),
		uint32(0x5d26c36e), uint32(0xb389767c), uint32(0xd6eecac4), uint32(0x6fd61d59), uint32(0x0ab1a1e1),
		uint32(0xe41e14f3), uint32(0x8179a84b), uint32(0xd769cb13), uint32(0xb20e77ab), uint32(0x5ca1c2b9),
		uint32(0x39c67e01), uint32(0x80fea99c), uint32(0xe5991524), uint32(0x0b36a036), uint32(0x6e511c8e),
		uint32(0xa7166686), uint32(0xc271da3e), uint32(0x2cde6f2c), uint32(0x49b9d394), uint32(0xf0810409),
		uint32(0x95e6b8b1), uint32(0x7b490da3), uint32(0x1e2eb11b), uint32(0x483ed243), uint32(0x2d596efb),
		uint32(0xc3f6dbe9), uint32(0xa6916751), uint32(0x1fa9b0cc), uint32(0x7ace0c74), uint32(0x9461b966),
		uint32(0xf10605de),
	},
} /* crc32.h:5:25 */

// =========================================================================
// This function can be used by asm versions of crc32()
func Xget_crc_table(tls *libc.TLS) uintptr { /* crc32.c:188:19: */
	return uintptr(uintptr(unsafe.Pointer(&crc_table)))
}

// =========================================================================

// =========================================================================
func Xcrc32_z(tls *libc.TLS, crc uint64, buf uintptr, len Z_size_t) uint64 { /* crc32.c:202:23: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if buf == Z_NULL {
		return 0
	}

	if uint64(unsafe.Sizeof(uintptr(0))) == uint64(unsafe.Sizeof(Ptrdiff_t(0))) {
		// var endian Z_crc_t at bp, 4

		*(*Z_crc_t)(unsafe.Pointer(bp /* endian */)) = Z_crc_t(1)
		if *(*uint8)(unsafe.Pointer(bp /* &endian */)) != 0 {
			return crc32_little(tls, crc, buf, len)
		} else {
			return crc32_big(tls, crc, buf, len)
		}
	}
	crc = (crc ^ 0xffffffff)
	for len >= uint64(8) {
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		len = len - (uint64(8))
	}
	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint64(&len, 1) != 0 {
			crc = (uint64(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		}
	}
	return (crc ^ 0xffffffff)
}

// =========================================================================
func Xcrc32(tls *libc.TLS, crc uint64, buf uintptr, len UInt) uint64 { /* crc32.c:237:23: */
	return Xcrc32_z(tls, crc, buf, uint64(len))
}

//
//    This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
//    integer pointer type. This violates the strict aliasing rule, where a
//    compiler can assume, for optimization purposes, that two pointers to
//    fundamentally different types won't ever point to the same memory. This can
//    manifest as a problem only if one of the pointers is written to. This code
//    only reads from those pointers. So long as this code remains isolated in
//    this compilation unit, there won't be a problem. For this reason, this code
//    should not be copied and pasted into a compilation unit in which other code
//    writes to the buffer that is passed to these routines.
//

// =========================================================================

// =========================================================================
func crc32_little(tls *libc.TLS, crc uint64, buf uintptr, len Z_size_t) uint64 { /* crc32.c:266:21: */
	var c Z_crc_t
	var buf4 uintptr

	c = Z_crc_t(crc)
	c = ^c
	for (len != 0) && ((Ptrdiff_t(buf) & int64(3)) != 0) {
		c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((c^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))&Z_crc_t(0xff)))*4)) ^ (c >> 8))
		len--
	}

	buf4 = buf
	for len >= uint64(32) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		len = len - (uint64(32))
	}
	for len >= uint64(4) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		len = len - (uint64(4))
	}
	buf = buf4

	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint64(&len, 1) != 0 {
			c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((c^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))&Z_crc_t(0xff)))*4)) ^ (c >> 8))
		}
	}
	c = ^c
	return uint64(c)
}

// =========================================================================

// =========================================================================
func crc32_big(tls *libc.TLS, crc uint64, buf uintptr, len Z_size_t) uint64 { /* crc32.c:306:21: */
	var c Z_crc_t
	var buf4 uintptr

	c = ((((((Z_crc_t(crc)) >> 24) & Z_crc_t(0xff)) + (((Z_crc_t(crc)) >> 8) & Z_crc_t(0xff00))) + (((Z_crc_t(crc)) & Z_crc_t(0xff00)) << 8)) + (((Z_crc_t(crc)) & Z_crc_t(0xff)) << 24))
	c = ^c
	for (len != 0) && ((Ptrdiff_t(buf) & int64(3)) != 0) {
		c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr(((c>>24)^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))*4)) ^ (c << 8))
		len--
	}

	buf4 = buf
	for len >= uint64(32) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		len = len - (uint64(32))
	}
	for len >= uint64(4) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		len = len - (uint64(4))
	}
	buf = buf4

	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint64(&len, 1) != 0 {
			c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr(((c>>24)^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))*4)) ^ (c << 8))
		}
	}
	c = ^c
	return (uint64((((((c) >> 24) & Z_crc_t(0xff)) + (((c) >> 8) & Z_crc_t(0xff00))) + (((c) & Z_crc_t(0xff00)) << 8)) + (((c) & Z_crc_t(0xff)) << 24)))
}

// =========================================================================
func gf2_matrix_times(tls *libc.TLS, mat uintptr, vec uint64) uint64 { /* crc32.c:344:21: */
	var sum uint64

	sum = uint64(0)
	for vec != 0 {
		if (vec & uint64(1)) != 0 {
			sum = sum ^ (*(*uint64)(unsafe.Pointer(mat)))
		}
		vec >>= 1
		mat += 8
	}
	return sum
}

// =========================================================================
func gf2_matrix_square(tls *libc.TLS, square uintptr, mat uintptr) { /* crc32.c:361:12: */
	var n int32

	for n = 0; n < GF2_DIM; n++ {
		*(*uint64)(unsafe.Pointer(square + uintptr(n)*8)) = gf2_matrix_times(tls, mat, *(*uint64)(unsafe.Pointer(mat + uintptr(n)*8)))
	}
}

// =========================================================================
func crc32_combine_(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off_t) ULong { /* crc32.c:372:13: */
	bp := tls.Alloc(512)
	defer tls.Free(512)

	var n int32
	var row uint64
	// var even [32]uint64 at bp+256, 256
	// even-power-of-two zeros operator
	// var odd [32]uint64 at bp, 256
	// odd-power-of-two zeros operator

	// degenerate case (also disallow negative lengths)
	if len2 <= int64(0) {
		return crc1
	}

	// put operator for one zero bit in odd
	*(*uint64)(unsafe.Pointer(bp /* &odd[0] */)) = 0xedb88320 // CRC-32 polynomial
	row = uint64(1)
	for n = 1; n < GF2_DIM; n++ {
		*(*uint64)(unsafe.Pointer(bp /* &odd[0] */ + uintptr(n)*8)) = row
		row <<= 1
	}

	// put operator for two zero bits in even
	gf2_matrix_square(tls, bp+256 /* &even[0] */, bp /* &odd[0] */)

	// put operator for four zero bits in odd
	gf2_matrix_square(tls, bp /* &odd[0] */, bp+256 /* &even[0] */)

	// apply len2 zeros to crc1 (first square will put the operator for one
	//        zero byte, eight zero bits, in even)
	for ok := true; ok; ok = (len2 != int64(0)) {
		// apply zeros operator for this bit of len2
		gf2_matrix_square(tls, bp+256 /* &even[0] */, bp /* &odd[0] */)
		if (len2 & int64(1)) != 0 {
			crc1 = gf2_matrix_times(tls, bp+256 /* &even[0] */, crc1)
		}
		len2 >>= 1

		// if no more bits set, then done
		if len2 == int64(0) {
			break
		}

		// another iteration of the loop with odd and even swapped
		gf2_matrix_square(tls, bp /* &odd[0] */, bp+256 /* &even[0] */)
		if (len2 & int64(1)) != 0 {
			crc1 = gf2_matrix_times(tls, bp /* &odd[0] */, crc1)
		}
		len2 >>= 1

		// if no more bits set, then done
	}

	// return combined crc
	crc1 = crc1 ^ (crc2)
	return crc1
}

// =========================================================================
func Xcrc32_combine(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off_t) ULong { /* crc32.c:428:15: */
	return crc32_combine_(tls, crc1, crc2, len2)
}

func Xcrc32_combine64(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off_t) ULong { /* crc32.c:436:15: */
	return crc32_combine_(tls, crc1, crc2, len2)
}

// Reverse the bytes in a 32-bit value

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip encoding
//    should be left enabled.

// ===========================================================================
// Internal compression state.

// number of length codes, not counting the special END_BLOCK code

// number of literal bytes 0..255

// number of Literal or Length codes, including the END_BLOCK code

// number of distance codes

// number of codes used to transfer the bit lengths

// maximum heap size

// All codes must not exceed MAX_BITS bits

// size of bit buffer in bi_buf

// Stream status

// Data structure describing a single value and its code string.
type Ct_data_s = struct {
	Ffc struct{ Ffreq Ush }
	Fdl struct{ Fdad Ush }
} /* zlib.h:84:1 */

// Reverse the bytes in a 32-bit value

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip encoding
//    should be left enabled.

// ===========================================================================
// Internal compression state.

// number of length codes, not counting the special END_BLOCK code

// number of literal bytes 0..255

// number of Literal or Length codes, including the END_BLOCK code

// number of distance codes

// number of codes used to transfer the bit lengths

// maximum heap size

// All codes must not exceed MAX_BITS bits

// size of bit buffer in bi_buf

// Stream status

// Data structure describing a single value and its code string.
type Ct_data = Ct_data_s /* deflate.h:77:7 */

type Static_tree_desc_s = struct {
	Fstatic_tree uintptr
	Fextra_bits  uintptr
	Fextra_base  int32
	Felems       int32
	Fmax_length  int32
	_            [4]byte
} /* deflate.h:84:9 */

type Tree_desc_s = struct {
	Fdyn_tree  uintptr
	Fmax_code  int32
	_          [4]byte
	Fstat_desc uintptr
} /* zlib.h:84:1 */

type Tree_desc = Tree_desc_s /* deflate.h:90:7 */

type Pos = Ush     /* deflate.h:92:13 */
type Posf = Pos    /* deflate.h:93:17 */
type IPos = uint32 /* deflate.h:94:18 */

// A Pos is an index in the character window. We use short instead of int to
// save space in the various tables. IPos is used only for parameter passing.

type Deflate_state = Internal_state /* deflate.h:276:7 */

var Xdeflate_copyright = *(*[69]int8)(unsafe.Pointer(ts + 7 /* " deflate 1.2.11 ..." */)) /* deflate.c:54:12 */
//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

// ===========================================================================
//  Function prototypes.
type Block_state = uint32 /* deflate.c:71:3 */

type Compress_func = uintptr /* deflate.c:73:21 */

// ===========================================================================
// Local data

// Tail of hash chains

// Matches of length 3 are discarded if their distance exceeds TOO_FAR

// Values for max_lazy_match, good_match and max_chain_length, depending on
// the desired pack level (0..9). The values given below have been tuned to
// exclude worst case performance for pathological files. Better values may be
// found for specific files.
type Config_s = struct {
	Fgood_length Ush
	Fmax_lazy    Ush
	Fnice_length Ush
	Fmax_chain   Ush
	Ffunc        Compress_func
} /* deflate.c:120:9 */

// ===========================================================================
// Local data

// Tail of hash chains

// Matches of length 3 are discarded if their distance exceeds TOO_FAR

// Values for max_lazy_match, good_match and max_chain_length, depending on
// the desired pack level (0..9). The values given below have been tuned to
// exclude worst case performance for pathological files. Better values may be
// found for specific files.
type Config = Config_s /* deflate.c:126:3 */

var configuration_table = [10]Config{
	//      good lazy nice chain
	/* 0 */ {Ffunc: 0}, // store only
	/* 1 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(4), Fnice_length: Ush(8), Fmax_chain: Ush(4), Ffunc: 0}, // max speed, no lazy matches
	/* 2 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(5), Fnice_length: Ush(16), Fmax_chain: Ush(8), Ffunc: 0},
	/* 3 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(6), Fnice_length: Ush(32), Fmax_chain: Ush(32), Ffunc: 0},

	/* 4 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(4), Fnice_length: Ush(16), Fmax_chain: Ush(16), Ffunc: 0}, // lazy matches
	/* 5 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(16), Fnice_length: Ush(32), Fmax_chain: Ush(32), Ffunc: 0},
	/* 6 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(16), Fnice_length: Ush(128), Fmax_chain: Ush(128), Ffunc: 0},
	/* 7 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(32), Fnice_length: Ush(128), Fmax_chain: Ush(256), Ffunc: 0},
	/* 8 */ {Fgood_length: Ush(32), Fmax_lazy: Ush(128), Fnice_length: Ush(258), Fmax_chain: Ush(1024), Ffunc: 0},
	/* 9 */ {Fgood_length: Ush(32), Fmax_lazy: Ush(258), Fnice_length: Ush(258), Fmax_chain: Ush(4096), Ffunc: 0}} /* deflate.c:134:20 */

// max compression

// Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
// For deflate_fast() (levels <= 3) good is ignored and lazy has a different
// meaning.

// rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH

// ===========================================================================
// Update a hash value with the given input byte
// IN  assertion: all calls to UPDATE_HASH are made with consecutive input
//    characters, so that a running hash key can be computed from the previous
//    key instead of complete recalculation each time.

// ===========================================================================
// Insert string str in the dictionary and set match_head to the previous head
// of the hash chain (the most recent string with same hash key). Return
// the previous length of the hash chain.
// If this file is compiled with -DFASTEST, the compression level is forced
// to 1, and no hash chains are maintained.
// IN  assertion: all calls to INSERT_STRING are made with consecutive input
//    characters and the first MIN_MATCH bytes of str are valid (except for
//    the last MIN_MATCH-1 bytes of the input file).

// ===========================================================================
// Initialize the hash table (avoiding 64K overflow for 16 bit systems).
// prev[] will be initialized on the fly.

// ===========================================================================
// Slide the hash table when sliding the window down (could be avoided with 32
// bit values at the expense of memory usage). We slide even when level == 0 to
// keep the hash table consistent if we switch back to level > 0 later.
func slide_hash(tls *libc.TLS, s uintptr) { /* deflate.c:201:12: */
	var n uint32
	var m uint32
	var p uintptr
	var wsize UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_size

	n = (*Deflate_state)(unsafe.Pointer(s)).Fhash_size
	p = ((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(n)*2)
	for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
		m = uint32(*(*Posf)(unsafe.Pointer(libc.PreDecUintptr(&p, 2))))
		*(*Posf)(unsafe.Pointer(p)) = func() uint16 {
			if m >= wsize {
				return (uint16(m - wsize))
			}
			return NIL
		}()
	}
	n = wsize
	p = ((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr(n)*2)
	for ok1 := true; ok1; ok1 = libc.PreDecUint32(&n, 1) != 0 {
		m = uint32(*(*Posf)(unsafe.Pointer(libc.PreDecUintptr(&p, 2))))
		*(*Posf)(unsafe.Pointer(p)) = func() uint16 {
			if m >= wsize {
				return (uint16(m - wsize))
			}
			return NIL
		}()
		// If n is not on any hash chain, prev[n] is garbage but
		// its value will never be used.
	}
}

// =========================================================================
func XdeflateInit_(tls *libc.TLS, strm Z_streamp, level int32, version uintptr, stream_size int32) int32 { /* deflate.c:228:13: */
	return XdeflateInit2_(tls, strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
		Z_DEFAULT_STRATEGY, version, stream_size)
	// To do: ignore strm->next_in if we use it as window
}

// =========================================================================
func XdeflateInit2_(tls *libc.TLS, strm Z_streamp, level int32, method int32, windowBits int32, memLevel int32, strategy int32, version uintptr, stream_size int32) int32 { /* deflate.c:240:13: */
	var s uintptr
	var wrap int32 = 1
	var overlay uintptr
	// We overlay pending_buf and d_buf+l_buf. This works since the average
	// output size for (length,distance) codes is <= 24 bits.

	if ((version == Z_NULL) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(my_version[0]))) || (uint64(stream_size) != uint64(unsafe.Sizeof(Z_stream{}))) {
		return -6
	}
	if strm == Z_NULL {
		return -2
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}

	if level == (-1) {
		level = 6
	}

	if windowBits < 0 { // suppress zlib wrapper
		wrap = 0
		windowBits = -windowBits
	} else if windowBits > 15 {
		wrap = 2 // write gzip wrapper instead
		windowBits = windowBits - (16)
	}
	if (((((((((memLevel < 1) || (memLevel > MAX_MEM_LEVEL)) || (method != Z_DEFLATED)) || (windowBits < 8)) || (windowBits > 15)) || (level < 0)) || (level > 9)) || (strategy < 0)) || (strategy > Z_FIXED)) || ((windowBits == 8) && (wrap != 1)) {
		return -2
	}
	if windowBits == 8 {
		windowBits = 9
	} // until 256-byte window bug fixed
	s = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Deflate_state{})))
	if s == Z_NULL {
		return -4
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = s
	(*Deflate_state)(unsafe.Pointer(s)).Fstrm = strm
	(*Deflate_state)(unsafe.Pointer(s)).Fstatus = INIT_STATE // to pass state test in deflateReset()

	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = wrap
	(*Deflate_state)(unsafe.Pointer(s)).Fgzhead = Z_NULL
	(*Deflate_state)(unsafe.Pointer(s)).Fw_bits = UInt(windowBits)
	(*Deflate_state)(unsafe.Pointer(s)).Fw_size = (UInt(int32(1) << (*Deflate_state)(unsafe.Pointer(s)).Fw_bits))
	(*Deflate_state)(unsafe.Pointer(s)).Fw_mask = ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - UInt(1))

	(*Deflate_state)(unsafe.Pointer(s)).Fhash_bits = (UInt(memLevel) + UInt(7))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_size = (UInt(int32(1) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_bits))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_mask = ((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_shift = ((((*Deflate_state)(unsafe.Pointer(s)).Fhash_bits + MIN_MATCH) - UInt(1)) / MIN_MATCH)

	(*Deflate_state)(unsafe.Pointer(s)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fw_size, (uint32(uint64(2) * uint64(unsafe.Sizeof(Byte(0))))))
	(*Deflate_state)(unsafe.Pointer(s)).Fprev = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fw_size, uint32(unsafe.Sizeof(Pos(0))))
	(*Deflate_state)(unsafe.Pointer(s)).Fhead = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fhash_size, uint32(unsafe.Sizeof(Pos(0))))

	(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = uint64(0) // nothing written to s->window yet

	(*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize = (UInt(int32(1) << (memLevel + 6))) // 16K elements by default

	overlay = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize, (uint32(uint64(unsafe.Sizeof(Ush(0))) + uint64(2))))
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_buf = overlay
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size = (Ulg((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize) * (uint64(unsafe.Sizeof(Ush(0))) + uint64(2)))

	if ((((*Deflate_state)(unsafe.Pointer(s)).Fwindow == Z_NULL) || ((*Deflate_state)(unsafe.Pointer(s)).Fprev == Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(s)).Fhead == Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf == Z_NULL) {
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = FINISH_STATE
		(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-4))]
		XdeflateEnd(tls, strm)
		return -4
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fd_buf = (overlay + uintptr((uint64((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize)/uint64(unsafe.Sizeof(Ush(0)))))*2)
	(*Deflate_state)(unsafe.Pointer(s)).Fl_buf = ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((uint64(1) + uint64(unsafe.Sizeof(Ush(0)))) * uint64((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize))))

	(*Deflate_state)(unsafe.Pointer(s)).Flevel = level
	(*Deflate_state)(unsafe.Pointer(s)).Fstrategy = strategy
	(*Deflate_state)(unsafe.Pointer(s)).Fmethod = Byte(method)

	return XdeflateReset(tls, strm)
}

var my_version = *(*[7]int8)(unsafe.Pointer(ts /* "1.2.11" */)) /* deflate.c:253:23 */

// =========================================================================
// Check for a valid deflate stream state. Return 0 if ok, 1 if not.
func deflateStateCheck(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:353:11: */
	var s uintptr
	if ((strm == Z_NULL) || ((*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0))) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return 1
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((s == Z_NULL) || ((*Deflate_state)(unsafe.Pointer(s)).Fstrm != strm)) || (((((((((*Deflate_state)(unsafe.Pointer(s)).Fstatus != INIT_STATE) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != GZIP_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != EXTRA_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != NAME_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != COMMENT_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != HCRC_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != BUSY_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != FINISH_STATE)) {
		return 1
	}
	return 0
}

// =========================================================================
func XdeflateSetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength UInt) int32 { /* deflate.c:376:13: */
	var s uintptr
	var str UInt
	var n UInt
	var wrap int32
	var avail uint32
	var next uintptr

	if (deflateStateCheck(tls, strm) != 0) || (dictionary == Z_NULL) {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	wrap = (*Deflate_state)(unsafe.Pointer(s)).Fwrap
	if ((wrap == 2) || ((wrap == 1) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != INIT_STATE))) || ((*Deflate_state)(unsafe.Pointer(s)).Flookahead != 0) {
		return -2
	}

	// when using zlib wrappers, compute Adler-32 for provided dictionary
	if wrap == 1 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, dictionary, dictLength)
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = 0 // avoid computing Adler-32 in read_buf

	// if dictionary would fill window, just replace the history
	if dictLength >= (*Deflate_state)(unsafe.Pointer(s)).Fw_size {
		if wrap == 0 { // already empty otherwise
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = NIL
			libc.X__builtin___memset_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (uint64(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))) * uint64(unsafe.Sizeof(Posf(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0))

			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
			(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
		}
		dictionary += (uintptr(dictLength - (*Deflate_state)(unsafe.Pointer(s)).Fw_size)) // use the tail
		dictLength = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
	}

	// insert dictionary into window and hash
	avail = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = dictLength
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = dictionary
	fill_window(tls, s)
	for (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= MIN_MATCH {
		str = (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		n = ((*Deflate_state)(unsafe.Pointer(s)).Flookahead - (UInt(MIN_MATCH - 1)))
		for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((str + MIN_MATCH) - UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr((str&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2)) = *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos(str)
			str++
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = str
		(*Deflate_state)(unsafe.Pointer(s)).Flookahead = (UInt(MIN_MATCH - 1))
		fill_window(tls, s)
	}
	*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = (*Deflate_state)(unsafe.Pointer(s)).Flookahead
	(*Deflate_state)(unsafe.Pointer(s)).Flookahead = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = libc.AssignPtrUint32(s+184 /* &.prev_length */, (UInt(MIN_MATCH - 1)))
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = avail
	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = wrap
	return Z_OK
}

// =========================================================================
func XdeflateGetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength uintptr) int32 { /* deflate.c:445:13: */
	var s uintptr
	var len UInt

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	len = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + (*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	if len > (*Deflate_state)(unsafe.Pointer(s)).Fw_size {
		len = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
	}
	if (dictionary != Z_NULL) && (len != 0) {
		libc.X__builtin___memcpy_chk(tls, dictionary, ((((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flookahead)) - uintptr(len)), uint64(len), libc.X__builtin_object_size(tls, dictionary, 0))
	}
	if dictLength != Z_NULL {
		*(*UInt)(unsafe.Pointer(dictLength)) = len
	}
	return Z_OK
}

// =========================================================================
func XdeflateResetKeep(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:467:13: */
	var s uintptr

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}

	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = libc.AssignPtrUint64(strm+40 /* &.total_out */, uint64(0))
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL // use zfree if we ever allocate msg dynamically
	(*Z_stream)(unsafe.Pointer(strm)).Fdata_type = Z_UNKNOWN

	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Deflate_state)(unsafe.Pointer(s)).Fpending = uint64(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_out = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf

	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap < 0 {
		(*Deflate_state)(unsafe.Pointer(s)).Fwrap = -(*Deflate_state)(unsafe.Pointer(s)).Fwrap // was made negative by deflate(..., Z_FINISH);
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fstatus = func() int32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
			return GZIP_STATE
		}
		return func() int32 {
			if (*Deflate_state)(unsafe.Pointer(s)).Fwrap != 0 {
				return INIT_STATE
			}
			return BUSY_STATE
		}()
	}()
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = func() uint64 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
			return Xcrc32(tls, uint64(0), Z_NULL, uint32(0))
		}
		return Xadler32(tls, uint64(0), Z_NULL, uint32(0))
	}()
	(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = Z_NO_FLUSH

	X_tr_init(tls, s)

	return Z_OK
}

// =========================================================================
func XdeflateReset(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:505:13: */
	var ret int32

	ret = XdeflateResetKeep(tls, strm)
	if ret == Z_OK {
		lm_init(tls, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	}
	return ret
}

// =========================================================================
func XdeflateSetHeader(tls *libc.TLS, strm Z_streamp, head Gz_headerp) int32 { /* deflate.c:517:13: */
	if (deflateStateCheck(tls, strm) != 0) || ((*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap != 2) {
		return -2
	}
	(*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fgzhead = head
	return Z_OK
}

// =========================================================================
func XdeflatePending(tls *libc.TLS, strm Z_streamp, pending uintptr, bits uintptr) int32 { /* deflate.c:528:13: */
	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	if pending != Z_NULL {
		*(*uint32)(unsafe.Pointer(pending)) = uint32((*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending)
	}
	if bits != Z_NULL {
		*(*int32)(unsafe.Pointer(bits)) = (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fbi_valid
	}
	return Z_OK
}

// =========================================================================
func XdeflatePrime(tls *libc.TLS, strm Z_streamp, bits int32, value int32) int32 { /* deflate.c:542:13: */
	var s uintptr
	var put int32

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Deflate_state)(unsafe.Pointer(s)).Fd_buf) < ((*Deflate_state)(unsafe.Pointer(s)).Fpending_out + uintptr((int32((Buf_size + 7)) >> 3))) {
		return -5
	}
	for ok := true; ok; ok = bits != 0 {
		put = (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)
		if put > bits {
			put = bits
		}
		*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush((value & ((int32(1) << put) - 1)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))))
		*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (put)
		X_tr_flush_bits(tls, s)
		value >>= put
		bits = bits - (put)
	}
	return Z_OK
}

// =========================================================================
func XdeflateParams(tls *libc.TLS, strm Z_streamp, level int32, strategy int32) int32 { /* deflate.c:568:13: */
	var s uintptr
	var func1 Compress_func

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	if level == (-1) {
		level = 6
	}
	if (((level < 0) || (level > 9)) || (strategy < 0)) || (strategy > Z_FIXED) {
		return -2
	}
	func1 = configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Ffunc

	if ((strategy != (*Deflate_state)(unsafe.Pointer(s)).Fstrategy) || (func1 != configuration_table[level].Ffunc)) && ((*Deflate_state)(unsafe.Pointer(s)).Fhigh_water != 0) {
		// Flush the last buffer:
		var err int32 = Xdeflate(tls, strm, Z_BLOCK)
		if err == (-2) {
			return err
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
			return -5
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flevel != level {
		if ((*Deflate_state)(unsafe.Pointer(s)).Flevel == 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fmatches != UInt(0)) {
			if (*Deflate_state)(unsafe.Pointer(s)).Fmatches == UInt(1) {
				slide_hash(tls, s)
			} else {
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = NIL
			}
			libc.X__builtin___memset_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (uint64(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))) * uint64(unsafe.Sizeof(Posf(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0))

			(*Deflate_state)(unsafe.Pointer(s)).Fmatches = UInt(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Flevel = level
		(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(configuration_table[level].Fmax_lazy)
		(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(configuration_table[level].Fgood_length)
		(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = int32(configuration_table[level].Fnice_length)
		(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(configuration_table[level].Fmax_chain)
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fstrategy = strategy
	return Z_OK
}

// =========================================================================
func XdeflateTune(tls *libc.TLS, strm Z_streamp, good_length int32, max_lazy int32, nice_length int32, max_chain int32) int32 { /* deflate.c:617:13: */
	var s uintptr

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(good_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(max_lazy)
	(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = nice_length
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(max_chain)
	return Z_OK
}

// =========================================================================
// For the default windowBits of 15 and memLevel of 8, this function returns
// a close to exact, as well as small, upper bound on the compressed size.
// They are coded as constants here for a reason--if the #define's are
// changed, then this function needs to be changed as well.  The return
// value for 15 and 8 only works for those exact settings.
//
// For any setting other than those defaults for windowBits and memLevel,
// the value returned is a conservative worst case for the maximum expansion
// resulting from using fixed blocks instead of stored blocks, which deflate
// can emit on compressed data for some combinations of the parameters.
//
// This function could be more sophisticated to provide closer upper bounds for
// every combination of windowBits and memLevel.  But even the conservative
// upper bound of about 14% expansion does not seem onerous for output buffer
// allocation.
func XdeflateBound(tls *libc.TLS, strm Z_streamp, sourceLen ULong) ULong { /* deflate.c:652:15: */
	var s uintptr
	var complen ULong
	var wraplen ULong

	// conservative upper bound for compressed data
	complen = (((sourceLen + ((sourceLen + uint64(7)) >> 3)) + ((sourceLen + uint64(63)) >> 6)) + uint64(5))

	// if can't get parameters, return conservative bound plus zlib wrapper
	if deflateStateCheck(tls, strm) != 0 {
		return (complen + uint64(6))
	}

	// compute wrapper length
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	switch (*Deflate_state)(unsafe.Pointer(s)).Fwrap {
	case 0: // raw deflate
		wraplen = uint64(0)
		break
	case 1: // zlib wrapper
		wraplen = (ULong(6 + (func() int32 {
			if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != 0 {
				return 4
			}
			return 0
		}())))
		break
	case 2: // gzip wrapper
		wraplen = uint64(18)
		if (*Deflate_state)(unsafe.Pointer(s)).Fgzhead != Z_NULL { // user-supplied gzip header
			var str uintptr
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != Z_NULL {
				wraplen = wraplen + (ULong(UInt(2) + (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len))
			}
			str = (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname
			if str != Z_NULL {
				for ok := true; ok; ok = *(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&str, 1))) != 0 {
					wraplen++
				}
			}
			str = (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment
			if str != Z_NULL {
				for ok1 := true; ok1; ok1 = *(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&str, 1))) != 0 {
					wraplen++
				}
			}
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
				wraplen = wraplen + (uint64(2))
			}
		}
		break
	default: // for compiler happiness
		wraplen = uint64(6)
	}

	// if not default parameters, return conservative bound
	if ((*Deflate_state)(unsafe.Pointer(s)).Fw_bits != UInt(15)) || ((*Deflate_state)(unsafe.Pointer(s)).Fhash_bits != (UInt(8 + 7))) {
		return (complen + wraplen)
	}

	// default settings: return tight bound for that case
	return ((((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + uint64(13)) - uint64(6)) + wraplen)
}

// =========================================================================
// Put a short in the pending buffer. The 16-bit value is put in MSB order.
// IN assertion: the stream state is correct and there is enough room in
// pending_buf.
func putShortMSB(tls *libc.TLS, s uintptr, b UInt) { /* deflate.c:716:12: */
	{
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(b >> 8))
	}

	{
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(b & UInt(0xff)))
	}

}

// =========================================================================
// Flush as much pending output as possible. All deflate() output, except for
// some deflate_stored() output, goes through this function so some
// applications may wish to modify it to avoid allocating a large
// strm->next_out buffer and copying into it. (See also read_buf()).
func flush_pending(tls *libc.TLS, strm Z_streamp) { /* deflate.c:730:12: */
	var len uint32
	var s uintptr = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	X_tr_flush_bits(tls, s)
	len = uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending)
	if len > (*Z_stream)(unsafe.Pointer(strm)).Favail_out {
		len = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	}
	if len == uint32(0) {
		return
	}

	libc.X__builtin___memcpy_chk(tls, (*Z_stream)(unsafe.Pointer(strm)).Fnext_out, (*Deflate_state)(unsafe.Pointer(s)).Fpending_out, uint64(len), libc.X__builtin_object_size(tls, (*Z_stream)(unsafe.Pointer(strm)).Fnext_out, 0))
	*(*uintptr)(unsafe.Pointer(strm + 24 /* &.next_out */)) += (uintptr(len))
	*(*uintptr)(unsafe.Pointer(s + 32 /* &.pending_out */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 40 /* &.total_out */)) += (ULong(len))
	*(*UInt)(unsafe.Pointer(strm + 32 /* &.avail_out */)) -= (len)
	*(*Ulg)(unsafe.Pointer(s + 40 /* &.pending */)) -= (Ulg(len))
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending == uint64(0) {
		(*Deflate_state)(unsafe.Pointer(s)).Fpending_out = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf
	}
}

// ===========================================================================
// Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].

// =========================================================================
func Xdeflate(tls *libc.TLS, strm Z_streamp, flush int32) int32 { /* deflate.c:763:13: */
	var old_flush int32 // value of flush param for previous deflate call
	var s uintptr

	if ((deflateStateCheck(tls, strm) != 0) || (flush > Z_BLOCK)) || (flush < 0) {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	if (((*Z_stream)(unsafe.Pointer(strm)).Fnext_out == Z_NULL) || (((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) && ((*Z_stream)(unsafe.Pointer(strm)).Fnext_in == Z_NULL))) || (((*Deflate_state)(unsafe.Pointer(s)).Fstatus == FINISH_STATE) && (flush != Z_FINISH)) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-2))]; return -2 }()
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	old_flush = (*Deflate_state)(unsafe.Pointer(s)).Flast_flush
	(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = flush

	// Flush as much pending output as possible
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
		flush_pending(tls, strm)
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
			// Since avail_out is 0, deflate will be called again with
			// more output space, but possibly with both pending and
			// avail_in equal to zero. There won't be anything to do,
			// but this is not an error situation so make sure we
			// return OK instead of BUF_ERROR at next call of deflate:
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}

		// Make sure there is something to do and avoid duplicate consecutive
		// flushes. For repeated and useless calls with Z_FINISH, we keep
		// returning Z_STREAM_END instead of Z_BUF_ERROR.
	} else if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && ((((flush) * 2) - (func() int32 {
		if (flush) > 4 {
			return 9
		}
		return 0
	}())) <= (((old_flush) * 2) - (func() int32 {
		if (old_flush) > 4 {
			return 9
		}
		return 0
	}())))) && (flush != Z_FINISH) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	// User must not provide more input after the first FINISH:
	if ((*Deflate_state)(unsafe.Pointer(s)).Fstatus == FINISH_STATE) && ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	// Write the header
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == INIT_STATE {
		// zlib header
		var header UInt = ((Z_DEFLATED + (((*Deflate_state)(unsafe.Pointer(s)).Fw_bits - UInt(8)) << 4)) << 8)
		var level_flags UInt

		if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
			level_flags = UInt(0)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Flevel < 6 {
			level_flags = UInt(1)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 6 {
			level_flags = UInt(2)
		} else {
			level_flags = UInt(3)
		}
		header = header | (level_flags << 6)
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != UInt(0) {
			header = header | (PRESET_DICT)
		}
		header = header + (UInt(31) - (header % UInt(31)))

		putShortMSB(tls, s, header)

		// Save the adler32 of the preset dictionary:
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != UInt(0) {
			putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16)))
			putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler & uint64(0xffff))))
		}
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, uint64(0), Z_NULL, uint32(0))
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

		// Compression must start with an empty pending buffer
		flush_pending(tls, strm)
		if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == GZIP_STATE {
		// gzip header
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, uint64(0), Z_NULL, uint32(0))
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(31)
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(139)
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(8)
		}

		if (*Deflate_state)(unsafe.Pointer(s)).Fgzhead == Z_NULL {
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = func() uint8 {
					if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 9 {
						return uint8(2)
					}
					return func() uint8 {
						if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
							return uint8(4)
						}
						return uint8(0)
					}()
				}()
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = OS_CODE
			}

			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

			// Compression must start with an empty pending buffer
			flush_pending(tls, strm)
			if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
				return Z_OK
			}
		} else {
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef(((((func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftext != 0 {
						return 1
					}
					return 0
				}()) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
						return 2
					}
					return 0
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra == Z_NULL {
						return 0
					}
					return 4
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname == Z_NULL {
						return 0
					}
					return 8
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment == Z_NULL {
						return 0
					}
					return 16
				}())))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime & uint64(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 8) & uint64(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 16) & uint64(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 24) & uint64(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = func() uint8 {
					if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 9 {
						return uint8(2)
					}
					return func() uint8 {
						if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
							return uint8(4)
						}
						return uint8(0)
					}()
				}()
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fos & 0xff))
			}

			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != Z_NULL {
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len & UInt(0xff)))
				}

				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len >> 8) & UInt(0xff)))
				}

			}
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
				(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf,
					uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending))
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = uint64(0)
			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = EXTRA_STATE
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == EXTRA_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != Z_NULL {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var left UInt = (UInt((Ulg((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len & UInt(0xffff))) - (*Deflate_state)(unsafe.Pointer(s)).Fgzindex))
			for ((*Deflate_state)(unsafe.Pointer(s)).Fpending + Ulg(left)) > (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
				var copy UInt = (UInt((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fpending))
				libc.X__builtin___memcpy_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fgzindex)), uint64(copy), libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf+uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), 0))
				(*Deflate_state)(unsafe.Pointer(s)).Fpending = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size
				for ok := true; ok; ok = 0 != 0 {
					if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
						(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
					}
				}
				*(*Ulg)(unsafe.Pointer(s + 64 /* &.gzindex */)) += (Ulg(copy))
				flush_pending(tls, strm)
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
					(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
					return Z_OK
				}
				beg = uint64(0)
				left = left - (copy)
			}
			libc.X__builtin___memcpy_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fgzindex)), uint64(left), libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf+uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), 0))
			*(*Ulg)(unsafe.Pointer(s + 40 /* &.pending */)) += (Ulg(left))
			for ok1 := true; ok1; ok1 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = uint64(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = NAME_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == NAME_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname != Z_NULL {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var val int32
			for ok2 := true; ok2; ok2 = (val != 0) {
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending == (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
					for ok3 := true; ok3; ok3 = 0 != 0 {
						if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
							(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
						}
					}
					flush_pending(tls, strm)
					if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
						return Z_OK
					}
					beg = uint64(0)
				}
				val = int32(*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fgzindex, 1)))))
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(val)
				}

			}
			for ok4 := true; ok4; ok4 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = uint64(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = COMMENT_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == COMMENT_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment != Z_NULL {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var val int32
			for ok5 := true; ok5; ok5 = (val != 0) {
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending == (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
					for ok6 := true; ok6; ok6 = 0 != 0 {
						if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
							(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
						}
					}
					flush_pending(tls, strm)
					if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
						return Z_OK
					}
					beg = uint64(0)
				}
				val = int32(*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fgzindex, 1)))))
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(val)
				}

			}
			for ok7 := true; ok7; ok7 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = HCRC_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == HCRC_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
			if ((*Deflate_state)(unsafe.Pointer(s)).Fpending + uint64(2)) > (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
				flush_pending(tls, strm)
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
					(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
					return Z_OK
				}
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Fadler & uint64(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 8) & uint64(0xff)))
			}

			(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, uint64(0), Z_NULL, uint32(0))
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

		// Compression must start with an empty pending buffer
		flush_pending(tls, strm)
		if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}
	}

	// Start a new block or continue the current one.
	if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) || ((*Deflate_state)(unsafe.Pointer(s)).Flookahead != UInt(0))) || ((flush != Z_NO_FLUSH) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != FINISH_STATE)) {
		var bstate Block_state

		if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 0 {
			bstate = deflate_stored(tls, s, flush)
		} else {
			if (*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_HUFFMAN_ONLY {
				bstate = deflate_huff(tls, s, flush)
			} else {
				if (*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_RLE {
					bstate = deflate_rle(tls, s, flush)
				} else {
					bstate = (*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer((uintptr(unsafe.Pointer(&configuration_table)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flevel)*16 + 8 /* &.func */))))(tls, s, flush)
				}
			}
		}

		if (bstate == Finish_started) || (bstate == Finish_done) {
			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = FINISH_STATE
		}
		if (bstate == Need_more) || (bstate == Finish_started) {
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1 // avoid BUF_ERROR next call, see above
			}
			return Z_OK
			// If flush != Z_NO_FLUSH && avail_out == 0, the next call
			// of deflate should use the same flush parameter to make sure
			// that the flush is complete. So we don't have to output an
			// empty block here, this will be done at next call. This also
			// ensures that for a very small output buffer, we emit at most
			// one empty block.
		}
		if bstate == Block_done {
			if flush == Z_PARTIAL_FLUSH {
				X_tr_align(tls, s)
			} else if flush != Z_BLOCK { // FULL_FLUSH or SYNC_FLUSH
				X_tr_stored_block(tls, s, uintptr(0), uint64(0), 0)
				// For a full flush, this empty block will be recognized
				// as a special marker by inflate_sync().
				if flush == Z_FULL_FLUSH {
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = NIL
					libc.X__builtin___memset_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (uint64(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))) * uint64(unsafe.Sizeof(Posf(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0))
					// forget history
					if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
						(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
						(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
					}
				}
			}
			flush_pending(tls, strm)
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1 // avoid BUF_ERROR at next call, see above
				return Z_OK
			}
		}
	}

	if flush != Z_FINISH {
		return Z_OK
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap <= 0 {
		return Z_STREAM_END
	}

	// Write the trailer
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Fadler & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 8) & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16) & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 24) & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 8) & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 16) & uint64(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 24) & uint64(0xff)))
		}

	} else {
		putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16)))
		putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler & uint64(0xffff))))
	}
	flush_pending(tls, strm)
	// If avail_out is zero, the application will call deflate again
	// to flush the rest.
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap > 0 {
		(*Deflate_state)(unsafe.Pointer(s)).Fwrap = -(*Deflate_state)(unsafe.Pointer(s)).Fwrap
	} // write the trailer only once!
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending != uint64(0) {
		return Z_OK
	}
	return Z_STREAM_END
}

// =========================================================================
func XdeflateEnd(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:1076:13: */
	var status int32

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}

	status = (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fstatus

	/* Deallocate in reverse order of allocations: */
	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending_buf != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending_buf)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fhead != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fhead)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fprev != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fprev)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwindow != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwindow)
		}
	}

	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = Z_NULL

	if status == BUSY_STATE {
		return -3
	}
	return Z_OK
}

// =========================================================================
// Copy the source state to the destination state.
// To simplify the source, this is not supported for 16-bit MSDOS (which
// doesn't have enough memory anyway to duplicate compression states).
func XdeflateCopy(tls *libc.TLS, dest Z_streamp, source Z_streamp) int32 { /* deflate.c:1102:13: */
	var ds uintptr
	var ss uintptr
	var overlay uintptr

	if (deflateStateCheck(tls, source) != 0) || (dest == Z_NULL) {
		return -2
	}

	ss = (*Z_stream)(unsafe.Pointer(source)).Fstate

	libc.X__builtin___memcpy_chk(tls, dest, source, uint64(unsafe.Sizeof(Z_stream{})), libc.X__builtin_object_size(tls, dest, 0))

	ds = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Deflate_state{})))
	if ds == Z_NULL {
		return -4
	}
	(*Z_stream)(unsafe.Pointer(dest)).Fstate = ds
	libc.X__builtin___memcpy_chk(tls, ds, ss, uint64(unsafe.Sizeof(Deflate_state{})), libc.X__builtin_object_size(tls, ds, 0))
	(*Deflate_state)(unsafe.Pointer(ds)).Fstrm = dest

	(*Deflate_state)(unsafe.Pointer(ds)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fw_size, (uint32(uint64(2) * uint64(unsafe.Sizeof(Byte(0))))))
	(*Deflate_state)(unsafe.Pointer(ds)).Fprev = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fw_size, uint32(unsafe.Sizeof(Pos(0))))
	(*Deflate_state)(unsafe.Pointer(ds)).Fhead = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fhash_size, uint32(unsafe.Sizeof(Pos(0))))
	overlay = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize, (uint32(uint64(unsafe.Sizeof(Ush(0))) + uint64(2))))
	(*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf = overlay

	if ((((*Deflate_state)(unsafe.Pointer(ds)).Fwindow == Z_NULL) || ((*Deflate_state)(unsafe.Pointer(ds)).Fprev == Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(ds)).Fhead == Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf == Z_NULL) {
		XdeflateEnd(tls, dest)
		return -4
	}
	// following zmemcpy do not work for 16-bit MSDOS
	libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fwindow, (*Deflate_state)(unsafe.Pointer(ss)).Fwindow, ((uint64((*Deflate_state)(unsafe.Pointer(ds)).Fw_size * UInt(2))) * uint64(unsafe.Sizeof(Byte(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fwindow, 0))
	libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fprev, (*Deflate_state)(unsafe.Pointer(ss)).Fprev, (uint64((*Deflate_state)(unsafe.Pointer(ds)).Fw_size) * uint64(unsafe.Sizeof(Pos(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fprev, 0))
	libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fhead, (*Deflate_state)(unsafe.Pointer(ss)).Fhead, (uint64((*Deflate_state)(unsafe.Pointer(ds)).Fhash_size) * uint64(unsafe.Sizeof(Pos(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fhead, 0))
	libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf, (*Deflate_state)(unsafe.Pointer(ss)).Fpending_buf, uint64(UInt((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf_size)), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf, 0))

	(*Deflate_state)(unsafe.Pointer(ds)).Fpending_out = ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf + uintptr(((int64((*Deflate_state)(unsafe.Pointer(ss)).Fpending_out) - int64((*Deflate_state)(unsafe.Pointer(ss)).Fpending_buf)) / 1)))
	(*Deflate_state)(unsafe.Pointer(ds)).Fd_buf = (overlay + uintptr((uint64((*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize)/uint64(unsafe.Sizeof(Ush(0)))))*2)
	(*Deflate_state)(unsafe.Pointer(ds)).Fl_buf = ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf + uintptr(((uint64(1) + uint64(unsafe.Sizeof(Ush(0)))) * uint64((*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize))))

	(*Deflate_state)(unsafe.Pointer(ds)).Fl_desc.Fdyn_tree = ds + 212   /* &.dyn_ltree */
	(*Deflate_state)(unsafe.Pointer(ds)).Fd_desc.Fdyn_tree = ds + 2504  /* &.dyn_dtree */
	(*Deflate_state)(unsafe.Pointer(ds)).Fbl_desc.Fdyn_tree = ds + 2748 /* &.bl_tree */

	return Z_OK
}

// ===========================================================================
// Read a new buffer from the current input stream, update the adler32
// and total number of bytes read.  All deflate() input goes through
// this function so some applications may wish to modify it to avoid
// allocating a large strm->next_in buffer and copying from it.
// (See also flush_pending()).
func read_buf(tls *libc.TLS, strm Z_streamp, buf uintptr, size uint32) uint32 { /* deflate.c:1164:16: */
	var len uint32 = (*Z_stream)(unsafe.Pointer(strm)).Favail_in

	if len > size {
		len = size
	}
	if len == uint32(0) {
		return uint32(0)
	}

	*(*UInt)(unsafe.Pointer(strm + 8 /* &.avail_in */)) -= (len)

	libc.X__builtin___memcpy_chk(tls, buf, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, uint64(len), libc.X__builtin_object_size(tls, buf, 0))
	if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap == 1 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, buf, len)
	} else if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap == 2 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, buf, len)
	}
	*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 16 /* &.total_in */)) += (ULong(len))

	return len
}

// ===========================================================================
// Initialize the "longest match" routines for a new zlib stream
func lm_init(tls *libc.TLS, s uintptr) { /* deflate.c:1194:12: */
	(*Deflate_state)(unsafe.Pointer(s)).Fwindow_size = (uint64(2) * Ulg((*Deflate_state)(unsafe.Pointer(s)).Fw_size))

	*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = NIL
	libc.X__builtin___memset_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (uint64(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))) * uint64(unsafe.Sizeof(Posf(0)))), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0))

	// Set the default configuration parameters:
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fmax_lazy)
	(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fgood_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = int32(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fnice_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fmax_chain)

	(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
	(*Deflate_state)(unsafe.Pointer(s)).Flookahead = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = libc.AssignPtrUint32(s+184 /* &.prev_length */, (UInt(MIN_MATCH - 1)))
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(0)
}

// ===========================================================================
// Set match_start to the longest match starting at the given string and
// return its length. Matches shorter or equal to prev_length are discarded,
// in which case the result is equal to prev_length and match_start is
// garbage.
// IN assertions: cur_match is the head of the hash chain for the current
//   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
// OUT assertion: the match length is not greater than s->lookahead.
// For 80x86 and 680x0, an optimized version will be provided in match.asm or
// match.S. The code will be functionally equivalent.
func longest_match(tls *libc.TLS, s uintptr, cur_match IPos) UInt { /* deflate.c:1236:12: */
	var chain_length uint32 = (*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length                                           // max hash chain length
	var scan uintptr = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) // current string
	var match uintptr                                                                                                         // matched string
	var len int32                                                                                                             // length of current match
	var best_len int32 = int32((*Deflate_state)(unsafe.Pointer(s)).Fprev_length)                                              // best match length so far
	var nice_match int32 = (*Deflate_state)(unsafe.Pointer(s)).Fnice_match                                                    // stop if match long enough
	var limit IPos
	if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart > ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1))) {
		limit = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1))))
	} else {
		limit = NIL
	}
	// Stop when cur_match becomes <= limit. To simplify the code,
	// we prevent matches with the string of window index 0.
	var prev uintptr = (*Deflate_state)(unsafe.Pointer(s)).Fprev
	var wmask UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_mask

	var strend uintptr = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr(MAX_MATCH))
	var scan_end1 Byte = *(*Bytef)(unsafe.Pointer(scan + uintptr((best_len - 1))))
	var scan_end Byte = *(*Bytef)(unsafe.Pointer(scan + uintptr(best_len)))

	// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	// It is easy to get rid of this optimization if necessary.

	// Do not waste too much time if we already have a good match:
	if (*Deflate_state)(unsafe.Pointer(s)).Fprev_length >= (*Deflate_state)(unsafe.Pointer(s)).Fgood_match {
		chain_length >>= 2
	}
	// Do not look for matches beyond the end of the input. This is necessary
	// to make deflate deterministic.
	if UInt(nice_match) > (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
		nice_match = int32((*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	}

	for ok := true; ok; ok = (((libc.AssignUint32(&cur_match, IPos(*(*Posf)(unsafe.Pointer(prev + uintptr((cur_match&wmask))*2))))) > limit) &&
		(libc.PreDecUint32(&chain_length, 1) != uint32(0))) {

		match = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(cur_match))

		// Skip to next match if the match length cannot increase
		// or if the match length is less than 2.  Note that the checks below
		// for insufficient lookahead only occur occasionally for performance
		// reasons.  Therefore uninitialized memory will be accessed, and
		// conditional jumps will be made that depend on those values.
		// However the length of the match is limited to the lookahead, so
		// the output of deflate is not affected by the uninitialized values.

		if (((int32(*(*Bytef)(unsafe.Pointer(match + uintptr(best_len)))) != int32(scan_end)) || (int32(*(*Bytef)(unsafe.Pointer(match + uintptr((best_len - 1))))) != int32(scan_end1))) || (int32(*(*Bytef)(unsafe.Pointer(match))) != int32(*(*Bytef)(unsafe.Pointer(scan))))) || (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))) != int32(*(*Bytef)(unsafe.Pointer(scan + 1)))) {
			continue
		}

		// The check at best_len-1 can be removed because it will be made
		// again later. (This heuristic is not always a win.)
		// It is not necessary to compare scan[2] and match[2] since they
		// are always equal when the other bytes match, given that
		// the hash keys are equal and that HASH_BITS >= 8.
		scan += uintptr(2)
		match++

		// We check for insufficient lookahead only every 8th comparison;
		// the 256th check will be made at strstart+258.
		for ok1 := true; ok1; ok1 = (((((((((int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (scan < strend)) {
		}

		len = (MAX_MATCH - (int32((int64(strend) - int64(scan)) / 1)))
		scan = (strend - uintptr(MAX_MATCH))

		if len > best_len {
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_start = cur_match
			best_len = len
			if len >= nice_match {
				break
			}
			scan_end1 = *(*Bytef)(unsafe.Pointer(scan + uintptr((best_len - 1))))
			scan_end = *(*Bytef)(unsafe.Pointer(scan + uintptr(best_len)))
		}
	}

	if UInt(best_len) <= (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
		return UInt(best_len)
	}
	return (*Deflate_state)(unsafe.Pointer(s)).Flookahead
}

// ===========================================================================
// Fill the window when the lookahead becomes insufficient.
// Updates strstart and lookahead.
//
// IN assertion: lookahead < MIN_LOOKAHEAD
// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
//    At least one byte has been read, or avail_in == 0; reads are
//    performed for at least two bytes (required for the zip translate_eol
//    option -- not supported here).
func fill_window(tls *libc.TLS, s uintptr) { /* deflate.c:1482:12: */
	var n uint32
	var more uint32 // Amount of free space at the end of the window.
	var wsize UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_size

	for ok := true; ok; ok = (((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in != UInt(0))) {
		more = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Flookahead)) - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))

		// Deal with !@#$% 64K limit:
		if uint64(unsafe.Sizeof(int32(0))) <= uint64(2) {
			if ((more == uint32(0)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart == UInt(0))) && ((*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0)) {
				more = wsize

			} else if more == libc.Uint32(libc.Uint32FromInt32(-1)) {
				// Very unlikely, but possible on 16 bit machine if
				// strstart == 0 && lookahead == 1 (input done a byte at time)
				more--
			}
		}

		// If the window is almost full and there is insufficient lookahead,
		// move the upper half to the lower one to make room in the upper half.
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart >= (wsize + ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {

			libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(wsize)), (uint64(wsize - more)), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, 0))
			*(*UInt)(unsafe.Pointer(s + 176 /* &.match_start */)) -= (wsize)
			*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) -= (wsize) // we now have strstart >= MAX_DIST
			*(*int64)(unsafe.Pointer(s + 152 /* &.block_start */)) -= (int64(wsize))
			slide_hash(tls, s)
			more = more + (wsize)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0) {
			break
		}

		// If there was no sliding:
		//    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
		//    more == window_size - lookahead - strstart
		// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
		// => more >= window_size - 2*WSIZE + 2
		// In the BIG_MEM or MMAP case (not yet supported),
		//   window_size == input_size + MIN_LOOKAHEAD  &&
		//   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
		// Otherwise, window_size == 2*WSIZE so more >= 2.
		// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

		n = read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flookahead)), more)
		*(*UInt)(unsafe.Pointer(s + 180 /* &.lookahead */)) += (n)

		// Initialize the hash value now that we have some input:
		if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead + (*Deflate_state)(unsafe.Pointer(s)).Finsert) >= MIN_MATCH {
			var str UInt = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Finsert)
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(str))))
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((str + UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			for (*Deflate_state)(unsafe.Pointer(s)).Finsert != 0 {
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((str + MIN_MATCH) - UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr((str&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2)) = *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos(str)
				str++
				(*Deflate_state)(unsafe.Pointer(s)).Finsert--
				if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead + (*Deflate_state)(unsafe.Pointer(s)).Finsert) < MIN_MATCH {
					break
				}
			}
		}
		// If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
		// but this is not important since only literal bytes will be emitted.

	}

	// If the WIN_INIT bytes after the end of the current data have never been
	// written, then zero those bytes in order to avoid memory check reports of
	// the use of uninitialized (or uninitialised as Julian writes) bytes by
	// the longest match routines.  Update the high water mark for the next
	// time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	// routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < (*Deflate_state)(unsafe.Pointer(s)).Fwindow_size {
		var curr Ulg = (Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (Ulg((*Deflate_state)(unsafe.Pointer(s)).Flookahead)))
		var init1 Ulg

		if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < curr {
			// Previous high water mark below current data -- zero WIN_INIT
			// bytes or up to end of window, whichever is less.
			init1 = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - curr)
			if init1 > MAX_MATCH {
				init1 = MAX_MATCH
			}
			libc.X__builtin___memset_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(curr)), 0, uint64(uint32(init1)), libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow+uintptr(curr)), 0))
			(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = (curr + init1)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < (curr + MAX_MATCH) {
			// High water mark at or above current data, but below current data
			// plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
			// to end of window, whichever is less.
			init1 = ((curr + MAX_MATCH) - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)
			if init1 > ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water) {
				init1 = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)
			}
			libc.X__builtin___memset_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)), 0, uint64(uint32(init1)), libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow+uintptr((*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)), 0))
			*(*Ulg)(unsafe.Pointer(s + 5944 /* &.high_water */)) += (init1)
		}
	}

}

// ===========================================================================
// Flush the current block, with given end-of-file flag.
// IN assertion: strstart is set to the end of the current match.

// Same but force premature exit if necessary.

// Maximum stored block length in deflate format (not including header).

// Minimum of a and b.

// ===========================================================================
// Copy without compression as much as possible from the input stream, return
// the current block state.
//
// In case deflateParams() is used to later switch to a non-zero compression
// level, s->matches (otherwise unused when storing) keeps track of the number
// of hash table slides to perform. If s->matches is 1, then one hash table
// slide will be done when switching. If s->matches is 2, the maximum value
// allowed here, then the hash table will be cleared, since two or more slides
// is the same as a clear.
//
// deflate_stored() is written to minimize the number of times an input byte is
// copied. It is most efficient with large input and output buffers, which
// maximizes the opportunites to have a single copy from next_in to next_out.
func deflate_stored(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1643:19: */
	// Smallest worthy block size when not flushing or finishing. By default
	// this is 32K. This can be as small as 507 bytes for memLevel == 1. For
	// large input and output buffers, the stored block size will be larger.
	var min_block uint32 = func() uint32 {
		if ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - uint64(5)) > (Ulg((*Deflate_state)(unsafe.Pointer(s)).Fw_size)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		}
		return (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - uint64(5)))
	}()

	// Copy as many min_block or larger stored blocks directly to next_out as
	// possible. If flushing, copy the remaining available input to next_out as
	// stored blocks, if there is enough space.
	var len uint32
	var left uint32
	var have uint32
	var last uint32 = uint32(0)
	var used uint32 = (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in
	for ok := true; ok; ok = (last == uint32(0)) {
		// Set len to the maximum size block that we can copy directly with the
		// available input data and output space. Set left to how much of that
		// would be copied from what's left in the window.
		len = MAX_STORED                                                                              // maximum deflate stored block length
		have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_valid + 42) >> 3))                    // number of header bytes
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out < have { // need room for header
			break
		}
		// maximum stored block length that will fit in avail_out:
		have = ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out - have)
		left = (uint32(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)) // bytes left in window
		if Ulg(len) > (Ulg(left) + Ulg((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)) {
			len = (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)
		} // limit len to the input
		if len > have {
			len = have
		} // limit len to the output

		// If the stored block would be less than min_block in length, or if
		// unable to copy all of the available input when flushing, then try
		// copying to the window and the pending buffer instead. Also don't
		// write an empty block when flushing -- deflate() does that.
		if (len < min_block) && ((((len == uint32(0)) && (flush != Z_FINISH)) || (flush == Z_NO_FLUSH)) || (len != (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in))) {
			break
		}

		// Make a dummy stored block in pending to get the header bytes,
		// including any pending bits. This also updates the debugging counts.
		if (flush == Z_FINISH) && (len == (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)) {
			last = uint32(1)
		} else {
			last = uint32(0)
		}
		X_tr_stored_block(tls, s, uintptr(0), uint64(0), int32(last))

		// Replace the lengths in the dummy stored block with len.
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - uint64(4))))) = Bytef(len)
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - uint64(3))))) = (Bytef(len >> 8))
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - uint64(2))))) = Bytef(^len)
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - uint64(1))))) = (Bytef(^len >> 8))

		// Write the stored block header bytes.
		flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)

		// Copy uncompressed bytes from the window to next_out.
		if left != 0 {
			if left > len {
				left = len
			}
			libc.X__builtin___memcpy_chk(tls, (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_out, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), uint64(left), libc.X__builtin_object_size(tls, (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_out, 0))
			*(*uintptr)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 24 /* &.next_out */)) += (uintptr(left))
			*(*UInt)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 32 /* &.avail_out */)) -= (left)
			*(*ULong)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 40 /* &.total_out */)) += (ULong(left))
			*(*int64)(unsafe.Pointer(s + 152 /* &.block_start */)) += (int64(left))
			len = len - (left)
		}

		// Copy uncompressed bytes directly from next_in to next_out, updating
		// the check value.
		if len != 0 {
			read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_out, len)
			*(*uintptr)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 24 /* &.next_out */)) += (uintptr(len))
			*(*UInt)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 32 /* &.avail_out */)) -= (len)
			*(*ULong)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 40 /* &.total_out */)) += (ULong(len))
		}
	}

	// Update the sliding window with the last s->w_size bytes of the copied
	// data, or append all of the copied data to the existing window if less
	// than s->w_size bytes were copied. Also update the number of bytes to
	// insert in the hash tables, in the event that deflateParams() switches to
	// a non-zero compression level.
	used = used - ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in) // number of input bytes directly copied
	if used != 0 {
		// If any input was used, then no unused input remains in the window,
		// therefore s->block_start == s->strstart.
		if used >= (*Deflate_state)(unsafe.Pointer(s)).Fw_size { // supplant the previous history
			(*Deflate_state)(unsafe.Pointer(s)).Fmatches = UInt(2) // clear hash
			libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_in - uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), uint64((*Deflate_state)(unsafe.Pointer(s)).Fw_size), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, 0))
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		} else {
			if ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) <= Ulg(used) {
				// Slide the window down.
				*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fw_size)
				libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), uint64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, 0))
				if (*Deflate_state)(unsafe.Pointer(s)).Fmatches < UInt(2) {
					(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
				} // add a pending slide_hash()
			}
			libc.X__builtin___memcpy_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)), ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_in - uintptr(used)), uint64(used), libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow+uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)), 0))
			*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) += (used)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		*(*UInt)(unsafe.Pointer(s + 5932 /* &.insert */)) += (func() uint32 {
			if (used) > ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - (*Deflate_state)(unsafe.Pointer(s)).Finsert) {
				return ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - (*Deflate_state)(unsafe.Pointer(s)).Finsert)
			}
			return used
		}())
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) {
		(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	}

	// If the last block was written to next_out, then done.
	if last != 0 {
		return Finish_done
	}

	// If flushing and all input has been consumed, then done.
	if (((flush != Z_NO_FLUSH) && (flush != Z_FINISH)) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) == (*Deflate_state)(unsafe.Pointer(s)).Fblock_start) {
		return Block_done
	}

	// Fill the window with any remaining input.
	have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) - uint64(1)))
	if ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in > have) && ((*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= int64((*Deflate_state)(unsafe.Pointer(s)).Fw_size)) {
		// Slide the window down.
		*(*int64)(unsafe.Pointer(s + 152 /* &.block_start */)) -= (int64((*Deflate_state)(unsafe.Pointer(s)).Fw_size))
		*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fw_size)
		libc.X__builtin___memcpy_chk(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), uint64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart), libc.X__builtin_object_size(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, 0))
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatches < UInt(2) {
			(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
		} // add a pending slide_hash()
		have = have + ((*Deflate_state)(unsafe.Pointer(s)).Fw_size) // more space now
	}
	if have > (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in {
		have = (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in
	}
	if have != 0 {
		read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)), have)
		*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) += (have)
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) {
		(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	}

	// There was not enough avail_out to write a complete worthy or flushed
	// stored block to next_out. Write a stored block to pending instead, if we
	// have enough input for a worthy block, or if flushing and there is enough
	// room for the remaining input as a stored block in the pending buffer.
	have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_valid + 42) >> 3)) // number of header bytes
	// maximum stored block length that will fit in pending:
	have = func() uint32 {
		if ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(have)) > (MAX_STORED) {
			return MAX_STORED
		}
		return (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(have)))
	}()
	min_block = func() uint32 {
		if (have) > ((*Deflate_state)(unsafe.Pointer(s)).Fw_size) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		}
		return have
	}()
	left = (uint32(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start))
	if (left >= min_block) || (((((left != 0) || (flush == Z_FINISH)) && (flush != Z_NO_FLUSH)) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (left <= have)) {
		len = func() uint32 {
			if (left) > (have) {
				return have
			}
			return left
		}()
		if ((flush == Z_FINISH) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (len == left) {
			last = uint32(1)
		} else {
			last = uint32(0)
		}
		X_tr_stored_block(tls, s, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), uint64(len), int32(last))
		*(*int64)(unsafe.Pointer(s + 152 /* &.block_start */)) += (int64(len))
		flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
	}

	// We've done all we can with the available input and output.
	if last != 0 {
		return Finish_started
	}
	return Need_more
}

// ===========================================================================
// Compress as much as possible from the input stream, return the current
// block state.
// This function does not perform lazy evaluation of matches and inserts
// new strings in the dictionary only for unmatched strings or for short
// matches. It is used only for the fast compression options.
func deflate_fast(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1824:19: */
	var hash_head IPos // head of the hash chain
	var bflush int32   // set if current block must be flushed

	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the next match, plus MIN_MATCH bytes to insert the
		// string following the next match.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1)) {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// Insert the string window[strstart .. strstart+2] in the
		// dictionary, and set hash_head to the head of the hash chain:
		hash_head = NIL
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= MIN_MATCH {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		}

		// Find the longest match, discarding those <= prev_length.
		// At this point we have always match_length < MIN_MATCH
		if (hash_head != NIL) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - hash_head) <= ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {
			// To simplify the code, we prevent matches with the string
			// of window index 0 (in particular we have to avoid a match
			// of the string with itself at the start of the input file).
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = longest_match(tls, s, hash_head)
			// longest_match() sets match_start
		}
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length >= MIN_MATCH {

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length - MIN_MATCH))
				var dist Ush = (Ush((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2504 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			*(*UInt)(unsafe.Pointer(s + 180 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)

			// Insert new strings in the hash table only if the match length
			// is not too large. This saves time but degrades compression.
			if ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= (*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match) && ((*Deflate_state)(unsafe.Pointer(s)).Flookahead >= MIN_MATCH) {
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length-- // string at strstart already in table
				for ok := true; ok; ok = (libc.PreDecUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length, 1) != UInt(0)) {
					(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
					(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
					hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					// strstart never exceeds WSIZE-MAX_MATCH, so there are
					// always MIN_MATCH bytes ahead.
				}
				(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			} else {
				*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart))))
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
				// If lookahead < MIN_MATCH, ins_h is garbage, but it does not
				// matter since it will be recomputed at next deflate call.
			}
		} else {
			// No match, output a literal byte

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		}
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = func() uint32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart < (UInt(MIN_MATCH - 1)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		}
		return (uint32(MIN_MATCH - 1))
	}()
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return Z_NULL
			}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// Same as above, but achieves better compression. We use a lazy
// evaluation for matches: a match is finally adopted only if there is
// no better match at the next window position.
func deflate_slow(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1926:19: */
	var hash_head IPos // head of hash chain
	var bflush int32   // set if current block must be flushed

	// Process the input block.
	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the next match, plus MIN_MATCH bytes to insert the
		// string following the next match.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1)) {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// Insert the string window[strstart .. strstart+2] in the
		// dictionary, and set hash_head to the head of the hash chain:
		hash_head = NIL
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= MIN_MATCH {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		}

		// Find the longest match, discarding those <= prev_length.
		(*Deflate_state)(unsafe.Pointer(s)).Fprev_length = (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length
		(*Deflate_state)(unsafe.Pointer(s)).Fprev_match = (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))

		if ((hash_head != NIL) && ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length < (*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - hash_head) <= ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {
			// To simplify the code, we prevent matches with the string
			// of window index 0 (in particular we have to avoid a match
			// of the string with itself at the start of the input file).
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = longest_match(tls, s, hash_head)
			// longest_match() sets match_start

			if ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= UInt(5)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_FILTERED) ||
				(((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length == MIN_MATCH) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start) > TOO_FAR))) {

				// If prev_match is also MIN_MATCH, match_start is garbage
				// but we will ignore the current match anyway.
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))
			}
		}
		// If there was a match at the previous step and the current
		// match is not better, output the previous match:
		if ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length >= MIN_MATCH) && ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= (*Deflate_state)(unsafe.Pointer(s)).Fprev_length) {
			var max_insert UInt = (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + (*Deflate_state)(unsafe.Pointer(s)).Flookahead) - MIN_MATCH)
			// Do not insert strings in hash table beyond this.

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fprev_length - MIN_MATCH))
				var dist Ush = (Ush(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)) - (*Deflate_state)(unsafe.Pointer(s)).Fprev_match))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2504 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			// Insert in hash table all strings up to the end of the match.
			// strstart-1 and strstart are already inserted. If there is not
			// enough lookahead, the last two strings are not inserted in
			// the hash table.
			*(*UInt)(unsafe.Pointer(s + 180 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length - UInt(1))
			*(*UInt)(unsafe.Pointer(s + 184 /* &.prev_length */)) -= (UInt(2))
			for ok := true; ok; ok = (libc.PreDecUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fprev_length, 1) != UInt(0)) {
				if libc.PreIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fstrstart, 1) <= max_insert {
					(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
					hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++

			if bflush != 0 {
				{
					X_tr_flush_block(tls, s, func() uintptr {
						if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
							return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
						}
						return Z_NULL
					}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
					(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
				}
				if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
					if 0 != 0 {
						return Finish_started
					}
					return Need_more
				}
			}

		} else if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_available != 0 {
			// If there was no match at the previous position, output a
			// single literal. If there was a match but the current match
			// is longer, truncate the previous match to a single literal.

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)))))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			if bflush != 0 {
				{
					X_tr_flush_block(tls, s, func() uintptr {
						if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
							return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
						}
						return Z_NULL
					}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
					(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				return Need_more
			}
		} else {
			// There is no previous match to compare with, wait for
			// the next step to decide.
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 1
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
		}
	}

	if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_available != 0 {

		{
			var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)))))
			*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
			*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
			*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
			bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
		}

		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = func() uint32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart < (UInt(MIN_MATCH - 1)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		}
		return (uint32(MIN_MATCH - 1))
	}()
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return Z_NULL
			}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// For Z_RLE, simply look for runs of bytes, generate matches only of distance
// one.  Do not maintain a hash table.  (It will be regenerated if this run of
// deflate switches away from Z_RLE.)
func deflate_rle(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:2057:19: */
	var bflush int32 // set if current block must be flushed
	var prev UInt    // byte at distance one to match
	var scan uintptr
	var strend uintptr // scan goes up to strend for length of run

	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the longest run, plus one for the unrolled loop.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead <= MAX_MATCH {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead <= MAX_MATCH) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// See how many times the previous byte repeats
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
		if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead >= MIN_MATCH) && ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart > UInt(0)) {
			scan = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) - uintptr(1))
			prev = UInt(*(*Bytef)(unsafe.Pointer(scan)))
			if ((prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) {
				strend = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr(MAX_MATCH))
				for ok := true; ok; ok = (((((((((prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (scan < strend)) {
				}
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (MAX_MATCH - (UInt((int64(strend) - int64(scan)) / 1)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length > (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
					(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (*Deflate_state)(unsafe.Pointer(s)).Flookahead
				}
			}

		}

		// Emit match if have run of MIN_MATCH or longer, else emit literal
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length >= MIN_MATCH {

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length - MIN_MATCH))
				var dist Ush = Ush(1)
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2504 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			*(*UInt)(unsafe.Pointer(s + 180 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
			*(*UInt)(unsafe.Pointer(s + 172 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
		} else {
			// No match, output a literal byte

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		}
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return Z_NULL
			}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
// (It will be regenerated if this run of deflate switches away from Huffman.)
func deflate_huff(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:2130:19: */
	var bflush int32 // set if current block must be flushed

	for {
		// Make sure that we have a literal to write.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
			fill_window(tls, s)
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				if flush == Z_NO_FLUSH {
					return Need_more
				}
				break // flush the current block
			}
		}

		// Output a literal byte
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)

		{
			var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
			*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
			*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
			*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
			bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
		}

		(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
		(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return Z_NULL
				}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return Z_NULL
			}(), (Ulg(int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int64((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

type Fpos_t = X__darwin_off_t /* _stdio.h:81:25 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type X__sbuf = struct {
	F_base uintptr
	F_size int32
	_      [4]byte
} /* _stdio.h:92:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type X__sFILE = struct {
	F_p     uintptr
	F_r     int32
	F_w     int32
	F_flags int16
	F_file  int16
	_       [4]byte
	F_bf    struct {
		F_base uintptr
		F_size int32
		_      [4]byte
	}
	F_lbfsize int32
	_         [4]byte
	F_cookie  uintptr
	F_close   uintptr
	F_read    uintptr
	F_seek    uintptr
	F_write   uintptr
	F_ub      struct {
		F_base uintptr
		F_size int32
		_      [4]byte
	}
	F_extra uintptr
	F_ur    int32
	F_ubuf  [3]uint8
	F_nbuf  [1]uint8
	F_lb    struct {
		F_base uintptr
		F_size int32
		_      [4]byte
	}
	F_blksize int32
	_         [4]byte
	F_offset  Fpos_t
} /* _stdio.h:126:9 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type FILE = X__sFILE /* _stdio.h:157:3 */ // getsubopt(3) external variable
// valloc is now declared in _malloc.h

// Poison the following routines if -fshort-wchar is set

// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 2000-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// -
// Copyright (c) 1983, 1990, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)fcntl.h	8.3 (Berkeley) 1/21/94

// This file includes the definitions for open and fcntl
// described by POSIX for <fcntl.h>; it also includes
// related kernel definitions.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// We should not be exporting size_t here.  Temporary for gcc bootstrapping.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// File status flags: these are used by open(2), fcntl(2).
// They are also used (indirectly) in the kernel file structure f_flags,
// which is a superset of the open/fcntl flags.  Open flags and f_flags
// are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
// Open/fcntl flags begin with O_; kernel-internal flags begin with F.
// open-only flags

// Kernel encoding of open mode; separate read and write bits that are
// independently testable: 1 greater than the above.
//
// XXX
// FREAD and FWRITE are excluded from the #ifdef KERNEL so that TIOCFLUSH,
// which was documented to use FREAD/FWRITE, continues to work.

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

//      O_DSYNC         0x00400000      /* synch I/O data integrity */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Descriptor value for the current working directory

// Flags for the at functions

// Data Protection Flags

// The O_* flags used to have only F* names, which were used in the kernel
// and by fcntl.  We retain the F* names for the kernel f_flags field
// and for backward compatibility for fcntl.

// Flags used for copyfile(2)

// Constants used for fcntl(2)

// command values
// 46,47 used to be F_READBOOTSTRAP and F_WRITEBOOTSTRAP

// should not be used (i.e. its ok to temporaily create cached pages)

// See F_DUPFD_CLOEXEC below for 67

// may be broken into smaller chunks with throttling in between

// FS-specific fcntl()'s numbers begin at 0x00010000 and go up

// file descriptor flags (F_GETFD, F_SETFD)

// record locking flags (F_GETLK, F_SETLK, F_SETLKW)

// [XSI] The values used for l_whence shall be defined as described
// in <unistd.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// whence values for lseek(2)

// [XSI] The symbolic names for file modes for use as values of mode_t
// shall be defined as described in <sys/stat.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// [XSI] The symbolic names for file modes for use as values of mode_t
// shall be defined as described in <sys/stat.h>
// File type

// File mode
// Read, write, execute/search by owner
// Read, write, execute/search by group
// Read, write, execute/search by others

// allocate flags (F_PREALLOCATE)

// Position Modes (fst_posmode) for F_PREALLOCATE

// we can keep them in sync should we desire

// Advisory file segment locking data type -
// information passed to system by user
type Flock = struct {
	Fl_start  Off_t
	Fl_len    Off_t
	Fl_pid    Pid_t
	Fl_type   int16
	Fl_whence int16
} /* fcntl.h:350:1 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Advisory file segment locking with time out -
// Information passed to system by user for F_SETLKWTIMEOUT
type Flocktimeout = struct {
	Ffl struct {
		Fl_start  Off_t
		Fl_len    Off_t
		Fl_pid    Pid_t
		Fl_type   int16
		Fl_whence int16
	}
	Ftimeout struct {
		Ftv_sec  X__darwin_time_t
		Ftv_nsec int64
	}
} /* fcntl.h:365:1 */

// advisory file read data type -
// information passed by user to system

type Radvisory = struct {
	Fra_offset Off_t
	Fra_count  int32
	_          [4]byte
} /* fcntl.h:378:1 */

// detached code signatures data type -
// information passed by user to system used by F_ADDSIGS and F_ADDFILESIGS.
// F_ADDFILESIGS is a shortcut for files that contain their own signature and
// doesn't require mapping of the file in order to load the signature.
type Fsignatures = struct {
	Ffs_file_start       Off_t
	Ffs_blob_start       uintptr
	Ffs_blob_size        Size_t
	Ffs_fsignatures_size Size_t
	Ffs_cdhash           [20]int8
	Ffs_hash_type        int32
} /* fcntl.h:391:9 */

// detached code signatures data type -
// information passed by user to system used by F_ADDSIGS and F_ADDFILESIGS.
// F_ADDFILESIGS is a shortcut for files that contain their own signature and
// doesn't require mapping of the file in order to load the signature.
type Fsignatures_t = Fsignatures /* fcntl.h:401:3 */

type Fsupplement = struct {
	Ffs_file_start Off_t
	Ffs_blob_start Off_t
	Ffs_blob_size  Size_t
	Ffs_orig_fd    int32
	_              [4]byte
} /* fcntl.h:403:9 */

type Fsupplement_t = Fsupplement /* fcntl.h:408:3 */

// DYLD needs to check if the object is allowed to be combined
// into the main binary. This is done between the code signature
// is loaded and dyld is doing all the work to process the LOAD commands.
//
// While this could be done in F_ADDFILESIGS.* family the hook into
// the MAC module doesn't say no when LV isn't enabled and then that
// is cached on the vnode, and the MAC module never gets change once
// a process that library validation enabled.
type Fchecklv = struct {
	Flv_file_start         Off_t
	Flv_error_message_size Size_t
	Flv_error_message      uintptr
} /* fcntl.h:422:9 */

// DYLD needs to check if the object is allowed to be combined
// into the main binary. This is done between the code signature
// is loaded and dyld is doing all the work to process the LOAD commands.
//
// While this could be done in F_ADDFILESIGS.* family the hook into
// the MAC module doesn't say no when LV isn't enabled and then that
// is cached on the vnode, and the MAC module never gets change once
// a process that library validation enabled.
type Fchecklv_t = Fchecklv /* fcntl.h:426:3 */

// At this time F_GETSIGSINFO can only indicate platformness.
//  As additional requestable information is defined, new keys will be added and the
//  fgetsigsinfo_t structure will be lengthened to add space for the additional information

// fgetsigsinfo_t used by F_GETSIGSINFO command
type Fgetsigsinfo = struct {
	Ffg_file_start      Off_t
	Ffg_info_request    int32
	Ffg_sig_is_platform int32
} /* fcntl.h:436:9 */

// At this time F_GETSIGSINFO can only indicate platformness.
//  As additional requestable information is defined, new keys will be added and the
//  fgetsigsinfo_t structure will be lengthened to add space for the additional information

// fgetsigsinfo_t used by F_GETSIGSINFO command
type Fgetsigsinfo_t = Fgetsigsinfo /* fcntl.h:440:3 */

// lock operations for flock(2)

// fstore_t type used by F_PREALLOCATE command

type Fstore = struct {
	Ffst_flags      uint32
	Ffst_posmode    int32
	Ffst_offset     Off_t
	Ffst_length     Off_t
	Ffst_bytesalloc Off_t
} /* fcntl.h:451:9 */

// lock operations for flock(2)

// fstore_t type used by F_PREALLOCATE command

type Fstore_t = Fstore /* fcntl.h:457:3 */

// fpunchhole_t used by F_PUNCHHOLE
type Fpunchhole = struct {
	Ffp_flags  uint32
	Freserved  uint32
	Ffp_offset Off_t
	Ffp_length Off_t
} /* fcntl.h:460:9 */

// fpunchhole_t used by F_PUNCHHOLE
type Fpunchhole_t = Fpunchhole /* fcntl.h:465:3 */

// factive_file_trim_t used by F_TRIM_ACTIVE_FILE
type Ftrimactivefile = struct {
	Ffta_offset Off_t
	Ffta_length Off_t
} /* fcntl.h:468:9 */

// factive_file_trim_t used by F_TRIM_ACTIVE_FILE
type Ftrimactivefile_t = Ftrimactivefile /* fcntl.h:471:3 */

// fspecread_t used by F_SPECULATIVE_READ
type Fspecread = struct {
	Ffsr_flags  uint32
	Freserved   uint32
	Ffsr_offset Off_t
	Ffsr_length Off_t
} /* fcntl.h:474:9 */

// fspecread_t used by F_SPECULATIVE_READ
type Fspecread_t = Fspecread /* fcntl.h:479:3 */

// fbootstraptransfer_t used by F_READBOOTSTRAP and F_WRITEBOOTSTRAP commands

type Fbootstraptransfer = struct {
	Ffbt_offset Off_t
	Ffbt_length Size_t
	Ffbt_buffer uintptr
} /* fcntl.h:483:9 */

// fbootstraptransfer_t used by F_READBOOTSTRAP and F_WRITEBOOTSTRAP commands

type Fbootstraptransfer_t = Fbootstraptransfer /* fcntl.h:487:3 */

// For F_LOG2PHYS this information is passed back to user
// Currently only devoffset is returned - that is the VOP_BMAP
// result - the disk device address corresponding to the
// current file offset (likely set with an lseek).
//
// The flags could hold an indication of whether the # of
// contiguous bytes reflects the true extent length on disk,
// or is an advisory value that indicates there is at least that
// many bytes contiguous.  For some filesystems it might be too
// inefficient to provide anything beyond the advisory value.
// Flags and contiguous bytes return values are not yet implemented.
// For them the fcntl will nedd to switch from using BMAP to CMAP
// and a per filesystem type flag will be needed to interpret the
// contiguous bytes count result from CMAP.
//
// F_LOG2PHYS_EXT is a variant of F_LOG2PHYS that uses a passed in
// file offset and length instead of the current file offset.
// F_LOG2PHYS_EXT operates on the same structure as F_LOG2PHYS, but
// treats it as an in/out.

type Log2phys = struct {
	Fl2p_flags       uint32
	_                [4]byte
	Fl2p_contigbytes Off_t
	Fl2p_devoffset   Off_t
} /* fcntl.h:513:1 */

type Filesec_t = uintptr /* _filesec_t.h:31:25 */

type Filesec_property_t = uint32 /* fcntl.h:547:3 */

// default memLevel

// default i/o buffer size -- double this for output when reading (this and
//    twice this must be able to fit in an unsigned type)

// gzip modes, also provide a little integrity check on the passed structure

// values for gz_state how

// internal gzip file state data structure
type Gz_state = struct {
	Fx        GzFile_s
	Fmode     int32
	Ffd       int32
	Fpath     uintptr
	Fsize     uint32
	Fwant     uint32
	Fin       uintptr
	Fout      uintptr
	Fdirect   int32
	Fhow      int32
	Fstart    Off_t
	Feof      int32
	Fpast     int32
	Flevel    int32
	Fstrategy int32
	Fskip     Off_t
	Fseek     int32
	Ferr      int32
	Fmsg      uintptr
	Fstrm     Z_stream
}                        /* gzguts.h:201:3 */
type Gz_statep = uintptr /* gzguts.h:202:22 */

// GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
//    value -- needed when comparing unsigned to z_off64_t, which is signed
//    (possible z_off64_t types off_t, off64_t, and long are all signed)

// gzclose() is in a separate file so that it is linked in only if it is used.
//    That way the other gzclose functions can be used instead to avoid linking in
//    unneeded compression or decompression routines.
func Xgzclose(tls *libc.TLS, file GzFile) int32 { /* gzclose.c:11:13: */
	var state Gz_statep

	if file == (uintptr(0)) {
		return -2
	}
	state = file

	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		return Xgzclose_r(tls, file)
	}
	return Xgzclose_w(tls, file)
}

// Reset gzip file state
func gz_reset(tls *libc.TLS, state Gz_statep) { /* gzlib.c:75:12: */
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)  // no output data available
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ { // for reading ...
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0    // not at end of file
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0   // have not read past end yet
		(*Gz_state)(unsafe.Pointer(state)).Fhow = LOOK // look for gzip header
	}
	(*Gz_state)(unsafe.Pointer(state)).Fseek = 0                 // no seek request pending
	Xgz_error(tls, state, Z_OK, uintptr(0))                      // clear error
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos = int64(0)        // no uncompressed data yet
	(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0) // no input data yet
}

// Open a gzip file either by name or file descriptor.
func gz_open(tls *libc.TLS, path uintptr, fd int32, mode uintptr) GzFile { /* gzlib.c:91:14: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var state Gz_statep
	var len Z_size_t
	var oflag int32
	var cloexec int32 = 0
	var exclusive int32 = 0

	// check input
	if path == (uintptr(0)) {
		return uintptr(0)
	}

	// allocate gzFile structure to return
	state = libc.Xmalloc(tls, uint64(unsafe.Sizeof(Gz_state{})))
	if state == (uintptr(0)) {
		return uintptr(0)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fsize = uint32(0) // no buffers allocated yet
	(*Gz_state)(unsafe.Pointer(state)).Fwant = GZBUFSIZE // requested buffer size
	(*Gz_state)(unsafe.Pointer(state)).Fmsg = uintptr(0) // no error message yet

	// interpret mode
	(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_NONE
	(*Gz_state)(unsafe.Pointer(state)).Flevel = -1
	(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_DEFAULT_STRATEGY
	(*Gz_state)(unsafe.Pointer(state)).Fdirect = 0
	for *(*int8)(unsafe.Pointer(mode)) != 0 {
		if (int32(*(*int8)(unsafe.Pointer(mode))) >= '0') && (int32(*(*int8)(unsafe.Pointer(mode))) <= '9') {
			(*Gz_state)(unsafe.Pointer(state)).Flevel = (int32(*(*int8)(unsafe.Pointer(mode))) - '0')
		} else {
			switch int32(*(*int8)(unsafe.Pointer(mode))) {
			case 'r':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_READ
				break
				fallthrough
			case 'w':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_WRITE
				break
				fallthrough
			case 'a':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_APPEND
				break
				fallthrough
			case '+': // can't read and write at the same time
				libc.Xfree(tls, state)
				return uintptr(0)
				fallthrough
			case 'b': // ignore -- will request binary anyway
				break
				fallthrough
			case 'e':
				cloexec = 1
				break
				fallthrough
			case 'x':
				exclusive = 1
				break
				fallthrough
			case 'f':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_FILTERED
				break
				fallthrough
			case 'h':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_HUFFMAN_ONLY
				break
				fallthrough
			case 'R':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_RLE
				break
				fallthrough
			case 'F':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_FIXED
				break
				fallthrough
			case 'T':
				(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1
				break
				fallthrough
			default: // could consider as an error, but just ignore

			}
		}
		mode++
	}

	// must provide an "r", "w", or "a"
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_NONE {
		libc.Xfree(tls, state)
		return uintptr(0)
	}

	// can't force transparent read
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		if (*Gz_state)(unsafe.Pointer(state)).Fdirect != 0 {
			libc.Xfree(tls, state)
			return uintptr(0)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1 // for empty file
	}

	// save the path name for error messages
	len = libc.Xstrlen(tls, path)
	(*Gz_state)(unsafe.Pointer(state)).Fpath = libc.Xmalloc(tls, (len + uint64(1)))
	if (*Gz_state)(unsafe.Pointer(state)).Fpath == (uintptr(0)) {
		libc.Xfree(tls, state)
		return uintptr(0)
	}
	libc.X__builtin___snprintf_chk(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath, (len + uint64(1)), 0, libc.X__builtin_object_size(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath, func() int32 {
		if X_USE_FORTIFY_LEVEL > 1 {
			return 1
		}
		return 0
	}()), ts+76 /* "%s" */, libc.VaList(bp, path))

	// compute the flags for open()
	oflag = ((func() int32 {
		if cloexec != 0 {
			return O_CLOEXEC
		}
		return 0
	}()) | (func() int32 {
		if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
			return O_RDONLY
		}
		return (((O_WRONLY | O_CREAT) | (func() int32 {
			if exclusive != 0 {
				return O_EXCL
			}
			return 0
		}())) | (func() int32 {
			if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_WRITE {
				return O_TRUNC
			}
			return O_APPEND
		}()))
	}()))

	// open the file with the appropriate flags (or just use fd)
	(*Gz_state)(unsafe.Pointer(state)).Ffd = func() int32 {
		if fd > -1 {
			return fd
		}
		return libc.Xopen(tls, path, oflag, libc.VaList(bp+8, 0666))
	}()
	if (*Gz_state)(unsafe.Pointer(state)).Ffd == -1 {
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
		libc.Xfree(tls, state)
		return uintptr(0)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_APPEND {
		libc.Xlseek(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_END) // so gzoffset() is correct
		(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_WRITE                          // simplify later checks
	}

	// save the current position for rewinding (only if reading)
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		(*Gz_state)(unsafe.Pointer(state)).Fstart = libc.Xlseek(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_CUR)
		if (*Gz_state)(unsafe.Pointer(state)).Fstart == int64(-1) {
			(*Gz_state)(unsafe.Pointer(state)).Fstart = int64(0)
		}
	}

	// initialize stream
	gz_reset(tls, state)

	// return stream
	return state
}

// -- see zlib.h --
func Xgzopen(tls *libc.TLS, path uintptr, mode uintptr) GzFile { /* gzlib.c:270:16: */
	return gz_open(tls, path, -1, mode)
}

// -- see zlib.h --
func Xgzopen64(tls *libc.TLS, path uintptr, mode uintptr) GzFile { /* gzlib.c:278:16: */
	return gz_open(tls, path, -1, mode)
}

// -- see zlib.h --
func Xgzdopen(tls *libc.TLS, fd int32, mode uintptr) GzFile { /* gzlib.c:286:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var path uintptr // identifier for error messages
	var gz GzFile

	if (fd == -1) || ((libc.AssignUintptr(&path, libc.Xmalloc(tls, (uint64(7)+(uint64(3)*uint64(unsafe.Sizeof(int32(0)))))))) == (uintptr(0))) {
		return uintptr(0)
	}
	libc.X__builtin___snprintf_chk(tls, path, (uint64(7) + (uint64(3) * uint64(unsafe.Sizeof(int32(0))))), 0, libc.X__builtin_object_size(tls, path, func() int32 {
		if X_USE_FORTIFY_LEVEL > 1 {
			return 1
		}
		return 0
	}()), ts+79 /* "<fd:%d>" */, libc.VaList(bp, fd))
	gz = gz_open(tls, path, fd, mode)
	libc.Xfree(tls, path)
	return gz
}

// -- see zlib.h --

// -- see zlib.h --
func Xgzbuffer(tls *libc.TLS, file GzFile, size uint32) int32 { /* gzlib.c:316:13: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return -1
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return -1
	}

	// make sure we haven't already allocated memory
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != uint32(0) {
		return -1
	}

	// check and set requested size
	if (size << 1) < size {
		return -1
	} // need to be able to double it
	if size < uint32(2) {
		size = uint32(2)
	} // need two bytes to check magic header
	(*Gz_state)(unsafe.Pointer(state)).Fwant = size
	return 0
}

// -- see zlib.h --
func Xgzrewind(tls *libc.TLS, file GzFile) int32 { /* gzlib.c:343:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// back up and start over
	if libc.Xlseek(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Gz_state)(unsafe.Pointer(state)).Fstart, SEEK_SET) == int64(-1) {
		return -1
	}
	gz_reset(tls, state)
	return 0
}

// -- see zlib.h --
func Xgzseek64(tls *libc.TLS, file GzFile, offset Off_t, whence int32) Off_t { /* gzlib.c:366:19: */
	var n uint32
	var ret Off_t
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// check that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return int64(-1)
	}

	// can only seek from start or relative to current position
	if (whence != SEEK_SET) && (whence != SEEK_CUR) {
		return int64(-1)
	}

	// normalize offset to a SEEK_CUR specification
	if whence == SEEK_SET {
		offset = offset - ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos)
	} else if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		offset = offset + ((*Gz_state)(unsafe.Pointer(state)).Fskip)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fseek = 0

	// if within raw area while reading, just go there
	if (((*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fhow == COPY1)) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + offset) >= int64(0)) {
		ret = libc.Xlseek(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (offset - Off_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave)), SEEK_CUR)
		if ret == int64(-1) {
			return int64(-1)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		Xgz_error(tls, state, Z_OK, uintptr(0))
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0)
		*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (offset)
		return (*Gz_state)(unsafe.Pointer(state)).Fx.Fpos
	}

	// calculate skip amount, rewinding if needed for back seek when reading
	if offset < int64(0) {
		if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ { // writing -- can't go backwards
			return int64(-1)
		}
		offset = offset + ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos)
		if offset < int64(0) { // before start of file!
			return int64(-1)
		}
		if Xgzrewind(tls, file) == -1 { // rewind, then skip to offset
			return int64(-1)
		}
	}

	// if reading, skip what's in output buffer (one less gzgetc() check)
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		if ((uint64(unsafe.Sizeof(int32(0))) == uint64(unsafe.Sizeof(Off_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > uint32(0x7fffffff))) || (Off_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > offset) {
			n = uint32(offset)
		} else {
			n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
		}
		*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
		*(*uintptr)(unsafe.Pointer(state /* &.x */ + 8 /* &.next */)) += (uintptr(n))
		*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(n))
		offset = offset - (Off_t(n))
	}

	// request skip (if not zero)
	if offset != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 1
		(*Gz_state)(unsafe.Pointer(state)).Fskip = offset
	}
	return ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + offset)
}

// -- see zlib.h --
func Xgzseek(tls *libc.TLS, file GzFile, offset Off_t, whence int32) Off_t { /* gzlib.c:443:17: */
	var ret Off_t

	ret = Xgzseek64(tls, file, offset, whence)
	if ret == ret {
		return ret
	}
	return int64(-1)
}

// -- see zlib.h --
func Xgztell64(tls *libc.TLS, file GzFile) Off_t { /* gzlib.c:455:19: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// return position
	return ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + (func() int64 {
		if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
			return (*Gz_state)(unsafe.Pointer(state)).Fskip
		}
		return int64(0)
	}()))
}

// -- see zlib.h --
func Xgztell(tls *libc.TLS, file GzFile) Off_t { /* gzlib.c:472:17: */
	var ret Off_t

	ret = Xgztell64(tls, file)
	if ret == ret {
		return ret
	}
	return int64(-1)
}

// -- see zlib.h --
func Xgzoffset64(tls *libc.TLS, file GzFile) Off_t { /* gzlib.c:482:19: */
	var offset Off_t
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// compute and return effective offset in file
	offset = libc.Xlseek(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_CUR)
	if offset == int64(-1) {
		return int64(-1)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ { // reading
		offset = offset - (Off_t((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in))
	} // don't count buffered input
	return offset
}

// -- see zlib.h --
func Xgzoffset(tls *libc.TLS, file GzFile) Off_t { /* gzlib.c:505:17: */
	var ret Off_t

	ret = Xgzoffset64(tls, file)
	if ret == ret {
		return ret
	}
	return int64(-1)
}

// -- see zlib.h --
func Xgzeof(tls *libc.TLS, file GzFile) int32 { /* gzlib.c:515:13: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return 0
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return 0
	}

	// return end-of-file state
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		return (*Gz_state)(unsafe.Pointer(state)).Fpast
	}
	return 0
}

// -- see zlib.h --
func Xgzerror(tls *libc.TLS, file GzFile, errnum uintptr) uintptr { /* gzlib.c:532:12: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return uintptr(0)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return uintptr(0)
	}

	// return error information
	if errnum != (uintptr(0)) {
		*(*int32)(unsafe.Pointer(errnum)) = (*Gz_state)(unsafe.Pointer(state)).Ferr
	}
	if (*Gz_state)(unsafe.Pointer(state)).Ferr == (-4) {
		return ts + 87 /* "out of memory" */
	}
	return func() uintptr {
		if (*Gz_state)(unsafe.Pointer(state)).Fmsg == (uintptr(0)) {
			return ts + 101 /* "" */
		}
		return (*Gz_state)(unsafe.Pointer(state)).Fmsg
	}()
}

// -- see zlib.h --
func Xgzclearerr(tls *libc.TLS, file GzFile) { /* gzlib.c:553:14: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return
	}

	// clear error and end-of-file
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
}

// Create an error message in allocated memory and set state->err and
//    state->msg accordingly.  Free any previous error message already there.  Do
//    not try to free or allocate space if the error is Z_MEM_ERROR (out of
//    memory).  Simply save the error message as a static string.  If there is an
//    allocation failure constructing the error message, then convert the error to
//    out of memory.
func Xgz_error(tls *libc.TLS, state Gz_statep, err int32, msg uintptr) { /* gzlib.c:579:20: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// free previously allocated message and clear
	if (*Gz_state)(unsafe.Pointer(state)).Fmsg != (uintptr(0)) {
		if (*Gz_state)(unsafe.Pointer(state)).Ferr != (-4) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fmsg)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fmsg = uintptr(0)
	}

	// if fatal, set state->x.have to 0 so that the gzgetc() macro fails
	if (err != Z_OK) && (err != (-5)) {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
	}

	// set error code, and if no message, then done
	(*Gz_state)(unsafe.Pointer(state)).Ferr = err
	if msg == (uintptr(0)) {
		return
	}

	// for an out of memory error, return literal string when requested
	if err == (-4) {
		return
	}

	// construct error message with path
	if (libc.AssignPtrUintptr(state+112 /* &.msg */, libc.Xmalloc(tls, ((libc.Xstrlen(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)+libc.Xstrlen(tls, msg))+uint64(3))))) == (uintptr(0)) {
		(*Gz_state)(unsafe.Pointer(state)).Ferr = -4
		return
	}
	libc.X__builtin___snprintf_chk(tls, (*Gz_state)(unsafe.Pointer(state)).Fmsg, ((libc.Xstrlen(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath) + libc.Xstrlen(tls, msg)) + uint64(3)), 0, libc.X__builtin_object_size(tls, (*Gz_state)(unsafe.Pointer(state)).Fmsg, func() int32 {
		if X_USE_FORTIFY_LEVEL > 1 {
			return 1
		}
		return 0
	}()), ts+102 /* "%s%s%s" */, libc.VaList(bp, (*Gz_state)(unsafe.Pointer(state)).Fpath, ts+109 /* ": " */, msg))
}

// Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
//    state->fd, and update state->eof, state->err, and state->msg as appropriate.
//    This function needs to loop on read(), since read() is not guaranteed to
//    read the number of bytes requested, depending on the type of descriptor.
func gz_load(tls *libc.TLS, state Gz_statep, buf uintptr, len uint32, have uintptr) int32 { /* gzread.c:21:11: */
	var ret int32
	var get uint32
	var max uint32 = ((uint32(libc.Uint32(libc.Uint32FromInt32(-1))) >> 2) + uint32(1))

	*(*uint32)(unsafe.Pointer(have)) = uint32(0)
	for ok := true; ok; ok = (*(*uint32)(unsafe.Pointer(have)) < len) {
		get = (len - *(*uint32)(unsafe.Pointer(have)))
		if get > max {
			get = max
		}
		ret = int32(libc.Xread(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (buf + uintptr(*(*uint32)(unsafe.Pointer(have)))), uint64(get)))
		if ret <= 0 {
			break
		}
		*(*uint32)(unsafe.Pointer(have)) += (uint32(ret))
	}
	if ret < 0 {
		Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__error(tls)))))
		return -1
	}
	if ret == 0 {
		(*Gz_state)(unsafe.Pointer(state)).Feof = 1
	}
	return 0
}

// Load up input buffer and set eof flag if last data loaded -- return -1 on
//    error, 0 otherwise.  Note that the eof flag is set when the end of the input
//    file is reached, even though there may be unused data in the buffer.  Once
//    that data has been used, no more attempts will be made to read the file.
//    If strm->avail_in != 0, then the current data is moved to the beginning of
//    the input buffer, and then the remainder of the buffer is loaded with the
//    available data from the input file.
func gz_avail(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:56:11: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var got uint32 at bp, 4

	var strm Z_streamp = (state + 120 /* &.strm */)

	if ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return -1
	}
	if (*Gz_state)(unsafe.Pointer(state)).Feof == 0 {
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 { // copy what's there to the start
			var p uintptr = (*Gz_state)(unsafe.Pointer(state)).Fin
			var q uintptr = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
			var n uint32 = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
			for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
				*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1)))
			}
		}
		if gz_load(tls, state, ((*Gz_state)(unsafe.Pointer(state)).Fin+uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in)),
			((*Gz_state)(unsafe.Pointer(state)).Fsize-(*Z_stream)(unsafe.Pointer(strm)).Favail_in), bp /* &got */) == -1 {
			return -1
		}
		*(*UInt)(unsafe.Pointer(strm + 8 /* &.avail_in */)) += (*(*uint32)(unsafe.Pointer(bp /* got */)))
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
	}
	return 0
}

// Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
//    If this is the first time in, allocate required memory.  state->how will be
//    left unchanged if there is no more input data available, will be set to COPY
//    if there is no gzip header and direct copying will be performed, or it will
//    be set to GZIP for decompression.  If direct copying, then leftover input
//    data from the input buffer will be copied to the output buffer.  In that
//    case, all further file reads will be directly to either the output buffer or
//    a user buffer.  If decompressing, the inflate state will be initialized.
//    gz_look() will return 0 on success or -1 on failure.
func gz_look(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:91:11: */
	var strm Z_streamp = (state + 120 /* &.strm */)

	// allocate read buffers and inflate memory
	if (*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0) {
		// allocate buffers
		(*Gz_state)(unsafe.Pointer(state)).Fin = libc.Xmalloc(tls, uint64((*Gz_state)(unsafe.Pointer(state)).Fwant))
		(*Gz_state)(unsafe.Pointer(state)).Fout = libc.Xmalloc(tls, (uint64((*Gz_state)(unsafe.Pointer(state)).Fwant << 1)))
		if ((*Gz_state)(unsafe.Pointer(state)).Fin == (uintptr(0))) || ((*Gz_state)(unsafe.Pointer(state)).Fout == (uintptr(0))) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		(*Gz_state)(unsafe.Pointer(state)).Fsize = (*Gz_state)(unsafe.Pointer(state)).Fwant

		// allocate inflate memory
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fzalloc = Z_NULL
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fzfree = Z_NULL
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fopaque = Z_NULL
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0)
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = Z_NULL
		if (XinflateInit2_(tls, (state+120 /* &.strm */), (15+16), ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{}))) != Z_OK) { // gunzip
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			(*Gz_state)(unsafe.Pointer(state)).Fsize = uint32(0)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
	}

	// get at least the magic bytes in the input buffer
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in < UInt(2) {
		if gz_avail(tls, state) == -1 {
			return -1
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			return 0
		}
	}

	// look for gzip magic bytes -- if there, do gzip decoding (note: there is
	//        a logical dilemma here when considering the case of a partially written
	//        gzip file, to wit, if a single 31 byte is written, then we cannot tell
	//        whether this is a single-byte file, or just a partially written gzip
	//        file -- for here we assume that if a gzip file is being written, then
	//        the header will be written in a single operation, so that reading a
	//        single byte is sufficient indication that it is not a gzip file)
	if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in > UInt(1)) && (int32(*(*Bytef)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fnext_in))) == 31)) && (int32(*(*Bytef)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fnext_in + 1))) == 139) {
		XinflateReset(tls, strm)
		(*Gz_state)(unsafe.Pointer(state)).Fhow = /* GZIP */ 2
		(*Gz_state)(unsafe.Pointer(state)).Fdirect = 0
		return 0
	}

	// no gzip header -- if we were decoding gzip before, then this is trailing
	//        garbage.  Ignore the trailing garbage and finish.
	if (*Gz_state)(unsafe.Pointer(state)).Fdirect == 0 {
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = UInt(0)
		(*Gz_state)(unsafe.Pointer(state)).Feof = 1
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		return 0
	}

	// doing raw i/o, copy any leftover input to output -- this assumes that
	//        the output buffer is larger than the input buffer, which also assures
	//        space for gzungetc()
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 {
		libc.X__builtin___memcpy_chk(tls, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, uint64((*Z_stream)(unsafe.Pointer(strm)).Favail_in), libc.X__builtin_object_size(tls, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, 0))
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = UInt(0)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fhow = COPY1
	(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1
	return 0
}

// Decompress from input to the provided next_out and avail_out in the state.
//    On return, state->x.have and state->x.next point to the just decompressed
//    data.  If the gzip stream completes, state->how is reset to LOOK to look for
//    the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
//    on success, -1 on failure.
func gz_decomp(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:175:11: */
	var ret int32 = Z_OK
	var had uint32
	var strm Z_streamp = (state + 120 /* &.strm */)

	// fill output buffer up to end of deflate stream
	had = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	for ok := true; ok; ok = (((*Z_stream)(unsafe.Pointer(strm)).Favail_out != 0) && (ret != Z_STREAM_END)) {
		// get more input for inflate()
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && (gz_avail(tls, state) == -1) {
			return -1
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			Xgz_error(tls, state, -5, ts+112 /* "unexpected end o..." */)
			break
		}

		// decompress and handle errors
		ret = Xinflate(tls, strm, Z_NO_FLUSH)
		if (ret == (-2)) || (ret == Z_NEED_DICT) {
			Xgz_error(tls, state, -2,
				ts+135 /* "internal error: ..." */)
			return -1
		}
		if ret == (-4) {
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		if ret == (-3) { // deflate stream invalid
			Xgz_error(tls, state, -3,
				func() uintptr {
					if (*Z_stream)(unsafe.Pointer(strm)).Fmsg == (uintptr(0)) {
						return ts + 174 /* "compressed data ..." */
					}
					return (*Z_stream)(unsafe.Pointer(strm)).Fmsg
				}())
			return -1
		}
	}

	// update available output
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = (had - (*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave))

	// if the gzip stream completed successfully, look for another
	if ret == Z_STREAM_END {
		(*Gz_state)(unsafe.Pointer(state)).Fhow = LOOK
	}

	// good decompression
	return 0
}

// Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
//    Data is either copied from the input file or decompressed from the input
//    file depending on state->how.  If state->how is LOOK, then a gzip header is
//    looked for to determine whether to copy or decompress.  Returns -1 on error,
//    otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
//    end of the input file has been reached and all data has been processed.
func gz_fetch(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:229:11: */
	var strm Z_streamp = (state + 120 /* &.strm */)

	for ok := true; ok; ok = (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) && (!((*Gz_state)(unsafe.Pointer(state)).Feof != 0) || ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0))) {
		switch (*Gz_state)(unsafe.Pointer(state)).Fhow {
		case LOOK: // -> LOOK, COPY (only if never GZIP), or GZIP
			if gz_look(tls, state) == -1 {
				return -1
			}
			if (*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK {
				return 0
			}
			break
		case COPY1: // -> COPY
			if gz_load(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fout, ((*Gz_state)(unsafe.Pointer(state)).Fsize<<1), (state /* &.x */ /* &.have */)) ==
				-1 {
				return -1
			}
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
			return 0
		case /* GZIP */ 2: // -> GZIP or LOOK (if end of gzip stream)
			(*Z_stream)(unsafe.Pointer(strm)).Favail_out = ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)
			(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
			if gz_decomp(tls, state) == -1 {
				return -1
			}
		}
	}
	return 0
}

// Skip len uncompressed bytes of output.  Return -1 on error, 0 on success.
func gz_skip(tls *libc.TLS, state Gz_statep, len Off_t) int32 { /* gzread.c:259:11: */
	var n uint32

	// skip over len bytes or reach end-of-file, whichever comes first
	for len != 0 {
		// skip over whatever is in output buffer
		if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
			if ((uint64(unsafe.Sizeof(int32(0))) == uint64(unsafe.Sizeof(Off_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > uint32(0x7fffffff))) || (Off_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > len) {
				n = uint32(len)
			} else {
				n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 8 /* &.next */)) += (uintptr(n))
			*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(n))
			len = len - (Off_t(n))
		} else if ((*Gz_state)(unsafe.Pointer(state)).Feof != 0) && ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0)) {
			break
		} else {
			// get more output, looking for header if required
			if gz_fetch(tls, state) == -1 {
				return -1
			}
		}
	}
	return 0
}

// Read len bytes into buf from file, or less than len up to the end of the
//    input.  Return the number of bytes read.  If zero is returned, either the
//    end of file was reached, or there was an error.  state->err must be
//    consulted in that case to determine which.
func gz_read(tls *libc.TLS, state Gz_statep, buf Voidp, len Z_size_t) Z_size_t { /* gzread.c:294:16: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var got Z_size_t
	// var n uint32 at bp, 4

	// if len is zero, avoid unnecessary operations
	if len == uint64(0) {
		return uint64(0)
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return uint64(0)
		}
	}

	// get len bytes to buf, or less than len if at the end
	got = uint64(0)
	for ok := true; ok; ok = len != 0 {
		// set n to the maximum amount of len that fits in an unsigned int
		*(*uint32)(unsafe.Pointer(bp /* n */)) = libc.Uint32FromInt32(-1)
		if Z_size_t(*(*uint32)(unsafe.Pointer(bp /* n */))) > len {
			*(*uint32)(unsafe.Pointer(bp /* n */)) = uint32(len)
		}

		// first just try copying data from the output buffer
		if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave < *(*uint32)(unsafe.Pointer(bp /* n */)) {
				*(*uint32)(unsafe.Pointer(bp /* n */)) = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			libc.X__builtin___memcpy_chk(tls, buf, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, uint64(*(*uint32)(unsafe.Pointer(bp /* n */))), libc.X__builtin_object_size(tls, buf, 0))
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 8 /* &.next */)) += (uintptr(*(*uint32)(unsafe.Pointer(bp /* n */))))
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (*(*uint32)(unsafe.Pointer(bp /* n */)))
		} else if ((*Gz_state)(unsafe.Pointer(state)).Feof != 0) && ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0)) {
			(*Gz_state)(unsafe.Pointer(state)).Fpast = 1 // tried to read past end
			break
		} else if ((*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK) || (*(*uint32)(unsafe.Pointer(bp /* n */)) < ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)) {
			// get more output, looking for header if required
			if gz_fetch(tls, state) == -1 {
				return uint64(0)
			}
			continue // no progress yet -- go back to copy above
			// the copy above assures that we will leave with space in the
			//                output buffer, allowing at least one gzungetc() to succeed
		} else if (*Gz_state)(unsafe.Pointer(state)).Fhow == COPY1 { // read directly
			if gz_load(tls, state, buf, *(*uint32)(unsafe.Pointer(bp /* n */)), bp /* &n */) == -1 {
				return uint64(0)
			}
		} else { // state->how == GZIP
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_out = *(*uint32)(unsafe.Pointer(bp /* n */))
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_out = buf
			if gz_decomp(tls, state) == -1 {
				return uint64(0)
			}
			*(*uint32)(unsafe.Pointer(bp /* n */)) = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		}

		// update progress
		len = len - (Z_size_t(*(*uint32)(unsafe.Pointer(bp /* n */))))
		buf = (buf + uintptr(*(*uint32)(unsafe.Pointer(bp /* n */))))
		got = got + (Z_size_t(*(*uint32)(unsafe.Pointer(bp /* n */))))
		*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(*(*uint32)(unsafe.Pointer(bp /* n */))))
	}

	// return number of bytes read into user buffer
	return got
}

// -- see zlib.h --
func Xgzread(tls *libc.TLS, file GzFile, buf Voidp, len uint32) int32 { /* gzread.c:375:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// since an int is returned, make sure len fits in one, otherwise return
	//        with an error (this avoids a flaw in the interface)
	if int32(len) < 0 {
		Xgz_error(tls, state, -2, ts+196 /* "request does not..." */)
		return -1
	}

	// read len or fewer bytes to buf
	len = uint32(gz_read(tls, state, buf, uint64(len)))

	// check for an error
	if ((len == uint32(0)) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK)) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return -1
	}

	// return the number of bytes read (this is assured to fit in an int)
	return int32(len)
}

// -- see zlib.h --
func Xgzfread(tls *libc.TLS, buf Voidp, size Z_size_t, nitems Z_size_t, file GzFile) Z_size_t { /* gzread.c:411:18: */
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return uint64(0)
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return uint64(0)
	}

	// compute bytes to read -- error on overflow
	len = (nitems * size)
	if (size != 0) && ((len / size) != nitems) {
		Xgz_error(tls, state, -2, ts+227 /* "request does not..." */)
		return uint64(0)
	}

	// read len or fewer bytes to buf, return the number of full items read
	if len != 0 {
		return (gz_read(tls, state, buf, len) / size)
	}
	return uint64(0)
}

// -- see zlib.h --
func Xgzgetc(tls *libc.TLS, file GzFile) int32 { /* gzread.c:447:13: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var ret int32
	// var buf [1]uint8 at bp, 1

	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// try output buffer (no need to check for skip request)
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave--
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos++
		return int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext), 1))))
	}

	// nothing there -- try gz_read()
	ret = int32(gz_read(tls, state, bp /* &buf[0] */, uint64(1)))
	if ret < 1 {
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer(bp /* &buf[0] */)))
}

func Xgzgetc_(tls *libc.TLS, file GzFile) int32 { /* gzread.c:476:13: */
	return Xgzgetc(tls, file)
}

// -- see zlib.h --
func Xgzungetc(tls *libc.TLS, c int32, file GzFile) int32 { /* gzread.c:483:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return -1
		}
	}

	// can't push EOF
	if c < 0 {
		return -1
	}

	// if output buffer empty, put byte at end (allows more pushing)
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0) {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(1)
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize << 1))) - uintptr(1))
		*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) = uint8(c)
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos--
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
		return c
	}

	// if no room, give up (must have already done a gzungetc())
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1) {
		Xgz_error(tls, state, -3, ts+260 /* "out of room to p..." */)
		return -1
	}

	// slide output data if needed and insert byte before existing data
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext == (*Gz_state)(unsafe.Pointer(state)).Fout {
		var src uintptr = ((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave))
		var dest uintptr = ((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)))
		for src > (*Gz_state)(unsafe.Pointer(state)).Fout {
			*(*uint8)(unsafe.Pointer(libc.PreDecUintptr(&dest, 1))) = *(*uint8)(unsafe.Pointer(libc.PreDecUintptr(&src, 1)))
		}
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = dest
	}
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave++
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext--
	*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) = uint8(c)
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos--
	(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
	return c
}

// -- see zlib.h --
func Xgzgets(tls *libc.TLS, file GzFile, buf uintptr, len int32) uintptr { /* gzread.c:543:6: */
	var left uint32
	var n uint32
	var str uintptr
	var eol uintptr
	var state Gz_statep

	// check parameters and get internal structure
	if ((file == (uintptr(0))) || (buf == (uintptr(0)))) || (len < 1) {
		return uintptr(0)
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return uintptr(0)
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return uintptr(0)
		}
	}

	// copy output bytes up to new line or len - 1, whichever comes first --
	//        append a terminating zero to the string (we don't check for a zero in
	//        the contents, let the user worry about that)
	str = buf
	left = (uint32(len) - uint32(1))
	if left != 0 {
		for ok := true; ok; ok = ((left != 0) && (eol == (uintptr(0)))) {
			// assure that something is in the output buffer
			if ((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) && (gz_fetch(tls, state) == -1) {
				return uintptr(0)
			} // error
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0) { // end of file
				(*Gz_state)(unsafe.Pointer(state)).Fpast = 1 // read past end
				break                                        // return what we have
			}

			// look for end-of-line in current output buffer
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave > left {
				n = left
			} else {
				n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			eol = libc.Xmemchr(tls, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, '\n', uint64(n))
			if eol != (uintptr(0)) {
				n = ((uint32((int64(eol) - int64((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1)) + uint32(1))
			}

			// copy through end-of-line, or remainder if not found
			libc.X__builtin___memcpy_chk(tls, buf, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, uint64(n), libc.X__builtin_object_size(tls, buf, 0))
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 8 /* &.next */)) += (uintptr(n))
			*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(n))
			left = left - (n)
			buf += uintptr(n)
		}
	}

	// return terminated string, or if nothing, end of file
	if buf == str {
		return uintptr(0)
	}
	*(*int8)(unsafe.Pointer(buf)) = int8(0)
	return str
}

// -- see zlib.h --
func Xgzdirect(tls *libc.TLS, file GzFile) int32 { /* gzread.c:607:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return 0
	}
	state = file

	// if the state is not known, but we can find out, then do so (this is
	//        mainly for right after a gzopen() or gzdopen())
	if (((*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK)) && ((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) {
		gz_look(tls, state)
	}

	// return 1 if transparent, 0 if processing a gzip stream
	return (*Gz_state)(unsafe.Pointer(state)).Fdirect
}

// -- see zlib.h --
func Xgzclose_r(tls *libc.TLS, file GzFile) int32 { /* gzread.c:627:13: */
	var ret int32
	var err int32
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're reading
	if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ {
		return -2
	}

	// free memory and close file
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		XinflateEnd(tls, (state + 120 /* &.strm */))
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Ferr == (-5) {
		err = -5
	} else {
		err = Z_OK
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
	libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
	ret = libc.Xclose(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd)
	libc.Xfree(tls, state)
	if ret != 0 {
		return -1
	}
	return err
}

// Initialize state for writing a gzip file.  Mark initialization by setting
//    state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
//    success.
func gz_init(tls *libc.TLS, state Gz_statep) int32 { /* gzwrite.c:17:11: */
	var ret int32
	var strm Z_streamp = (state + 120 /* &.strm */)

	// allocate input buffer (double size for gzprintf)
	(*Gz_state)(unsafe.Pointer(state)).Fin = libc.Xmalloc(tls, (uint64((*Gz_state)(unsafe.Pointer(state)).Fwant << 1)))
	if (*Gz_state)(unsafe.Pointer(state)).Fin == (uintptr(0)) {
		Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
		return -1
	}

	// only need output buffer and deflate state if compressing
	if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
		// allocate output buffer
		(*Gz_state)(unsafe.Pointer(state)).Fout = libc.Xmalloc(tls, uint64((*Gz_state)(unsafe.Pointer(state)).Fwant))
		if (*Gz_state)(unsafe.Pointer(state)).Fout == (uintptr(0)) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}

		// allocate deflate memory, set up for gzip compression
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = Z_NULL
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = Z_NULL
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = Z_NULL
		ret = XdeflateInit2_(tls, strm, (*Gz_state)(unsafe.Pointer(state)).Flevel, Z_DEFLATED, (MAX_WBITS + 16), DEF_MEM_LEVEL, (*Gz_state)(unsafe.Pointer(state)).Fstrategy, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
		if ret != Z_OK {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = uintptr(0)
	}

	// mark state as initialized
	(*Gz_state)(unsafe.Pointer(state)).Fsize = (*Gz_state)(unsafe.Pointer(state)).Fwant

	// initialize write buffer if compressing
	if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
		(*Z_stream)(unsafe.Pointer(strm)).Favail_out = (*Gz_state)(unsafe.Pointer(state)).Fsize
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	}
	return 0
}

// Compress whatever is at avail_in and next_in and write to the output file.
//    Return -1 if there is an error writing to the output file or if gz_init()
//    fails to allocate memory, otherwise 0.  flush is assumed to be a valid
//    deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
//    reset to start a new gzip stream.  If gz->direct is true, then simply write
//    to the output file without compressing, and ignore flush.
func gz_comp(tls *libc.TLS, state Gz_statep, flush int32) int32 { /* gzwrite.c:73:11: */
	var ret int32
	var writ int32
	var have uint32
	var put uint32
	var max uint32 = ((uint32(libc.Uint32(libc.Uint32FromInt32(-1))) >> 2) + uint32(1))
	var strm Z_streamp = (state + 120 /* &.strm */)

	// allocate memory if this is the first time through
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return -1
	}

	// write directly if requested
	if (*Gz_state)(unsafe.Pointer(state)).Fdirect != 0 {
		for (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 {
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_in > max {
				put = max
			} else {
				put = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
			}
			writ = int32(libc.Xwrite(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, uint64(put)))
			if writ < 0 {
				Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__error(tls)))))
				return -1
			}
			*(*UInt)(unsafe.Pointer(strm + 8 /* &.avail_in */)) -= (uint32(writ))
			*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(writ))
		}
		return 0
	}

	// run deflate() on provided input until it produces no more output
	ret = Z_OK
	for ok := true; ok; ok = have != 0 {
		// write out current buffer contents if full, or if flushing, but if
		//            doing Z_FINISH then don't write until we get to Z_STREAM_END
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0)) || ((flush != Z_NO_FLUSH) && ((flush != Z_FINISH) || (ret == Z_STREAM_END))) {
			for (*Z_stream)(unsafe.Pointer(strm)).Fnext_out > (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext {
				if ((int64((*Z_stream)(unsafe.Pointer(strm)).Fnext_out) - int64((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1) > int64(int32(max)) {
					put = max
				} else {
					put = (uint32((int64((*Z_stream)(unsafe.Pointer(strm)).Fnext_out) - int64((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1))
				}
				writ = int32(libc.Xwrite(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, uint64(put)))
				if writ < 0 {
					Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__error(tls)))))
					return -1
				}
				*(*uintptr)(unsafe.Pointer(state /* &.x */ + 8 /* &.next */)) += (uintptr(writ))
			}
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Z_stream)(unsafe.Pointer(strm)).Favail_out = (*Gz_state)(unsafe.Pointer(state)).Fsize
				(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
				(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
			}
		}

		// compress
		have = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
		ret = Xdeflate(tls, strm, flush)
		if ret == (-2) {
			Xgz_error(tls, state, -2,
				ts+291 /* "internal error: ..." */)
			return -1
		}
		have = have - ((*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	}

	// if that completed a deflate stream, allow another to start
	if flush == Z_FINISH {
		XdeflateReset(tls, strm)
	}

	// all done, no errors
	return 0
}

// Compress len zeros to output.  Return -1 on a write error or memory
//    allocation failure by gz_comp(), or 0 on success.
func gz_zero(tls *libc.TLS, state Gz_statep, len Off_t) int32 { /* gzwrite.c:145:11: */
	var first int32
	var n uint32
	var strm Z_streamp = (state + 120 /* &.strm */)

	// consume whatever's left in the input buffer
	if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
		return -1
	}

	// compress len zeros (len guaranteed > 0)
	first = 1
	for len != 0 {
		if ((uint64(unsafe.Sizeof(int32(0))) == uint64(unsafe.Sizeof(Off_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fsize) > uint32(0x7fffffff))) || (Off_t((*Gz_state)(unsafe.Pointer(state)).Fsize) > len) {
			n = uint32(len)
		} else {
			n = (*Gz_state)(unsafe.Pointer(state)).Fsize
		}
		if first != 0 {
			libc.X__builtin___memset_chk(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, 0, uint64(n), libc.X__builtin_object_size(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, 0))
			first = 0
		}
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = n
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(n))
		if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
			return -1
		}
		len = len - (Off_t(n))
	}
	return 0
}

// Write len bytes from buf to file.  Return the number of bytes written.  If
//    the returned value is less than len, then there was an error.
func gz_write(tls *libc.TLS, state Gz_statep, buf Voidpc, len Z_size_t) Z_size_t { /* gzwrite.c:178:16: */
	var put Z_size_t = len

	// if len is zero, avoid unnecessary operations
	if len == uint64(0) {
		return uint64(0)
	}

	// allocate memory if this is the first time through
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return uint64(0)
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return uint64(0)
		}
	}

	// for small len, copy to input buffer, otherwise compress directly
	if len < Z_size_t((*Gz_state)(unsafe.Pointer(state)).Fsize) {
		// copy to input buffer, compress when full
		for ok := true; ok; ok = len != 0 {
			var have uint32
			var copy uint32

			if (*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0) {
				(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
			}
			have = (uint32(((int64((*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in + uintptr((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in))) - int64((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))
			copy = ((*Gz_state)(unsafe.Pointer(state)).Fsize - have)
			if Z_size_t(copy) > len {
				copy = uint32(len)
			}
			libc.X__builtin___memcpy_chk(tls, ((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(have)), buf, uint64(copy), libc.X__builtin_object_size(tls, ((*Gz_state)(unsafe.Pointer(state)).Fin+uintptr(have)), 0))
			*(*UInt)(unsafe.Pointer(state + 120 /* &.strm */ + 8 /* &.avail_in */)) += (copy)
			*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(copy))
			buf = (buf + uintptr(copy))
			len = len - (Z_size_t(copy))
			if (len != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
				return uint64(0)
			}
		}
	} else {
		// consume whatever's left in the input buffer
		if ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
			return uint64(0)
		}

		// directly compress user buffer to file
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = buf
		for ok1 := true; ok1; ok1 = len != 0 {
			var n uint32 = libc.Uint32(libc.Uint32FromInt32(-1))
			if Z_size_t(n) > len {
				n = uint32(len)
			}
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = n
			*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(n))
			if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
				return uint64(0)
			}
			len = len - (Z_size_t(n))
		}
	}

	// input was all buffered or compressed
	return put
}

// -- see zlib.h --
func Xgzwrite(tls *libc.TLS, file GzFile, buf Voidpc, len uint32) int32 { /* gzwrite.c:246:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return 0
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return 0
	}

	// since an int is returned, make sure len fits in one, otherwise return
	//        with an error (this avoids a flaw in the interface)
	if int32(len) < 0 {
		Xgz_error(tls, state, -3, ts+330 /* "requested length..." */)
		return 0
	}

	// write len bytes from buf (the return value will fit in an int)
	return int32(gz_write(tls, state, buf, uint64(len)))
}

// -- see zlib.h --
func Xgzfwrite(tls *libc.TLS, buf Voidpc, size Z_size_t, nitems Z_size_t, file GzFile) Z_size_t { /* gzwrite.c:274:18: */
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return uint64(0)
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return uint64(0)
	}

	// compute bytes to read -- error on overflow
	len = (nitems * size)
	if (size != 0) && ((len / size) != nitems) {
		Xgz_error(tls, state, -2, ts+227 /* "request does not..." */)
		return uint64(0)
	}

	// write len bytes to buf, return the number of full items written
	if len != 0 {
		return (gz_write(tls, state, buf, len) / size)
	}
	return uint64(0)
}

// -- see zlib.h --
func Xgzputc(tls *libc.TLS, file GzFile, c int32) int32 { /* gzwrite.c:304:13: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var have uint32
	// var buf [1]uint8 at bp, 1

	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file
	strm = (state + 120 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -1
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return -1
		}
	}

	// try writing to input buffer for speed (state->size == 0 if buffer not
	//        initialized)
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		}
		have = (uint32(((int64((*Z_stream)(unsafe.Pointer(strm)).Fnext_in + uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in))) - int64((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))
		if have < (*Gz_state)(unsafe.Pointer(state)).Fsize {
			*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(have))) = uint8(c)
			(*Z_stream)(unsafe.Pointer(strm)).Favail_in++
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos++
			return (c & 0xff)
		}
	}

	// no room in buffer or not initialized, use gz_write()
	*(*uint8)(unsafe.Pointer(bp /* &buf[0] */)) = uint8(c)
	if gz_write(tls, state, bp /* &buf[0] */, uint64(1)) != uint64(1) {
		return -1
	}
	return (c & 0xff)
}

// -- see zlib.h --
func Xgzputs(tls *libc.TLS, file GzFile, str uintptr) int32 { /* gzwrite.c:352:13: */
	var ret int32
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -1
	}

	// write string
	len = libc.Xstrlen(tls, str)
	ret = int32(gz_write(tls, state, str, len))
	if (ret == 0) && (len != uint64(0)) {
		return -1
	}
	return ret
}

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// -- see zlib.h --
func Xgzvprintf(tls *libc.TLS, file GzFile, format uintptr, va Va_list) int32 { /* gzwrite.c:379:15: */
	var len int32
	var left uint32
	var next uintptr
	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file
	strm = (state + 120 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// make sure we have some buffer space
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return (*Gz_state)(unsafe.Pointer(state)).Ferr
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// do the printf() into the input buffer, put length in len -- the input
	//        buffer is double-sized just for this function, so there is guaranteed to
	//        be state->size bytes available after the current contents
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
	}
	next = (((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(((int64((*Z_stream)(unsafe.Pointer(strm)).Fnext_in) - int64((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))) + uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in))
	*(*int8)(unsafe.Pointer(next + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize - uint32(1))))) = int8(0)
	len = libc.X__builtin___vsnprintf_chk(tls, next, uint64((*Gz_state)(unsafe.Pointer(state)).Fsize), 0, libc.X__builtin_object_size(tls, next, func() int32 {
		if X_USE_FORTIFY_LEVEL > 1 {
			return 1
		}
		return 0
	}()), format, va)

	// check that printf() results fit in buffer
	if ((len == 0) || (uint32(len) >= (*Gz_state)(unsafe.Pointer(state)).Fsize)) || (int32(*(*int8)(unsafe.Pointer(next + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize - uint32(1)))))) != 0) {
		return 0
	}

	// update buffer and position, compress first half if past that
	*(*UInt)(unsafe.Pointer(strm + 8 /* &.avail_in */)) += (uint32(len))
	*(*Off_t)(unsafe.Pointer(state /* &.x */ + 16 /* &.pos */)) += (Off_t(len))
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in >= (*Gz_state)(unsafe.Pointer(state)).Fsize {
		left = ((*Z_stream)(unsafe.Pointer(strm)).Favail_in - (*Gz_state)(unsafe.Pointer(state)).Fsize)
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = (*Gz_state)(unsafe.Pointer(state)).Fsize
		if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
		libc.X__builtin___memcpy_chk(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, ((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr((*Gz_state)(unsafe.Pointer(state)).Fsize)), uint64(left), libc.X__builtin_object_size(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, 0))
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = left
	}
	return len
}

func Xgzprintf(tls *libc.TLS, file GzFile, format uintptr, va uintptr) int32 { /* gzwrite.c:451:15: */
	var va1 Va_list
	_ = va1
	var ret int32

	va1 = va
	ret = Xgzvprintf(tls, file, format, va1)
	_ = va1
	return ret
}

// -- see zlib.h --
func Xgzflush(tls *libc.TLS, file GzFile, flush int32) int32 { /* gzwrite.c:553:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// check flush parameter
	if (flush < 0) || (flush > Z_FINISH) {
		return -2
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// compress remaining data with requested flush
	gz_comp(tls, state, flush)
	return (*Gz_state)(unsafe.Pointer(state)).Ferr
}

// -- see zlib.h --
func Xgzsetparams(tls *libc.TLS, file GzFile, level int32, strategy int32) int32 { /* gzwrite.c:585:13: */
	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file
	strm = (state + 120 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// if no change is requested, then do nothing
	if (level == (*Gz_state)(unsafe.Pointer(state)).Flevel) && (strategy == (*Gz_state)(unsafe.Pointer(state)).Fstrategy) {
		return Z_OK
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// change compression parameters for subsequent input
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		// flush previous input with previous parameters before changing
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0) && (gz_comp(tls, state, Z_BLOCK) == -1) {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
		XdeflateParams(tls, strm, level, strategy)
	}
	(*Gz_state)(unsafe.Pointer(state)).Flevel = level
	(*Gz_state)(unsafe.Pointer(state)).Fstrategy = strategy
	return Z_OK
}

// -- see zlib.h --
func Xgzclose_w(tls *libc.TLS, file GzFile) int32 { /* gzwrite.c:627:13: */
	var ret int32 = Z_OK
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're writing
	if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE {
		return -2
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			ret = (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// flush, free memory, and close file
	if gz_comp(tls, state, Z_FINISH) == -1 {
		ret = (*Gz_state)(unsafe.Pointer(state)).Ferr
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
			XdeflateEnd(tls, (state + 120 /* &.strm */))
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
		}
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
	libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
	if libc.Xclose(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd) == -1 {
		ret = -1
	}
	libc.Xfree(tls, state)
	return ret
}

// Reverse the bytes in a 32-bit value

// inftrees.h -- header to use inftrees.c
// Copyright (C) 1995-2005, 2010 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// Structure for decoding tables.  Each entry provides either the
//    information needed to do the operation requested by the code that
//    indexed that table entry, or it provides a pointer to another
//    table that indexes more bits of the code.  op indicates whether
//    the entry is a pointer to another table, a literal, a length or
//    distance, an end-of-block, or an invalid code.  For a table
//    pointer, the low four bits of op is the number of index bits of
//    that table.  For a length or distance, the low four bits of op
//    is the number of extra bits to get after the code.  bits is
//    the number of bits in this code or part of the code to drop off
//    of the bit buffer.  val is the actual byte to output in the case
//    of a literal, the base length or distance, or the offset from
//    the current table to the next table.  Each entry is four bytes.
type Code = struct {
	Fop   uint8
	Fbits uint8
	Fval  uint16
} /* inftrees.h:28:3 */

// op values as set by inflate_table():
//     00000000 - literal
//     0000tttt - table link, tttt != 0 is the number of table index bits
//     0001eeee - length or distance, eeee is the number of extra bits
//     01100000 - end of block
//     01000000 - invalid code
//

// Maximum size of the dynamic table.  The maximum number of code structures is
//    1444, which is the sum of 852 for literal/length codes and 592 for distance
//    codes.  These values were found by exhaustive searches using the program
//    examples/enough.c found in the zlib distribtution.  The arguments to that
//    program are the number of symbols, the initial root table size, and the
//    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
//    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
//    The initial root table size (9 or 6) is found in the fifth argument of the
//    inflate_table() calls in inflate.c and infback.c.  If the root table size is
//    changed, then these maximum sizes would be need to be recalculated and
//    updated.

// Type of code to build for inflate_table()
type Codetype = uint32 /* inftrees.h:58:3 */
// inflate.h -- internal inflate state definition
// Copyright (C) 1995-2016 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip decoding
//    should be left enabled.

// Possible inflate modes between inflate() calls
type Inflate_mode = uint32 /* inflate.h:53:3 */

//
//     State transitions between above modes -
//
//     (most modes can go to BAD or MEM on error -- not shown for clarity)
//
//     Process header:
//         HEAD -> (gzip) or (zlib) or (raw)
//         (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
//                   HCRC -> TYPE
//         (zlib) -> DICTID or TYPE
//         DICTID -> DICT -> TYPE
//         (raw) -> TYPEDO
//     Read deflate blocks:
//             TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
//             STORED -> COPY_ -> COPY -> TYPE
//             TABLE -> LENLENS -> CODELENS -> LEN_
//             LEN_ -> LEN
//     Read deflate codes in fixed or dynamic block:
//                 LEN -> LENEXT or LIT or TYPE
//                 LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
//                 LIT -> LEN
//     Process trailer:
//         CHECK -> LENGTH -> DONE
//

// State maintained between inflate() calls -- approximately 7K bytes, not
//    including the allocated sliding window, which is up to 32K bytes.
type Inflate_state = struct {
	Fstrm     Z_streamp
	Fmode     Inflate_mode
	Flast     int32
	Fwrap     int32
	Fhavedict int32
	Fflags    int32
	Fdmax     uint32
	Fcheck    uint64
	Ftotal    uint64
	Fhead     Gz_headerp
	Fwbits    uint32
	Fwsize    uint32
	Fwhave    uint32
	Fwnext    uint32
	Fwindow   uintptr
	Fhold     uint64
	Fbits     uint32
	Flength   uint32
	Foffset   uint32
	Fextra    uint32
	Flencode  uintptr
	Fdistcode uintptr
	Flenbits  uint32
	Fdistbits uint32
	Fncode    uint32
	Fnlen     uint32
	Fndist    uint32
	Fhave     uint32
	Fnext     uintptr
	Flens     [320]uint16
	Fwork     [288]uint16
	Fcodes    [1444]Code
	Fsane     int32
	Fback     int32
	Fwas      uint32
	_         [4]byte
} /* inflate.h:82:1 */

//
//    strm provides memory allocation functions in zalloc and zfree, or
//    Z_NULL to use the library memory allocation functions.
//
//    windowBits is in the range 8..15, and window is a user-supplied
//    window and output buffer that is 2**windowBits bytes.
//
func XinflateBackInit_(tls *libc.TLS, strm Z_streamp, windowBits int32, window uintptr, version uintptr, stream_size int32) int32 { /* infback.c:28:13: */
	var state uintptr

	if ((version == Z_NULL) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(*(*int8)(unsafe.Pointer(ts /* "1.2.11" */))))) || (stream_size != (int32(unsafe.Sizeof(Z_stream{})))) {
		return -6
	}
	if (((strm == Z_NULL) || (window == Z_NULL)) || (windowBits < 8)) || (windowBits > 15) {
		return -2
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL // in case we return an error
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}
	state = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if state == Z_NULL {
		return -4
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fstate = state
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = 32768
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = UInt(windowBits)
	(*Inflate_state)(unsafe.Pointer(state)).Fwsize = (uint32(1) << windowBits)
	(*Inflate_state)(unsafe.Pointer(state)).Fwindow = window
	(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	return Z_OK
}

//
//    Return state with length and distance decoding tables and index sizes set to
//    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
//    If BUILDFIXED is defined, then instead this routine builds the tables the
//    first time it's called, and returns those tables the first time and
//    thereafter.  This reduces the size of the code by about 2K bytes, in
//    exchange for a little execution time.  However, BUILDFIXED should not be
//    used for threaded applications, since the rewriting of the tables and virgin
//    may not be thread-safe.
//
func fixedtables(tls *libc.TLS, state uintptr) { /* infback.c:82:12: */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = uintptr(unsafe.Pointer(&lenfix))
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = uintptr(unsafe.Pointer(&distfix))
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(5)
}

var lenfix = [512]Code{
	{Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)}, {Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)},
	{Fbits: uint8(9), Fval: uint16(192)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)}, {Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(160)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)},
	{Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(224)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(144)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)},
	{Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(208)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(176)},
	{Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)}, {Fbits: uint8(9), Fval: uint16(240)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)},
	{Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)}, {Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(200)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)},
	{Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(168)}, {Fbits: uint8(8), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(232)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)},
	{Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(152)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(216)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)}, {Fbits: uint8(9), Fval: uint16(184)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)},
	{Fbits: uint8(9), Fval: uint16(248)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)}, {Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)},
	{Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(196)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(164)}, {Fbits: uint8(8), Fval: uint16(2)},
	{Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(228)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(148)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)}, {Fbits: uint8(9), Fval: uint16(212)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)},
	{Fbits: uint8(9), Fval: uint16(180)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)}, {Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(244)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)},
	{Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(204)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)},
	{Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(172)}, {Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(236)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)}, {Fbits: uint8(9), Fval: uint16(156)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)},
	{Fbits: uint8(9), Fval: uint16(220)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)}, {Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(188)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)},
	{Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(252)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)},
	{Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(194)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(162)},
	{Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)}, {Fbits: uint8(9), Fval: uint16(226)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)},
	{Fbits: uint8(9), Fval: uint16(146)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)}, {Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(210)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)},
	{Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(178)}, {Fbits: uint8(8), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(242)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(202)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)}, {Fbits: uint8(9), Fval: uint16(170)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)},
	{Fbits: uint8(9), Fval: uint16(234)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)}, {Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(154)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)},
	{Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(218)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(186)}, {Fbits: uint8(8), Fval: uint16(13)},
	{Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(250)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)}, {Fbits: uint8(9), Fval: uint16(198)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)},
	{Fbits: uint8(9), Fval: uint16(166)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)}, {Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(230)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)},
	{Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(150)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(214)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)},
	{Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(182)}, {Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(246)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)},
	{Fbits: uint8(9), Fval: uint16(206)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)}, {Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(174)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)},
	{Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(238)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(158)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)},
	{Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(222)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(190)},
	{Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)}, {Fbits: uint8(9), Fval: uint16(254)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)},
	{Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)}, {Fbits: uint8(9), Fval: uint16(193)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)},
	{Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(161)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)}, {Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(225)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)},
	{Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(145)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(209)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(177)}, {Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)},
	{Fbits: uint8(9), Fval: uint16(241)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)},
	{Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(201)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)}, {Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(169)}, {Fbits: uint8(8), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(233)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(153)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(217)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)},
	{Fbits: uint8(9), Fval: uint16(185)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)}, {Fbits: uint8(9), Fval: uint16(249)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)},
	{Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)}, {Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(197)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)},
	{Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(165)}, {Fbits: uint8(8), Fval: uint16(2)}, {Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(229)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(149)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)},
	{Fbits: uint8(9), Fval: uint16(213)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)}, {Fbits: uint8(9), Fval: uint16(181)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)},
	{Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(245)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)}, {Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)},
	{Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(205)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(173)},
	{Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(237)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)},
	{Fbits: uint8(9), Fval: uint16(157)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)}, {Fbits: uint8(9), Fval: uint16(221)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)},
	{Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(189)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)}, {Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(253)}, {Fop: uint8(96), Fbits: uint8(7)},
	{Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(195)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(163)}, {Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)},
	{Fbits: uint8(9), Fval: uint16(227)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)}, {Fbits: uint8(9), Fval: uint16(147)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)},
	{Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(211)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)}, {Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(179)}, {Fbits: uint8(8), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(243)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(203)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)},
	{Fbits: uint8(9), Fval: uint16(171)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)}, {Fbits: uint8(9), Fval: uint16(235)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)},
	{Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(155)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)}, {Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(219)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)},
	{Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(187)}, {Fbits: uint8(8), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(251)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)},
	{Fbits: uint8(9), Fval: uint16(199)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)}, {Fbits: uint8(9), Fval: uint16(167)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)},
	{Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(231)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)}, {Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(151)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)},
	{Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(215)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(183)},
	{Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(247)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)},
	{Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)}, {Fbits: uint8(9), Fval: uint16(207)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)},
	{Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(175)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)}, {Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(239)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(159)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(223)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(191)}, {Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)},
	{Fbits: uint8(9), Fval: uint16(255)},
} /* inffixed.h:10:23 */
var distfix = [32]Code{
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(1)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(257)}, {Fop: uint8(19), Fbits: uint8(5), Fval: uint16(17)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(4097)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(5)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1025)},
	{Fop: uint8(21), Fbits: uint8(5), Fval: uint16(65)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(16385)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(3)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(513)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(33)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(8193)},
	{Fop: uint8(18), Fbits: uint8(5), Fval: uint16(9)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(2049)}, {Fop: uint8(22), Fbits: uint8(5), Fval: uint16(129)}, {Fop: uint8(64), Fbits: uint8(5)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(2)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(385)},
	{Fop: uint8(19), Fbits: uint8(5), Fval: uint16(25)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(6145)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(7)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1537)}, {Fop: uint8(21), Fbits: uint8(5), Fval: uint16(97)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(24577)},
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(4)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(769)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(49)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(12289)}, {Fop: uint8(18), Fbits: uint8(5), Fval: uint16(13)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(3073)},
	{Fop: uint8(22), Fbits: uint8(5), Fval: uint16(193)}, {Fop: uint8(64), Fbits: uint8(5)},
} /* inffixed.h:87:23 */

// Macros for inflateBack():

// Load returned state from inflate_fast()

// Set state from registers for inflate_fast()

// Clear the input bit accumulator

// Assure that some input is available.  If input is requested, but denied,
//    then return a Z_BUF_ERROR from inflateBack().

// Get a byte of input into the bit accumulator, or return from inflateBack()
//    with an error if there is no input available.

// Assure that there are at least n bits in the bit accumulator.  If there is
//    not enough available input to do that, then return from inflateBack() with
//    an error.

// Return the low n bits of the bit accumulator (n < 16)

// Remove n bits from the bit accumulator

// Remove zero to seven bits as needed to go to a byte boundary

// Assure that some output space is available, by writing out the window
//    if it's full.  If the write fails, return from inflateBack() with a
//    Z_BUF_ERROR.

//
//    strm provides the memory allocation functions and window buffer on input,
//    and provides information on the unused input on return.  For Z_DATA_ERROR
//    returns, strm will also provide an error message.
//
//    in() and out() are the call-back input and output functions.  When
//    inflateBack() needs more input, it calls in().  When inflateBack() has
//    filled the window with output, or when it completes with data in the
//    window, it calls out() to write out the data.  The application must not
//    change the provided input until in() is called again or inflateBack()
//    returns.  The application must not change the window/output buffer until
//    inflateBack() returns.
//
//    in() and out() are called with a descriptor parameter provided in the
//    inflateBack() call.  This parameter can be a structure that provides the
//    information required to do the read or write, as well as accumulated
//    information on the input and output such as totals and check values.
//
//    in() should return zero on failure.  out() should return non-zero on
//    failure.  If either in() or out() fails, than inflateBack() returns a
//    Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
//    was in() or out() that caused in the error.  Otherwise,  inflateBack()
//    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
//    error, or Z_MEM_ERROR if it could not allocate memory for the state.
//    inflateBack() can also return Z_STREAM_ERROR if the input parameters
//    are not correct, i.e. strm is Z_NULL or the state was not initialized.
//
func XinflateBack(tls *libc.TLS, strm Z_streamp, in In_func, in_desc uintptr, out Out_func, out_desc uintptr) int32 { /* infback.c:250:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var state uintptr
	// var next uintptr at bp, 8
	// next input
	var put uintptr // next output
	var have uint32
	var left uint32  // available input and output
	var hold uint64  // bit buffer
	var bits uint32  // bits in bit buffer
	var copy uint32  // number of stored or match bytes to copy
	var from uintptr // where to copy match bytes from
	var here Code    // current decoding table entry
	var last Code    // parent table entry
	var len uint32   // length to copy for repeats, bits to drop
	var ret int32

	// Check that the strm exists and that the state was initialized
	if !((strm == Z_NULL) || ((*Z_stream)(unsafe.Pointer(strm)).Fstate == Z_NULL)) {
		goto __1
	}
	return -2
__1:
	;
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// Reset the state
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	(*Inflate_state)(unsafe.Pointer(state)).Flast = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	if *(*uintptr)(unsafe.Pointer(bp /* next */)) != Z_NULL {
		have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	} else {
		have = uint32(0)
	}
	hold = uint64(0)
	bits = uint32(0)
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize

	// Inflate until end of block marked as last
__2:
	switch (*Inflate_state)(unsafe.Pointer(state)).Fmode {
	case TYPE:
		goto __6

	case STORED:
		goto __7

	case TABLE:
		goto __8

	case LEN:
		goto __9

	case DONE:
		goto __10

	case BAD:
		goto __11

	default:
		goto __12
	}
	goto __5
__6:
	// determine and dispatch block type
	if !((*Inflate_state)(unsafe.Pointer(state)).Flast != 0) {
		goto __13
	}
__14:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DONE
	goto __5
__13:
	;
__17:
__20:
	if !(bits < (uint32(3))) {
		goto __21
	}
__22:
__25:
	if !(have == uint32(0)) {
		goto __28
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __29
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__29:
	;
__28:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	goto __20
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flast = (int32(uint32(hold) & ((uint32(1) << (1)) - uint32(1))))
__30:
	hold >>= 1
	bits = bits - (uint32(1))
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	switch uint32(hold) & ((uint32(1) << (2)) - uint32(1)) {
	case uint32(0):
		goto __34
	case uint32(1):
		goto __35
	case uint32(2):
		goto __36
	case uint32(3):
		goto __37
	}
	goto __33
__34: // stored block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = STORED
	goto __33
__35: // fixed block
	fixedtables(tls, state)

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN // decode codes
	goto __33
__36: // dynamic block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TABLE
	goto __33
__37:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 367 /* "invalid block ty..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
__33:
	;
__38:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
	goto __5

__7:
	// get and verify stored block length
__41:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	; // go to byte boundary
__44:
__47:
	if !(bits < (uint32(32))) {
		goto __48
	}
__49:
__52:
	if !(have == uint32(0)) {
		goto __55
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __56
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__56:
	;
__55:
	;
	goto __53
__53:
	if 0 != 0 {
		goto __52
	}
	goto __54
__54:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __50
__50:
	if 0 != 0 {
		goto __49
	}
	goto __51
__51:
	;
	goto __47
__48:
	;
	goto __45
__45:
	if 0 != 0 {
		goto __44
	}
	goto __46
__46:
	;
	if !((hold & uint64(0xffff)) != ((hold >> 16) ^ uint64(0xffff))) {
		goto __57
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 386 /* "invalid stored b..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__57:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = (uint32(hold) & uint32(0xffff))

__58:
	hold = uint64(0)
	bits = uint32(0)
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;

	// copy stored block from input to output
__61:
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength != uint32(0)) {
		goto __62
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__63:
	if !(have == uint32(0)) {
		goto __66
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __67
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__67:
	;
__66:
	;
	goto __64
__64:
	if 0 != 0 {
		goto __63
	}
	goto __65
__65:
	;
__68:
	if !(left == uint32(0)) {
		goto __71
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __72
	}
	ret = -5
	goto inf_leave
__72:
	;
__71:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
	if !(copy > have) {
		goto __73
	}
	copy = have
__73:
	;
	if !(copy > left) {
		goto __74
	}
	copy = left
__74:
	;
	libc.X__builtin___memcpy_chk(tls, put, *(*uintptr)(unsafe.Pointer(bp /* next */)), uint64(copy), libc.X__builtin_object_size(tls, put, 0))
	have = have - (copy)
	*(*uintptr)(unsafe.Pointer(bp /* next */)) += uintptr(copy)
	left = left - (copy)
	put += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) -= (copy)
	goto __61
__62:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __5

__8:
	// get dynamic table entries descriptor
__75:
__78:
	if !(bits < (uint32(14))) {
		goto __79
	}
__80:
__83:
	if !(have == uint32(0)) {
		goto __86
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __87
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__87:
	;
__86:
	;
	goto __84
__84:
	if 0 != 0 {
		goto __83
	}
	goto __85
__85:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __81
__81:
	if 0 != 0 {
		goto __80
	}
	goto __82
__82:
	;
	goto __78
__79:
	;
	goto __76
__76:
	if 0 != 0 {
		goto __75
	}
	goto __77
__77:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnlen = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(257))
__88:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __89
__89:
	if 0 != 0 {
		goto __88
	}
	goto __90
__90:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fndist = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(1))
__91:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fncode = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(4))
__94:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __95
__95:
	if 0 != 0 {
		goto __94
	}
	goto __96
__96:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fnlen > uint32(286)) || ((*Inflate_state)(unsafe.Pointer(state)).Fndist > uint32(30))) {
		goto __97
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 415 /* "too many length ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__97:
	;

	// get code length code lengths (not a typo)
	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
__98:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < (*Inflate_state)(unsafe.Pointer(state)).Fncode) {
		goto __99
	}
__100:
__103:
	if !(bits < (uint32(3))) {
		goto __104
	}
__105:
__108:
	if !(have == uint32(0)) {
		goto __111
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __112
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__112:
	;
__111:
	;
	goto __109
__109:
	if 0 != 0 {
		goto __108
	}
	goto __110
__110:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __106
__106:
	if 0 != 0 {
		goto __105
	}
	goto __107
__107:
	;
	goto __103
__104:
	;
	goto __101
__101:
	if 0 != 0 {
		goto __100
	}
	goto __102
__102:
	;
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(order[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = (uint16(uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__113:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __114
__114:
	if 0 != 0 {
		goto __113
	}
	goto __115
__115:
	;
	goto __98
__99:
	;
__116:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < uint32(19)) {
		goto __117
	}
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(order[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = uint16(0)
	goto __116
__117:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1368 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(7)
	ret = Xinflate_table(tls, CODES, state+152 /* &.lens */, uint32(19), (state + 144 /* &.next */),
		(state + 120 /* &.lenbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __118
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 451 /* "invalid code len..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__118:
	;

	// get length and distance code code lengths
	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
__119:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __120
	}
__121:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __124
	}
	goto __123
__124:
	;
__125:
__128:
	if !(have == uint32(0)) {
		goto __131
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __132
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__132:
	;
__131:
	;
	goto __129
__129:
	if 0 != 0 {
		goto __128
	}
	goto __130
__130:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __126
__126:
	if 0 != 0 {
		goto __125
	}
	goto __127
__127:
	;
	goto __122
__122:
	goto __121
	goto __123
__123:
	;
	if !(int32(here.Fval) < 16) {
		goto __133
	}
__135:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __136
__136:
	if 0 != 0 {
		goto __135
	}
	goto __137
__137:
	;
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = here.Fval
	goto __134
__133:
	if !(int32(here.Fval) == 16) {
		goto __138
	}
__140:
__143:
	if !(bits < (uint32(int32(here.Fbits) + 2))) {
		goto __144
	}
__145:
__148:
	if !(have == uint32(0)) {
		goto __151
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __152
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__152:
	;
__151:
	;
	goto __149
__149:
	if 0 != 0 {
		goto __148
	}
	goto __150
__150:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __146
__146:
	if 0 != 0 {
		goto __145
	}
	goto __147
__147:
	;
	goto __143
__144:
	;
	goto __141
__141:
	if 0 != 0 {
		goto __140
	}
	goto __142
__142:
	;
__153:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __154
__154:
	if 0 != 0 {
		goto __153
	}
	goto __155
__155:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave == uint32(0)) {
		goto __156
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __120
__156:
	;
	len = uint32(*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fhave-uint32(1)))*2)))
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (2)) - uint32(1))))
__157:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __158
__158:
	if 0 != 0 {
		goto __157
	}
	goto __159
__159:
	;
	goto __139
__138:
	if !(int32(here.Fval) == 17) {
		goto __160
	}
__162:
__165:
	if !(bits < (uint32(int32(here.Fbits) + 3))) {
		goto __166
	}
__167:
__170:
	if !(have == uint32(0)) {
		goto __173
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __174
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__174:
	;
__173:
	;
	goto __171
__171:
	if 0 != 0 {
		goto __170
	}
	goto __172
__172:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __168
__168:
	if 0 != 0 {
		goto __167
	}
	goto __169
__169:
	;
	goto __165
__166:
	;
	goto __163
__163:
	if 0 != 0 {
		goto __162
	}
	goto __164
__164:
	;
__175:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __176
__176:
	if 0 != 0 {
		goto __175
	}
	goto __177
__177:
	;
	len = uint32(0)
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__178:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __179
__179:
	if 0 != 0 {
		goto __178
	}
	goto __180
__180:
	;
	goto __161
__160:
__181:
__184:
	if !(bits < (uint32(int32(here.Fbits) + 7))) {
		goto __185
	}
__186:
__189:
	if !(have == uint32(0)) {
		goto __192
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __193
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__193:
	;
__192:
	;
	goto __190
__190:
	if 0 != 0 {
		goto __189
	}
	goto __191
__191:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __187
__187:
	if 0 != 0 {
		goto __186
	}
	goto __188
__188:
	;
	goto __184
__185:
	;
	goto __182
__182:
	if 0 != 0 {
		goto __181
	}
	goto __183
__183:
	;
__194:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __195
__195:
	if 0 != 0 {
		goto __194
	}
	goto __196
__196:
	;
	len = uint32(0)
	copy = (uint32(11) + (uint32(hold) & ((uint32(1) << (7)) - uint32(1))))
__197:
	hold >>= 7
	bits = bits - (uint32(7))
	goto __198
__198:
	if 0 != 0 {
		goto __197
	}
	goto __199
__199:
	;
__161:
	;
__139:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhave + copy) > ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __200
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __120
__200:
	;
__201:
	if !(libc.PostDecUint32(&copy, 1) != 0) {
		goto __202
	}
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = uint16(len)
	goto __201
__202:
	;
__134:
	;
	goto __119
__120:
	;

	// handle error breaks in while
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == BAD) {
		goto __203
	}
	goto __5
__203:
	;

	// check for end-of-block code (better have one)
	if !(int32(*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + 256*2))) == 0) {
		goto __204
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 502 /* "invalid code -- ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__204:
	;

	// build code tables -- note: do not change the lenbits or distbits
	//                values here (9 and 6) without reading the comments in inftrees.h
	//                concerning the ENOUGH constants, which depend on those values
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1368 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	ret = Xinflate_table(tls, LENS, state+152 /* &.lens */, (*Inflate_state)(unsafe.Pointer(state)).Fnlen, (state + 144 /* &.next */),
		(state + 120 /* &.lenbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __205
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 539 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__205:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(6)
	ret = Xinflate_table(tls, DISTS, ((state + 152 /* &.lens */) + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fnlen)*2), (*Inflate_state)(unsafe.Pointer(state)).Fndist,
		(state + 144 /* &.next */), (state + 124 /* &.distbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __206
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 567 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__206:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN

__9:
	// use inflate_fast() if we have enough input and output
	if !((have >= uint32(6)) && (left >= uint32(258))) {
		goto __207
	}
__208:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = *(*uintptr)(unsafe.Pointer(bp /* next */))
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __209
__209:
	if 0 != 0 {
		goto __208
	}
	goto __210
__210:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize) {
		goto __211
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - left)
__211:
	;
	Xinflate_fast(tls, strm, (*Inflate_state)(unsafe.Pointer(state)).Fwsize)
__212:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
	goto __5
__207:
	;

	// get a literal, length, or end-of-block code
__215:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __218
	}
	goto __217
__218:
	;
__219:
__222:
	if !(have == uint32(0)) {
		goto __225
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __226
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__226:
	;
__225:
	;
	goto __223
__223:
	if 0 != 0 {
		goto __222
	}
	goto __224
__224:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __220
__220:
	if 0 != 0 {
		goto __219
	}
	goto __221
__221:
	;
	goto __216
__216:
	goto __215
	goto __217
__217:
	;
	if !((here.Fop != 0) && ((int32(here.Fop) & 0xf0) == 0)) {
		goto __227
	}
	last = here
__228:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __231
	}
	goto __230
__231:
	;
__232:
__235:
	if !(have == uint32(0)) {
		goto __238
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __239
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__239:
	;
__238:
	;
	goto __236
__236:
	if 0 != 0 {
		goto __235
	}
	goto __237
__237:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __233
__233:
	if 0 != 0 {
		goto __232
	}
	goto __234
__234:
	;
	goto __229
__229:
	goto __228
	goto __230
__230:
	;
__240:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __241
__241:
	if 0 != 0 {
		goto __240
	}
	goto __242
__242:
	;
__227:
	;
__243:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __244
__244:
	if 0 != 0 {
		goto __243
	}
	goto __245
__245:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(here.Fval)

	// process literal
	if !(int32(here.Fop) == 0) {
		goto __246
	}

__247:
	if !(left == uint32(0)) {
		goto __250
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __251
	}
	ret = -5
	goto inf_leave
__251:
	;
__250:
	;
	goto __248
__248:
	if 0 != 0 {
		goto __247
	}
	goto __249
__249:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Flength)
	left--
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
	goto __5
__246:
	;

	// process end of block
	if !((int32(here.Fop) & 32) != 0) {
		goto __252
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __5
__252:
	;

	// invalid code
	if !((int32(here.Fop) & 64) != 0) {
		goto __253
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__253:
	;

	// length code -- get extra bits, if any
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != uint32(0)) {
		goto __254
	}
__255:
__258:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __259
	}
__260:
__263:
	if !(have == uint32(0)) {
		goto __266
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __267
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__267:
	;
__266:
	;
	goto __264
__264:
	if 0 != 0 {
		goto __263
	}
	goto __265
__265:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __261
__261:
	if 0 != 0 {
		goto __260
	}
	goto __262
__262:
	;
	goto __258
__259:
	;
	goto __256
__256:
	if 0 != 0 {
		goto __255
	}
	goto __257
__257:
	;
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__268:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __269
__269:
	if 0 != 0 {
		goto __268
	}
	goto __270
__270:
	;
__254:
	;

	// get distance code
__271:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Fdistbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __274
	}
	goto __273
__274:
	;
__275:
__278:
	if !(have == uint32(0)) {
		goto __281
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __282
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__282:
	;
__281:
	;
	goto __279
__279:
	if 0 != 0 {
		goto __278
	}
	goto __280
__280:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __276
__276:
	if 0 != 0 {
		goto __275
	}
	goto __277
__277:
	;
	goto __272
__272:
	goto __271
	goto __273
__273:
	;
	if !((int32(here.Fop) & 0xf0) == 0) {
		goto __283
	}
	last = here
__284:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __287
	}
	goto __286
__287:
	;
__288:
__291:
	if !(have == uint32(0)) {
		goto __294
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __295
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__295:
	;
__294:
	;
	goto __292
__292:
	if 0 != 0 {
		goto __291
	}
	goto __293
__293:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __289
__289:
	if 0 != 0 {
		goto __288
	}
	goto __290
__290:
	;
	goto __285
__285:
	goto __284
	goto __286
__286:
	;
__296:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __297
__297:
	if 0 != 0 {
		goto __296
	}
	goto __298
__298:
	;
__283:
	;
__299:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __300
__300:
	if 0 != 0 {
		goto __299
	}
	goto __301
__301:
	;
	if !((int32(here.Fop) & 64) != 0) {
		goto __302
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__302:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Foffset = uint32(here.Fval)

	// get distance extra bits, if any
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != uint32(0)) {
		goto __303
	}
__304:
__307:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __308
	}
__309:
__312:
	if !(have == uint32(0)) {
		goto __315
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __316
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = Z_NULL
	ret = -5
	goto inf_leave
__316:
	;
__315:
	;
	goto __313
__313:
	if 0 != 0 {
		goto __312
	}
	goto __314
__314:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __310
__310:
	if 0 != 0 {
		goto __309
	}
	goto __311
__311:
	;
	goto __307
__308:
	;
	goto __305
__305:
	if 0 != 0 {
		goto __304
	}
	goto __306
__306:
	;
	*(*uint32)(unsafe.Pointer(state + 96 /* &.offset */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__317:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __318
__318:
	if 0 != 0 {
		goto __317
	}
	goto __319
__319:
	;
__303:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Foffset > ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
			return left
		}
		return uint32(0)
	}()))) {
		goto __320
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__320:
	;

	// copy match from window to output
__321:
__324:
	if !(left == uint32(0)) {
		goto __327
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __328
	}
	ret = -5
	goto inf_leave
__328:
	;
__327:
	;
	goto __325
__325:
	if 0 != 0 {
		goto __324
	}
	goto __326
__326:
	;
	copy = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (*Inflate_state)(unsafe.Pointer(state)).Foffset)
	if !(copy < left) {
		goto __329
	}
	from = (put + uintptr(copy))
	copy = (left - copy)
	goto __330
__329:
	from = (put - uintptr((*Inflate_state)(unsafe.Pointer(state)).Foffset))
	copy = left
__330:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Flength) {
		goto __331
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__331:
	;
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) -= (copy)
	left = left - (copy)
__332:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __333
__333:
	if libc.PreDecUint32(&copy, 1) != 0 {
		goto __332
	}
	goto __334
__334:
	;
	goto __322
__322:
	if (*Inflate_state)(unsafe.Pointer(state)).Flength != uint32(0) {
		goto __321
	}
	goto __323
__323:
	;
	goto __5

__10:
	// inflate stream terminated properly -- write leftover output
	ret = Z_STREAM_END
	if !(left < (*Inflate_state)(unsafe.Pointer(state)).Fwsize) {
		goto __335
	}
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, ((*Inflate_state)(unsafe.Pointer(state)).Fwsize-left)) != 0) {
		goto __336
	}
	ret = -5
__336:
	;
__335:
	;
	goto inf_leave

__11:
	ret = -3
	goto inf_leave

__12: // can't happen, but makes compilers happy
	ret = -2
	goto inf_leave
__5:
	;
	goto __3
__3:
	goto __2
	goto __4
__4:
	;

	// Return unused input
inf_leave:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = *(*uintptr)(unsafe.Pointer(bp /* next */))
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	return ret
}

var order =                                                                                                                                                                                                                          // permutation of code lengths
[19]uint16{uint16(16), uint16(17), uint16(18), uint16(0), uint16(8), uint16(7), uint16(9), uint16(6), uint16(10), uint16(5), uint16(11), uint16(4), uint16(12), uint16(3), uint16(13), uint16(2), uint16(14), uint16(1), uint16(15)} /* infback.c:269:33 */

func XinflateBackEnd(tls *libc.TLS, strm Z_streamp) int32 { /* infback.c:631:13: */
	if ((strm == Z_NULL) || ((*Z_stream)(unsafe.Pointer(strm)).Fstate == Z_NULL)) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return -2
	}
	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = Z_NULL

	return Z_OK
}

//
//    Decode literal, length, and distance codes and write out the resulting
//    literal and match bytes until either not enough input or output is
//    available, an end-of-block is encountered, or a data error is encountered.
//    When large enough input and output buffers are supplied to inflate(), for
//    example, a 16K input buffer and a 64K output buffer, more than 95% of the
//    inflate execution time is spent in this routine.
//
//    Entry assumptions:
//
//         state->mode == LEN
//         strm->avail_in >= 6
//         strm->avail_out >= 258
//         start >= strm->avail_out
//         state->bits < 8
//
//    On return, state->mode is one of:
//
//         LEN -- ran out of enough output space or enough available input
//         TYPE -- reached end of block code, inflate() to interpret next block
//         BAD -- error in block data
//
//    Notes:
//
//     - The maximum input bits used by a length/distance pair is 15 bits for the
//       length code, 5 bits for the length extra, 15 bits for the distance code,
//       and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
//       Therefore if strm->avail_in >= 6, then there is enough input to avoid
//       checking for available input while decoding.
//
//     - The maximum bytes that a single length/distance pair can output is 258
//       bytes, which is the maximum length that can be coded.  inflate_fast()
//       requires strm->avail_out >= 258 for each loop to avoid checking for
//       output space.
//
func Xinflate_fast(tls *libc.TLS, strm Z_streamp, start uint32) { /* inffast.c:50:20: */
	var state uintptr
	var in uintptr     // local strm->next_in
	var last uintptr   // have enough input while in < last
	var out uintptr    // local strm->next_out
	var beg uintptr    // inflate()'s initial strm->next_out
	var end uintptr    // while out < end, enough space available
	var wsize uint32   // window size or zero if not using window
	var whave uint32   // valid bytes in the window
	var wnext uint32   // window write index
	var window uintptr // allocated sliding window, if wsize != 0
	var hold uint64    // local strm->hold
	var bits uint32    // local strm->bits
	var lcode uintptr  // local strm->lencode
	var dcode uintptr  // local strm->distcode
	var lmask uint32   // mask for first level of length codes
	var dmask uint32   // mask for first level of distance codes
	var here Code      // retrieved table entry
	var op uint32      // code bits, operation, extra bits, or
	//  window position, window bytes to copy
	var len uint32   // match length, unused bytes
	var dist uint32  // match distance
	var from uintptr // where to copy match from

	// copy state to local variables
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	in = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	last = (in + uintptr(((*Z_stream)(unsafe.Pointer(strm)).Favail_in - UInt(5))))
	out = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	beg = (out - uintptr((start - (*Z_stream)(unsafe.Pointer(strm)).Favail_out)))
	end = (out + uintptr(((*Z_stream)(unsafe.Pointer(strm)).Favail_out - UInt(257))))
	wsize = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	whave = (*Inflate_state)(unsafe.Pointer(state)).Fwhave
	wnext = (*Inflate_state)(unsafe.Pointer(state)).Fwnext
	window = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	lcode = (*Inflate_state)(unsafe.Pointer(state)).Flencode
	dcode = (*Inflate_state)(unsafe.Pointer(state)).Fdistcode
	lmask = ((uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Flenbits) - uint32(1))
	dmask = ((uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fdistbits) - uint32(1))

	// decode literals and length/distances until end-of-block or not enough
	//        input data or output space
__1:
	if !(bits < uint32(15)) {
		goto __4
	}
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__4:
	;
	here = *(*Code)(unsafe.Pointer(lcode + uintptr((hold&uint64(lmask)))*4))
dolen:
	op = uint32(here.Fbits)
	hold >>= op
	bits = bits - (op)
	op = uint32(here.Fop)
	if !(op == uint32(0)) {
		goto __5
	} // literal

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = uint8(here.Fval)
	goto __6
__5:
	if !((op & uint32(16)) != 0) {
		goto __7
	} // length base
	len = uint32(here.Fval)
	op = op & (uint32(15)) // number of extra bits
	if !(op != 0) {
		goto __9
	}
	if !(bits < op) {
		goto __10
	}
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__10:
	;
	len = len + (uint32(hold) & ((uint32(1) << op) - uint32(1)))
	hold >>= op
	bits = bits - (op)
__9:
	;

	if !(bits < uint32(15)) {
		goto __11
	}
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__11:
	;
	here = *(*Code)(unsafe.Pointer(dcode + uintptr((hold&uint64(dmask)))*4))
dodist:
	op = uint32(here.Fbits)
	hold >>= op
	bits = bits - (op)
	op = uint32(here.Fop)
	if !((op & uint32(16)) != 0) {
		goto __12
	} // distance base
	dist = uint32(here.Fval)
	op = op & (uint32(15)) // number of extra bits
	if !(bits < op) {
		goto __14
	}
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	if !(bits < op) {
		goto __15
	}
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__15:
	;
__14:
	;
	dist = dist + (uint32(hold) & ((uint32(1) << op) - uint32(1)))
	hold >>= op
	bits = bits - (op)

	op = (uint32((int64(out) - int64(beg)) / 1)) // max distance in output
	if !(dist > op) {
		goto __16
	} // see if copy from window
	op = (dist - op) // distance back in window
	if !(op > whave) {
		goto __18
	}
	if !((*Inflate_state)(unsafe.Pointer(state)).Fsane != 0) {
		goto __19
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__19:
	;
__18:
	;
	from = window
	if !(wnext == uint32(0)) {
		goto __20
	} // very common case
	from += (uintptr(wsize - op))
	if !(op < len) {
		goto __22
	} // some from window
	len = len - (op)
__23:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __24
__24:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __23
	}
	goto __25
__25:
	;
	from = (out - uintptr(dist)) // rest from output
__22:
	;
	goto __21
__20:
	if !(wnext < op) {
		goto __26
	} // wrap around window
	from += (uintptr((wsize + wnext) - op))
	op = op - (wnext)
	if !(op < len) {
		goto __28
	} // some from end of window
	len = len - (op)
__29:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __30
__30:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __29
	}
	goto __31
__31:
	;
	from = window
	if !(wnext < len) {
		goto __32
	} // some from start of window
	op = wnext
	len = len - (op)
__33:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __34
__34:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __33
	}
	goto __35
__35:
	;
	from = (out - uintptr(dist)) // rest from output
__32:
	;
__28:
	;
	goto __27
__26: // contiguous in window
	from += (uintptr(wnext - op))
	if !(op < len) {
		goto __36
	} // some from window
	len = len - (op)
__37:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __38
__38:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __37
	}
	goto __39
__39:
	;
	from = (out - uintptr(dist)) // rest from output
__36:
	;
__27:
	;
__21:
	;
__40:
	if !(len > uint32(2)) {
		goto __41
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	len = len - (uint32(3))
	goto __40
__41:
	;
	if !(len != 0) {
		goto __42
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	if !(len > uint32(1)) {
		goto __43
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
__43:
	;
__42:
	;
	goto __17
__16:
	from = (out - uintptr(dist)) // copy direct from output
__44: // minimum length is three
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	len = len - (uint32(3))
	goto __45
__45:
	if len > uint32(2) {
		goto __44
	}
	goto __46
__46:
	;
	if !(len != 0) {
		goto __47
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	if !(len > uint32(1)) {
		goto __48
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
__48:
	;
__47:
	;
__17:
	;
	goto __13
__12:
	if !((op & uint32(64)) == uint32(0)) {
		goto __49
	} // 2nd level distance code
	here = *(*Code)(unsafe.Pointer(dcode + uintptr((uint64(here.Fval)+(hold&(uint64((uint32(1)<<op)-uint32(1))))))*4))
	goto dodist
	goto __50
__49:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__50:
	;
__13:
	;
	goto __8
__7:
	if !((op & uint32(64)) == uint32(0)) {
		goto __51
	} // 2nd level length code
	here = *(*Code)(unsafe.Pointer(lcode + uintptr((uint64(here.Fval)+(hold&(uint64((uint32(1)<<op)-uint32(1))))))*4))
	goto dolen
	goto __52
__51:
	if !((op & uint32(32)) != 0) {
		goto __53
	} // end-of-block

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __3
	goto __54
__53:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__54:
	;
__52:
	;
__8:
	;
__6:
	;
	goto __2
__2:
	if (in < last) && (out < end) {
		goto __1
	}
	goto __3
__3:
	;

	// return unused bytes (on entry, bits < 8, so in won't go too far back)
	len = (bits >> 3)
	in -= uintptr(len)
	bits = bits - (len << 3)
	hold = hold & (uint64((uint32(1) << bits) - uint32(1)))

	// update state and return
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = in
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = out
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = func() uint32 {
		if in < last {
			return (uint32(int64(5) + ((int64(last) - int64(in)) / 1)))
		}
		return (uint32(int64(5) - ((int64(in) - int64(last)) / 1)))
	}()
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = func() uint32 {
		if out < end {
			return (uint32(int64(257) + ((int64(end) - int64(out)) / 1)))
		}
		return (uint32(int64(257) - ((int64(out) - int64(end)) / 1)))
	}()
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	return
}

//
//    inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
//    - Using bit fields for code structure
//    - Different op definition to avoid & for extra bits (do & for table bits)
//    - Three separate decoding do-loops for direct, window, and wnext == 0
//    - Special case for distance > 1 copies to do overlapped load and store copy
//    - Explicit branch predictions (based on measured branch probabilities)
//    - Deferring match copy and interspersed it with decoding subsequent codes
//    - Swapping literal/length else
//    - Swapping window/direct else
//    - Larger unrolled copy loops (three is about right)
//    - Moving len -= 3 statement into middle of loop
//

func inflateStateCheck(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:105:11: */
	var state uintptr
	if ((strm == Z_NULL) || ((*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0))) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return 1
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if (((state == Z_NULL) || ((*Inflate_state)(unsafe.Pointer(state)).Fstrm != strm)) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode < HEAD)) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode > SYNC) {
		return 1
	}
	return 0
}

func XinflateResetKeep(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:119:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = libc.AssignPtrUint64(strm+40 /* &.total_out */, libc.AssignPtrUint64(state+40 /* &.total */, uint64(0)))
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL
	if (*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0 { // to support ill-conceived Java test suite
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = (ULong((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 1))
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HEAD
	(*Inflate_state)(unsafe.Pointer(state)).Flast = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fhavedict = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = 32768
	(*Inflate_state)(unsafe.Pointer(state)).Fhead = Z_NULL
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = uint64(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = libc.AssignPtrUintptr(state+112 /* &.distcode */, libc.AssignPtrUintptr(state+144 /* &.next */, state+1368 /* &.codes */))
	(*Inflate_state)(unsafe.Pointer(state)).Fsane = 1
	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1

	return Z_OK
}

func XinflateReset(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:144:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Inflate_state)(unsafe.Pointer(state)).Fwsize = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
	return XinflateResetKeep(tls, strm)
}

func XinflateReset2(tls *libc.TLS, strm Z_streamp, windowBits int32) int32 { /* inflate.c:157:13: */
	var wrap int32
	var state uintptr

	// get the state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// extract wrap request from windowBits parameter
	if windowBits < 0 {
		wrap = 0
		windowBits = -windowBits
	} else {
		wrap = ((windowBits >> 4) + 5)
		if windowBits < 48 {
			windowBits = windowBits & (15)
		}
	}

	// set number of window bits, free window if different
	if (windowBits != 0) && ((windowBits < 8) || (windowBits > 15)) {
		return -2
	}
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwindow != Z_NULL) && ((*Inflate_state)(unsafe.Pointer(state)).Fwbits != uint32(windowBits)) {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Inflate_state)(unsafe.Pointer(state)).Fwindow)
		(*Inflate_state)(unsafe.Pointer(state)).Fwindow = Z_NULL
	}

	// update state and reset the rest of it
	(*Inflate_state)(unsafe.Pointer(state)).Fwrap = wrap
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = uint32(windowBits)
	return XinflateReset(tls, strm)
}

func XinflateInit2_(tls *libc.TLS, strm Z_streamp, windowBits int32, version uintptr, stream_size int32) int32 { /* inflate.c:195:13: */
	var ret int32
	var state uintptr

	if ((version == Z_NULL) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(*(*int8)(unsafe.Pointer(ts /* "1.2.11" */))))) || (stream_size != (int32(unsafe.Sizeof(Z_stream{})))) {
		return -6
	}
	if strm == Z_NULL {
		return -2
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Z_NULL // in case we return an error
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}
	state = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if state == Z_NULL {
		return -4
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fstate = state
	(*Inflate_state)(unsafe.Pointer(state)).Fstrm = strm
	(*Inflate_state)(unsafe.Pointer(state)).Fwindow = Z_NULL
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HEAD // to pass state test in inflateReset2()
	ret = XinflateReset2(tls, strm, windowBits)
	if ret != Z_OK {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, state)
		(*Z_stream)(unsafe.Pointer(strm)).Fstate = Z_NULL
	}
	return ret
}

func XinflateInit_(tls *libc.TLS, strm Z_streamp, version uintptr, stream_size int32) int32 { /* inflate.c:239:13: */
	return XinflateInit2_(tls, strm, MAX_WBITS, version, stream_size)
}

func XinflatePrime(tls *libc.TLS, strm Z_streamp, bits int32, value int32) int32 { /* inflate.c:247:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if bits < 0 {
		(*Inflate_state)(unsafe.Pointer(state)).Fhold = uint64(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fbits = uint32(0)
		return Z_OK
	}
	if (bits > 16) || (((*Inflate_state)(unsafe.Pointer(state)).Fbits + UInt(bits)) > uint32(32)) {
		return -2
	}
	value = int32(int64(value) & ((int64(1) << bits) - int64(1)))
	*(*uint64)(unsafe.Pointer(state + 80 /* &.hold */)) += (uint64(uint32(value) << (*Inflate_state)(unsafe.Pointer(state)).Fbits))
	*(*uint32)(unsafe.Pointer(state + 88 /* &.bits */)) += (UInt(bits))
	return Z_OK
}

//
//    Return state with length and distance decoding tables and index sizes set to
//    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
//    If BUILDFIXED is defined, then instead this routine builds the tables the
//    first time it's called, and returns those tables the first time and
//    thereafter.  This reduces the size of the code by about 2K bytes, in
//    exchange for a little execution time.  However, BUILDFIXED should not be
//    used for threaded applications, since the rewriting of the tables and virgin
//    may not be thread-safe.
//
func fixedtables1(tls *libc.TLS, state uintptr) { /* inflate.c:278:12: */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = uintptr(unsafe.Pointer(&lenfix1))
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = uintptr(unsafe.Pointer(&distfix1))
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(5)
}

var lenfix1 = [512]Code{
	{Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)}, {Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)},
	{Fbits: uint8(9), Fval: uint16(192)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)}, {Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(160)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)},
	{Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(224)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(144)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)},
	{Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(208)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(176)},
	{Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)}, {Fbits: uint8(9), Fval: uint16(240)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)},
	{Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)}, {Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(200)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)},
	{Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(168)}, {Fbits: uint8(8), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(232)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)},
	{Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(152)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(216)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)}, {Fbits: uint8(9), Fval: uint16(184)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)},
	{Fbits: uint8(9), Fval: uint16(248)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)}, {Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)},
	{Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(196)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(164)}, {Fbits: uint8(8), Fval: uint16(2)},
	{Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(228)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(148)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)}, {Fbits: uint8(9), Fval: uint16(212)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)},
	{Fbits: uint8(9), Fval: uint16(180)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)}, {Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(244)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)},
	{Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(204)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)},
	{Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(172)}, {Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(236)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)}, {Fbits: uint8(9), Fval: uint16(156)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)},
	{Fbits: uint8(9), Fval: uint16(220)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)}, {Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(188)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)},
	{Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(252)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)},
	{Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(194)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(162)},
	{Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)}, {Fbits: uint8(9), Fval: uint16(226)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)},
	{Fbits: uint8(9), Fval: uint16(146)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)}, {Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(210)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)},
	{Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(178)}, {Fbits: uint8(8), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(242)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(202)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)}, {Fbits: uint8(9), Fval: uint16(170)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)},
	{Fbits: uint8(9), Fval: uint16(234)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)}, {Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(154)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)},
	{Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(218)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(186)}, {Fbits: uint8(8), Fval: uint16(13)},
	{Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(250)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)}, {Fbits: uint8(9), Fval: uint16(198)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)},
	{Fbits: uint8(9), Fval: uint16(166)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)}, {Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(230)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)},
	{Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(150)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(214)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)},
	{Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(182)}, {Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(246)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)},
	{Fbits: uint8(9), Fval: uint16(206)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)}, {Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(174)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)},
	{Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(238)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(158)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)},
	{Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(222)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(190)},
	{Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)}, {Fbits: uint8(9), Fval: uint16(254)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)},
	{Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)}, {Fbits: uint8(9), Fval: uint16(193)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)},
	{Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(161)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)}, {Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(225)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)},
	{Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(145)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(209)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(177)}, {Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)},
	{Fbits: uint8(9), Fval: uint16(241)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)},
	{Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(201)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)}, {Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(169)}, {Fbits: uint8(8), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(233)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(153)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(217)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)},
	{Fbits: uint8(9), Fval: uint16(185)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)}, {Fbits: uint8(9), Fval: uint16(249)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)},
	{Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)}, {Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(197)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)},
	{Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(165)}, {Fbits: uint8(8), Fval: uint16(2)}, {Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(229)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(149)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)},
	{Fbits: uint8(9), Fval: uint16(213)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)}, {Fbits: uint8(9), Fval: uint16(181)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)},
	{Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(245)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)}, {Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)},
	{Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(205)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(173)},
	{Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(237)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)},
	{Fbits: uint8(9), Fval: uint16(157)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)}, {Fbits: uint8(9), Fval: uint16(221)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)},
	{Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(189)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)}, {Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(253)}, {Fop: uint8(96), Fbits: uint8(7)},
	{Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(195)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(163)}, {Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)},
	{Fbits: uint8(9), Fval: uint16(227)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)}, {Fbits: uint8(9), Fval: uint16(147)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)},
	{Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(211)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)}, {Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(179)}, {Fbits: uint8(8), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(243)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(203)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)},
	{Fbits: uint8(9), Fval: uint16(171)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)}, {Fbits: uint8(9), Fval: uint16(235)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)},
	{Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(155)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)}, {Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(219)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)},
	{Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(187)}, {Fbits: uint8(8), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(251)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)},
	{Fbits: uint8(9), Fval: uint16(199)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)}, {Fbits: uint8(9), Fval: uint16(167)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)},
	{Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(231)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)}, {Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(151)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)},
	{Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(215)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(183)},
	{Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(247)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)},
	{Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)}, {Fbits: uint8(9), Fval: uint16(207)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)},
	{Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(175)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)}, {Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(239)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(159)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(223)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(191)}, {Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)},
	{Fbits: uint8(9), Fval: uint16(255)},
} /* inffixed.h:10:23 */
var distfix1 = [32]Code{
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(1)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(257)}, {Fop: uint8(19), Fbits: uint8(5), Fval: uint16(17)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(4097)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(5)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1025)},
	{Fop: uint8(21), Fbits: uint8(5), Fval: uint16(65)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(16385)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(3)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(513)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(33)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(8193)},
	{Fop: uint8(18), Fbits: uint8(5), Fval: uint16(9)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(2049)}, {Fop: uint8(22), Fbits: uint8(5), Fval: uint16(129)}, {Fop: uint8(64), Fbits: uint8(5)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(2)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(385)},
	{Fop: uint8(19), Fbits: uint8(5), Fval: uint16(25)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(6145)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(7)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1537)}, {Fop: uint8(21), Fbits: uint8(5), Fval: uint16(97)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(24577)},
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(4)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(769)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(49)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(12289)}, {Fop: uint8(18), Fbits: uint8(5), Fval: uint16(13)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(3073)},
	{Fop: uint8(22), Fbits: uint8(5), Fval: uint16(193)}, {Fop: uint8(64), Fbits: uint8(5)},
} /* inffixed.h:87:23 */

//
//    Update the window with the last wsize (normally 32K) bytes written before
//    returning.  If window does not exist yet, create it.  This is only called
//    when a window is already in use, or when output has been written during this
//    inflate call, but the end of the deflate stream has not been reached yet.
//    It is also called to create a window for dictionary data when a dictionary
//    is loaded.
//
//    Providing output buffers larger than 32K to inflate() should provide a speed
//    advantage, since only the last 32K of output is copied to the sliding window
//    upon return from inflate(), and since all distances after the first 32K of
//    output will fall in the output data, making match copies simpler and faster.
//    The advantage may be dependent on the size of the processor's data caches.
//
func updatewindow(tls *libc.TLS, strm Z_streamp, end uintptr, copy uint32) int32 { /* inflate.c:396:11: */
	var state uintptr
	var dist uint32

	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// if it hasn't been done already, allocate space for the window
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow == Z_NULL {
		(*Inflate_state)(unsafe.Pointer(state)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits), uint32(unsafe.Sizeof(uint8(0))))
		if (*Inflate_state)(unsafe.Pointer(state)).Fwindow == Z_NULL {
			return 1
		}
	}

	// if window not in use yet, initialize
	if (*Inflate_state)(unsafe.Pointer(state)).Fwsize == uint32(0) {
		(*Inflate_state)(unsafe.Pointer(state)).Fwsize = (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits)
		(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	}

	// copy state->wsize or less output bytes into the circular window
	if copy >= (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
		libc.X__builtin___memcpy_chk(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, (end - uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwsize)), uint64((*Inflate_state)(unsafe.Pointer(state)).Fwsize), libc.X__builtin_object_size(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, 0))
		(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fwhave = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	} else {
		dist = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (*Inflate_state)(unsafe.Pointer(state)).Fwnext)
		if dist > copy {
			dist = copy
		}
		libc.X__builtin___memcpy_chk(tls, ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), (end - uintptr(copy)), uint64(dist), libc.X__builtin_object_size(tls, ((*Inflate_state)(unsafe.Pointer(state)).Fwindow+uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), 0))
		copy = copy - (dist)
		if copy != 0 {
			libc.X__builtin___memcpy_chk(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, (end - uintptr(copy)), uint64(copy), libc.X__builtin_object_size(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, 0))
			(*Inflate_state)(unsafe.Pointer(state)).Fwnext = copy
			(*Inflate_state)(unsafe.Pointer(state)).Fwhave = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
		} else {
			*(*uint32)(unsafe.Pointer(state + 68 /* &.wnext */)) += (dist)
			if (*Inflate_state)(unsafe.Pointer(state)).Fwnext == (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
				(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
			}
			if (*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
				*(*uint32)(unsafe.Pointer(state + 64 /* &.whave */)) += (dist)
			}
		}
	}
	return 0
}

// Macros for inflate():

// check function to use adler32() for zlib or crc32() for gzip

// check macros for header crc

// Load registers with state in inflate() for speed

// Restore state from registers in inflate()

// Clear the input bit accumulator

// Get a byte of input into the bit accumulator, or return from inflate()
//    if there is no input available.

// Assure that there are at least n bits in the bit accumulator.  If there is
//    not enough available input to do that, then return from inflate().

// Return the low n bits of the bit accumulator (n < 16)

// Remove n bits from the bit accumulator

// Remove zero to seven bits as needed to go to a byte boundary

//
//    inflate() uses a state machine to process as much input data and generate as
//    much output data as possible before returning.  The state machine is
//    structured roughly as follows:
//
//     for (;;) switch (state) {
//     ...
//     case STATEn:
//         if (not enough input data or output space to make progress)
//             return;
//         ... make progress ...
//         state = STATEm;
//         break;
//     ...
//     }
//
//    so when inflate() is called again, the same case is attempted again, and
//    if the appropriate resources are provided, the machine proceeds to the
//    next state.  The NEEDBITS() macro is usually the way the state evaluates
//    whether it can proceed or should return.  NEEDBITS() does the return if
//    the requested bits are not available.  The typical use of the BITS macros
//    is:
//
//         NEEDBITS(n);
//         ... do something with BITS(n) ...
//         DROPBITS(n);
//
//    where NEEDBITS(n) either returns from inflate() if there isn't enough
//    input left to load n bits into the accumulator, or it continues.  BITS(n)
//    gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
//    the low n bits off the accumulator.  INITBITS() clears the accumulator
//    and sets the number of available bits to zero.  BYTEBITS() discards just
//    enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
//    and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
//
//    NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
//    if there is no input available.  The decoding of variable length codes uses
//    PULLBYTE() directly in order to pull just enough bytes to decode the next
//    code, and no more.
//
//    Some states loop until they get enough input, making sure that enough
//    state information is maintained to continue the loop where it left off
//    if NEEDBITS() returns in the loop.  For example, want, need, and keep
//    would all have to actually be part of the saved state in case NEEDBITS()
//    returns:
//
//     case STATEw:
//         while (want < need) {
//             NEEDBITS(n);
//             keep[want++] = BITS(n);
//             DROPBITS(n);
//         }
//         state = STATEx;
//     case STATEx:
//
//    As shown above, if the next state is also the next case, then the break
//    is omitted.
//
//    A state may also return if there is not enough output space available to
//    complete that state.  Those states are copying stored data, writing a
//    literal byte, and copying a matching string.
//
//    When returning, a "goto inf_leave" is used to update the total counters,
//    update the check value, and determine whether any progress has been made
//    during that inflate() call in order to return the proper return code.
//    Progress is defined as a change in either strm->avail_in or strm->avail_out.
//    When there is a window, goto inf_leave will update the window with the last
//    output written.  If a goto inf_leave occurs in the middle of decompression
//    and there is no window currently, goto inf_leave will create one and copy
//    output to the window for the next call of inflate().
//
//    In this implementation, the flush parameter of inflate() only affects the
//    return code (per zlib.h).  inflate() always writes as much as possible to
//    strm->next_out, given the space available and the provided input--the effect
//    documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
//    the allocation of and copying into a sliding window until necessary, which
//    provides the effect documented in zlib.h for Z_FINISH when the entire input
//    stream available.  So the only thing the flush parameter actually does is:
//    when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
//    will return Z_BUF_ERROR if it has not reached the end of the stream.
//

func Xinflate(tls *libc.TLS, strm Z_streamp, flush int32) int32 { /* inflate.c:622:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var state uintptr
	var next uintptr // next input
	var put uintptr  // next output
	var have uint32
	var left uint32 // available input and output
	var hold uint64 // bit buffer
	var bits uint32 // bits in bit buffer
	var in uint32
	var out uint32   // save starting available input and output
	var copy uint32  // number of stored or match bytes to copy
	var from uintptr // where to copy match bytes from
	var here Code    // current decoding table entry
	var last Code    // parent table entry
	var len uint32   // length to copy for repeats, bits to drop
	var ret int32    // return code
	// var hbuf [4]uint8 at bp, 4

	if !(((inflateStateCheck(tls, strm) != 0) || ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out == Z_NULL)) || (((*Z_stream)(unsafe.Pointer(strm)).Fnext_in == Z_NULL) && ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)))) {
		goto __1
	}
	return -2
__1:
	;

	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE) {
		goto __2
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPEDO
__2:
	; // skip check
__3:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	in = have
	out = left
	ret = Z_OK
__6:
	switch (*Inflate_state)(unsafe.Pointer(state)).Fmode {
	case HEAD:
		goto __10
	case FLAGS:
		goto __11
	case TIME:
		goto __12
	case OS:
		goto __13
	case EXLEN:
		goto __14
	case EXTRA:
		goto __15
	case NAME:
		goto __16
	case COMMENT:
		goto __17
	case HCRC:
		goto __18
	case DICTID:
		goto __19
	case DICT:
		goto __20
	case TYPE:
		goto __21
	case TYPEDO:
		goto __22
	case STORED:
		goto __23
	case COPY_:
		goto __24
	case COPY:
		goto __25
	case TABLE:
		goto __26
	case LENLENS:
		goto __27
	case CODELENS:
		goto __28
	case LEN_:
		goto __29
	case LEN:
		goto __30
	case LENEXT:
		goto __31
	case DIST:
		goto __32
	case DISTEXT:
		goto __33
	case MATCH:
		goto __34
	case LIT:
		goto __35
	case CHECK:
		goto __36
	case LENGTH:
		goto __37
	case DONE:
		goto __38
	case BAD:
		goto __39
	case MEM:
		goto __40
	case SYNC:
		goto __41
	default:
		goto __42
	}
	goto __9
__10:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwrap == 0) {
		goto __43
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPEDO
	goto __9
__43:
	;
__44:
__47:
	if !(bits < (uint32(16))) {
		goto __48
	}
__49:
	if !(have == uint32(0)) {
		goto __52
	}
	goto inf_leave
__52:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __50
__50:
	if 0 != 0 {
		goto __49
	}
	goto __51
__51:
	;
	goto __47
__48:
	;
	goto __45
__45:
	if 0 != 0 {
		goto __44
	}
	goto __46
__46:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 2) != 0) && (hold == uint64(0x8b1f))) {
		goto __53
	} // gzip header
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwbits == uint32(0)) {
		goto __54
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = uint32(15)
__54:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, uint64(0), Z_NULL, uint32(0))
__55:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
__58:
	hold = uint64(0)
	bits = uint32(0)
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = FLAGS
	goto __9
__53:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fflags = 0 // expect zlib header
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __61
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fdone = -1
__61:
	;
	if !(!(((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 1) != 0) || ((((uint64((uint32(hold) & ((uint32(1) << (8)) - uint32(1))) << 8)) + (hold >> 8)) % uint64(31)) != 0)) {
		goto __62
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 669 /* "incorrect header..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__62:
	;
	if !((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) != Z_DEFLATED) {
		goto __63
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 692 /* "unknown compress..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__63:
	;
__64:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __65
__65:
	if 0 != 0 {
		goto __64
	}
	goto __66
__66:
	;
	len = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(8))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwbits == uint32(0)) {
		goto __67
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = len
__67:
	;
	if !((len > uint32(15)) || (len > (*Inflate_state)(unsafe.Pointer(state)).Fwbits)) {
		goto __68
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 719 /* "invalid window s..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__68:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = (uint32(1) << len)

	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, Xadler32(tls, uint64(0), Z_NULL, uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = func() uint32 {
		if (hold & uint64(0x200)) != 0 {
			return DICTID
		}
		return TYPE
	}()
__69:
	hold = uint64(0)
	bits = uint32(0)
	goto __70
__70:
	if 0 != 0 {
		goto __69
	}
	goto __71
__71:
	;
	goto __9
__11:
__72:
__75:
	if !(bits < (uint32(16))) {
		goto __76
	}
__77:
	if !(have == uint32(0)) {
		goto __80
	}
	goto inf_leave
__80:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __78
__78:
	if 0 != 0 {
		goto __77
	}
	goto __79
__79:
	;
	goto __75
__76:
	;
	goto __73
__73:
	if 0 != 0 {
		goto __72
	}
	goto __74
__74:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fflags = int32(hold)
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0xff) != Z_DEFLATED) {
		goto __81
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 692 /* "unknown compress..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__81:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0xe000) != 0) {
		goto __82
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 739 /* "unknown header f..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__82:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __83
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Ftext = (int32((hold >> 8) & uint64(1)))
__83:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __84
	}
__85:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __86
__86:
	if 0 != 0 {
		goto __85
	}
	goto __87
__87:
	;
__84:
	;
__88:
	hold = uint64(0)
	bits = uint32(0)
	goto __89
__89:
	if 0 != 0 {
		goto __88
	}
	goto __90
__90:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TIME
__12:
__91:
__94:
	if !(bits < (uint32(32))) {
		goto __95
	}
__96:
	if !(have == uint32(0)) {
		goto __99
	}
	goto inf_leave
__99:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __97
__97:
	if 0 != 0 {
		goto __96
	}
	goto __98
__98:
	;
	goto __94
__95:
	;
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __100
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Ftime = hold
__100:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __101
	}
__102:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 2)) = (uint8((hold) >> 16))
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 3)) = (uint8((hold) >> 24))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(4))
	goto __103
__103:
	if 0 != 0 {
		goto __102
	}
	goto __104
__104:
	;
__101:
	;
__105:
	hold = uint64(0)
	bits = uint32(0)
	goto __106
__106:
	if 0 != 0 {
		goto __105
	}
	goto __107
__107:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = OS
__13:
__108:
__111:
	if !(bits < (uint32(16))) {
		goto __112
	}
__113:
	if !(have == uint32(0)) {
		goto __116
	}
	goto inf_leave
__116:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __114
__114:
	if 0 != 0 {
		goto __113
	}
	goto __115
__115:
	;
	goto __111
__112:
	;
	goto __109
__109:
	if 0 != 0 {
		goto __108
	}
	goto __110
__110:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __117
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fxflags = (int32(hold & uint64(0xff)))
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fos = (int32(hold >> 8))
__117:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __118
	}
__119:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __120
__120:
	if 0 != 0 {
		goto __119
	}
	goto __121
__121:
	;
__118:
	;
__122:
	hold = uint64(0)
	bits = uint32(0)
	goto __123
__123:
	if 0 != 0 {
		goto __122
	}
	goto __124
__124:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = EXLEN
__14:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0400) != 0) {
		goto __125
	}
__127:
__130:
	if !(bits < (uint32(16))) {
		goto __131
	}
__132:
	if !(have == uint32(0)) {
		goto __135
	}
	goto inf_leave
__135:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __133
__133:
	if 0 != 0 {
		goto __132
	}
	goto __134
__134:
	;
	goto __130
__131:
	;
	goto __128
__128:
	if 0 != 0 {
		goto __127
	}
	goto __129
__129:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(hold)
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __136
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_len = uint32(hold)
__136:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __137
	}
__138:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __139
__139:
	if 0 != 0 {
		goto __138
	}
	goto __140
__140:
	;
__137:
	;
__141:
	hold = uint64(0)
	bits = uint32(0)
	goto __142
__142:
	if 0 != 0 {
		goto __141
	}
	goto __143
__143:
	;
	goto __126
__125:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __144
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra = Z_NULL
__144:
	;
__126:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = EXTRA
__15:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0400) != 0) {
		goto __145
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
	if !(copy > have) {
		goto __146
	}
	copy = have
__146:
	;
	if !(copy != 0) {
		goto __147
	}
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra != Z_NULL)) {
		goto __148
	}
	len = ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_len - (*Inflate_state)(unsafe.Pointer(state)).Flength)
	libc.X__builtin___memcpy_chk(tls, ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra + uintptr(len)), next, func() uint64 {
		if (len + copy) > (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_max {
			return (uint64((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_max - len))
		}
		return uint64(copy)
	}(), libc.X__builtin_object_size(tls, ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra+uintptr(len)), 0))
__148:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __149
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__149:
	;
	have = have - (copy)
	next += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) -= (copy)
__147:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength != 0) {
		goto __150
	}
	goto inf_leave
__150:
	;
__145:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = NAME
__16:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0800) != 0) {
		goto __151
	}
	if !(have == uint32(0)) {
		goto __153
	}
	goto inf_leave
__153:
	;
	copy = uint32(0)
__154:
	len = uint32(*(*uint8)(unsafe.Pointer(next + uintptr(libc.PostIncUint32(&copy, 1)))))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname != Z_NULL)) && ((*Inflate_state)(unsafe.Pointer(state)).Flength < (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname_max)) {
		goto __157
	}
	*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Flength, 1)))) = Bytef(len)
__157:
	;
	goto __155
__155:
	if (len != 0) && (copy < have) {
		goto __154
	}
	goto __156
__156:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __158
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__158:
	;
	have = have - (copy)
	next += uintptr(copy)
	if !(len != 0) {
		goto __159
	}
	goto inf_leave
__159:
	;
	goto __152
__151:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __160
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname = Z_NULL
__160:
	;
__152:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COMMENT
__17:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x1000) != 0) {
		goto __161
	}
	if !(have == uint32(0)) {
		goto __163
	}
	goto inf_leave
__163:
	;
	copy = uint32(0)
__164:
	len = uint32(*(*uint8)(unsafe.Pointer(next + uintptr(libc.PostIncUint32(&copy, 1)))))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment != Z_NULL)) && ((*Inflate_state)(unsafe.Pointer(state)).Flength < (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomm_max)) {
		goto __167
	}
	*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Flength, 1)))) = Bytef(len)
__167:
	;
	goto __165
__165:
	if (len != 0) && (copy < have) {
		goto __164
	}
	goto __166
__166:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __168
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__168:
	;
	have = have - (copy)
	next += uintptr(copy)
	if !(len != 0) {
		goto __169
	}
	goto inf_leave
__169:
	;
	goto __162
__161:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __170
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment = Z_NULL
__170:
	;
__162:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HCRC
__18:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) {
		goto __171
	}
__172:
__175:
	if !(bits < (uint32(16))) {
		goto __176
	}
__177:
	if !(have == uint32(0)) {
		goto __180
	}
	goto inf_leave
__180:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __178
__178:
	if 0 != 0 {
		goto __177
	}
	goto __179
__179:
	;
	goto __175
__176:
	;
	goto __173
__173:
	if 0 != 0 {
		goto __172
	}
	goto __174
__174:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (hold != ((*Inflate_state)(unsafe.Pointer(state)).Fcheck & uint64(0xffff)))) {
		goto __181
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 764 /* "header crc misma..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__181:
	;
__182:
	hold = uint64(0)
	bits = uint32(0)
	goto __183
__183:
	if 0 != 0 {
		goto __182
	}
	goto __184
__184:
	;
__171:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != Z_NULL) {
		goto __185
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fhcrc = (((*Inflate_state)(unsafe.Pointer(state)).Fflags >> 9) & 1)
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fdone = 1
__185:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, Xcrc32(tls, uint64(0), Z_NULL, uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__19:
__186:
__189:
	if !(bits < (uint32(32))) {
		goto __190
	}
__191:
	if !(have == uint32(0)) {
		goto __194
	}
	goto inf_leave
__194:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __192
__192:
	if 0 != 0 {
		goto __191
	}
	goto __193
__193:
	;
	goto __189
__190:
	;
	goto __187
__187:
	if 0 != 0 {
		goto __186
	}
	goto __188
__188:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, ((((((hold) >> 24) & uint64(0xff)) + (((hold) >> 8) & uint64(0xff00))) + (((hold) & uint64(0xff00)) << 8)) + (((hold) & uint64(0xff)) << 24)))
__195:
	hold = uint64(0)
	bits = uint32(0)
	goto __196
__196:
	if 0 != 0 {
		goto __195
	}
	goto __197
__197:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DICT
__20:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhavedict == 0) {
		goto __198
	}
__199:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __200
__200:
	if 0 != 0 {
		goto __199
	}
	goto __201
__201:
	;
	return Z_NEED_DICT
__198:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, Xadler32(tls, uint64(0), Z_NULL, uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
__21:
	if !((flush == Z_BLOCK) || (flush == Z_TREES)) {
		goto __202
	}
	goto inf_leave
__202:
	;
__22:
	if !((*Inflate_state)(unsafe.Pointer(state)).Flast != 0) {
		goto __203
	}
__204:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __205
__205:
	if 0 != 0 {
		goto __204
	}
	goto __206
__206:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = CHECK
	goto __9
__203:
	;
__207:
__210:
	if !(bits < (uint32(3))) {
		goto __211
	}
__212:
	if !(have == uint32(0)) {
		goto __215
	}
	goto inf_leave
__215:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
	goto __210
__211:
	;
	goto __208
__208:
	if 0 != 0 {
		goto __207
	}
	goto __209
__209:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flast = (int32(uint32(hold) & ((uint32(1) << (1)) - uint32(1))))
__216:
	hold >>= 1
	bits = bits - (uint32(1))
	goto __217
__217:
	if 0 != 0 {
		goto __216
	}
	goto __218
__218:
	;
	switch uint32(hold) & ((uint32(1) << (2)) - uint32(1)) {
	case uint32(0):
		goto __220
	case uint32(1):
		goto __221
	case uint32(2):
		goto __222
	case uint32(3):
		goto __223
	}
	goto __219
__220: // stored block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = STORED
	goto __219
__221: // fixed block
	fixedtables1(tls, state)

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN_ // decode codes
	if !(flush == Z_TREES) {
		goto __224
	}
__225:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __226
__226:
	if 0 != 0 {
		goto __225
	}
	goto __227
__227:
	;
	goto inf_leave
__224:
	;
	goto __219
__222: // dynamic block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TABLE
	goto __219
__223:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 367 /* "invalid block ty..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
__219:
	;
__228:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __229
__229:
	if 0 != 0 {
		goto __228
	}
	goto __230
__230:
	;
	goto __9
__23:
__231:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __232
__232:
	if 0 != 0 {
		goto __231
	}
	goto __233
__233:
	; // go to byte boundary
__234:
__237:
	if !(bits < (uint32(32))) {
		goto __238
	}
__239:
	if !(have == uint32(0)) {
		goto __242
	}
	goto inf_leave
__242:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __240
__240:
	if 0 != 0 {
		goto __239
	}
	goto __241
__241:
	;
	goto __237
__238:
	;
	goto __235
__235:
	if 0 != 0 {
		goto __234
	}
	goto __236
__236:
	;
	if !((hold & uint64(0xffff)) != ((hold >> 16) ^ uint64(0xffff))) {
		goto __243
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 386 /* "invalid stored b..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__243:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = (uint32(hold) & uint32(0xffff))

__244:
	hold = uint64(0)
	bits = uint32(0)
	goto __245
__245:
	if 0 != 0 {
		goto __244
	}
	goto __246
__246:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COPY_
	if !(flush == Z_TREES) {
		goto __247
	}
	goto inf_leave
__247:
	;
__24:
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COPY
__25:
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
	if !(copy != 0) {
		goto __248
	}
	if !(copy > have) {
		goto __249
	}
	copy = have
__249:
	;
	if !(copy > left) {
		goto __250
	}
	copy = left
__250:
	;
	if !(copy == uint32(0)) {
		goto __251
	}
	goto inf_leave
__251:
	;
	libc.X__builtin___memcpy_chk(tls, put, next, uint64(copy), libc.X__builtin_object_size(tls, put, 0))
	have = have - (copy)
	next += uintptr(copy)
	left = left - (copy)
	put += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) -= (copy)
	goto __9
__248:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__26:
__252:
__255:
	if !(bits < (uint32(14))) {
		goto __256
	}
__257:
	if !(have == uint32(0)) {
		goto __260
	}
	goto inf_leave
__260:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __258
__258:
	if 0 != 0 {
		goto __257
	}
	goto __259
__259:
	;
	goto __255
__256:
	;
	goto __253
__253:
	if 0 != 0 {
		goto __252
	}
	goto __254
__254:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnlen = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(257))
__261:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __262
__262:
	if 0 != 0 {
		goto __261
	}
	goto __263
__263:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fndist = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(1))
__264:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __265
__265:
	if 0 != 0 {
		goto __264
	}
	goto __266
__266:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fncode = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(4))
__267:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __268
__268:
	if 0 != 0 {
		goto __267
	}
	goto __269
__269:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fnlen > uint32(286)) || ((*Inflate_state)(unsafe.Pointer(state)).Fndist > uint32(30))) {
		goto __270
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 415 /* "too many length ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__270:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENLENS
__27:
__271:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < (*Inflate_state)(unsafe.Pointer(state)).Fncode) {
		goto __272
	}
__273:
__276:
	if !(bits < (uint32(3))) {
		goto __277
	}
__278:
	if !(have == uint32(0)) {
		goto __281
	}
	goto inf_leave
__281:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __279
__279:
	if 0 != 0 {
		goto __278
	}
	goto __280
__280:
	;
	goto __276
__277:
	;
	goto __274
__274:
	if 0 != 0 {
		goto __273
	}
	goto __275
__275:
	;
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(order1[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = (uint16(uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__282:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __283
__283:
	if 0 != 0 {
		goto __282
	}
	goto __284
__284:
	;
	goto __271
__272:
	;
__285:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < uint32(19)) {
		goto __286
	}
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(order1[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = uint16(0)
	goto __285
__286:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1368 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(7)
	ret = Xinflate_table(tls, CODES, state+152 /* &.lens */, uint32(19), (state + 144 /* &.next */),
		(state + 120 /* &.lenbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __287
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 451 /* "invalid code len..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__287:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = CODELENS
__28:
__288:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __289
	}
__290:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __293
	}
	goto __292
__293:
	;
__294:
	if !(have == uint32(0)) {
		goto __297
	}
	goto inf_leave
__297:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __295
__295:
	if 0 != 0 {
		goto __294
	}
	goto __296
__296:
	;
	goto __291
__291:
	goto __290
	goto __292
__292:
	;
	if !(int32(here.Fval) < 16) {
		goto __298
	}
__300:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __301
__301:
	if 0 != 0 {
		goto __300
	}
	goto __302
__302:
	;
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = here.Fval
	goto __299
__298:
	if !(int32(here.Fval) == 16) {
		goto __303
	}
__305:
__308:
	if !(bits < (uint32(int32(here.Fbits) + 2))) {
		goto __309
	}
__310:
	if !(have == uint32(0)) {
		goto __313
	}
	goto inf_leave
__313:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __311
__311:
	if 0 != 0 {
		goto __310
	}
	goto __312
__312:
	;
	goto __308
__309:
	;
	goto __306
__306:
	if 0 != 0 {
		goto __305
	}
	goto __307
__307:
	;
__314:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __315
__315:
	if 0 != 0 {
		goto __314
	}
	goto __316
__316:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave == uint32(0)) {
		goto __317
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __289
__317:
	;
	len = uint32(*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fhave-uint32(1)))*2)))
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (2)) - uint32(1))))
__318:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __319
__319:
	if 0 != 0 {
		goto __318
	}
	goto __320
__320:
	;
	goto __304
__303:
	if !(int32(here.Fval) == 17) {
		goto __321
	}
__323:
__326:
	if !(bits < (uint32(int32(here.Fbits) + 3))) {
		goto __327
	}
__328:
	if !(have == uint32(0)) {
		goto __331
	}
	goto inf_leave
__331:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __329
__329:
	if 0 != 0 {
		goto __328
	}
	goto __330
__330:
	;
	goto __326
__327:
	;
	goto __324
__324:
	if 0 != 0 {
		goto __323
	}
	goto __325
__325:
	;
__332:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __333
__333:
	if 0 != 0 {
		goto __332
	}
	goto __334
__334:
	;
	len = uint32(0)
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__335:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __336
__336:
	if 0 != 0 {
		goto __335
	}
	goto __337
__337:
	;
	goto __322
__321:
__338:
__341:
	if !(bits < (uint32(int32(here.Fbits) + 7))) {
		goto __342
	}
__343:
	if !(have == uint32(0)) {
		goto __346
	}
	goto inf_leave
__346:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __344
__344:
	if 0 != 0 {
		goto __343
	}
	goto __345
__345:
	;
	goto __341
__342:
	;
	goto __339
__339:
	if 0 != 0 {
		goto __338
	}
	goto __340
__340:
	;
__347:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __348
__348:
	if 0 != 0 {
		goto __347
	}
	goto __349
__349:
	;
	len = uint32(0)
	copy = (uint32(11) + (uint32(hold) & ((uint32(1) << (7)) - uint32(1))))
__350:
	hold >>= 7
	bits = bits - (uint32(7))
	goto __351
__351:
	if 0 != 0 {
		goto __350
	}
	goto __352
__352:
	;
__322:
	;
__304:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhave + copy) > ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __353
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __289
__353:
	;
__354:
	if !(libc.PostDecUint32(&copy, 1) != 0) {
		goto __355
	}
	*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = uint16(len)
	goto __354
__355:
	;
__299:
	;
	goto __288
__289:
	;

	// handle error breaks in while
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == BAD) {
		goto __356
	}
	goto __9
__356:
	;

	// check for end-of-block code (better have one)
	if !(int32(*(*uint16)(unsafe.Pointer((state + 152 /* &.lens */) + 256*2))) == 0) {
		goto __357
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 502 /* "invalid code -- ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__357:
	;

	// build code tables -- note: do not change the lenbits or distbits
	//                values here (9 and 6) without reading the comments in inftrees.h
	//                concerning the ENOUGH constants, which depend on those values
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1368 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	ret = Xinflate_table(tls, LENS, state+152 /* &.lens */, (*Inflate_state)(unsafe.Pointer(state)).Fnlen, (state + 144 /* &.next */),
		(state + 120 /* &.lenbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __358
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 539 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__358:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(6)
	ret = Xinflate_table(tls, DISTS, ((state + 152 /* &.lens */) + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fnlen)*2), (*Inflate_state)(unsafe.Pointer(state)).Fndist,
		(state + 144 /* &.next */), (state + 124 /* &.distbits */), state+792 /* &.work */)
	if !(ret != 0) {
		goto __359
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 567 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__359:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN_
	if !(flush == Z_TREES) {
		goto __360
	}
	goto inf_leave
__360:
	;
__29:
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
__30:
	if !((have >= uint32(6)) && (left >= uint32(258))) {
		goto __361
	}
__362:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __363
__363:
	if 0 != 0 {
		goto __362
	}
	goto __364
__364:
	;
	Xinflate_fast(tls, strm, out)
__365:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __366
__366:
	if 0 != 0 {
		goto __365
	}
	goto __367
__367:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE) {
		goto __368
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1
__368:
	;
	goto __9
__361:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fback = 0
__369:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __372
	}
	goto __371
__372:
	;
__373:
	if !(have == uint32(0)) {
		goto __376
	}
	goto inf_leave
__376:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __374
__374:
	if 0 != 0 {
		goto __373
	}
	goto __375
__375:
	;
	goto __370
__370:
	goto __369
	goto __371
__371:
	;
	if !((here.Fop != 0) && ((int32(here.Fop) & 0xf0) == 0)) {
		goto __377
	}
	last = here
__378:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __381
	}
	goto __380
__381:
	;
__382:
	if !(have == uint32(0)) {
		goto __385
	}
	goto inf_leave
__385:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __383
__383:
	if 0 != 0 {
		goto __382
	}
	goto __384
__384:
	;
	goto __379
__379:
	goto __378
	goto __380
__380:
	;
__386:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __387
__387:
	if 0 != 0 {
		goto __386
	}
	goto __388
__388:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += (int32(last.Fbits))
__377:
	;
__389:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __390
__390:
	if 0 != 0 {
		goto __389
	}
	goto __391
__391:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += (int32(here.Fbits))
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(here.Fval)
	if !((int32(here.Fop)) == 0) {
		goto __392
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LIT
	goto __9
__392:
	;
	if !((int32(here.Fop) & 32) != 0) {
		goto __393
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__393:
	;
	if !((int32(here.Fop) & 64) != 0) {
		goto __394
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__394:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENEXT
__31:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != 0) {
		goto __395
	}
__396:
__399:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __400
	}
__401:
	if !(have == uint32(0)) {
		goto __404
	}
	goto inf_leave
__404:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __402
__402:
	if 0 != 0 {
		goto __401
	}
	goto __403
__403:
	;
	goto __399
__400:
	;
	goto __397
__397:
	if 0 != 0 {
		goto __396
	}
	goto __398
__398:
	;
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__405:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __406
__406:
	if 0 != 0 {
		goto __405
	}
	goto __407
__407:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += int32(((*Inflate_state)(unsafe.Pointer(state)).Fextra))
__395:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fwas = (*Inflate_state)(unsafe.Pointer(state)).Flength
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DIST
__32:
__408:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Fdistbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __411
	}
	goto __410
__411:
	;
__412:
	if !(have == uint32(0)) {
		goto __415
	}
	goto inf_leave
__415:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __413
__413:
	if 0 != 0 {
		goto __412
	}
	goto __414
__414:
	;
	goto __409
__409:
	goto __408
	goto __410
__410:
	;
	if !((int32(here.Fop) & 0xf0) == 0) {
		goto __416
	}
	last = here
__417:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __420
	}
	goto __419
__420:
	;
__421:
	if !(have == uint32(0)) {
		goto __424
	}
	goto inf_leave
__424:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __422
__422:
	if 0 != 0 {
		goto __421
	}
	goto __423
__423:
	;
	goto __418
__418:
	goto __417
	goto __419
__419:
	;
__425:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __426
__426:
	if 0 != 0 {
		goto __425
	}
	goto __427
__427:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += (int32(last.Fbits))
__416:
	;
__428:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __429
__429:
	if 0 != 0 {
		goto __428
	}
	goto __430
__430:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += (int32(here.Fbits))
	if !((int32(here.Fop) & 64) != 0) {
		goto __431
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__431:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Foffset = uint32(here.Fval)
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DISTEXT
__33:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != 0) {
		goto __432
	}
__433:
__436:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __437
	}
__438:
	if !(have == uint32(0)) {
		goto __441
	}
	goto inf_leave
__441:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __439
__439:
	if 0 != 0 {
		goto __438
	}
	goto __440
__440:
	;
	goto __436
__437:
	;
	goto __434
__434:
	if 0 != 0 {
		goto __433
	}
	goto __435
__435:
	;
	*(*uint32)(unsafe.Pointer(state + 96 /* &.offset */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__442:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __443
__443:
	if 0 != 0 {
		goto __442
	}
	goto __444
__444:
	;
	*(*int32)(unsafe.Pointer(state + 7148 /* &.back */)) += int32(((*Inflate_state)(unsafe.Pointer(state)).Fextra))
__432:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = MATCH
__34:
	if !(left == uint32(0)) {
		goto __445
	}
	goto inf_leave
__445:
	;
	copy = (out - left)
	if !((*Inflate_state)(unsafe.Pointer(state)).Foffset > copy) {
		goto __446
	} // copy from window
	copy = ((*Inflate_state)(unsafe.Pointer(state)).Foffset - copy)
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Fwhave) {
		goto __448
	}
	if !((*Inflate_state)(unsafe.Pointer(state)).Fsane != 0) {
		goto __449
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__449:
	;
__448:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Fwnext) {
		goto __450
	}
	copy = copy - ((*Inflate_state)(unsafe.Pointer(state)).Fwnext)
	from = ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fwsize - copy)))
	goto __451
__450:
	from = ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fwnext - copy)))
__451:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Flength) {
		goto __452
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__452:
	;
	goto __447
__446: // copy from output
	from = (put - uintptr((*Inflate_state)(unsafe.Pointer(state)).Foffset))
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__447:
	;
	if !(copy > left) {
		goto __453
	}
	copy = left
__453:
	;
	left = left - (copy)
	*(*uint32)(unsafe.Pointer(state + 92 /* &.length */)) -= (copy)
__454:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __455
__455:
	if libc.PreDecUint32(&copy, 1) != 0 {
		goto __454
	}
	goto __456
__456:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength == uint32(0)) {
		goto __457
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
__457:
	;
	goto __9
__35:
	if !(left == uint32(0)) {
		goto __458
	}
	goto inf_leave
__458:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Flength)
	left--
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
	goto __9
__36:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) {
		goto __459
	}
__460:
__463:
	if !(bits < (uint32(32))) {
		goto __464
	}
__465:
	if !(have == uint32(0)) {
		goto __468
	}
	goto inf_leave
__468:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __466
__466:
	if 0 != 0 {
		goto __465
	}
	goto __467
__467:
	;
	goto __463
__464:
	;
	goto __461
__461:
	if 0 != 0 {
		goto __460
	}
	goto __462
__462:
	;
	out = out - (left)
	*(*ULong)(unsafe.Pointer(strm + 40 /* &.total_out */)) += (ULong(out))
	*(*uint64)(unsafe.Pointer(state + 40 /* &.total */)) += (uint64(out))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (out != 0)) {
		goto __469
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, func() uint64 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, (put - uintptr(out)), out)
		}
		return Xadler32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, (put - uintptr(out)), out)
	}())
__469:
	;
	out = left
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && ((func() uint64 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return hold
		}
		return ((((((hold) >> 24) & uint64(0xff)) + (((hold) >> 8) & uint64(0xff00))) + (((hold) & uint64(0xff00)) << 8)) + (((hold) & uint64(0xff)) << 24))
	}()) != (*Inflate_state)(unsafe.Pointer(state)).Fcheck)) {
		goto __470
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 784 /* "incorrect data c..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__470:
	;
__471:
	hold = uint64(0)
	bits = uint32(0)
	goto __472
__472:
	if 0 != 0 {
		goto __471
	}
	goto __473
__473:
	;

__459:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENGTH
__37:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) && ((*Inflate_state)(unsafe.Pointer(state)).Fflags != 0)) {
		goto __474
	}
__475:
__478:
	if !(bits < (uint32(32))) {
		goto __479
	}
__480:
	if !(have == uint32(0)) {
		goto __483
	}
	goto inf_leave
__483:
	;
	have--
	hold = hold + ((uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __481
__481:
	if 0 != 0 {
		goto __480
	}
	goto __482
__482:
	;
	goto __478
__479:
	;
	goto __476
__476:
	if 0 != 0 {
		goto __475
	}
	goto __477
__477:
	;
	if !(hold != ((*Inflate_state)(unsafe.Pointer(state)).Ftotal & 0xffffffff)) {
		goto __484
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 805 /* "incorrect length..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__484:
	;
__485:
	hold = uint64(0)
	bits = uint32(0)
	goto __486
__486:
	if 0 != 0 {
		goto __485
	}
	goto __487
__487:
	;

__474:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DONE
__38:
	ret = Z_STREAM_END
	goto inf_leave
__39:
	ret = -3
	goto inf_leave
__40:
	return -4
__41:
__42:
	return -2
__9:
	;
	goto __7
__7:
	goto __6
	goto __8
__8:
	;

	//
	//        Return from inflate(), updating the total counts and the check value.
	//        If there was no progress during the inflate() call, return a buffer
	//        error.  Call updatewindow() to create and/or update the window state.
	//        Note: a memory error from inflate() is non-recoverable.
	//
inf_leave:
__488:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __489
__489:
	if 0 != 0 {
		goto __488
	}
	goto __490
__490:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fwsize != 0) || (((out != (*Z_stream)(unsafe.Pointer(strm)).Favail_out) && ((*Inflate_state)(unsafe.Pointer(state)).Fmode < BAD)) && (((*Inflate_state)(unsafe.Pointer(state)).Fmode < CHECK) || (flush != Z_FINISH)))) {
		goto __491
	}
	if !(updatewindow(tls, strm, (*Z_stream)(unsafe.Pointer(strm)).Fnext_out, (out-(*Z_stream)(unsafe.Pointer(strm)).Favail_out)) != 0) {
		goto __492
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = MEM
	return -4
__492:
	;
__491:
	;
	in = in - ((*Z_stream)(unsafe.Pointer(strm)).Favail_in)
	out = out - ((*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	*(*ULong)(unsafe.Pointer(strm + 16 /* &.total_in */)) += (ULong(in))
	*(*ULong)(unsafe.Pointer(strm + 40 /* &.total_out */)) += (ULong(out))
	*(*uint64)(unsafe.Pointer(state + 40 /* &.total */)) += (uint64(out))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (out != 0)) {
		goto __493
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint64(state+32 /* &.check */, func() uint64 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr(out)), out)
		}
		return Xadler32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr(out)), out)
	}())
__493:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fdata_type = (((int32((*Inflate_state)(unsafe.Pointer(state)).Fbits) + (func() int32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Flast != 0 {
			return 64
		}
		return 0
	}())) + (func() int32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE {
			return 128
		}
		return 0
	}())) + (func() int32 {
		if ((*Inflate_state)(unsafe.Pointer(state)).Fmode == LEN_) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode == COPY_) {
			return 256
		}
		return 0
	}()))
	if !((((in == uint32(0)) && (out == uint32(0))) || (flush == Z_FINISH)) && (ret == Z_OK)) {
		goto __494
	}
	ret = -5
__494:
	;
	return ret
}

var order1 =                                                                                                                                                                                                                         // permutation of code lengths
[19]uint16{uint16(16), uint16(17), uint16(18), uint16(0), uint16(8), uint16(7), uint16(9), uint16(6), uint16(10), uint16(5), uint16(11), uint16(4), uint16(12), uint16(3), uint16(13), uint16(2), uint16(14), uint16(1), uint16(15)} /* inflate.c:642:33 */

func XinflateEnd(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1277:13: */
	var state uintptr
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow != Z_NULL {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Inflate_state)(unsafe.Pointer(state)).Fwindow)
	}
	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = Z_NULL

	return Z_OK
}

func XinflateGetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength uintptr) int32 { /* inflate.c:1291:13: */
	var state uintptr

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// copy dictionary
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwhave != 0) && (dictionary != Z_NULL) {
		libc.X__builtin___memcpy_chk(tls, dictionary, ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), (uint64((*Inflate_state)(unsafe.Pointer(state)).Fwhave - (*Inflate_state)(unsafe.Pointer(state)).Fwnext)), libc.X__builtin_object_size(tls, dictionary, 0))
		libc.X__builtin___memcpy_chk(tls, ((dictionary + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwhave)) - uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), (*Inflate_state)(unsafe.Pointer(state)).Fwindow, uint64((*Inflate_state)(unsafe.Pointer(state)).Fwnext), libc.X__builtin_object_size(tls, ((dictionary+uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwhave))-uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), 0))
	}
	if dictLength != Z_NULL {
		*(*UInt)(unsafe.Pointer(dictLength)) = (*Inflate_state)(unsafe.Pointer(state)).Fwhave
	}
	return Z_OK
}

func XinflateSetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength UInt) int32 { /* inflate.c:1314:13: */
	var state uintptr
	var dictid uint64
	var ret int32

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) && ((*Inflate_state)(unsafe.Pointer(state)).Fmode != DICT) {
		return -2
	}

	// check for correct dictionary identifier
	if (*Inflate_state)(unsafe.Pointer(state)).Fmode == DICT {
		dictid = Xadler32(tls, uint64(0), Z_NULL, uint32(0))
		dictid = Xadler32(tls, dictid, dictionary, dictLength)
		if dictid != (*Inflate_state)(unsafe.Pointer(state)).Fcheck {
			return -3
		}
	}

	// copy dictionary to window using updatewindow(), which will amend the
	//        existing dictionary if appropriate
	ret = updatewindow(tls, strm, (dictionary + uintptr(dictLength)), dictLength)
	if ret != 0 {
		(*Inflate_state)(unsafe.Pointer(state)).Fmode = MEM
		return -4
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fhavedict = 1

	return Z_OK
}

func XinflateGetHeader(tls *libc.TLS, strm Z_streamp, head Gz_headerp) int32 { /* inflate.c:1349:13: */
	var state uintptr

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 2) == 0 {
		return -2
	}

	// save header structure
	(*Inflate_state)(unsafe.Pointer(state)).Fhead = head
	(*Gz_header)(unsafe.Pointer(head)).Fdone = 0
	return Z_OK
}

//
//    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
//    or when out of input.  When called, *have is the number of pattern bytes
//    found in order so far, in 0..3.  On return *have is updated to the new
//    state.  If on return *have equals four, then the pattern was found and the
//    return value is how many bytes were read including the last byte of the
//    pattern.  If *have is less than four, then the pattern has not been found
//    yet and the return value is len.  In the latter case, syncsearch() can be
//    called again with more data and the *have state.  *have is initialized to
//    zero for the first call.
//
func syncsearch(tls *libc.TLS, have uintptr, buf uintptr, len uint32) uint32 { /* inflate.c:1377:16: */
	var got uint32
	var next uint32

	got = *(*uint32)(unsafe.Pointer(have))
	next = uint32(0)
	for (next < len) && (got < uint32(4)) {
		if (int32(*(*uint8)(unsafe.Pointer(buf + uintptr(next))))) == (func() int32 {
			if got < uint32(2) {
				return 0
			}
			return 0xff
		}()) {
			got++
		} else if *(*uint8)(unsafe.Pointer(buf + uintptr(next))) != 0 {
			got = uint32(0)
		} else {
			got = (uint32(4) - got)
		}
		next++
	}
	*(*uint32)(unsafe.Pointer(have)) = got
	return next
}

func XinflateSync(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1400:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var len uint32 // number of bytes to look at or looked at
	var in uint64
	var out uint64 // temporary to save total_in and total_out
	// var buf [4]uint8 at bp, 4
	// to restore bit buffer to byte string
	var state uintptr

	// check parameters
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && ((*Inflate_state)(unsafe.Pointer(state)).Fbits < uint32(8)) {
		return -5
	}

	// if first time, start search in bit buffer
	if (*Inflate_state)(unsafe.Pointer(state)).Fmode != SYNC {
		(*Inflate_state)(unsafe.Pointer(state)).Fmode = SYNC
		libc.AssignShlPtrUint64(state+80 /* &.hold */, int((uint64((*Inflate_state)(unsafe.Pointer(state)).Fbits & uint32(7)))))
		*(*uint32)(unsafe.Pointer(state + 88 /* &.bits */)) -= ((*Inflate_state)(unsafe.Pointer(state)).Fbits & uint32(7))
		len = uint32(0)
		for (*Inflate_state)(unsafe.Pointer(state)).Fbits >= uint32(8) {
			*(*uint8)(unsafe.Pointer(bp /* &buf[0] */ + uintptr(libc.PostIncUint32(&len, 1)))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Fhold)
			libc.AssignShrPtrUint64(state+80 /* &.hold */, int(uint64(8)))
			*(*uint32)(unsafe.Pointer(state + 88 /* &.bits */)) -= (uint32(8))
		}
		(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
		syncsearch(tls, (state + 140 /* &.have */), bp /* &buf[0] */, len)
	}

	// search available input
	len = syncsearch(tls, (state + 140 /* &.have */), (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, (*Z_stream)(unsafe.Pointer(strm)).Favail_in)
	*(*UInt)(unsafe.Pointer(strm + 8 /* &.avail_in */)) -= (len)
	*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 16 /* &.total_in */)) += (ULong(len))

	// return no joy or set up to restart inflate() on a new block
	if (*Inflate_state)(unsafe.Pointer(state)).Fhave != uint32(4) {
		return -3
	}
	in = (*Z_stream)(unsafe.Pointer(strm)).Ftotal_in
	out = (*Z_stream)(unsafe.Pointer(strm)).Ftotal_out
	XinflateReset(tls, strm)
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = in
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_out = out
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	return Z_OK
}

//
//    Returns true if inflate is currently at the end of a block generated by
//    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
//    implementation to provide an additional safety check. PPP uses
//    Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
//    block. When decompressing, PPP checks that at the end of input packet,
//    inflate is waiting for these length bytes.
//
func XinflateSyncPoint(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1451:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return (libc.Bool32(((*Inflate_state)(unsafe.Pointer(state)).Fmode == STORED) && ((*Inflate_state)(unsafe.Pointer(state)).Fbits == uint32(0))))
}

func XinflateCopy(tls *libc.TLS, dest Z_streamp, source Z_streamp) int32 { /* inflate.c:1461:13: */
	var state uintptr
	var copy uintptr
	var window uintptr
	var wsize uint32

	// check input
	if (inflateStateCheck(tls, source) != 0) || (dest == Z_NULL) {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(source)).Fstate

	// allocate space
	copy = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((source + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if copy == Z_NULL {
		return -4
	}
	window = Z_NULL
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow != Z_NULL {
		window = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((source + 64 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits), uint32(unsafe.Sizeof(uint8(0))))
		if window == Z_NULL {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((source + 72 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, copy)
			return -4
		}
	}

	// copy state
	libc.X__builtin___memcpy_chk(tls, dest, source, uint64(unsafe.Sizeof(Z_stream{})), libc.X__builtin_object_size(tls, dest, 0))
	libc.X__builtin___memcpy_chk(tls, copy, state, uint64(unsafe.Sizeof(Inflate_state{})), libc.X__builtin_object_size(tls, copy, 0))
	(*Inflate_state)(unsafe.Pointer(copy)).Fstrm = dest
	if ((*Inflate_state)(unsafe.Pointer(state)).Flencode >= state+1368 /* &.codes */) && ((*Inflate_state)(unsafe.Pointer(state)).Flencode <= (((state + 1368 /* &.codes */) + uintptr((ENOUGH_LENS+ENOUGH_DISTS))*4) - uintptr(1)*4)) {
		(*Inflate_state)(unsafe.Pointer(copy)).Flencode = ((copy + 1368 /* &.codes */) + uintptr((int64(((*Inflate_state)(unsafe.Pointer(state)).Flencode-(state+1368 /* &.codes */))/4)))*4)
		(*Inflate_state)(unsafe.Pointer(copy)).Fdistcode = ((copy + 1368 /* &.codes */) + uintptr((int64(((*Inflate_state)(unsafe.Pointer(state)).Fdistcode-(state+1368 /* &.codes */))/4)))*4)
	}
	(*Inflate_state)(unsafe.Pointer(copy)).Fnext = ((copy + 1368 /* &.codes */) + uintptr((int64(((*Inflate_state)(unsafe.Pointer(state)).Fnext-(state+1368 /* &.codes */))/4)))*4)
	if window != Z_NULL {
		wsize = (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits)
		libc.X__builtin___memcpy_chk(tls, window, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, uint64(wsize), libc.X__builtin_object_size(tls, window, 0))
	}
	(*Inflate_state)(unsafe.Pointer(copy)).Fwindow = window
	(*Z_stream)(unsafe.Pointer(dest)).Fstate = copy
	return Z_OK
}

func XinflateUndermine(tls *libc.TLS, strm Z_streamp, subvert int32) int32 { /* inflate.c:1508:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	_ = subvert
	(*Inflate_state)(unsafe.Pointer(state)).Fsane = 1
	return -3
}

func XinflateValidate(tls *libc.TLS, strm Z_streamp, check int32) int32 { /* inflate.c:1526:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if check != 0 {
		*(*int32)(unsafe.Pointer(state + 16 /* &.wrap */)) |= (4)
	} else {
		*(*int32)(unsafe.Pointer(state + 16 /* &.wrap */)) &= (libc.CplInt32(4))
	}
	return Z_OK
}

func XinflateMark(tls *libc.TLS, strm Z_streamp) int64 { /* inflate.c:1541:14: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -(int64(1) << 16)
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return ((int64((uint64(int64((*Inflate_state)(unsafe.Pointer(state)).Fback))) << 16)) + (func() int64 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fmode == COPY {
			return int64((*Inflate_state)(unsafe.Pointer(state)).Flength)
		}
		return func() int64 {
			if (*Inflate_state)(unsafe.Pointer(state)).Fmode == MATCH {
				return (int64((*Inflate_state)(unsafe.Pointer(state)).Fwas - (*Inflate_state)(unsafe.Pointer(state)).Flength))
			}
			return int64(0)
		}()
	}()))
}

func XinflateCodesUsed(tls *libc.TLS, strm Z_streamp) uint64 { /* inflate.c:1554:23: */
	var state uintptr
	if inflateStateCheck(tls, strm) != 0 {
		return libc.Uint64(libc.Uint64FromInt32(-1))
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return (uint64(int64(((*Inflate_state)(unsafe.Pointer(state)).Fnext - (state + 1368 /* &.codes */)) / 4)))
}

var Xinflate_copyright = *(*[48]int8)(unsafe.Pointer(ts + 828 /* " inflate 1.2.11 ..." */)) /* inftrees.c:11:12 */

//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

//
//    Build a set of tables to decode the provided canonical Huffman code.
//    The code lengths are lens[0..codes-1].  The result starts at *table,
//    whose indices are 0..2^bits-1.  work is a writable array of at least
//    lens shorts, which is used as a work area.  type is the type of code
//    to be generated, CODES, LENS, or DISTS.  On return, zero is success,
//    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
//    on return points to the next available entry's address.  bits is the
//    requested root table index bits, and on return it is the actual root
//    table index bits.  It will differ if the request is greater than the
//    longest code or if it is less than the shortest code.
//
func Xinflate_table(tls *libc.TLS, type1 Codetype, lens uintptr, codes uint32, table uintptr, bits uintptr, work uintptr) int32 { /* inftrees.c:32:19: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var len uint32 // a code's length in bits
	var sym uint32 // index of code symbols
	var min uint32
	var max uint32    // minimum and maximum code lengths
	var root uint32   // number of index bits for root table
	var curr uint32   // number of index bits for current table
	var drop uint32   // code bits to drop for sub-table
	var left int32    // number of prefix codes available
	var used uint32   // code entries in table used
	var huff uint32   // Huffman code
	var incr uint32   // for incrementing code, index
	var fill uint32   // index for replicating entries
	var low uint32    // low bits for current root entry
	var mask uint32   // mask for low root bits
	var here Code     // table entry for duplication
	var next uintptr  // next available space in table
	var base uintptr  // base value table to use
	var extra uintptr // extra bits table to use
	var match uint32  // use base and extra for symbol >= match
	// var count [16]uint16 at bp, 32
	// number of codes of each length
	// var offs [16]uint16 at bp+32, 32

	//
	//        Process a set of code lengths to create a canonical Huffman code.  The
	//        code lengths are lens[0..codes-1].  Each length corresponds to the
	//        symbols 0..codes-1.  The Huffman code is generated by first sorting the
	//        symbols by length from short to long, and retaining the symbol order
	//        for codes with equal lengths.  Then the code starts with all zero bits
	//        for the first code of the shortest length, and the codes are integer
	//        increments for the same length, and zeros are appended as the length
	//        increases.  For the deflate format, these bits are stored backwards
	//        from their more natural integer increment ordering, and so when the
	//        decoding tables are built in the large loop below, the integer codes
	//        are incremented backwards.
	//
	//        This routine assumes, but does not check, that all of the entries in
	//        lens[] are in the range 0..MAXBITS.  The caller must assure this.
	//        1..MAXBITS is interpreted as that code length.  zero means that that
	//        symbol does not occur in this code.
	//
	//        The codes are sorted by computing a count of codes for each length,
	//        creating from that a table of starting indices for each length in the
	//        sorted table, and then entering the symbols in order in the sorted
	//        table.  The sorted table is work[], with that space being provided by
	//        the caller.
	//
	//        The length counts are used for other purposes as well, i.e. finding
	//        the minimum and maximum length codes, determining if there are any
	//        codes at all, checking for a valid set of lengths, and looking ahead
	//        at length counts to determine sub-table sizes when building the
	//        decoding tables.
	//

	// accumulate lengths for codes (assumes lens[] all in 0..MAXBITS)
	for len = uint32(0); len <= MAXBITS; len++ {
		*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2)) = uint16(0)
	}
	for sym = uint32(0); sym < codes; sym++ {
		*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2)))*2))++
	}

	// bound code lengths, force root to be within code lengths
	root = *(*uint32)(unsafe.Pointer(bits))
	for max = MAXBITS; max >= uint32(1); max-- {
		if int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(max)*2))) != 0 {
			break
		}
	}
	if root > max {
		root = max
	}
	if max == uint32(0) { // no symbols to code at all
		here.Fop = uint8(64) // invalid code marker
		here.Fbits = uint8(1)
		here.Fval = uint16(0)
		*(*Code)(unsafe.Pointer(libc.PostIncUintptr(&(*(*uintptr)(unsafe.Pointer(table))), 4))) = here // make a table to force an error
		*(*Code)(unsafe.Pointer(libc.PostIncUintptr(&(*(*uintptr)(unsafe.Pointer(table))), 4))) = here
		*(*uint32)(unsafe.Pointer(bits)) = uint32(1)
		return 0 // no symbols, but wait for decoding to report error
	}
	for min = uint32(1); min < max; min++ {
		if int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(min)*2))) != 0 {
			break
		}
	}
	if root < min {
		root = min
	}

	// check for an over-subscribed or incomplete set of lengths
	left = 1
	for len = uint32(1); len <= MAXBITS; len++ {
		left <<= 1
		left = left - (int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2))))
		if left < 0 {
			return -1
		} // over-subscribed
	}
	if (left > 0) && ((type1 == CODES) || (max != uint32(1))) {
		return -1
	} // incomplete set

	// generate offsets into symbol table for each length for sorting
	*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + 1*2)) = uint16(0)
	for len = uint32(1); len < MAXBITS; len++ {
		*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr((len+uint32(1)))*2)) = (uint16(int32(*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr(len)*2))) + int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2)))))
	}

	// sort symbols by length, by symbol order within each length
	for sym = uint32(0); sym < codes; sym++ {
		if int32(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2))) != 0 {
			*(*uint16)(unsafe.Pointer(work + uintptr(libc.PostIncUint16(&*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2)))*2)), 1))*2)) = uint16(sym)
		}
	}

	//
	//        Create and fill in decoding tables.  In this loop, the table being
	//        filled is at next and has curr index bits.  The code being used is huff
	//        with length len.  That code is converted to an index by dropping drop
	//        bits off of the bottom.  For codes where len is less than drop + curr,
	//        those top drop + curr - len bits are incremented through all values to
	//        fill the table with replicated entries.
	//
	//        root is the number of index bits for the root table.  When len exceeds
	//        root, sub-tables are created pointed to by the root entry with an index
	//        of the low root bits of huff.  This is saved in low to check for when a
	//        new sub-table should be started.  drop is zero when the root table is
	//        being filled, and drop is root when sub-tables are being filled.
	//
	//        When a new sub-table is needed, it is necessary to look ahead in the
	//        code lengths to determine what size sub-table is needed.  The length
	//        counts are used for this, and so count[] is decremented as codes are
	//        entered in the tables.
	//
	//        used keeps track of how many table entries have been allocated from the
	//        provided *table space.  It is checked for LENS and DIST tables against
	//        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	//        the initial root table size constants.  See the comments in inftrees.h
	//        for more information.
	//
	//        sym increments through all symbols, and the loop terminates when
	//        all codes of length max, i.e. all codes, have been processed.  This
	//        routine permits incomplete codes, so another loop after this one fills
	//        in the rest of the decoding tables with invalid code markers.
	//

	// set up for code type
	switch type1 {
	case CODES:
		base = libc.AssignUintptr(&extra, work) // dummy value--not used
		match = uint32(20)
		break
	case LENS:
		base = uintptr(unsafe.Pointer(&lbase))
		extra = uintptr(unsafe.Pointer(&lext))
		match = uint32(257)
		break
	default: // DISTS
		base = uintptr(unsafe.Pointer(&dbase))
		extra = uintptr(unsafe.Pointer(&dext))
		match = uint32(0)
	}

	// initialize state for loop
	huff = uint32(0)                            // starting code
	sym = uint32(0)                             // starting code symbol
	len = min                                   // starting code length
	next = *(*uintptr)(unsafe.Pointer(table))   // current table to fill in
	curr = root                                 // current table index bits
	drop = uint32(0)                            // current bits to drop from code for index
	low = libc.Uint32(libc.Uint32FromInt32(-1)) // trigger new sub-table when len > root
	used = (uint32(1) << root)                  // use root table entries
	mask = (used - uint32(1))                   // mask for comparing low

	// check available table space
	if ((type1 == LENS) && (used > ENOUGH_LENS)) || ((type1 == DISTS) && (used > ENOUGH_DISTS)) {
		return 1
	}

	// process all codes and make table entries
	for {
		// create table entry
		here.Fbits = (uint8(len - drop))
		if (uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))) + 1) < match {
			here.Fop = uint8(0)
			here.Fval = *(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))
		} else if uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))) >= match {
			here.Fop = uint8(*(*uint16)(unsafe.Pointer(extra + uintptr((uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))-match))*2)))
			here.Fval = *(*uint16)(unsafe.Pointer(base + uintptr((uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))-match))*2))
		} else {
			here.Fop = (uint8(32 + 64)) // end of block
			here.Fval = uint16(0)
		}

		// replicate for those indices with low len bits equal to huff
		incr = (uint32(1) << (len - drop))
		fill = (uint32(1) << curr)
		min = fill // save offset to next table
		for ok := true; ok; ok = (fill != uint32(0)) {
			fill = fill - (incr)
			*(*Code)(unsafe.Pointer(next + uintptr(((huff>>drop)+fill))*4)) = here
		}

		// backwards increment the len-bit code huff
		incr = (uint32(1) << (len - uint32(1)))
		for (huff & incr) != 0 {
			incr >>= 1
		}
		if incr != uint32(0) {
			huff = huff & (incr - uint32(1))
			huff = huff + (incr)
		} else {
			huff = uint32(0)
		}

		// go to next symbol, update count, len
		sym++
		if int32(libc.PreDecUint16(&(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2))), 1)) == 0 {
			if len == max {
				break
			}
			len = uint32(*(*uint16)(unsafe.Pointer(lens + uintptr(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))*2)))
		}

		// create new sub-table if needed
		if (len > root) && ((huff & mask) != low) {
			// if first time, transition to sub-tables
			if drop == uint32(0) {
				drop = root
			}

			// increment past last table
			next += 4 * (uintptr(min)) // here min is 1 << curr

			// determine length of next table
			curr = (len - drop)
			left = (int32(1) << curr)
			for (curr + drop) < max {
				left = left - (int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr((curr+drop))*2))))
				if left <= 0 {
					break
				}
				curr++
				left <<= 1
			}

			// check for enough space
			used = used + (uint32(1) << curr)
			if ((type1 == LENS) && (used > ENOUGH_LENS)) || ((type1 == DISTS) && (used > ENOUGH_DISTS)) {
				return 1
			}

			// point entry in root table to sub-table
			low = (huff & mask)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fop = uint8(curr)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fbits = uint8(root)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fval = (uint16((int64(next) - int64(*(*uintptr)(unsafe.Pointer(table)))) / 4))
		}
	}

	// fill in remaining table entry if code is incomplete (guaranteed to have
	//        at most one remaining entry, since if the code is incomplete, the
	//        maximum code length that was allowed to get this far is one bit)
	if huff != uint32(0) {
		here.Fop = uint8(64) // invalid code marker
		here.Fbits = (uint8(len - drop))
		here.Fval = uint16(0)
		*(*Code)(unsafe.Pointer(next + uintptr(huff)*4)) = here
	}

	// set return parameters
	*(*uintptr)(unsafe.Pointer(table)) += (uintptr(used)) * 4
	*(*uint32)(unsafe.Pointer(bits)) = root
	return 0
}

var lbase = [31]uint16{ // Length codes 257..285 base
	uint16(3), uint16(4), uint16(5), uint16(6), uint16(7), uint16(8), uint16(9), uint16(10), uint16(11), uint16(13), uint16(15), uint16(17), uint16(19), uint16(23), uint16(27), uint16(31),
			uint16(35), uint16(43), uint16(51), uint16(59), uint16(67), uint16(83), uint16(99), uint16(115), uint16(131), uint16(163), uint16(195), uint16(227), uint16(258), uint16(0), uint16(0)} /* inftrees.c:60:33 */
var lext = [31]uint16{ // Length codes 257..285 extra
	uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(17), uint16(17), uint16(17), uint16(17), uint16(18), uint16(18), uint16(18), uint16(18),
			uint16(19), uint16(19), uint16(19), uint16(19), uint16(20), uint16(20), uint16(20), uint16(20), uint16(21), uint16(21), uint16(21), uint16(21), uint16(16), uint16(77), uint16(202)} /* inftrees.c:63:33 */
var dbase = [32]uint16{ // Distance codes 0..29 base
	uint16(1), uint16(2), uint16(3), uint16(4), uint16(5), uint16(7), uint16(9), uint16(13), uint16(17), uint16(25), uint16(33), uint16(49), uint16(65), uint16(97), uint16(129), uint16(193),
	uint16(257), uint16(385), uint16(513), uint16(769), uint16(1025), uint16(1537), uint16(2049), uint16(3073), uint16(4097), uint16(6145),
			uint16(8193), uint16(12289), uint16(16385), uint16(24577), uint16(0), uint16(0)} /* inftrees.c:66:33 */
var dext = [32]uint16{ // Distance codes 0..29 extra
	uint16(16), uint16(16), uint16(16), uint16(16), uint16(17), uint16(17), uint16(18), uint16(18), uint16(19), uint16(19), uint16(20), uint16(20), uint16(21), uint16(21), uint16(22), uint16(22),
	uint16(23), uint16(23), uint16(24), uint16(24), uint16(25), uint16(25), uint16(26), uint16(26), uint16(27), uint16(27),
	uint16(28), uint16(28), uint16(29), uint16(29), uint16(64), uint16(64)} /* inftrees.c:70:33 */

type Static_tree_desc = Static_tree_desc_s /* deflate.h:84:36 */

// ===========================================================================
// Constants

// Bit length codes must not exceed MAX_BL_BITS bits

// end of block literal code

// repeat previous bit length 3-6 times (2 bits of repeat count)

// repeat a zero length 3-10 times  (3 bits of repeat count)

// repeat a zero length 11-138 times  (7 bits of repeat count)

var extra_lbits = [29]int32{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0} /* trees.c:62:17 */

var extra_dbits = [30]int32{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13} /* trees.c:65:17 */

var extra_blbits = [19]int32{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7} /* trees.c:68:17 */

var bl_order = [19]Uch{Uch(16), Uch(17), Uch(18), Uch(0), Uch(8), Uch(7), Uch(9), Uch(6), Uch(10), Uch(5), Uch(11), Uch(4), Uch(12), Uch(3), Uch(13), Uch(2), Uch(14), Uch(1), Uch(15)} /* trees.c:71:17 */
// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit length codes.

// ===========================================================================
// Local data. These are initialized only once.

// header created automatically with -DGEN_TREES_H

var static_ltree = [288]Ct_data{{
	Ffc: struct{ Ffreq Ush }{Ffreq: Ush(12)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(140)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(76)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(204)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(44)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(172)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(108)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(236)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(28)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(156)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(92)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(220)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(60)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(188)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(124)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(252)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(2)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(130)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(66)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(194)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(34)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(162)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(98)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(226)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(18)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(146)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(82)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(210)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(50)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(178)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(114)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(242)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(10)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(138)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(74)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(202)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(42)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(170)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(106)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(234)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(26)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(154)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(90)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(218)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(58)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(186)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(122)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(250)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(6)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(134)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(70)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(198)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(38)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(166)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(102)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(230)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(22)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(150)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(86)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(214)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(54)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(182)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(118)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(246)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(14)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(142)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(78)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(206)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(46)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(174)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(110)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(238)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(30)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(158)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(94)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(222)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(62)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(190)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(126)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(254)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(1)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(129)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(65)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(193)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(33)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(161)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(97)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(225)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(17)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(145)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(81)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(209)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(49)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(177)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(113)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(241)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(9)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(137)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(73)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(201)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(41)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(169)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(105)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(233)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(25)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(153)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(89)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(217)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(57)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(185)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(121)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(249)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(5)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(133)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(69)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(197)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(37)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(165)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(101)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(229)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(21)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(149)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(85)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(213)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(53)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(181)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(117)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(245)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(13)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(141)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(77)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(205)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(45)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(173)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(109)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(237)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(29)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(157)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(93)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(221)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(61)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(189)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(125)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(253)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(19)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(275)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(147)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(403)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(83)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(339)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(211)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(467)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(51)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(307)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(179)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(435)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(115)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(371)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(243)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(499)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(11)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(267)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(139)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(395)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(75)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(331)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(203)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(459)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(43)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(299)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(171)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(427)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(107)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(363)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(235)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(491)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(27)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(283)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(155)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(411)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(91)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(347)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(219)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(475)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(59)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(315)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(187)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(443)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(123)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(379)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(251)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(507)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(7)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(263)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(135)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(391)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(71)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(327)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(199)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(455)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(39)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(295)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(167)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(423)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(103)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(359)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(231)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(487)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(23)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(279)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(151)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(407)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(87)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(343)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(215)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(471)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(55)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(311)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(183)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(439)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(119)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(375)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(247)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(503)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(15)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(271)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(143)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(399)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(79)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(335)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(207)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(463)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(47)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(303)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(175)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(431)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(111)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(367)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(239)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(495)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(31)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(287)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(159)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(415)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(95)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(351)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(223)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(479)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(63)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(319)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(191)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(447)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(127)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(383)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(255)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(511)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(64)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(32)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(96)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(16)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(80)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(48)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(112)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(8)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(72)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(40)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(104)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(24)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(88)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(56)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(120)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(4)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(68)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(36)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(100)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(20)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(84)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(52)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(116)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(3)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(131)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(67)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(195)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(35)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(163)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(99)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(227)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}} /* trees.h:3:21 */

var static_dtree = [30]Ct_data{{Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(16)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(8)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(24)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(4)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(20)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(12)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(28)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(2)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(18)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(10)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(26)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(6)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(22)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(14)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(30)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(1)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(17)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(9)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(25)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(5)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(21)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(13)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(29)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(3)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(19)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(11)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(27)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(7)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(23)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}} /* trees.h:64:21 */

var X_dist_code = [512]Uch{
	Uch(0), Uch(1), Uch(2), Uch(3), Uch(4), Uch(4), Uch(5), Uch(5), Uch(6), Uch(6), Uch(6), Uch(6), Uch(7), Uch(7), Uch(7), Uch(7), Uch(8), Uch(8), Uch(8), Uch(8),
	Uch(8), Uch(8), Uch(8), Uch(8), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10),
	Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11),
	Uch(11), Uch(11), Uch(11), Uch(11), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12),
	Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(13), Uch(13), Uch(13), Uch(13),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(0), Uch(0), Uch(16), Uch(17),
	Uch(18), Uch(18), Uch(19), Uch(19), Uch(20), Uch(20), Uch(20), Uch(20), Uch(21), Uch(21), Uch(21), Uch(21), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22),
	Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(24), Uch(24), Uch(24), Uch(24), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
} /* trees.h:73:25 */

var X_length_code = [256]Uch{
	Uch(0), Uch(1), Uch(2), Uch(3), Uch(4), Uch(5), Uch(6), Uch(7), Uch(8), Uch(8), Uch(9), Uch(9), Uch(10), Uch(10), Uch(11), Uch(11), Uch(12), Uch(12), Uch(12), Uch(12),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(14), Uch(14), Uch(14), Uch(14), Uch(15), Uch(15), Uch(15), Uch(15), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16),
	Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(19), Uch(19), Uch(19), Uch(19),
	Uch(19), Uch(19), Uch(19), Uch(19), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20),
	Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(22), Uch(22), Uch(22), Uch(22),
	Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23),
	Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25),
	Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(28),
} /* trees.h:102:25 */

var base_length = [29]int32{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
	64, 80, 96, 112, 128, 160, 192, 224, 0,
} /* trees.h:118:17 */

var base_dist = [30]int32{
	0, 1, 2, 3, 4, 6, 8, 12, 16, 24,
	32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
	1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,
} /* trees.h:123:17 */

var static_l_desc = Static_tree_desc{Fstatic_tree: 0, Fextra_bits: 0, Fextra_base: (LITERALS + 1), Felems: ((LITERALS + 1) + LENGTH_CODES), Fmax_length: MAX_BITS} /* trees.c:125:31 */

var static_d_desc = Static_tree_desc{Fstatic_tree: 0, Fextra_bits: 0, Felems: D_CODES, Fmax_length: MAX_BITS} /* trees.c:128:31 */

var static_bl_desc = Static_tree_desc{Fextra_bits: 0, Felems: BL_CODES, Fmax_length: MAX_BL_BITS} /* trees.c:131:31 */

// Send a code of the given tree. c and tree must not have side effects

// ===========================================================================
// Output a short LSB first on the stream.
// IN assertion: there is enough room in pendingBuf.

// ===========================================================================
// Send a value on a given number of bits.
// IN assertion: length <= 16 and value fits in length bits.

// the arguments must not have side effects

// ===========================================================================
// Initialize the various 'constant' tables.
func tr_static_init(tls *libc.TLS) { /* trees.c:232:12: */
}

// ===========================================================================
// Genererate the file trees.h describing the static trees.

// ===========================================================================
// Initialize the tree data structures for a new zlib stream.
func X_tr_init(tls *libc.TLS, s uintptr) { /* trees.c:379:20: */
	tr_static_init(tls)

	(*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fdyn_tree = s + 212 /* &.dyn_ltree */
	(*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_l_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fdyn_tree = s + 2504 /* &.dyn_dtree */
	(*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_d_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fbl_desc.Fdyn_tree = s + 2748 /* &.bl_tree */
	(*Deflate_state)(unsafe.Pointer(s)).Fbl_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_bl_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0

	// Initialize the first block of the first file:
	init_block(tls, s)
}

// ===========================================================================
// Initialize a new block.
func init_block(tls *libc.TLS, s uintptr) { /* trees.c:407:12: */
	var n int32 // iterates over tree elements

	// Initialize the trees.
	for n = 0; n < ((LITERALS + 1) + LENGTH_CODES); n++ {
		*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}
	for n = 0; n < D_CODES; n++ {
		*(*Ush)(unsafe.Pointer((s + 2504 /* &.dyn_dtree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}
	for n = 0; n < BL_CODES; n++ {
		*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}

	*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + 256*4 /* &.fc */)) = Ush(1)
	(*Deflate_state)(unsafe.Pointer(s)).Fopt_len = libc.AssignPtrUint64(s+5920 /* &.static_len */, uint64(0))
	(*Deflate_state)(unsafe.Pointer(s)).Flast_lit = libc.AssignPtrUint32(s+5928 /* &.matches */, UInt(0))
}

// Index within the heap array of least frequent node in the Huffman tree

// ===========================================================================
// Remove the smallest element from the heap and recreate the heap with
// one less element. Updates heap and heap_len.

// ===========================================================================
// Compares to subtrees, using the tree depth as tie breaker when
// the subtrees have equal frequency. This minimizes the worst case length.

// ===========================================================================
// Restore the heap property by moving down the tree starting at node k,
// exchanging a node with the smallest of its two sons if necessary, stopping
// when the heap property is re-established (each father smaller than its
// two sons).
func pqdownheap(tls *libc.TLS, s uintptr, tree uintptr, k int32) { /* trees.c:451:12: */
	var v int32 = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(k)*4))
	var j int32 = (k << 1) // left son of k
	for j <= (*Deflate_state)(unsafe.Pointer(s)).Fheap_len {
		// Set j to the smallest of the two sons:
		if (j < (*Deflate_state)(unsafe.Pointer(s)).Fheap_len) && ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr((j+1))*4)))*4 /* &.fc */))) < int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) || ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr((j+1))*4)))*4 /* &.fc */))) == int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) && (int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr((j+1))*4)))))) <= int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4))))))))) {
			j++
		}
		// Exit if v is smaller than both sons
		if (int32(*(*Ush)(unsafe.Pointer(tree + uintptr(v)*4 /* &.fc */))) < int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) || ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(v)*4 /* &.fc */))) == int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) && (int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(v)))) <= int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4)))))))) {
			break
		}

		// Exchange v with the smallest son
		*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(k)*4)) = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(j)*4))
		k = j

		// And continue down the tree, setting j to the left son of k
		j <<= 1
	}
	*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(k)*4)) = v
}

// ===========================================================================
// Compute the optimal bit lengths for a tree and update the total bit length
// for the current block.
// IN assertion: the fields freq and dad are set, heap[heap_max] and
//    above are the tree nodes sorted by increasing frequency.
// OUT assertions: the field len is set to the optimal bit length, the
//     array bl_count contains the frequencies for each bit length.
//     The length opt_len is updated; static_len is also updated if stree is
//     not null.
func gen_bitlen(tls *libc.TLS, s uintptr, desc uintptr) { /* trees.c:486:12: */
	var tree uintptr = (*Tree_desc)(unsafe.Pointer(desc)).Fdyn_tree
	var max_code int32 = (*Tree_desc)(unsafe.Pointer(desc)).Fmax_code
	var stree uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fstatic_tree
	var extra uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fextra_bits
	var base int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fextra_base
	var max_length int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fmax_length
	var h int32 // heap index
	var n int32
	var m int32            // iterate over the tree elements
	var bits int32         // bit length
	var xbits int32        // extra bits
	var f Ush              // frequency
	var overflow int32 = 0 // number of elements with bit length too large

	for bits = 0; bits <= MAX_BITS; bits++ {
		*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(bits)*2)) = Ush(0)
	}

	// In a first pass, compute the optimal bit lengths (which may
	// overflow in the case of the bit length tree).
	*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fheap_max)*4)))*4 + 2 /* &.dl */)) = Ush(0) // root of the heap

	for h = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_max + 1); h < ((2 * ((LITERALS + 1) + LENGTH_CODES)) + 1); h++ {
		n = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(h)*4))
		bits = (int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)))*4 + 2 /* &.dl */))) + 1)
		if bits > max_length {
			bits = max_length
			overflow++
		}
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = Ush(bits)
		// We overwrite tree[n].Dad which is no longer needed

		if n > max_code {
			continue
		} // not a leaf node

		*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(bits)*2))++
		xbits = 0
		if n >= base {
			xbits = *(*Intf)(unsafe.Pointer(extra + uintptr((n-base))*4))
		}
		f = *(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))
		*(*Ulg)(unsafe.Pointer(s + 5912 /* &.opt_len */)) += (Ulg(f) * Ulg((uint32(bits + xbits))))
		if stree != 0 {
			*(*Ulg)(unsafe.Pointer(s + 5920 /* &.static_len */)) += (Ulg(f) * Ulg((uint32(int32(*(*Ush)(unsafe.Pointer(stree + uintptr(n)*4 + 2 /* &.dl */))) + xbits))))
		}
	}
	if overflow == 0 {
		return
	}

	// This happens for example on obj2 and pic of the Calgary corpus

	// Find the first bit length which could increase:
	for ok := true; ok; ok = (overflow > 0) {
		bits = (max_length - 1)
		for int32(*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(bits)*2))) == 0 {
			bits--
		}
		*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(bits)*2))--               // move one leaf down the tree
		*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr((bits+1))*2)) += Ush((2)) // move one overflow item as its brother
		*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(max_length)*2))--
		// The brother of the overflow item also moves one step up,
		// but this does not affect bl_count[max_length]
		overflow = overflow - (2)
	}

	// Now recompute all bit lengths, scanning in increasing frequency.
	// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	// lengths instead of fixing only the wrong ones. This idea is taken
	// from 'ar' written by Haruhiko Okumura.)
	for bits = max_length; bits != 0; bits-- {
		n = int32(*(*Ush)(unsafe.Pointer((s + 2976 /* &.bl_count */) + uintptr(bits)*2)))
		for n != 0 {
			m = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PreDecInt32(&h, 1))*4))
			if m > max_code {
				continue
			}
			if uint32(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */))) != uint32(bits) {

				*(*Ulg)(unsafe.Pointer(s + 5912 /* &.opt_len */)) += ((Ulg(bits) - Ulg(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */)))) * Ulg(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 /* &.fc */))))
				*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */)) = Ush(bits)
			}
			n--
		}
	}
}

// ===========================================================================
// Generate the codes for a given tree and bit counts (which need not be
// optimal).
// IN assertion: the array bl_count contains the bit length statistics for
// the given tree and the field len is set for all tree elements.
// OUT assertion: the field code is set for all tree elements of non
//     zero code length.
func gen_codes(tls *libc.TLS, tree uintptr, max_code int32, bl_count uintptr) { /* trees.c:572:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var next_code [16]Ush at bp, 32
	// next code value for each bit length
	var code uint32 = uint32(0) // running code value
	var bits int32              // bit index
	var n int32                 // code index

	// The distribution counts are first used to generate the code values
	// without bit reversal.
	for bits = 1; bits <= MAX_BITS; bits++ {
		code = ((code + uint32(*(*Ushf)(unsafe.Pointer(bl_count + uintptr((bits-1))*2)))) << 1)
		*(*Ush)(unsafe.Pointer(bp /* &next_code[0] */ + uintptr(bits)*2)) = Ush(code)
	}
	// Check that the bit counts in bl_count are consistent. The last code
	// must be all ones.

	for n = 0; n <= max_code; n++ {
		var len int32 = int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)))
		if len == 0 {
			continue
		}
		// Now reverse the bits
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */)) = Ush(bi_reverse(tls, uint32(libc.PostIncUint16(&*(*Ush)(unsafe.Pointer(bp /* &next_code[0] */ + uintptr(len)*2)), 1)), len))

	}
}

// ===========================================================================
// Construct one Huffman tree and assigns the code bit strings and lengths.
// Update the total bit length for the current block.
// IN assertion: the field freq is set for all tree elements.
// OUT assertions: the fields len and code are set to the optimal bit length
//     and corresponding code. The length opt_len is updated; static_len is
//     also updated if stree is not null. The field max_code is set.
func build_tree(tls *libc.TLS, s uintptr, desc uintptr) { /* trees.c:615:12: */
	var tree uintptr = (*Tree_desc)(unsafe.Pointer(desc)).Fdyn_tree
	var stree uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fstatic_tree
	var elems int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Felems
	var n int32
	var m int32             // iterate over heap elements
	var max_code int32 = -1 // largest code with non zero frequency
	var node int32          // new node being created

	// Construct the initial heap, with least frequent element in
	// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	// heap[0] is not used.
	(*Deflate_state)(unsafe.Pointer(s)).Fheap_len = 0
	(*Deflate_state)(unsafe.Pointer(s)).Fheap_max = ((2 * ((LITERALS + 1) + LENGTH_CODES)) + 1)

	for n = 0; n < elems; n++ {
		if int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))) != 0 {
			*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PreIncInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_len), 1))*4)) = libc.AssignInt32(&max_code, n)
			*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(n))) = Uch(0)
		} else {
			*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = Ush(0)
		}
	}

	// The pkzip format requires that at least one distance code exists,
	// and that at least one bit should be sent even if there is only one
	// possible code. So to avoid special checks later on we force at least
	// two codes of non zero frequency.
	for (*Deflate_state)(unsafe.Pointer(s)).Fheap_len < 2 {
		node = libc.AssignPtrInt32((s+3008 /* &.heap */)+uintptr(libc.PreIncInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_len), 1))*4, func() int32 {
			if max_code < 2 {
				return libc.PreIncInt32(&max_code, 1)
			}
			return 0
		}())
		*(*Ush)(unsafe.Pointer(tree + uintptr(node)*4 /* &.fc */)) = Ush(1)
		*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(node))) = Uch(0)
		(*Deflate_state)(unsafe.Pointer(s)).Fopt_len--
		if stree != 0 {
			*(*Ulg)(unsafe.Pointer(s + 5920 /* &.static_len */)) -= (Ulg(*(*Ush)(unsafe.Pointer(stree + uintptr(node)*4 + 2 /* &.dl */))))
		}
		// node is 0 or 1 so it does not have extra bits
	}
	(*Tree_desc)(unsafe.Pointer(desc)).Fmax_code = max_code

	// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	// establish sub-heaps of increasing lengths:
	for n = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_len / 2); n >= 1; n-- {
		pqdownheap(tls, s, tree, n)
	}

	// Construct the Huffman tree by repeatedly combining the least two
	// frequent nodes.
	node = elems // next internal node of the tree
	for ok := true; ok; ok = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_len >= 2) {
		{
			n = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + 1*4))
			*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + 1*4)) = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PostDecInt32(&(*Deflate_state)(unsafe.Pointer(s)).Fheap_len, 1))*4))
			pqdownheap(tls, s, tree, SMALLEST)
		}
		// n = node of least frequency
		m = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + 1*4)) // m = node of next least frequency

		*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = n // keep the nodes sorted by frequency
		*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = m

		// Create a new node father of n and m
		*(*Ush)(unsafe.Pointer(tree + uintptr(node)*4 /* &.fc */)) = (Ush(int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))) + int32(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 /* &.fc */)))))
		*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(node))) = (Uch((func() int32 {
			if int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(n)))) >= int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(m)))) {
				return int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(n))))
			}
			return int32(*(*Uch)(unsafe.Pointer((s + 5308 /* &.depth */) + uintptr(m))))
		}()) + 1))
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = libc.AssignPtrUint16(tree+uintptr(m)*4+2 /* &.dl */ /* &.dad */, Ush(node))
		// and insert the new node in the heap
		*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + 1*4)) = libc.PostIncInt32(&node, 1)
		pqdownheap(tls, s, tree, SMALLEST)

	}

	*(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = *(*int32)(unsafe.Pointer((s + 3008 /* &.heap */) + 1*4))

	// At this point, the fields freq and dad are set. We can now
	// generate the bit lengths.
	gen_bitlen(tls, s, desc)

	// The field len is now set, we can generate the bit codes
	gen_codes(tls, tree, max_code, s+2976 /* &.bl_count */)
}

// ===========================================================================
// Scan a literal or distance tree to determine the frequencies of the codes
// in the bit length tree.
func scan_tree(tls *libc.TLS, s uintptr, tree uintptr, max_code int32) { /* trees.c:703:12: */
	var n int32                                                             // iterates over all tree elements
	var prevlen int32 = -1                                                  // last emitted length
	var curlen int32                                                        // length of current code
	var nextlen int32 = int32(*(*Ush)(unsafe.Pointer(tree + 2 /* &.dl */))) // length of next code
	var count int32 = 0                                                     // repeat count of the current code
	var max_count int32 = 7                                                 // max repeat count
	var min_count int32 = 4                                                 // min repeat count

	if nextlen == 0 {
		max_count = 138
		min_count = 3
	}
	*(*Ush)(unsafe.Pointer(tree + uintptr((max_code+1))*4 + 2 /* &.dl */)) = Ush(0xffff) // guard

	for n = 0; n <= max_code; n++ {
		curlen = nextlen
		nextlen = int32(*(*Ush)(unsafe.Pointer(tree + uintptr((n+1))*4 + 2 /* &.dl */)))
		if (libc.PreIncInt32(&count, 1) < max_count) && (curlen == nextlen) {
			continue
		} else if count < min_count {
			*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */ /* &.freq */)) += Ush((count))
		} else if curlen != 0 {
			if curlen != prevlen {
				*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */))++
			}
			*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 16*4 /* &.fc */))++
		} else if count <= 10 {
			*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 17*4 /* &.fc */))++
		} else {
			*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 18*4 /* &.fc */))++
		}
		count = 0
		prevlen = curlen
		if nextlen == 0 {
			max_count = 138
			min_count = 3
		} else if curlen == nextlen {
			max_count = 6
			min_count = 3
		} else {
			max_count = 7
			min_count = 4
		}
	}
}

// ===========================================================================
// Send a literal or distance tree in compressed form, using the codes in
// bl_tree.
func send_tree(tls *libc.TLS, s uintptr, tree uintptr, max_code int32) { /* trees.c:748:12: */
	var n int32                                                             // iterates over all tree elements
	var prevlen int32 = -1                                                  // last emitted length
	var curlen int32                                                        // length of current code
	var nextlen int32 = int32(*(*Ush)(unsafe.Pointer(tree + 2 /* &.dl */))) // length of next code
	var count int32 = 0                                                     // repeat count of the current code
	var max_count int32 = 7                                                 // max repeat count
	var min_count int32 = 4                                                 // min repeat count

	/* tree[max_code+1].Len = -1; */ // guard already set
	if nextlen == 0 {
		max_count = 138
		min_count = 3
	}

	for n = 0; n <= max_code; n++ {
		curlen = nextlen
		nextlen = int32(*(*Ush)(unsafe.Pointer(tree + uintptr((n+1))*4 + 2 /* &.dl */)))
		if (libc.PreIncInt32(&count, 1) < max_count) && (curlen == nextlen) {
			continue
		} else if count < min_count {
			for ok := true; ok; ok = (libc.PreDecInt32(&count, 1) != 0) {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
					}
				}
			}

		} else if curlen != 0 {
			if curlen != prevlen {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
					}
				}
				count--
			}

			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 16*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 16*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 16*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 2
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 3)
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(count - 3))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}

		} else if count <= 10 {
			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 17*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 17*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 17*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 3
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 3)
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(count - 3))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}

		} else {
			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 18*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 18*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + 18*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 7
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 11)
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(count - 11))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
				}
			}

		}
		count = 0
		prevlen = curlen
		if nextlen == 0 {
			max_count = 138
			min_count = 3
		} else if curlen == nextlen {
			max_count = 6
			min_count = 3
		} else {
			max_count = 7
			min_count = 4
		}
	}
}

// ===========================================================================
// Construct the Huffman tree for the bit lengths and return the index in
// bl_order of the last bit length code to send.
func build_bl_tree(tls *libc.TLS, s uintptr) int32 { /* trees.c:799:11: */
	var max_blindex int32 // index of last bit length code of non zero freq

	// Determine the bit length frequencies for literal and distance trees
	scan_tree(tls, s, s+212 /* &.dyn_ltree */, (*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fmax_code)
	scan_tree(tls, s, s+2504 /* &.dyn_dtree */, (*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fmax_code)

	// Build the bit length tree:
	build_tree(tls, s, (s + 2952 /* &.bl_desc */))
	// opt_len now includes the length of the tree representations, except
	// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

	// Determine the number of bit length codes to send. The pkzip format
	// requires that at least 4 bit length codes be sent. (appnote.txt says
	// 3 but the actual value used is 4.)
	for max_blindex = (BL_CODES - 1); max_blindex >= 3; max_blindex-- {
		if int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(bl_order[max_blindex])*4 + 2 /* &.dl */))) != 0 {
			break
		}
	}
	// Update opt_len to include the bit length tree and counts
	*(*Ulg)(unsafe.Pointer(s + 5912 /* &.opt_len */)) += ((((uint64(3) * (Ulg(max_blindex) + uint64(1))) + uint64(5)) + uint64(5)) + uint64(4))

	return max_blindex
}

// ===========================================================================
// Send the header for a block using dynamic Huffman trees: the counts, the
// lengths of the bit length codes, the literal tree and the distance tree.
// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
func send_all_trees(tls *libc.TLS, s uintptr, lcodes int32, dcodes int32, blcodes int32) { /* trees.c:834:12: */
	var rank int32 // index in bl_order

	{
		var len int32 = 5
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (lcodes - 257)
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(lcodes - 257))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}
	/* not +255 as stated in appnote.txt */
	{
		var len int32 = 5
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (dcodes - 1)
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(dcodes - 1))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}

	{
		var len int32 = 4
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (blcodes - 4)
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(blcodes - 4))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}
	// not -3 as stated in appnote.txt
	for rank = 0; rank < blcodes; rank++ {

		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(bl_order[rank])*4 + 2 /* &.dl */)))
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2748 /* &.bl_tree */) + uintptr(bl_order[rank])*4 + 2 /* &.dl */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
			}
		}

	}

	send_tree(tls, s, s+212 /* &.dyn_ltree */, (lcodes - 1)) // literal tree

	send_tree(tls, s, s+2504 /* &.dyn_dtree */, (dcodes - 1)) // distance tree

}

// ===========================================================================
// Send a stored block
func X_tr_stored_block(tls *libc.TLS, s uintptr, buf uintptr, stored_len Ulg, last int32) { /* trees.c:863:20: */
	{
		var len int32 = 3
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = ((int32(STORED_BLOCK) << 1) + last)
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush((int32(STORED_BLOCK) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}
	// send block type
	bi_windup(tls, s) /* align on byte boundary */
	{
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32(Ush(stored_len))) & 0xff))
		}
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32((Ush(stored_len))) >> 8))
		}

	}

	{
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32(Ush(^stored_len))) & 0xff))
		}
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32((Ush(^stored_len))) >> 8))
		}

	}

	libc.X__builtin___memcpy_chk(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), buf, stored_len, libc.X__builtin_object_size(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf+uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), 0))
	*(*Ulg)(unsafe.Pointer(s + 40 /* &.pending */)) += (stored_len)
}

// ===========================================================================
// Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
func X_tr_flush_bits(tls *libc.TLS, s uintptr) { /* trees.c:886:20: */
	bi_flush(tls, s)
}

// ===========================================================================
// Send one empty static block to give enough lookahead for inflate.
// This takes 10 bits, of which 7 may remain in the bit buffer.
func X_tr_align(tls *libc.TLS, s uintptr) { /* trees.c:896:20: */
	{
		var len int32 = 3
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (int32(STATIC_TREES) << 1)
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(int32((Ush(int32(STATIC_TREES) << 1)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}

	{
		var len int32 = int32(*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 + 2 /* &.dl */)))
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = int32(*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 /* &.fc */)))
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}

	bi_flush(tls, s)
}

// ===========================================================================
// Determine the best encoding for the current block: dynamic trees, static
// trees or store, and write out the encoded block.
func X_tr_flush_block(tls *libc.TLS, s uintptr, buf uintptr, stored_len Ulg, last int32) { /* trees.c:911:20: */
	var opt_lenb Ulg
	var static_lenb Ulg       // opt_len and static_len in bytes
	var max_blindex int32 = 0 // index of last bit length code of non zero freq

	// Build the Huffman trees unless a stored block is forced
	if (*Deflate_state)(unsafe.Pointer(s)).Flevel > 0 {

		// Check if the file is binary or text
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fdata_type == Z_UNKNOWN {
			(*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fdata_type = detect_data_type(tls, s)
		}

		// Construct the literal and distance trees
		build_tree(tls, s, (s + 2904 /* &.l_desc */))

		build_tree(tls, s, (s + 2928 /* &.d_desc */))

		// At this point, opt_len and static_len are the total bit lengths of
		// the compressed block data, excluding the tree representations.

		// Build the bit length tree for the above two trees, and get the index
		// in bl_order of the last bit length code to send.
		max_blindex = build_bl_tree(tls, s)

		// Determine the best encoding. Compute the block lengths in bytes.
		opt_lenb = ((((*Deflate_state)(unsafe.Pointer(s)).Fopt_len + uint64(3)) + uint64(7)) >> 3)
		static_lenb = ((((*Deflate_state)(unsafe.Pointer(s)).Fstatic_len + uint64(3)) + uint64(7)) >> 3)

		if static_lenb <= opt_lenb {
			opt_lenb = static_lenb
		}

	} else {

		opt_lenb = libc.AssignUint64(&static_lenb, (stored_len + uint64(5))) // force a stored block
	}

	if ((stored_len + uint64(4)) <= opt_lenb) && (buf != uintptr(0)) {
		// 4: two words for the lengths
		// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
		// Otherwise we can't have processed more than WSIZE input bytes since
		// the last block flush, because compression would have been
		// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
		// transform a block into a stored block.
		X_tr_stored_block(tls, s, buf, stored_len, last)

	} else if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_FIXED) || (static_lenb == opt_lenb) {
		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = ((int32(STATIC_TREES) << 1) + last)
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush((int32(STATIC_TREES) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
			}
		}

		compress_block(tls, s, uintptr(uintptr(unsafe.Pointer(&static_ltree))),
			uintptr(uintptr(unsafe.Pointer(&static_dtree))))
	} else {
		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = ((int32(DYN_TREES) << 1) + last)
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush((int32(DYN_TREES) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
			}
		}

		send_all_trees(tls, s, ((*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fmax_code + 1), ((*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fmax_code + 1),
			(max_blindex + 1))
		compress_block(tls, s, s+212, /* &.dyn_ltree */
			s+2504 /* &.dyn_dtree */)
	}

	// The above check is made mod 2^32, for files larger than 512 MB
	// and uLong implemented on 32 bits.
	init_block(tls, s)

	if last != 0 {
		bi_windup(tls, s)
	}

}

// ===========================================================================
// Save the match info and tally the frequency counts. Return true if
// the current block must be flushed.
func X_tr_tally(tls *libc.TLS, s uintptr, dist uint32, lc uint32) int32 { /* trees.c:1014:19: */
	*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ush(dist)
	*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = Uch(lc)
	if dist == uint32(0) {
		// lc is the unmatched char
		*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(lc)*4 /* &.fc */))++
	} else {
		(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
		// Here, lc is the match length - MIN_MATCH
		dist-- // dist = match distance - 1

		*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[lc])+LITERALS)+1))*4 /* &.fc */))++
		*(*Ush)(unsafe.Pointer((s + 2504 /* &.dyn_dtree */) + uintptr((func() int32 {
			if (dist) < uint32(256) {
				return int32(X_dist_code[dist])
			}
			return int32(X_dist_code[(uint32(256) + ((dist) >> 7))])
		}()))*4 /* &.fc */))++
	}

	return (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
	// We avoid equality with lit_bufsize because of wraparound at 64K
	// on 16 bit machines and because stored blocks are restricted to
	// 64K-1 bytes.
}

// ===========================================================================
// Send the block data compressed using the given Huffman trees
func compress_block(tls *libc.TLS, s uintptr, ltree uintptr, dtree uintptr) { /* trees.c:1064:12: */
	var dist uint32           // distance of matched string
	var lc int32              // match length or unmatched char (if dist == 0)
	var lx uint32 = uint32(0) // running index in l_buf
	var code uint32           // the code to send
	var extra int32           // number of extra bits to send

	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != UInt(0) {
		for ok := true; ok; ok = (lx < (*Deflate_state)(unsafe.Pointer(s)).Flast_lit) {
			dist = uint32(*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr(lx)*2)))
			lc = int32(*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&lx, 1)))))
			if dist == uint32(0) {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
					}
				}
				// send a literal byte

			} else {
				// Here, lc is the match length - MIN_MATCH
				code = uint32(X_length_code[lc])
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+LITERALS)+uint32(1)))*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+LITERALS)+uint32(1)))*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+LITERALS)+uint32(1)))*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
					}
				}
				// send the length code
				extra = extra_lbits[code]
				if extra != 0 {
					lc = lc - (base_length[code])
					{
						var len int32 = extra
						if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
							var val int32 = lc
							*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							{
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
								}
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
								}

							}
							(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
							*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
						} else {
							*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(lc))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
						}
					}
					// send the extra length bits
				}
				dist-- // dist is now the match distance - 1
				code = func() uint32 {
					if (dist) < uint32(256) {
						return uint32(X_dist_code[dist])
					}
					return uint32(X_dist_code[(uint32(256) + ((dist) >> 7))])
				}()

				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
					}
				}
				// send the distance code
				extra = extra_dbits[code]
				if extra != 0 {
					dist = dist - (uint32(base_dist[code]))
					{
						var len int32 = extra
						if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
							var val int32 = int32(dist)
							*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							{
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
								}
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
								}

							}
							(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
							*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
						} else {
							*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((Ush(dist))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
						}
					}
					// send the extra distance bits
				}
			} // literal or match pair ?

			// Check that the overlay between pending_buf and d_buf+l_buf is ok:

		}
	}

	{
		var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + 256*4 + 2 /* &.dl */)))
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + 256*4 /* &.fc */)))
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5936 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + 256*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) += (len)
		}
	}

}

// ===========================================================================
// Check if the data type is TEXT or BINARY, using the following algorithm:
// - TEXT if the two conditions below are satisfied:
//    a) There are no non-portable control characters belonging to the
//       "black list" (0..6, 14..25, 28..31).
//    b) There is at least one printable character belonging to the
//       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
// - BINARY otherwise.
// - The following partially-portable control characters form a
//   "gray list" that is ignored in this detection algorithm:
//   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
// IN assertion: the fields Freq of dyn_ltree are set.
func detect_data_type(tls *libc.TLS, s uintptr) int32 { /* trees.c:1124:11: */
	// black_mask is the bit mask of black-listed bytes
	// set bits 0..6, 14..25, and 28..31
	// 0xf3ffc07f = binary 11110011111111111100000001111111
	var black_mask uint64 = 0xf3ffc07f
	var n int32

	// Check for non-textual ("black-listed") bytes.
	n = 0
__1:
	if !(n <= 31) {
		goto __3
	}
	if ((black_mask & uint64(1)) != 0) && (int32(*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */))) != 0) {
		return Z_BINARY
	}
	goto __2
__2:
	n++
	black_mask >>= 1
	goto __1
	goto __3
__3:
	;

	// Check for textual ("white-listed") bytes.
	if ((int32(*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + 9*4 /* &.fc */))) != 0) || (int32(*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + 10*4 /* &.fc */))) != 0)) ||
		(int32(*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + 13*4 /* &.fc */))) != 0) {
		return Z_TEXT
	}
	for n = 32; n < LITERALS; n++ {
		if int32(*(*Ush)(unsafe.Pointer((s + 212 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */))) != 0 {
			return Z_TEXT
		}
	}

	// There are no "black-listed" or "white-listed" bytes:
	// this stream either is empty or has tolerated ("gray-listed") bytes only.
	return Z_BINARY
}

// ===========================================================================
// Reverse the first len bits of a code, using straightforward code (a faster
// method would use a table)
// IN assertion: 1 <= len <= 15
func bi_reverse(tls *libc.TLS, code uint32, len int32) uint32 { /* trees.c:1158:16: */
	var res uint32 = uint32(0)
	for ok := true; ok; ok = (libc.PreDecInt32(&len, 1) > 0) {
		res = res | (code & uint32(1))
		code >>= 1
		res <<= 1
	}
	return (res >> 1)
}

// ===========================================================================
// Flush the bit buffer, keeping at most 7 bits in it.
func bi_flush(tls *libc.TLS, s uintptr) { /* trees.c:1173:12: */
	if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid == 16 {
		{
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
			}

		}

		(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
		(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0
	} else if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid >= 8 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Byte((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)
		}

		libc.AssignShrPtrUint16(s+5936 /* &.bi_buf */, int(Ush(8)))
		*(*int32)(unsafe.Pointer(s + 5940 /* &.bi_valid */)) -= (8)
	}
}

// ===========================================================================
// Flush the bit buffer and align the output on a byte boundary
func bi_windup(tls *libc.TLS, s uintptr) { /* trees.c:1190:12: */
	if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > 8 {
		{
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
			}

		}

	} else if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > 0 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint64(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Byte((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0
}

// ===========================================================================
//      Decompresses the source buffer into the destination buffer.  *sourceLen is
//    the byte length of the source buffer. Upon entry, *destLen is the total size
//    of the destination buffer, which must be large enough to hold the entire
//    uncompressed data. (The size of the uncompressed data must have been saved
//    previously by the compressor and transmitted to the decompressor by some
//    mechanism outside the scope of this compression library.) Upon exit,
//    *destLen is the size of the decompressed data and *sourceLen is the number
//    of source bytes consumed. Upon return, source + *sourceLen points to the
//    first unused input byte.
//
//      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
//    memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
//    Z_DATA_ERROR if the input data was corrupted, including if the input data is
//    an incomplete zlib stream.
func Xuncompress2(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen uintptr) int32 { /* uncompr.c:27:13: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var stream Z_stream at bp+8, 112

	var err int32
	var max UInt = libc.Uint32(libc.Uint32FromInt32(-1))
	var len ULong
	var left ULong
	// var buf [1]Byte at bp, 1
	// for detection of incomplete stream when *destLen == 0

	len = *(*ULong)(unsafe.Pointer(sourceLen))
	if *(*ULongf)(unsafe.Pointer(destLen)) != 0 {
		left = *(*ULongf)(unsafe.Pointer(destLen))
		*(*ULongf)(unsafe.Pointer(destLen)) = uint64(0)
	} else {
		left = uint64(1)
		dest = bp /* &buf[0] */
	}

	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Fnext_in = source
	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_in = UInt(0)
	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Fzalloc = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Fzfree = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Fopaque = uintptr(0)

	err = XinflateInit_(tls, bp+8 /* &stream */, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
	if err != Z_OK {
		return err
	}

	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Fnext_out = dest
	(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_out = UInt(0)

	for ok := true; ok; ok = (err == Z_OK) {
		if (*Z_stream)(unsafe.Pointer(bp+8 /* &stream */)).Favail_out == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_out = func() uint32 {
				if left > ULong(max) {
					return max
				}
				return UInt(left)
			}()
			left = left - (ULong((*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_out))
		}
		if (*Z_stream)(unsafe.Pointer(bp+8 /* &stream */)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_in = func() uint32 {
				if len > ULong(max) {
					return max
				}
				return UInt(len)
			}()
			len = len - (ULong((*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Favail_in))
		}
		err = Xinflate(tls, bp+8 /* &stream */, Z_NO_FLUSH)
	}

	*(*ULong)(unsafe.Pointer(sourceLen)) -= (len + ULong((*Z_stream)(unsafe.Pointer(bp+8 /* &stream */)).Favail_in))
	if dest != bp /* buf */ {
		*(*ULongf)(unsafe.Pointer(destLen)) = (*Z_stream)(unsafe.Pointer(bp + 8 /* &stream */)).Ftotal_out
	} else if ((*Z_stream)(unsafe.Pointer(bp+8 /* &stream */)).Ftotal_out != 0) && (err == (-5)) {
		left = uint64(1)
	}

	XinflateEnd(tls, bp+8 /* &stream */)
	if err == Z_STREAM_END {
		return Z_OK
	}
	if err == Z_NEED_DICT {
		return -3
	}
	if (err == (-5)) && ((left + ULong((*Z_stream)(unsafe.Pointer(bp+8 /* &stream */)).Favail_out)) != 0) {
		return -3
	}
	return err
}

func Xuncompress(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong) int32 { /* uncompr.c:86:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*ULong)(unsafe.Pointer(bp)) = sourceLen

	return Xuncompress2(tls, dest, destLen, source, bp /* &sourceLen */)
}

// GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
//    value -- needed when comparing unsigned to z_off64_t, which is signed
//    (possible z_off64_t types off_t, off64_t, and long are all signed)

var Xz_errmsg = [10]uintptr{
	uintptr(ts + 876 /* "need dictionary" */),     // Z_NEED_DICT       2
	uintptr(ts + 892 /* "stream end" */),          // Z_STREAM_END      1
	uintptr(ts + 101 /* "" */),                    // Z_OK              0
	uintptr(ts + 903 /* "file error" */),          // Z_ERRNO         (-1)
	uintptr(ts + 914 /* "stream error" */),        // Z_STREAM_ERROR  (-2)
	uintptr(ts + 927 /* "data error" */),          // Z_DATA_ERROR    (-3)
	uintptr(ts + 938 /* "insufficient mem..." */), // Z_MEM_ERROR     (-4)
	uintptr(ts + 958 /* "buffer error" */),        // Z_BUF_ERROR     (-5)
	uintptr(ts + 971 /* "incompatible ver..." */), // Z_VERSION_ERROR (-6)
	uintptr(ts + 101 /* "" */),
} /* zutil.c:13:14 */

func XzlibVersion(tls *libc.TLS) uintptr { /* zutil.c:27:12: */
	return ts /* "1.2.11" */
}

func XzlibCompileFlags(tls *libc.TLS) ULong { /* zutil.c:32:15: */
	var flags ULong

	flags = uint64(0)
	switch int32(unsafe.Sizeof(UInt(0))) {
	case 2:
		break
	case 4:
		flags = flags + (uint64(1))
		break
	case 8:
		flags = flags + (uint64(2))
		break
	default:
		flags = flags + (uint64(3))
	}
	switch int32(unsafe.Sizeof(ULong(0))) {
	case 2:
		break
	case 4:
		flags = flags + (uint64(int32(1) << 2))
		break
	case 8:
		flags = flags + (uint64(int32(2) << 2))
		break
	default:
		flags = flags + (uint64(int32(3) << 2))
	}
	switch int32(unsafe.Sizeof(Voidpf(0))) {
	case 2:
		break
	case 4:
		flags = flags + (uint64(int32(1) << 4))
		break
	case 8:
		flags = flags + (uint64(int32(2) << 4))
		break
	default:
		flags = flags + (uint64(int32(3) << 4))
	}
	switch int32(unsafe.Sizeof(Off_t(0))) {
	case 2:
		break
	case 4:
		flags = flags + (uint64(int32(1) << 6))
		break
	case 8:
		flags = flags + (uint64(int32(2) << 6))
		break
	default:
		flags = flags + (uint64(int32(3) << 6))
	}
	return flags
}

// exported to allow conversion of error code to string for compress() and
// uncompress()
func XzError(tls *libc.TLS, err int32) uintptr { /* zutil.c:133:12: */
	return Xz_errmsg[(Z_NEED_DICT - (err))]
}

func Xzcalloc(tls *libc.TLS, opaque Voidpf, items uint32, size uint32) Voidpf { /* zutil.c:305:22: */
	_ = opaque
	if uint64(unsafe.Sizeof(UInt(0))) > uint64(2) {
		return libc.Xmalloc(tls, (uint64(items * size)))
	}
	return libc.Xcalloc(tls, uint64(items), uint64(size))
}

func Xzcfree(tls *libc.TLS, opaque Voidpf, ptr Voidpf) { /* zutil.c:315:20: */
	_ = opaque
	libc.Xfree(tls, ptr)
}

func init() {
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 8 /* .func */)) = deflate_stored // deflate.c:136:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 24 /* .func */)) = deflate_fast  // deflate.c:137:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 40 /* .func */)) = deflate_fast  // deflate.c:138:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 56 /* .func */)) = deflate_fast  // deflate.c:139:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 72 /* .func */)) = deflate_slow  // deflate.c:141:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 88 /* .func */)) = deflate_slow  // deflate.c:142:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 104 /* .func */)) = deflate_slow // deflate.c:143:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 120 /* .func */)) = deflate_slow // deflate.c:144:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 136 /* .func */)) = deflate_slow // deflate.c:145:30:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 152 /* .func */)) = deflate_slow // deflate.c:146:30:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_bl_desc)) + 8 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_blbits))            // trees.c:132:22:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_d_desc)) + 0 /* .static_tree */)) = uintptr(unsafe.Pointer(&static_dtree))            // trees.c:129:2:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_d_desc)) + 8 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_dbits))              // trees.c:129:16:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_l_desc)) + 0 /* .static_tree */)) = uintptr(unsafe.Pointer(&static_ltree))            // trees.c:126:2:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_l_desc)) + 8 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_lbits))              // trees.c:126:16:
}

var ts1 = "1.2.11\x00 deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler \x00%s\x00<fd:%d>\x00out of memory\x00\x00%s%s%s\x00: \x00unexpected end of file\x00internal error: inflate stream corrupt\x00compressed data error\x00request does not fit in an int\x00request does not fit in a size_t\x00out of room to push characters\x00internal error: deflate stream corrupt\x00requested length does not fit in int\x00invalid block type\x00invalid stored block lengths\x00too many length or distance symbols\x00invalid code lengths set\x00invalid bit length repeat\x00invalid code -- missing end-of-block\x00invalid literal/lengths set\x00invalid distances set\x00invalid literal/length code\x00invalid distance code\x00invalid distance too far back\x00incorrect header check\x00unknown compression method\x00invalid window size\x00unknown header flags set\x00header crc mismatch\x00incorrect data check\x00incorrect length check\x00 inflate 1.2.11 Copyright 1995-2017 Mark Adler \x00need dictionary\x00stream end\x00file error\x00stream error\x00data error\x00insufficient memory\x00buffer error\x00incompatible version\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
