// Code generated by 'ccgo -export-defines "" -export-enums "" -export-externs X -export-fields F -export-structs "" -export-typedefs "" -o lib/z_linux_386.go -pkgname z -trace-translation-units /tmp/go-generate-515242649/cdb.json libz.a', DO NOT EDIT.

package z

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

const (
	AIO_PRIO_DELTA_MAX                   = 20
	BASE                                 = 65521
	BC_BASE_MAX                          = 99
	BC_DIM_MAX                           = 2048
	BC_SCALE_MAX                         = 99
	BC_STRING_MAX                        = 1000
	BIG_ENDIAN                           = 4321
	BYTE_ORDER                           = 1234
	CHARCLASS_NAME_MAX                   = 2048
	CHAR_BIT                             = 8
	CHAR_MAX                             = 127
	CHAR_MIN                             = -128
	COLL_WEIGHTS_MAX                     = 255
	DEF_MEM_LEVEL                        = 8
	DEF_WBITS                            = 15
	DELAYTIMER_MAX                       = 2147483647
	DYN_TREES                            = 2
	EXIT_FAILURE                         = 1
	EXIT_SUCCESS                         = 0
	EXPR_NEST_MAX                        = 32
	FAR                                  = 0
	FD_SETSIZE                           = 1024
	F_LOCK                               = 1
	F_OK                                 = 0
	F_TEST                               = 3
	F_TLOCK                              = 2
	F_ULOCK                              = 0
	HAVE_HIDDEN                          = 1
	HAVE_MEMCPY                          = 0
	HOST_NAME_MAX                        = 64
	INT_MAX                              = 2147483647
	INT_MIN                              = -2147483648
	LINE_MAX                             = 2048
	LITTLE_ENDIAN                        = 1234
	LLONG_MAX                            = 9223372036854775807
	LLONG_MIN                            = -9223372036854775808
	LOGIN_NAME_MAX                       = 256
	LONG_MAX                             = 2147483647
	LONG_MIN                             = -2147483648
	L_INCR                               = 1
	L_SET                                = 0
	L_XTND                               = 2
	MAX_CANON                            = 255
	MAX_INPUT                            = 255
	MAX_MATCH                            = 258
	MAX_MEM_LEVEL                        = 9
	MAX_WBITS                            = 15
	MB_LEN_MAX                           = 16
	MIN_MATCH                            = 3
	MQ_PRIO_MAX                          = 32768
	NAME_MAX                             = 255
	NGROUPS_MAX                          = 65536
	NMAX                                 = 5552
	OS_CODE                              = 3
	PATH_MAX                             = 4096
	PDP_ENDIAN                           = 3412
	PIPE_BUF                             = 4096
	PRESET_DICT                          = 0x20
	PTHREAD_DESTRUCTOR_ITERATIONS        = 4
	PTHREAD_KEYS_MAX                     = 1024
	PTHREAD_STACK_MIN                    = 16384
	RAND_MAX                             = 2147483647
	RE_DUP_MAX                           = 32767
	RTSIG_MAX                            = 32
	R_OK                                 = 4
	SCHAR_MAX                            = 127
	SCHAR_MIN                            = -128
	SEEK_CUR                             = 1
	SEEK_END                             = 2
	SEEK_SET                             = 0
	SEM_VALUE_MAX                        = 2147483647
	SHRT_MAX                             = 32767
	SHRT_MIN                             = -32768
	SSIZE_MAX                            = 2147483647
	STATIC_TREES                         = 1
	STDC                                 = 0
	STDC99                               = 0
	STDERR_FILENO                        = 2
	STDIN_FILENO                         = 0
	STDOUT_FILENO                        = 1
	STORED_BLOCK                         = 0
	TTY_NAME_MAX                         = 32
	UCHAR_MAX                            = 255
	UINT_MAX                             = 4294967295
	ULLONG_MAX                           = 18446744073709551615
	ULONG_MAX                            = 4294967295
	USHRT_MAX                            = 65535
	WCONTINUED                           = 8
	WEXITED                              = 4
	WNOHANG                              = 1
	WNOWAIT                              = 0x01000000
	WSTOPPED                             = 2
	WUNTRACED                            = 2
	W_OK                                 = 2
	XATTR_LIST_MAX                       = 65536
	XATTR_NAME_MAX                       = 255
	XATTR_SIZE_MAX                       = 65536
	X_OK                                 = 1
	ZCONF_H                              = 0
	ZEXPORT                              = 0
	ZEXPORTVA                            = 0
	ZLIB_H                               = 0
	ZLIB_VERNUM                          = 0x12b0
	ZLIB_VERSION                         = "1.2.11"
	ZLIB_VER_MAJOR                       = 1
	ZLIB_VER_MINOR                       = 2
	ZLIB_VER_REVISION                    = 11
	ZLIB_VER_SUBREVISION                 = 0
	ZUTIL_H                              = 0
	Z_ASCII                              = 1
	Z_BEST_COMPRESSION                   = 9
	Z_BEST_SPEED                         = 1
	Z_BINARY                             = 0
	Z_BLOCK                              = 5
	Z_BUF_ERROR                          = -5
	Z_DATA_ERROR                         = -3
	Z_DEFAULT_COMPRESSION                = -1
	Z_DEFAULT_STRATEGY                   = 0
	Z_DEFLATED                           = 8
	Z_ERRNO                              = -1
	Z_FILTERED                           = 1
	Z_FINISH                             = 4
	Z_FIXED                              = 4
	Z_FULL_FLUSH                         = 3
	Z_HAVE_STDARG_H                      = 0
	Z_HAVE_UNISTD_H                      = 0
	Z_HUFFMAN_ONLY                       = 2
	Z_LARGE64                            = 0
	Z_LFS64                              = 0
	Z_MEM_ERROR                          = -4
	Z_NEED_DICT                          = 2
	Z_NO_COMPRESSION                     = 0
	Z_NO_FLUSH                           = 0
	Z_NULL                               = 0
	Z_OK                                 = 0
	Z_PARTIAL_FLUSH                      = 1
	Z_RLE                                = 3
	Z_STREAM_END                         = 1
	Z_STREAM_ERROR                       = -2
	Z_SYNC_FLUSH                         = 2
	Z_TEXT                               = 1
	Z_TREES                              = 6
	Z_UNKNOWN                            = 2
	Z_VERSION_ERROR                      = -6
	Z_WANT64                             = 0
	X_ALLOCA_H                           = 1
	X_ANSI_STDARG_H_                     = 0
	X_ANSI_STDDEF_H                      = 0
	X_ATFILE_SOURCE                      = 1
	X_BITS_BYTESWAP_H                    = 1
	X_BITS_FLOATN_COMMON_H               = 0
	X_BITS_FLOATN_H                      = 0
	X_BITS_POSIX1_LIM_H                  = 1
	X_BITS_POSIX2_LIM_H                  = 1
	X_BITS_POSIX_OPT_H                   = 1
	X_BITS_PTHREADTYPES_ARCH_H           = 1
	X_BITS_PTHREADTYPES_COMMON_H         = 1
	X_BITS_STDINT_INTN_H                 = 1
	X_BITS_TYPESIZES_H                   = 1
	X_BITS_TYPES_H                       = 1
	X_BITS_TYPES_LOCALE_T_H              = 1
	X_BITS_TYPES___LOCALE_T_H            = 1
	X_BITS_UINTN_IDENTITY_H              = 1
	X_BSD_PTRDIFF_T_                     = 0
	X_BSD_SIZE_T_                        = 0
	X_BSD_SIZE_T_DEFINED_                = 0
	X_DEFAULT_SOURCE                     = 1
	X_ENDIAN_H                           = 1
	X_FEATURES_H                         = 1
	X_FILE_OFFSET_BITS                   = 64
	X_GCC_LIMITS_H_                      = 0
	X_GCC_MAX_ALIGN_T                    = 0
	X_GCC_PTRDIFF_T                      = 0
	X_GCC_SIZE_T                         = 0
	X_GCC_WCHAR_T                        = 0
	X_GETOPT_CORE_H                      = 1
	X_GETOPT_POSIX_H                     = 1
	X_LARGEFILE64_SOURCE                 = 1
	X_LFS64_ASYNCHRONOUS_IO              = 1
	X_LFS64_LARGEFILE                    = 1
	X_LFS64_STDIO                        = 1
	X_LFS_ASYNCHRONOUS_IO                = 1
	X_LFS_LARGEFILE                      = 1
	X_LIBC_LIMITS_H_                     = 1
	X_LIMITS_H___                        = 0
	X_LINUX_LIMITS_H                     = 0
	X_POSIX2_BC_BASE_MAX                 = 99
	X_POSIX2_BC_DIM_MAX                  = 2048
	X_POSIX2_BC_SCALE_MAX                = 99
	X_POSIX2_BC_STRING_MAX               = 1000
	X_POSIX2_CHARCLASS_NAME_MAX          = 14
	X_POSIX2_CHAR_TERM                   = 200809
	X_POSIX2_COLL_WEIGHTS_MAX            = 2
	X_POSIX2_C_BIND                      = 200809
	X_POSIX2_C_DEV                       = 200809
	X_POSIX2_C_VERSION                   = 200809
	X_POSIX2_EXPR_NEST_MAX               = 32
	X_POSIX2_LINE_MAX                    = 2048
	X_POSIX2_LOCALEDEF                   = 200809
	X_POSIX2_RE_DUP_MAX                  = 255
	X_POSIX2_SW_DEV                      = 200809
	X_POSIX2_VERSION                     = 200809
	X_POSIX_ADVISORY_INFO                = 200809
	X_POSIX_AIO_LISTIO_MAX               = 2
	X_POSIX_AIO_MAX                      = 1
	X_POSIX_ARG_MAX                      = 4096
	X_POSIX_ASYNCHRONOUS_IO              = 200809
	X_POSIX_ASYNC_IO                     = 1
	X_POSIX_BARRIERS                     = 200809
	X_POSIX_CHILD_MAX                    = 25
	X_POSIX_CHOWN_RESTRICTED             = 0
	X_POSIX_CLOCKRES_MIN                 = 20000000
	X_POSIX_CLOCK_SELECTION              = 200809
	X_POSIX_CPUTIME                      = 0
	X_POSIX_C_SOURCE                     = 200809
	X_POSIX_DELAYTIMER_MAX               = 32
	X_POSIX_FSYNC                        = 200809
	X_POSIX_HOST_NAME_MAX                = 255
	X_POSIX_IPV6                         = 200809
	X_POSIX_JOB_CONTROL                  = 1
	X_POSIX_LINK_MAX                     = 8
	X_POSIX_LOGIN_NAME_MAX               = 9
	X_POSIX_MAPPED_FILES                 = 200809
	X_POSIX_MAX_CANON                    = 255
	X_POSIX_MAX_INPUT                    = 255
	X_POSIX_MEMLOCK                      = 200809
	X_POSIX_MEMLOCK_RANGE                = 200809
	X_POSIX_MEMORY_PROTECTION            = 200809
	X_POSIX_MESSAGE_PASSING              = 200809
	X_POSIX_MONOTONIC_CLOCK              = 0
	X_POSIX_MQ_OPEN_MAX                  = 8
	X_POSIX_MQ_PRIO_MAX                  = 32
	X_POSIX_NAME_MAX                     = 14
	X_POSIX_NGROUPS_MAX                  = 8
	X_POSIX_NO_TRUNC                     = 1
	X_POSIX_OPEN_MAX                     = 20
	X_POSIX_PATH_MAX                     = 256
	X_POSIX_PIPE_BUF                     = 512
	X_POSIX_PRIORITIZED_IO               = 200809
	X_POSIX_PRIORITY_SCHEDULING          = 200809
	X_POSIX_RAW_SOCKETS                  = 200809
	X_POSIX_READER_WRITER_LOCKS          = 200809
	X_POSIX_REALTIME_SIGNALS             = 200809
	X_POSIX_REENTRANT_FUNCTIONS          = 1
	X_POSIX_REGEXP                       = 1
	X_POSIX_RE_DUP_MAX                   = 255
	X_POSIX_RTSIG_MAX                    = 8
	X_POSIX_SAVED_IDS                    = 1
	X_POSIX_SEMAPHORES                   = 200809
	X_POSIX_SEM_NSEMS_MAX                = 256
	X_POSIX_SEM_VALUE_MAX                = 32767
	X_POSIX_SHARED_MEMORY_OBJECTS        = 200809
	X_POSIX_SHELL                        = 1
	X_POSIX_SIGQUEUE_MAX                 = 32
	X_POSIX_SOURCE                       = 1
	X_POSIX_SPAWN                        = 200809
	X_POSIX_SPIN_LOCKS                   = 200809
	X_POSIX_SPORADIC_SERVER              = -1
	X_POSIX_SSIZE_MAX                    = 32767
	X_POSIX_STREAM_MAX                   = 8
	X_POSIX_SYMLINK_MAX                  = 255
	X_POSIX_SYMLOOP_MAX                  = 8
	X_POSIX_SYNCHRONIZED_IO              = 200809
	X_POSIX_THREADS                      = 200809
	X_POSIX_THREAD_ATTR_STACKADDR        = 200809
	X_POSIX_THREAD_ATTR_STACKSIZE        = 200809
	X_POSIX_THREAD_CPUTIME               = 0
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
	X_POSIX_THREAD_KEYS_MAX              = 128
	X_POSIX_THREAD_PRIORITY_SCHEDULING   = 200809
	X_POSIX_THREAD_PRIO_INHERIT          = 200809
	X_POSIX_THREAD_PRIO_PROTECT          = 200809
	X_POSIX_THREAD_PROCESS_SHARED        = 200809
	X_POSIX_THREAD_ROBUST_PRIO_INHERIT   = 200809
	X_POSIX_THREAD_ROBUST_PRIO_PROTECT   = -1
	X_POSIX_THREAD_SAFE_FUNCTIONS        = 200809
	X_POSIX_THREAD_SPORADIC_SERVER       = -1
	X_POSIX_THREAD_THREADS_MAX           = 64
	X_POSIX_TIMEOUTS                     = 200809
	X_POSIX_TIMERS                       = 200809
	X_POSIX_TIMER_MAX                    = 32
	X_POSIX_TRACE                        = -1
	X_POSIX_TRACE_EVENT_FILTER           = -1
	X_POSIX_TRACE_INHERIT                = -1
	X_POSIX_TRACE_LOG                    = -1
	X_POSIX_TTY_NAME_MAX                 = 9
	X_POSIX_TYPED_MEMORY_OBJECTS         = -1
	X_POSIX_TZNAME_MAX                   = 6
	X_POSIX_V6_ILP32_OFF32               = 1
	X_POSIX_V6_ILP32_OFFBIG              = 1
	X_POSIX_V7_ILP32_OFF32               = 1
	X_POSIX_V7_ILP32_OFFBIG              = 1
	X_POSIX_VDISABLE                     = 0
	X_POSIX_VERSION                      = 200809
	X_PTRDIFF_T                          = 0
	X_PTRDIFF_T_                         = 0
	X_PTRDIFF_T_DECLARED                 = 0
	X_SIZET_                             = 0
	X_SIZE_T                             = 0
	X_SIZE_T_                            = 0
	X_SIZE_T_DECLARED                    = 0
	X_SIZE_T_DEFINED                     = 0
	X_SIZE_T_DEFINED_                    = 0
	X_STDARG_H                           = 0
	X_STDC_PREDEF_H                      = 1
	X_STDDEF_H                           = 0
	X_STDDEF_H_                          = 0
	X_STDLIB_H                           = 1
	X_STRINGS_H                          = 1
	X_STRING_H                           = 1
	X_STRUCT_TIMESPEC                    = 1
	X_SYS_CDEFS_H                        = 1
	X_SYS_SELECT_H                       = 1
	X_SYS_SIZE_T_H                       = 0
	X_SYS_TYPES_H                        = 1
	X_THREAD_SHARED_TYPES_H              = 1
	X_T_PTRDIFF                          = 0
	X_T_PTRDIFF_                         = 0
	X_T_SIZE                             = 0
	X_T_SIZE_                            = 0
	X_T_WCHAR                            = 0
	X_T_WCHAR_                           = 0
	X_UNISTD_H                           = 1
	X_VA_LIST                            = 0
	X_VA_LIST_                           = 0
	X_VA_LIST_DEFINED                    = 0
	X_VA_LIST_T_H                        = 0
	X_WCHAR_T                            = 0
	X_WCHAR_T_                           = 0
	X_WCHAR_T_DECLARED                   = 0
	X_WCHAR_T_DEFINED                    = 0
	X_WCHAR_T_DEFINED_                   = 0
	X_WCHAR_T_H                          = 0
	X_XBS5_ILP32_OFF32                   = 1
	X_XBS5_ILP32_OFFBIG                  = 1
	X_XOPEN_ENH_I18N                     = 1
	X_XOPEN_LEGACY                       = 1
	X_XOPEN_REALTIME                     = 1
	X_XOPEN_REALTIME_THREADS             = 1
	X_XOPEN_SHM                          = 1
	X_XOPEN_UNIX                         = 1
	X_XOPEN_VERSION                      = 700
	X_XOPEN_XCU_VERSION                  = 4
	X_XOPEN_XPG2                         = 1
	X_XOPEN_XPG3                         = 1
	X_XOPEN_XPG4                         = 1
	I386                                 = 1
	Linux                                = 1
	Unix                                 = 1
	Z_const                              = 0
	BYFOUR                               = 0
	GF2_DIM                              = 32
	TBLS                                 = 8
	BL_CODES                             = 19
	BUSY_STATE                           = 113
	Buf_size                             = 16
	COMMENT_STATE                        = 91
	DEFLATE_H                            = 0
	D_CODES                              = 30
	EXTRA_STATE                          = 69
	FINISH_STATE                         = 666
	GZIP                                 = 0
	GZIP_STATE                           = 57
	HCRC_STATE                           = 103
	HEAP_SIZE                            = 573
	INIT_STATE                           = 42
	LENGTH_CODES                         = 29
	LITERALS                             = 256
	L_CODES                              = 286
	MAX_BITS                             = 15
	MAX_STORED                           = 65535
	MIN_LOOKAHEAD                        = 262
	NAME_STATE                           = 73
	NIL                                  = 0
	TOO_FAR                              = 4096
	WIN_INIT                             = 258
	AT_EACCESS                           = 0x200
	AT_FDCWD                             = -100
	AT_REMOVEDIR                         = 0x200
	AT_SYMLINK_FOLLOW                    = 0x400
	AT_SYMLINK_NOFOLLOW                  = 0x100
	BUFSIZ                               = 8192
	COPY1                                = 1
	E2BIG                                = 7
	EACCES                               = 13
	EADDRINUSE                           = 98
	EADDRNOTAVAIL                        = 99
	EADV                                 = 68
	EAFNOSUPPORT                         = 97
	EAGAIN                               = 11
	EALREADY                             = 114
	EBADE                                = 52
	EBADF                                = 9
	EBADFD                               = 77
	EBADMSG                              = 74
	EBADR                                = 53
	EBADRQC                              = 56
	EBADSLT                              = 57
	EBFONT                               = 59
	EBUSY                                = 16
	ECANCELED                            = 125
	ECHILD                               = 10
	ECHRNG                               = 44
	ECOMM                                = 70
	ECONNABORTED                         = 103
	ECONNREFUSED                         = 111
	ECONNRESET                           = 104
	EDEADLK                              = 35
	EDEADLOCK                            = 35
	EDESTADDRREQ                         = 89
	EDOM                                 = 33
	EDOTDOT                              = 73
	EDQUOT                               = 122
	EEXIST                               = 17
	EFAULT                               = 14
	EFBIG                                = 27
	EHOSTDOWN                            = 112
	EHOSTUNREACH                         = 113
	EHWPOISON                            = 133
	EIDRM                                = 43
	EILSEQ                               = 84
	EINPROGRESS                          = 115
	EINTR                                = 4
	EINVAL                               = 22
	EIO                                  = 5
	EISCONN                              = 106
	EISDIR                               = 21
	EISNAM                               = 120
	EKEYEXPIRED                          = 127
	EKEYREJECTED                         = 129
	EKEYREVOKED                          = 128
	EL2HLT                               = 51
	EL2NSYNC                             = 45
	EL3HLT                               = 46
	EL3RST                               = 47
	ELIBACC                              = 79
	ELIBBAD                              = 80
	ELIBEXEC                             = 83
	ELIBMAX                              = 82
	ELIBSCN                              = 81
	ELNRNG                               = 48
	ELOOP                                = 40
	EMEDIUMTYPE                          = 124
	EMFILE                               = 24
	EMLINK                               = 31
	EMSGSIZE                             = 90
	EMULTIHOP                            = 72
	ENAMETOOLONG                         = 36
	ENAVAIL                              = 119
	ENETDOWN                             = 100
	ENETRESET                            = 102
	ENETUNREACH                          = 101
	ENFILE                               = 23
	ENOANO                               = 55
	ENOBUFS                              = 105
	ENOCSI                               = 50
	ENODATA                              = 61
	ENODEV                               = 19
	ENOENT                               = 2
	ENOEXEC                              = 8
	ENOKEY                               = 126
	ENOLCK                               = 37
	ENOLINK                              = 67
	ENOMEDIUM                            = 123
	ENOMEM                               = 12
	ENOMSG                               = 42
	ENONET                               = 64
	ENOPKG                               = 65
	ENOPROTOOPT                          = 92
	ENOSPC                               = 28
	ENOSR                                = 63
	ENOSTR                               = 60
	ENOSYS                               = 38
	ENOTBLK                              = 15
	ENOTCONN                             = 107
	ENOTDIR                              = 20
	ENOTEMPTY                            = 39
	ENOTNAM                              = 118
	ENOTRECOVERABLE                      = 131
	ENOTSOCK                             = 88
	ENOTSUP                              = 95
	ENOTTY                               = 25
	ENOTUNIQ                             = 76
	ENXIO                                = 6
	EOF                                  = -1
	EOPNOTSUPP                           = 95
	EOVERFLOW                            = 75
	EOWNERDEAD                           = 130
	EPERM                                = 1
	EPFNOSUPPORT                         = 96
	EPIPE                                = 32
	EPROTO                               = 71
	EPROTONOSUPPORT                      = 93
	EPROTOTYPE                           = 91
	ERANGE                               = 34
	EREMCHG                              = 78
	EREMOTE                              = 66
	EREMOTEIO                            = 121
	ERESTART                             = 85
	ERFKILL                              = 132
	EROFS                                = 30
	ESHUTDOWN                            = 108
	ESOCKTNOSUPPORT                      = 94
	ESPIPE                               = 29
	ESRCH                                = 3
	ESRMNT                               = 69
	ESTALE                               = 116
	ESTRPIPE                             = 86
	ETIME                                = 62
	ETIMEDOUT                            = 110
	ETOOMANYREFS                         = 109
	ETXTBSY                              = 26
	EUCLEAN                              = 117
	EUNATCH                              = 49
	EUSERS                               = 87
	EWOULDBLOCK                          = 11
	EXDEV                                = 18
	EXFULL                               = 54
	FAPPEND                              = 1024
	FASYNC                               = 8192
	FD_CLOEXEC                           = 1
	FFSYNC                               = 1052672
	FILENAME_MAX                         = 4096
	FNDELAY                              = 2048
	FNONBLOCK                            = 2048
	FOPEN_MAX                            = 16
	F_DUPFD                              = 0
	F_DUPFD_CLOEXEC                      = 1030
	F_EXLCK                              = 4
	F_GETFD                              = 1
	F_GETFL                              = 3
	F_GETLK                              = 5
	F_GETLK64                            = 12
	F_GETOWN                             = 9
	F_RDLCK                              = 0
	F_SETFD                              = 2
	F_SETFL                              = 4
	F_SETLK                              = 6
	F_SETLK64                            = 13
	F_SETLKW                             = 7
	F_SETLKW64                           = 14
	F_SETOWN                             = 8
	F_SHLCK                              = 8
	F_UNLCK                              = 2
	F_WRLCK                              = 1
	GZBUFSIZE                            = 8192
	GZ_APPEND                            = 1
	GZ_NONE                              = 0
	GZ_READ                              = 7247
	GZ_WRITE                             = 31153
	HAVE_VSNPRINTF                       = 0
	LOCK_EX                              = 2
	LOCK_NB                              = 4
	LOCK_SH                              = 1
	LOCK_UN                              = 8
	LOOK                                 = 0
	L_ctermid                            = 9
	L_tmpnam                             = 20
	O_ACCMODE                            = 0003
	O_APPEND                             = 02000
	O_ASYNC                              = 020000
	O_CLOEXEC                            = 524288
	O_CREAT                              = 0100
	O_DIRECTORY                          = 65536
	O_DSYNC                              = 4096
	O_EXCL                               = 0200
	O_FSYNC                              = 1052672
	O_LARGEFILE                          = 32768
	O_NDELAY                             = 2048
	O_NOCTTY                             = 0400
	O_NOFOLLOW                           = 131072
	O_NONBLOCK                           = 04000
	O_RDONLY                             = 00
	O_RDWR                               = 02
	O_RSYNC                              = 1052672
	O_SYNC                               = 04010000
	O_TRUNC                              = 01000
	O_WRONLY                             = 01
	POSIX_FADV_DONTNEED                  = 4
	POSIX_FADV_NOREUSE                   = 5
	POSIX_FADV_NORMAL                    = 0
	POSIX_FADV_RANDOM                    = 1
	POSIX_FADV_SEQUENTIAL                = 2
	POSIX_FADV_WILLNEED                  = 3
	P_tmpdir                             = "/tmp"
	S_IFBLK                              = 24576
	S_IFCHR                              = 8192
	S_IFDIR                              = 16384
	S_IFIFO                              = 4096
	S_IFLNK                              = 40960
	S_IFMT                               = 61440
	S_IFREG                              = 32768
	S_IFSOCK                             = 49152
	S_IRGRP                              = 32
	S_IROTH                              = 4
	S_IRUSR                              = 256
	S_IRWXG                              = 56
	S_IRWXO                              = 7
	S_IRWXU                              = 448
	S_ISGID                              = 1024
	S_ISUID                              = 2048
	S_ISVTX                              = 512
	S_IWGRP                              = 16
	S_IWOTH                              = 2
	S_IWUSR                              = 128
	S_IXGRP                              = 8
	S_IXOTH                              = 1
	S_IXUSR                              = 64
	TMP_MAX                              = 238328
	UTIME_NOW                            = 1073741823
	UTIME_OMIT                           = 1073741822
	X_ASM_GENERIC_ERRNO_BASE_H           = 0
	X_ASM_GENERIC_ERRNO_H                = 0
	X_BITS_ERRNO_H                       = 1
	X_BITS_STAT_H                        = 1
	X_BITS_STDIO_LIM_H                   = 1
	X_ERRNO_H                            = 1
	X_FCNTL_H                            = 1
	X_IOFBF                              = 0
	X_IOLBF                              = 1
	X_IONBF                              = 2
	X_IO_EOF_SEEN                        = 0x0010
	X_IO_ERR_SEEN                        = 0x0020
	X_IO_USER_LOCK                       = 0x8000
	X_LARGEFILE_SOURCE                   = 1
	X_MKNOD_VER                          = 1
	X_MKNOD_VER_LINUX                    = 1
	X_MKNOD_VER_SVR4                     = 2
	X_STATBUF_ST_BLKSIZE                 = 0
	X_STATBUF_ST_NSEC                    = 0
	X_STATBUF_ST_RDEV                    = 0
	X_STAT_VER                           = 3
	X_STAT_VER_KERNEL                    = 1
	X_STAT_VER_LINUX                     = 3
	X_STAT_VER_LINUX_OLD                 = 1
	X_STAT_VER_SVR4                      = 2
	X_STDIO_H                            = 1
	ENOUGH                               = 1444
	ENOUGH_DISTS                         = 592
	ENOUGH_LENS                          = 852
	GUNZIP                               = 0
	MAXBITS                              = 15
	DIST_CODE_LEN                        = 512
	END_BLOCK                            = 256
	MAX_BL_BITS                          = 7
	REPZ_11_138                          = 18
	REPZ_3_10                            = 17
	REP_3_6                              = 16
	SMALLEST                             = 1
)

// Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
//    the `_SC_*' symbols for the NAME argument to `sysconf';
//    and the `_CS_*' symbols for the NAME argument to `confstr'.
// `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
//    Copyright (C) 1993-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Values for the NAME argument to `pathconf' and `fpathconf'.
const ( /* confname.h:24:1: */
	X_PC_LINK_MAX           = 0
	X_PC_MAX_CANON          = 1
	X_PC_MAX_INPUT          = 2
	X_PC_NAME_MAX           = 3
	X_PC_PATH_MAX           = 4
	X_PC_PIPE_BUF           = 5
	X_PC_CHOWN_RESTRICTED   = 6
	X_PC_NO_TRUNC           = 7
	X_PC_VDISABLE           = 8
	X_PC_SYNC_IO            = 9
	X_PC_ASYNC_IO           = 10
	X_PC_PRIO_IO            = 11
	X_PC_SOCK_MAXBUF        = 12
	X_PC_FILESIZEBITS       = 13
	X_PC_REC_INCR_XFER_SIZE = 14
	X_PC_REC_MAX_XFER_SIZE  = 15
	X_PC_REC_MIN_XFER_SIZE  = 16
	X_PC_REC_XFER_ALIGN     = 17
	X_PC_ALLOC_SIZE_MIN     = 18
	X_PC_SYMLINK_MAX        = 19
	X_PC_2_SYMLINKS         = 20
)

// Values for the NAME argument to `confstr'.
const ( /* confname.h:533:1: */
	X_CS_PATH = 0 // The default search path.

	X_CS_V6_WIDTH_RESTRICTED_ENVS = 1

	X_CS_GNU_LIBC_VERSION       = 2
	X_CS_GNU_LIBPTHREAD_VERSION = 3

	X_CS_V5_WIDTH_RESTRICTED_ENVS = 4

	X_CS_V7_WIDTH_RESTRICTED_ENVS = 5

	X_CS_LFS_CFLAGS      = 1000
	X_CS_LFS_LDFLAGS     = 1001
	X_CS_LFS_LIBS        = 1002
	X_CS_LFS_LINTFLAGS   = 1003
	X_CS_LFS64_CFLAGS    = 1004
	X_CS_LFS64_LDFLAGS   = 1005
	X_CS_LFS64_LIBS      = 1006
	X_CS_LFS64_LINTFLAGS = 1007

	X_CS_XBS5_ILP32_OFF32_CFLAGS     = 1100
	X_CS_XBS5_ILP32_OFF32_LDFLAGS    = 1101
	X_CS_XBS5_ILP32_OFF32_LIBS       = 1102
	X_CS_XBS5_ILP32_OFF32_LINTFLAGS  = 1103
	X_CS_XBS5_ILP32_OFFBIG_CFLAGS    = 1104
	X_CS_XBS5_ILP32_OFFBIG_LDFLAGS   = 1105
	X_CS_XBS5_ILP32_OFFBIG_LIBS      = 1106
	X_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
	X_CS_XBS5_LP64_OFF64_CFLAGS      = 1108
	X_CS_XBS5_LP64_OFF64_LDFLAGS     = 1109
	X_CS_XBS5_LP64_OFF64_LIBS        = 1110
	X_CS_XBS5_LP64_OFF64_LINTFLAGS   = 1111
	X_CS_XBS5_LPBIG_OFFBIG_CFLAGS    = 1112
	X_CS_XBS5_LPBIG_OFFBIG_LDFLAGS   = 1113
	X_CS_XBS5_LPBIG_OFFBIG_LIBS      = 1114
	X_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115

	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS     = 1116
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS    = 1117
	X_CS_POSIX_V6_ILP32_OFF32_LIBS       = 1118
	X_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  = 1119
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    = 1120
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   = 1121
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS      = 1122
	X_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS      = 1124
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS     = 1125
	X_CS_POSIX_V6_LP64_OFF64_LIBS        = 1126
	X_CS_POSIX_V6_LP64_OFF64_LINTFLAGS   = 1127
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    = 1128
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   = 1129
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS      = 1130
	X_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131

	X_CS_POSIX_V7_ILP32_OFF32_CFLAGS     = 1132
	X_CS_POSIX_V7_ILP32_OFF32_LDFLAGS    = 1133
	X_CS_POSIX_V7_ILP32_OFF32_LIBS       = 1134
	X_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS  = 1135
	X_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS    = 1136
	X_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS   = 1137
	X_CS_POSIX_V7_ILP32_OFFBIG_LIBS      = 1138
	X_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
	X_CS_POSIX_V7_LP64_OFF64_CFLAGS      = 1140
	X_CS_POSIX_V7_LP64_OFF64_LDFLAGS     = 1141
	X_CS_POSIX_V7_LP64_OFF64_LIBS        = 1142
	X_CS_POSIX_V7_LP64_OFF64_LINTFLAGS   = 1143
	X_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS    = 1144
	X_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS   = 1145
	X_CS_POSIX_V7_LPBIG_OFFBIG_LIBS      = 1146
	X_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147

	X_CS_V6_ENV = 1148
	X_CS_V7_ENV = 1149
)

// Values for the argument to `sysconf'.
const ( /* confname.h:71:1: */
	X_SC_ARG_MAX               = 0
	X_SC_CHILD_MAX             = 1
	X_SC_CLK_TCK               = 2
	X_SC_NGROUPS_MAX           = 3
	X_SC_OPEN_MAX              = 4
	X_SC_STREAM_MAX            = 5
	X_SC_TZNAME_MAX            = 6
	X_SC_JOB_CONTROL           = 7
	X_SC_SAVED_IDS             = 8
	X_SC_REALTIME_SIGNALS      = 9
	X_SC_PRIORITY_SCHEDULING   = 10
	X_SC_TIMERS                = 11
	X_SC_ASYNCHRONOUS_IO       = 12
	X_SC_PRIORITIZED_IO        = 13
	X_SC_SYNCHRONIZED_IO       = 14
	X_SC_FSYNC                 = 15
	X_SC_MAPPED_FILES          = 16
	X_SC_MEMLOCK               = 17
	X_SC_MEMLOCK_RANGE         = 18
	X_SC_MEMORY_PROTECTION     = 19
	X_SC_MESSAGE_PASSING       = 20
	X_SC_SEMAPHORES            = 21
	X_SC_SHARED_MEMORY_OBJECTS = 22
	X_SC_AIO_LISTIO_MAX        = 23
	X_SC_AIO_MAX               = 24
	X_SC_AIO_PRIO_DELTA_MAX    = 25
	X_SC_DELAYTIMER_MAX        = 26
	X_SC_MQ_OPEN_MAX           = 27
	X_SC_MQ_PRIO_MAX           = 28
	X_SC_VERSION               = 29
	X_SC_PAGESIZE              = 30
	X_SC_RTSIG_MAX             = 31
	X_SC_SEM_NSEMS_MAX         = 32
	X_SC_SEM_VALUE_MAX         = 33
	X_SC_SIGQUEUE_MAX          = 34
	X_SC_TIMER_MAX             = 35

	// Values for the argument to `sysconf'
	//        corresponding to _POSIX2_* symbols.
	X_SC_BC_BASE_MAX        = 36
	X_SC_BC_DIM_MAX         = 37
	X_SC_BC_SCALE_MAX       = 38
	X_SC_BC_STRING_MAX      = 39
	X_SC_COLL_WEIGHTS_MAX   = 40
	X_SC_EQUIV_CLASS_MAX    = 41
	X_SC_EXPR_NEST_MAX      = 42
	X_SC_LINE_MAX           = 43
	X_SC_RE_DUP_MAX         = 44
	X_SC_CHARCLASS_NAME_MAX = 45

	X_SC_2_VERSION   = 46
	X_SC_2_C_BIND    = 47
	X_SC_2_C_DEV     = 48
	X_SC_2_FORT_DEV  = 49
	X_SC_2_FORT_RUN  = 50
	X_SC_2_SW_DEV    = 51
	X_SC_2_LOCALEDEF = 52

	X_SC_PII                 = 53
	X_SC_PII_XTI             = 54
	X_SC_PII_SOCKET          = 55
	X_SC_PII_INTERNET        = 56
	X_SC_PII_OSI             = 57
	X_SC_POLL                = 58
	X_SC_SELECT              = 59
	X_SC_UIO_MAXIOV          = 60
	X_SC_IOV_MAX             = 60
	X_SC_PII_INTERNET_STREAM = 61
	X_SC_PII_INTERNET_DGRAM  = 62
	X_SC_PII_OSI_COTS        = 63
	X_SC_PII_OSI_CLTS        = 64
	X_SC_PII_OSI_M           = 65
	X_SC_T_IOV_MAX           = 66

	// Values according to POSIX 1003.1c (POSIX threads).
	X_SC_THREADS                      = 67
	X_SC_THREAD_SAFE_FUNCTIONS        = 68
	X_SC_GETGR_R_SIZE_MAX             = 69
	X_SC_GETPW_R_SIZE_MAX             = 70
	X_SC_LOGIN_NAME_MAX               = 71
	X_SC_TTY_NAME_MAX                 = 72
	X_SC_THREAD_DESTRUCTOR_ITERATIONS = 73
	X_SC_THREAD_KEYS_MAX              = 74
	X_SC_THREAD_STACK_MIN             = 75
	X_SC_THREAD_THREADS_MAX           = 76
	X_SC_THREAD_ATTR_STACKADDR        = 77
	X_SC_THREAD_ATTR_STACKSIZE        = 78
	X_SC_THREAD_PRIORITY_SCHEDULING   = 79
	X_SC_THREAD_PRIO_INHERIT          = 80
	X_SC_THREAD_PRIO_PROTECT          = 81
	X_SC_THREAD_PROCESS_SHARED        = 82

	X_SC_NPROCESSORS_CONF = 83
	X_SC_NPROCESSORS_ONLN = 84
	X_SC_PHYS_PAGES       = 85
	X_SC_AVPHYS_PAGES     = 86
	X_SC_ATEXIT_MAX       = 87
	X_SC_PASS_MAX         = 88

	X_SC_XOPEN_VERSION     = 89
	X_SC_XOPEN_XCU_VERSION = 90
	X_SC_XOPEN_UNIX        = 91
	X_SC_XOPEN_CRYPT       = 92
	X_SC_XOPEN_ENH_I18N    = 93
	X_SC_XOPEN_SHM         = 94

	X_SC_2_CHAR_TERM = 95
	X_SC_2_C_VERSION = 96
	X_SC_2_UPE       = 97

	X_SC_XOPEN_XPG2 = 98
	X_SC_XOPEN_XPG3 = 99
	X_SC_XOPEN_XPG4 = 100

	X_SC_CHAR_BIT   = 101
	X_SC_CHAR_MAX   = 102
	X_SC_CHAR_MIN   = 103
	X_SC_INT_MAX    = 104
	X_SC_INT_MIN    = 105
	X_SC_LONG_BIT   = 106
	X_SC_WORD_BIT   = 107
	X_SC_MB_LEN_MAX = 108
	X_SC_NZERO      = 109
	X_SC_SSIZE_MAX  = 110
	X_SC_SCHAR_MAX  = 111
	X_SC_SCHAR_MIN  = 112
	X_SC_SHRT_MAX   = 113
	X_SC_SHRT_MIN   = 114
	X_SC_UCHAR_MAX  = 115
	X_SC_UINT_MAX   = 116
	X_SC_ULONG_MAX  = 117
	X_SC_USHRT_MAX  = 118

	X_SC_NL_ARGMAX  = 119
	X_SC_NL_LANGMAX = 120
	X_SC_NL_MSGMAX  = 121
	X_SC_NL_NMAX    = 122
	X_SC_NL_SETMAX  = 123
	X_SC_NL_TEXTMAX = 124

	X_SC_XBS5_ILP32_OFF32  = 125
	X_SC_XBS5_ILP32_OFFBIG = 126
	X_SC_XBS5_LP64_OFF64   = 127
	X_SC_XBS5_LPBIG_OFFBIG = 128

	X_SC_XOPEN_LEGACY           = 129
	X_SC_XOPEN_REALTIME         = 130
	X_SC_XOPEN_REALTIME_THREADS = 131

	X_SC_ADVISORY_INFO          = 132
	X_SC_BARRIERS               = 133
	X_SC_BASE                   = 134
	X_SC_C_LANG_SUPPORT         = 135
	X_SC_C_LANG_SUPPORT_R       = 136
	X_SC_CLOCK_SELECTION        = 137
	X_SC_CPUTIME                = 138
	X_SC_THREAD_CPUTIME         = 139
	X_SC_DEVICE_IO              = 140
	X_SC_DEVICE_SPECIFIC        = 141
	X_SC_DEVICE_SPECIFIC_R      = 142
	X_SC_FD_MGMT                = 143
	X_SC_FIFO                   = 144
	X_SC_PIPE                   = 145
	X_SC_FILE_ATTRIBUTES        = 146
	X_SC_FILE_LOCKING           = 147
	X_SC_FILE_SYSTEM            = 148
	X_SC_MONOTONIC_CLOCK        = 149
	X_SC_MULTI_PROCESS          = 150
	X_SC_SINGLE_PROCESS         = 151
	X_SC_NETWORKING             = 152
	X_SC_READER_WRITER_LOCKS    = 153
	X_SC_SPIN_LOCKS             = 154
	X_SC_REGEXP                 = 155
	X_SC_REGEX_VERSION          = 156
	X_SC_SHELL                  = 157
	X_SC_SIGNALS                = 158
	X_SC_SPAWN                  = 159
	X_SC_SPORADIC_SERVER        = 160
	X_SC_THREAD_SPORADIC_SERVER = 161
	X_SC_SYSTEM_DATABASE        = 162
	X_SC_SYSTEM_DATABASE_R      = 163
	X_SC_TIMEOUTS               = 164
	X_SC_TYPED_MEMORY_OBJECTS   = 165
	X_SC_USER_GROUPS            = 166
	X_SC_USER_GROUPS_R          = 167
	X_SC_2_PBS                  = 168
	X_SC_2_PBS_ACCOUNTING       = 169
	X_SC_2_PBS_LOCATE           = 170
	X_SC_2_PBS_MESSAGE          = 171
	X_SC_2_PBS_TRACK            = 172
	X_SC_SYMLOOP_MAX            = 173
	X_SC_STREAMS                = 174
	X_SC_2_PBS_CHECKPOINT       = 175

	X_SC_V6_ILP32_OFF32  = 176
	X_SC_V6_ILP32_OFFBIG = 177
	X_SC_V6_LP64_OFF64   = 178
	X_SC_V6_LPBIG_OFFBIG = 179

	X_SC_HOST_NAME_MAX      = 180
	X_SC_TRACE              = 181
	X_SC_TRACE_EVENT_FILTER = 182
	X_SC_TRACE_INHERIT      = 183
	X_SC_TRACE_LOG          = 184

	X_SC_LEVEL1_ICACHE_SIZE     = 185
	X_SC_LEVEL1_ICACHE_ASSOC    = 186
	X_SC_LEVEL1_ICACHE_LINESIZE = 187
	X_SC_LEVEL1_DCACHE_SIZE     = 188
	X_SC_LEVEL1_DCACHE_ASSOC    = 189
	X_SC_LEVEL1_DCACHE_LINESIZE = 190
	X_SC_LEVEL2_CACHE_SIZE      = 191
	X_SC_LEVEL2_CACHE_ASSOC     = 192
	X_SC_LEVEL2_CACHE_LINESIZE  = 193
	X_SC_LEVEL3_CACHE_SIZE      = 194
	X_SC_LEVEL3_CACHE_ASSOC     = 195
	X_SC_LEVEL3_CACHE_LINESIZE  = 196
	X_SC_LEVEL4_CACHE_SIZE      = 197
	X_SC_LEVEL4_CACHE_ASSOC     = 198
	X_SC_LEVEL4_CACHE_LINESIZE  = 199
	// Leave room here, maybe we need a few more cache levels some day.

	X_SC_IPV6        = 235
	X_SC_RAW_SOCKETS = 236

	X_SC_V7_ILP32_OFF32  = 237
	X_SC_V7_ILP32_OFFBIG = 238
	X_SC_V7_LP64_OFF64   = 239
	X_SC_V7_LPBIG_OFFBIG = 240

	X_SC_SS_REPL_MAX = 241

	X_SC_TRACE_EVENT_NAME_MAX = 242
	X_SC_TRACE_NAME_MAX       = 243
	X_SC_TRACE_SYS_MAX        = 244
	X_SC_TRACE_USER_EVENT_MAX = 245

	X_SC_XOPEN_STREAMS = 246

	X_SC_THREAD_ROBUST_PRIO_INHERIT = 247
	X_SC_THREAD_ROBUST_PRIO_PROTECT = 248
)

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get size_t, wchar_t and NULL from <stddef.h>.
// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

const ( /* waitflags.h:52:1: */
	P_ALL  = 0 // Wait for any child.
	P_PID  = 1 // Wait for specified process.
	P_PGID = 2
)

//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

// ===========================================================================
//  Function prototypes.
const ( /* deflate.c:66:1: */
	Need_more      = 0 // block not completed, need more input or more output
	Block_done     = 1 // block flush performed
	Finish_started = 2 // finish started, need only more output at next deflate
	Finish_done    = 3
)

// inflate.h -- internal inflate state definition
// Copyright (C) 1995-2016 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip decoding
//    should be left enabled.

// Possible inflate modes between inflate() calls
const ( /* inflate.h:20:1: */
	HEAD     = 16180 // i: waiting for magic header
	FLAGS    = 16181 // i: waiting for method and flags (gzip)
	TIME     = 16182 // i: waiting for modification time (gzip)
	OS       = 16183 // i: waiting for extra flags and operating system (gzip)
	EXLEN    = 16184 // i: waiting for extra length (gzip)
	EXTRA    = 16185 // i: waiting for extra bytes (gzip)
	NAME     = 16186 // i: waiting for end of file name (gzip)
	COMMENT  = 16187 // i: waiting for end of comment (gzip)
	HCRC     = 16188 // i: waiting for header crc (gzip)
	DICTID   = 16189 // i: waiting for dictionary check value
	DICT     = 16190 // waiting for inflateSetDictionary() call
	TYPE     = 16191 // i: waiting for type bits, including last-flag bit
	TYPEDO   = 16192 // i: same, but skip check to exit inflate on new block
	STORED   = 16193 // i: waiting for stored size (length and complement)
	COPY_    = 16194 // i/o: same as COPY below, but only first time in
	COPY     = 16195 // i/o: waiting for input or output to copy stored block
	TABLE    = 16196 // i: waiting for dynamic block table lengths
	LENLENS  = 16197 // i: waiting for code length code lengths
	CODELENS = 16198 // i: waiting for length/lit and distance code lengths
	LEN_     = 16199 // i: same as LEN below, but only first time in
	LEN      = 16200 // i: waiting for length/lit/eob code
	LENEXT   = 16201 // i: waiting for length extra bits
	DIST     = 16202 // i: waiting for distance code
	DISTEXT  = 16203 // i: waiting for distance extra bits
	MATCH    = 16204 // o: waiting for output space to copy string
	LIT      = 16205 // o: waiting for output space to write literal
	CHECK    = 16206 // i: waiting for 32-bit check value
	LENGTH   = 16207 // i: waiting for 32-bit length (gzip)
	DONE     = 16208 // finished check, done -- remain here until reset
	BAD      = 16209 // got a data error -- remain here until reset
	MEM      = 16210 // got an inflate() memory error -- remain here until reset
	SYNC     = 16211
)

// op values as set by inflate_table():
//     00000000 - literal
//     0000tttt - table link, tttt != 0 is the number of table index bits
//     0001eeee - length or distance, eeee is the number of extra bits
//     01100000 - end of block
//     01000000 - invalid code
//

// Maximum size of the dynamic table.  The maximum number of code structures is
//    1444, which is the sum of 852 for literal/length codes and 592 for distance
//    codes.  These values were found by exhaustive searches using the program
//    examples/enough.c found in the zlib distribtution.  The arguments to that
//    program are the number of symbols, the initial root table size, and the
//    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
//    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
//    The initial root table size (9 or 6) is found in the fifth argument of the
//    inflate_table() calls in inflate.c and infback.c.  If the root table size is
//    changed, then these maximum sizes would be need to be recalculated and
//    updated.

// Type of code to build for inflate_table()
const ( /* inftrees.h:54:1: */
	CODES = 0
	LENS  = 1
	DISTS = 2
)

type Ptrdiff_t = int32 /* <builtin>:3:26 */

type Size_t = uint32 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type Max_align_t = struct {
	F__max_align_ll   int64
	F__max_align_ld   float64
	F__max_align_f128 X__float128
} /* stddef.h:437:3 */

type Z_size_t = Size_t /* zconf.h:248:21 */

// Maximum value for memLevel in deflateInit2

// Maximum value for windowBits in deflateInit2 and inflateInit2.
// WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
// created by gzip. (Files created by minigzip can still be extracted by
// gzip.)

// The memory requirements for deflate are (in bytes):
//             (1 << (windowBits+2)) +  (1 << (memLevel+9))
//  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
//  plus a few kilobytes for small objects. For example, if you want to reduce
//  the default memory requirements from 256K to 128K, compile with
//      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
//  Of course this will generally degrade compression (there's no free lunch).
//
//    The memory requirements for inflate are (in bytes) 1 << windowBits
//  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
//  for small objects.

// Type declarations

// The following definitions for FAR are needed only for MSDOS mixed
// model programming (small or medium model with some far allocations).
// This was tested only with MSC; for other MSDOS compilers you may have
// to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
// just define FAR to be empty.

type Byte = uint8   /* zconf.h:391:24 */ // 8 bits
type UInt = uint32  /* zconf.h:393:24 */ // 16 bits or more
type ULong = uint32 /* zconf.h:394:24 */ // 32 bits or more

type Bytef = Byte   /* zconf.h:400:22 */
type Charf = int8   /* zconf.h:402:19 */
type Intf = int32   /* zconf.h:403:19 */
type UIntf = UInt   /* zconf.h:404:19 */
type ULongf = ULong /* zconf.h:405:19 */

type Voidpc = uintptr /* zconf.h:408:23 */
type Voidpf = uintptr /* zconf.h:409:23 */
type Voidp = uintptr  /* zconf.h:410:23 */

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    anymore supported.

// Some user header file might have defined this before.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this works only with
//    gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// Compilers that are not clang may object to
//        #if defined __clang__ && __has_extension(...)
//    even though they do not need to evaluate the right-hand side of the &&.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC has various useful declarations that can be made with the
//    `__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonull function attribute allows to mark pointer parameters which
//    must not be NULL.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked fot by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 supports this.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Determine the wordsize from the preprocessor defines.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Maximum length of any multibyte character in any locale.
//    We define this value here since the gcc header does not define
//    the correct value.

// If we are not using GNU CC we have to define all the symbols ourself.
//    Otherwise use gcc's definitions (see below).

// Get the compiler's limits.h, which defines almost all the ISO constants.
//
//     We put this #include_next outside the double inclusion check because
//     it should be possible to include this file more than once and still get
//     the definitions from gcc's header.

// The <limits.h> files in some gcc versions don't define LLONG_MIN,
//    LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
//    ages are available.

// The integer width macros are not defined by GCC's <limits.h> before
//    GCC 7, or if _GNU_SOURCE rather than
//    __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.

// POSIX adds things to <limits.h>.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
//
//	Never include this file directly; use <limits.h> instead.

// Determine the wordsize from the preprocessor defines.

// These are the standard-mandated minimum values.

// Minimum number of operations in one list I/O call.

// Minimal number of outstanding asynchronous I/O operations.

// Maximum length of arguments to `execve', including environment.

// Maximum simultaneous processes per real user ID.

// Minimal number of timer expiration overruns.

// Maximum length of a host name (not including the terminating null)
//    as returned from the GETHOSTNAME function.

// Maximum link count of a file.

// Maximum length of login name.

// Number of bytes in a terminal canonical input queue.

// Number of bytes for which space will be
//    available in a terminal input queue.

// Maximum number of message queues open for a process.

// Maximum number of supported message priorities.

// Number of bytes in a filename.

// Number of simultaneous supplementary group IDs per process.

// Number of files one process can have open at once.

// Number of bytes in a pathname.

// Number of bytes than can be written atomically to a pipe.

// The number of repeated occurrences of a BRE permitted by the
//    REGEXEC and REGCOMP functions when using the interval notation.

// Minimal number of realtime signals reserved for the application.

// Number of semaphores a process can have.

// Maximal value of a semaphore.

// Number of pending realtime signals.

// Largest value of a `ssize_t'.

// Number of streams a process can have open at once.

// The number of bytes in a symbolic link.

// The number of symbolic links that can be traversed in the
//    resolution of a pathname in the absence of a loop.

// Number of timer for a process.

// Maximum number of characters in a tty name.

// Maximum length of a timezone name (element of `tzname').

// Maximum clock resolution in nanoseconds.

// Get the implementation-specific values for the above.
// Minimum guaranteed maximum values for system limits.  Linux version.
//    Copyright (C) 1993-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <http://www.gnu.org/licenses/>.

// The kernel header pollutes the namespace with the NR_OPEN symbol
//    and defines LINK_MAX although filesystems have different maxima.  A
//    similar thing is true for OPEN_MAX: the limit can be changed at
//    runtime and therefore the macro must not be defined.  Remove this
//    after including the header if necessary.

// The kernel sources contain a file with all the needed information.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Have to remove NR_OPEN?
// Have to remove LINK_MAX?
// Have to remove OPEN_MAX?
// Have to remove ARG_MAX?

// The number of data keys per process.
// This is the value this implementation supports.

// Controlling the iterations of destructors for thread-specific data.
// Number of iterations this implementation does.

// The number of threads per process.
// We have no predefined limit on the number of threads.

// Maximum amount by which a process can descrease its asynchronous I/O
//    priority level.

// Minimum size for a thread.  We are free to choose a reasonable value.

// Maximum number of timer expiration overruns.

// Maximum tty name length.

// Maximum login name length.  This is arbitrary.

// Maximum host name length.

// Maximum message queue priority level.

// Maximum value the semaphore can have.

// ssize_t is not formally required to be the signed type
//    corresponding to size_t, but it is for all configurations supported
//    by glibc.

// This value is a guaranteed minimum maximum.
//    The current maximum can be got from `sysconf'.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; include <limits.h> instead.

// The maximum `ibase' and `obase' values allowed by the `bc' utility.

// The maximum number of elements allowed in an array by the `bc' utility.

// The maximum `scale' value allowed by the `bc' utility.

// The maximum length of a string constant accepted by the `bc' utility.

// The maximum number of weights that can be assigned to an entry of
//    the LC_COLLATE `order' keyword in the locale definition file.

// The maximum number of expressions that can be nested
//    within parentheses by the `expr' utility.

// The maximum length, in bytes, of an input line.

// The maximum number of repeated occurrences of a regular expression
//    permitted when using the interval notation `\{M,N\}'.

// The maximum number of bytes in a character class name.  We have no
//    fixed limit, 2048 is a high number.

// These values are implementation-specific,
//    and may vary within the implementation.
//    Their precise values can be obtained from sysconf.

// This value is defined like this in regex.h.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

type Z_crc_t = uint32 /* zconf.h:429:17 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Convenience types.
type X__u_char = uint8   /* types.h:30:23 */
type X__u_short = uint16 /* types.h:31:28 */
type X__u_int = uint32   /* types.h:32:22 */
type X__u_long = uint32  /* types.h:33:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type X__int8_t = int8     /* types.h:36:21 */
type X__uint8_t = uint8   /* types.h:37:23 */
type X__int16_t = int16   /* types.h:38:26 */
type X__uint16_t = uint16 /* types.h:39:28 */
type X__int32_t = int32   /* types.h:40:20 */
type X__uint32_t = uint32 /* types.h:41:22 */
type X__int64_t = int64   /* types.h:46:44 */
type X__uint64_t = uint64 /* types.h:47:46 */

// Smallest types with at least a given width.
type X__int_least8_t = X__int8_t     /* types.h:51:18 */
type X__uint_least8_t = X__uint8_t   /* types.h:52:19 */
type X__int_least16_t = X__int16_t   /* types.h:53:19 */
type X__uint_least16_t = X__uint16_t /* types.h:54:20 */
type X__int_least32_t = X__int32_t   /* types.h:55:19 */
type X__uint_least32_t = X__uint32_t /* types.h:56:20 */
type X__int_least64_t = X__int64_t   /* types.h:57:19 */
type X__uint_least64_t = X__uint64_t /* types.h:58:20 */

// quad_t is also 64 bits.
type X__quad_t = int64    /* types.h:65:37 */
type X__u_quad_t = uint64 /* types.h:66:46 */

// Largest integral types.
type X__intmax_t = int64   /* types.h:74:37 */
type X__uintmax_t = uint64 /* types.h:75:46 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, always long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// We want __extension__ before typedef's that use nonstandard base types
//    such as `long long' in C89 mode.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Number of descriptors that can fit in an `fd_set'.

type X__dev_t = X__u_quad_t                /* types.h:143:25 */ // Type of device numbers.
type X__uid_t = uint32                     /* types.h:144:25 */ // Type of user identifications.
type X__gid_t = uint32                     /* types.h:145:25 */ // Type of group identifications.
type X__ino_t = uint32                     /* types.h:146:25 */ // Type of file serial numbers.
type X__ino64_t = X__u_quad_t              /* types.h:147:27 */ // Type of file serial numbers (LFS).
type X__mode_t = uint32                    /* types.h:148:26 */ // Type of file attribute bitmasks.
type X__nlink_t = uint32                   /* types.h:149:27 */ // Type of file link counts.
type X__off_t = int32                      /* types.h:150:25 */ // Type of file sizes and offsets.
type X__off64_t = X__quad_t                /* types.h:151:27 */ // Type of file sizes and offsets (LFS).
type X__pid_t = int32                      /* types.h:152:25 */ // Type of process identifications.
type X__fsid_t = struct{ F__val [2]int32 } /* types.h:153:26 */ // Type of file system IDs.
type X__clock_t = int32                    /* types.h:154:27 */ // Type of CPU usage counts.
type X__rlim_t = uint32                    /* types.h:155:26 */ // Type for resource measurement.
type X__rlim64_t = X__u_quad_t             /* types.h:156:28 */ // Type for resource measurement (LFS).
type X__id_t = uint32                      /* types.h:157:24 */ // General type for IDs.
type X__time_t = int32                     /* types.h:158:26 */ // Seconds since the Epoch.
type X__useconds_t = uint32                /* types.h:159:30 */ // Count of microseconds.
type X__suseconds_t = int32                /* types.h:160:31 */ // Signed count of microseconds.

type X__daddr_t = int32 /* types.h:162:27 */ // The type of a disk address.
type X__key_t = int32   /* types.h:163:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type X__clockid_t = int32 /* types.h:166:29 */

// Timer ID returned by `timer_create'.
type X__timer_t = uintptr /* types.h:169:12 */

// Type to represent block size.
type X__blksize_t = int32 /* types.h:172:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type X__blkcnt_t = int32       /* types.h:177:28 */
type X__blkcnt64_t = X__quad_t /* types.h:178:30 */

// Type to count file system blocks.
type X__fsblkcnt_t = uint32        /* types.h:181:30 */
type X__fsblkcnt64_t = X__u_quad_t /* types.h:182:32 */

// Type to count file system nodes.
type X__fsfilcnt_t = uint32        /* types.h:185:30 */
type X__fsfilcnt64_t = X__u_quad_t /* types.h:186:32 */

// Type of miscellaneous file system fields.
type X__fsword_t = int32 /* types.h:189:28 */

type X__ssize_t = int32 /* types.h:191:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type X__syscall_slong_t = int32 /* types.h:194:33 */
// Unsigned long type used in system calls.
type X__syscall_ulong_t = uint32 /* types.h:196:33 */

// These few don't really vary by system, they always correspond
//    to one of the other defined types.
type X__loff_t = X__off64_t /* types.h:200:19 */ // Type of file sizes and offsets (LFS).
type X__caddr_t = uintptr   /* types.h:201:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type X__intptr_t = int32 /* types.h:204:25 */

// Duplicate info from sys/socket.h.
type X__socklen_t = uint32 /* types.h:207:23 */

// C99: An integer type that can be accessed as an atomic entity,
//    even in the presence of asynchronous interrupts.
//    It is not currently necessary for this to be machine-specific.
type X__sig_atomic_t = int32 /* types.h:212:13 */

type U_char = X__u_char     /* types.h:33:18 */
type U_short = X__u_short   /* types.h:34:19 */
type U_int = X__u_int       /* types.h:35:17 */
type U_long = X__u_long     /* types.h:36:18 */
type Quad_t = X__quad_t     /* types.h:37:18 */
type U_quad_t = X__u_quad_t /* types.h:38:20 */
type Fsid_t = X__fsid_t     /* types.h:39:18 */
type Loff_t = X__loff_t     /* types.h:42:18 */

type Ino_t = X__ino64_t   /* types.h:49:19 */
type Ino64_t = X__ino64_t /* types.h:54:19 */

type Dev_t = X__dev_t /* types.h:59:17 */

type Gid_t = X__gid_t /* types.h:64:17 */

type Mode_t = X__mode_t /* types.h:69:18 */

type Nlink_t = X__nlink_t /* types.h:74:19 */

type Uid_t = X__uid_t /* types.h:79:17 */

type Off_t = X__off64_t   /* types.h:87:19 */
type Off64_t = X__off64_t /* types.h:92:19 */

type Pid_t = X__pid_t /* types.h:97:17 */

type Id_t = X__id_t /* types.h:103:16 */

type Ssize_t = X__ssize_t /* types.h:108:19 */

type Daddr_t = X__daddr_t /* types.h:114:19 */
type Caddr_t = X__caddr_t /* types.h:115:19 */

type Key_t = X__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Clock_t = X__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Clockid_t = X__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Time_t = X__time_t /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Timer_t = X__timer_t /* timer_t.h:7:19 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Old compatibility names for C types.
type Ulong = uint32  /* types.h:148:27 */
type Ushort = uint16 /* types.h:149:28 */
type Uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Int8_t = X__int8_t   /* stdint-intn.h:24:18 */
type Int16_t = X__int16_t /* stdint-intn.h:25:19 */
type Int32_t = X__int32_t /* stdint-intn.h:26:19 */
type Int64_t = X__int64_t /* stdint-intn.h:27:19 */

// For GCC 2.7 and later, we can use specific type-size attributes.

type U_int8_t = uint32  /* types.h:177:1 */
type U_int16_t = uint32 /* types.h:178:1 */
type U_int32_t = uint32 /* types.h:179:1 */
type U_int64_t = uint32 /* types.h:180:1 */

type Register_t = int32 /* types.h:182:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Get sigset_t.

type X__sigset_t = struct{ F__val [32]uint32 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Sigset_t = X__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type Timeval = struct {
	Ftv_sec  X__time_t
	Ftv_usec X__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type Timespec = struct {
	Ftv_sec  X__time_t
	Ftv_nsec X__syscall_slong_t
} /* struct_timespec.h:9:1 */

type Suseconds_t = X__suseconds_t /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type X__fd_mask = int32 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Fd_set = struct{ F__fds_bits [32]X__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Fd_mask = X__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Blksize_t = X__blksize_t /* types.h:202:21 */

// Types from the Large File Support interface.
type Blkcnt_t = X__blkcnt64_t     /* types.h:222:22 */ // Type to count number of disk blocks.
type Fsblkcnt_t = X__fsblkcnt64_t /* types.h:226:24 */ // Type to count file system blocks.
type Fsfilcnt_t = X__fsfilcnt64_t /* types.h:230:24 */ // Type to count file system inodes.

type Blkcnt64_t = X__blkcnt64_t     /* types.h:236:22 */ // Type to count number of disk blocks.
type Fsblkcnt64_t = X__fsblkcnt64_t /* types.h:237:24 */ // Type to count file system blocks.
type Fsfilcnt64_t = X__fsfilcnt64_t /* types.h:238:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    Also, the following macros must be define for internal pthread_mutex_t
//    struct definitions (struct __pthread_mutex_s):
//
//    __PTHREAD_COMPAT_PADDING_MID   - any additional members after 'kind'
// 				    and before '__spin' (for 64 bits) or
// 				    '__nusers' (for 32 bits).
//    __PTHREAD_COMPAT_PADDING_END   - any additional members at the end of
// 				    the internal structure.
//    __PTHREAD_MUTEX_LOCK_ELISION   - 1 if the architecture supports lock
// 				    elision or 0 otherwise.
//    __PTHREAD_MUTEX_NUSERS_AFTER_KIND - control where to put __nusers.  The
// 				       preferred value for new architectures
// 				       is 0.
//    __PTHREAD_MUTEX_USE_UNION      - control whether internal __spins and
// 				    __list will be place inside a union for
// 				    linuxthreads compatibility.
// 				    The preferred value for new architectures
// 				    is 0.
//
//    For a new port the preferred values for the required defines are:
//
//    #define __PTHREAD_COMPAT_PADDING_MID
//    #define __PTHREAD_COMPAT_PADDING_END
//    #define __PTHREAD_MUTEX_LOCK_ELISION         0
//    #define __PTHREAD_MUTEX_NUSERS_AFTER_KIND    0
//    #define __PTHREAD_MUTEX_USE_UNION            0
//
//    __PTHREAD_MUTEX_LOCK_ELISION can be set to 1 if the hardware plans to
//    eventually support lock elision using transactional memory.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.
//
//    And finally the internal pthread_rwlock_t (struct __pthread_rwlock_arch_t)
//    must be defined.
//
// Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Definitions for internal mutex struct.

type X__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__flags         uint8
	F__shared        uint8
	F__rwelision     int8
	F__pad2          uint8
	F__cur_writer    int32
} /* pthreadtypes-arch.h:65:1 */

// Extra attributes for the cleanup functions.

// Common definition of pthread_mutex_t.

type X__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:88:9 */

// Extra attributes for the cleanup functions.

// Common definition of pthread_mutex_t.

type X__pthread_slist_t = X__pthread_internal_slist /* thread-shared-types.h:91:3 */

// Lock elision support.

type X__pthread_mutex_s = struct {
	F__lock   int32
	F__count  uint32
	F__owner  int32
	F__kind   int32
	F__nusers uint32
	F__20     struct {
		_               [0]uint32
		F__elision_data struct {
			F__espins   int16
			F__eelision int16
		}
	}
} /* thread-shared-types.h:118:1 */

// Common definition of pthread_cond_t.

type X__pthread_cond_s = struct {
	F__0            struct{ F__wseq uint64 }
	F__8            struct{ F__g1_start uint64 }
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:171:1 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type Pthread_t = uint32 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type Pthread_mutexattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type Pthread_condattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Pthread_attr_t1 = struct {
	_       [0]uint32
	F__size [36]int8
} /* pthreadtypes.h:56:1 */

type Pthread_attr_t = Pthread_attr_t1 /* pthreadtypes.h:62:30 */

type Pthread_mutex_t = struct{ F__data X__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Pthread_cond_t = struct{ F__data X__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type Pthread_rwlock_t = struct{ F__data X__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Pthread_rwlockattr_t = struct {
	_       [0]uint32
	F__size [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type Pthread_barrier_t = struct {
	_       [0]uint32
	F__size [20]int8
} /* pthreadtypes.h:112:3 */

type Pthread_barrierattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:118:3 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type X__gnuc_va_list = X__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//    stdio.h, because ANSI C says that stdio.h is not supposed to define
//    va_list.  stdio.h needs to have access to that data type,
//    but must not use that name.  It should use the name __gnuc_va_list,
//    which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//    But on BSD NET2 we must not test or define or undef it.
//    (Note that the comments in NET 2's ansi.h
//    are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type Va_list = X__gnuc_va_list /* stdarg.h:99:24 */

// a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
// "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
// though the former does not conform to the LFS document), but considering
// both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
// equivalently requesting no 64-bit operations

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// These may be used to determine what facilities are present at compile time.
//    Their values can be obtained at run time from `sysconf'.

// POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.

// These are not #ifdef __USE_POSIX2 because they are
//    in the theoretically application-owned namespace.

// The utilities on GNU systems also correspond to this version.

// The utilities on GNU systems also correspond to this version.

// This symbol was required until the 2001 edition of POSIX.

// If defined, the implementation supports the
//    C Language Bindings Option.

// If defined, the implementation supports the
//    C Language Development Utilities Option.

// If defined, the implementation supports the
//    Software Development Utilities Option.

// If defined, the implementation supports the
//    creation of locales with the localedef utility.

// X/Open version number to which the library conforms.  It is selectable.

// Commands and utilities from XPG4 are available.

// We are compatible with the old published standards as well.

// The X/Open Unix extensions are available.

// The enhanced internationalization capabilities according to XPG4.2
//    are present.

// The legacy interfaces are also available.

// Get values of POSIX options:
//
//    If these symbols are defined, the corresponding features are
//    always available.  If not, they may be available sometimes.
//    The current values can be obtained with `sysconf'.
//
//    _POSIX_JOB_CONTROL		Job control is supported.
//    _POSIX_SAVED_IDS		Processes have a saved set-user-ID
// 				and a saved set-group-ID.
//    _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
//    _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
//    _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
//    _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
//    _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
//    _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
//    _POSIX_FSYNC			The fsync function is present.
//    _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
//    _POSIX_MEMLOCK		Locking of all memory is supported.
//    _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
//    _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
//    _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
//    _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
//    _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
//    _POSIX_THREADS		POSIX.1c pthreads are supported.
//    _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
//    _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
//    _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
//    _POSIX_THREAD_PRIORITY_SCHEDULING
// 				POSIX.1c thread execution scheduling supported.
//    _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
//    _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
//    _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
//    _POSIX_PII			Protocol-independent interfaces are supported.
//    _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
//    _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
//    _POSIX_PII_INTERNET		Internet family of protocols supported.
//    _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
//    _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
//    _POSIX_PII_OSI		ISO/OSI family of protocols supported.
//    _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
//    _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
//    _POSIX_POLL			Implementation supports `poll' function.
//    _POSIX_SELECT		Implementation supports `select' and `pselect'.
//
//    _XOPEN_REALTIME		X/Open realtime support is available.
//    _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
//    _XOPEN_SHM			Shared memory interface according to XPG4.2.
//
//    _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
// 				int, long, pointer, and off_t types.
//    _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
// 				int, long, and pointer and off_t with at least
// 				64 bits.
//    _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
// 				int, and 64-bit long, pointer, and off_t types.
//    _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
// 				least 32 bits int and long, pointer, and off_t
// 				with at least 64 bits.
//
//    If any of these symbols is defined as -1, the corresponding option is not
//    true for any file.  If any is defined as other than -1, the corresponding
//    option is true for all files.  If a symbol is not defined at all, the value
//    for a specific file can be obtained from `pathconf' and `fpathconf'.
//
//    _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
// 				the owner of a file.  `chown' can only be used
// 				to change the group ID of a file to a group of
// 				which the calling process is a member.
//    _POSIX_NO_TRUNC		Pathname components longer than
// 				NAME_MAX generate an error.
//    _POSIX_VDISABLE		If defined, if the value of an element of the
// 				`c_cc' member of `struct termios' is
// 				_POSIX_VDISABLE, no character will have the
// 				effect associated with that element.
//    _POSIX_SYNC_IO		Synchronous I/O may be performed.
//    _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
//    _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
//
//    Support for the Large File Support interface is not generally available.
//    If it is available the following constants are defined to one.
//    _LFS64_LARGEFILE		Low-level I/O supports large files.
//    _LFS64_STDIO			Standard I/O supports large files.
//

// Define POSIX options for Linux.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <http://www.gnu.org/licenses/>.

// Job control is supported.

// Processes have a saved set-user-ID and a saved set-group-ID.

// Priority scheduling is supported.

// Synchronizing file data is supported.

// The fsync function is present.

// Mapping of files to memory is supported.

// Locking of all memory is supported.

// Locking of ranges of memory is supported.

// Setting of memory protections is supported.

// Some filesystems allow all users to change file ownership.

// `c_cc' member of 'struct termios' structure can be disabled by
//    using the value _POSIX_VDISABLE.

// Filenames are not silently truncated.

// X/Open realtime support is available.

// X/Open thread realtime support is available.

// XPG4.2 shared memory is supported.

// Tell we have POSIX threads.

// We have the reentrant functions described in POSIX.

// We provide priority scheduling for threads.

// We support user-defined stack sizes.

// We support user-defined stacks.

// We support priority inheritence.

// We support priority protection, though only for non-robust
//    mutexes.

// We support priority inheritence for robust mutexes.

// We do not support priority protection for robust mutexes.

// We support POSIX.1b semaphores.

// Real-time signals are supported.

// We support asynchronous I/O.
// Alternative name for Unix98.
// Support for prioritization is also available.

// The LFS support in asynchronous I/O is also available.

// The rest of the LFS is also available.

// POSIX shared memory objects are implemented.

// CPU-time clocks support needs to be checked at runtime.

// Clock support in threads must be also checked at runtime.

// GNU libc provides regular expression handling.

// Reader/Writer locks are available.

// We have a POSIX shell.

// We support the Timeouts option.

// We support spinlocks.

// The `spawn' function family is supported.

// We have POSIX timers.

// The barrier functions are available.

// POSIX message queues are available.

// Thread process-shared synchronization is supported.

// The monotonic clock might be available.

// The clock selection interfaces are available.

// Advisory information interfaces are available.

// IPv6 support is available.

// Raw socket support is available.

// We have at least one terminal.

// Neither process nor thread sporadic server interfaces is available.

// trace.h is not available.

// Typed memory objects are not available.

// Get the environment definitions from Unix98.
// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// This header should define the following symbols under the described
//    situations.  A value `1' means that the model is always supported,
//    `-1' means it is never supported.  Undefined means it cannot be
//    statically decided.
//
//    _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
//    _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
//
//    _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
//    _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
//
//    The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
//    _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
//    _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
//    used in previous versions of the Unix standard and are available
//    only for compatibility.

// We have 32-bit wide `int', `long int' and pointers and all platforms
//    support LFS.  -mx32 has 64-bit wide `off_t'.

// -m32 has 32-bit wide `off_t'.

// We optionally provide an environment with the above size but an 64-bit
//    side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.

// Environments with 64-bit wide pointers can be provided,
//    so these macros aren't defined:
//    # undef _POSIX_V7_LP64_OFF64
//    # undef _POSIX_V7_LPBIG_OFFBIG
//    # undef _POSIX_V6_LP64_OFF64
//    # undef _POSIX_V6_LPBIG_OFFBIG
//    # undef _XBS5_LP64_OFF64
//    # undef _XBS5_LPBIG_OFFBIG
//    and sysconf tests for it at runtime.

// Standard file descriptors.

// All functions that are not declared anywhere else.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// The Single Unix specification says that some more types are
//    available here.

type Useconds_t = X__useconds_t /* unistd.h:255:22 */

type Intptr_t = X__intptr_t /* unistd.h:267:20 */

type Socklen_t = X__socklen_t /* unistd.h:274:21 */

// Define some macros helping to catch buffer overflows.

// MVS linker does not support external names larger than 8 bytes

//
//     The 'zlib' compression library provides in-memory compression and
//   decompression functions, including integrity checks of the uncompressed data.
//   This version of the library supports only one compression method (deflation)
//   but other algorithms will be added later and will have the same stream
//   interface.
//
//     Compression can be done in a single step if the buffers are large enough,
//   or can be done by repeated calls of the compression function.  In the latter
//   case, the application must provide more input and/or consume the output
//   (providing more output space) before each call.
//
//     The compressed data format used by default by the in-memory functions is
//   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
//   around a deflate stream, which is itself documented in RFC 1951.
//
//     The library also supports reading and writing files in gzip (.gz) format
//   with an interface similar to that of stdio using the functions that start
//   with "gz".  The gzip format is different from the zlib format.  gzip is a
//   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
//
//     This library can optionally read and write gzip and raw deflate streams in
//   memory as well.
//
//     The zlib format was designed to be compact and fast for use in memory
//   and on communications channels.  The gzip format was designed for single-
//   file compression on file systems, has a larger header than zlib to maintain
//   directory information, and uses a different, slower check method than zlib.
//
//     The library does not install any signal handler.  The decoder checks
//   the consistency of the compressed data, so the library should never crash
//   even in the case of corrupted input.

type Alloc_func = uintptr /* zlib.h:81:16 */
type Free_func = uintptr  /* zlib.h:82:16 */

type Internal_state = struct {
	Fstrm             Z_streamp
	Fstatus           int32
	Fpending_buf      uintptr
	Fpending_buf_size Ulg
	Fpending_out      uintptr
	Fpending          Ulg
	Fwrap             int32
	Fgzhead           Gz_headerp
	Fgzindex          Ulg
	Fmethod           Byte
	_                 [3]byte
	Flast_flush       int32
	Fw_size           UInt
	Fw_bits           UInt
	Fw_mask           UInt
	Fwindow           uintptr
	Fwindow_size      Ulg
	Fprev             uintptr
	Fhead             uintptr
	Fins_h            UInt
	Fhash_size        UInt
	Fhash_bits        UInt
	Fhash_mask        UInt
	Fhash_shift       UInt
	Fblock_start      int32
	Fmatch_length     UInt
	Fprev_match       IPos
	Fmatch_available  int32
	Fstrstart         UInt
	Fmatch_start      UInt
	Flookahead        UInt
	Fprev_length      UInt
	Fmax_chain_length UInt
	Fmax_lazy_match   UInt
	Flevel            int32
	Fstrategy         int32
	Fgood_match       UInt
	Fnice_match       int32
	Fdyn_ltree        [573]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fdyn_dtree [61]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fbl_tree [39]struct {
		Ffc struct{ Ffreq Ush }
		Fdl struct{ Fdad Ush }
	}
	Fl_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		Fstat_desc uintptr
	}
	Fd_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		Fstat_desc uintptr
	}
	Fbl_desc struct {
		Fdyn_tree  uintptr
		Fmax_code  int32
		Fstat_desc uintptr
	}
	Fbl_count    [16]Ush
	Fheap        [573]int32
	Fheap_len    int32
	Fheap_max    int32
	Fdepth       [573]Uch
	_            [3]byte
	Fl_buf       uintptr
	Flit_bufsize UInt
	Flast_lit    UInt
	Fd_buf       uintptr
	Fopt_len     Ulg
	Fstatic_len  Ulg
	Fmatches     UInt
	Finsert      UInt
	Fbi_buf      Ush
	_            [2]byte
	Fbi_valid    int32
	Fhigh_water  Ulg
} /* zlib.h:84:1 */

type Z_stream_s = struct {
	Fnext_in   uintptr
	Favail_in  UInt
	Ftotal_in  ULong
	Fnext_out  uintptr
	Favail_out UInt
	Ftotal_out ULong
	Fmsg       uintptr
	Fstate     uintptr
	Fzalloc    Alloc_func
	Fzfree     Free_func
	Fopaque    Voidpf
	Fdata_type int32
	Fadler     ULong
	Freserved  ULong
} /* zlib.h:86:9 */

type Z_stream = Z_stream_s /* zlib.h:106:3 */

type Z_streamp = uintptr /* zlib.h:108:22 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type Gz_header_s = struct {
	Ftext      int32
	Ftime      ULong
	Fxflags    int32
	Fos        int32
	Fextra     uintptr
	Fextra_len UInt
	Fextra_max UInt
	Fname      uintptr
	Fname_max  UInt
	Fcomment   uintptr
	Fcomm_max  UInt
	Fhcrc      int32
	Fdone      int32
} /* zlib.h:114:9 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type Gz_header = Gz_header_s /* zlib.h:129:3 */

type Gz_headerp = uintptr /* zlib.h:131:23 */
//
//      inflateGetHeader() requests that gzip header information be stored in the
//    provided gz_header structure.  inflateGetHeader() may be called after
//    inflateInit2() or inflateReset(), and before the first call of inflate().
//    As inflate() processes the gzip stream, head->done is zero until the header
//    is completed, at which time head->done is set to one.  If a zlib stream is
//    being decoded, then head->done is set to -1 to indicate that there will be
//    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
//    used to force inflate() to return immediately after header processing is
//    complete and before any actual data is decompressed.
//
//      The text, time, xflags, and os fields are filled in with the gzip header
//    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
//    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
//    contains the maximum number of bytes to write to extra.  Once done is true,
//    extra_len contains the actual extra field length, and extra contains the
//    extra field, or that field truncated if extra_max is less than extra_len.
//    If name is not Z_NULL, then up to name_max characters are written there,
//    terminated with a zero unless the length is greater than name_max.  If
//    comment is not Z_NULL, then up to comm_max characters are written there,
//    terminated with a zero unless the length is greater than comm_max.  When any
//    of extra, name, or comment are not Z_NULL and the respective field is not
//    present in the header, then that field is set to Z_NULL to signal its
//    absence.  This allows the use of deflateSetHeader() with the returned
//    structure to duplicate the header.  However if those fields are set to
//    allocated memory, then the application will need to save those pointers
//    elsewhere so that they can be eventually freed.
//
//      If inflateGetHeader is not used, then the header information is simply
//    discarded.  The header is always checked for validity, including the header
//    CRC if present.  inflateReset() will reset the process to discard the header
//    information.  The application would need to call inflateGetHeader() again to
//    retrieve the header from the next gzip stream.
//
//      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
//    stream state was inconsistent.

//
// ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
//                                         unsigned char FAR *window));
//
//      Initialize the internal stream state for decompression using inflateBack()
//    calls.  The fields zalloc, zfree and opaque in strm must be initialized
//    before the call.  If zalloc and zfree are Z_NULL, then the default library-
//    derived memory allocation routines are used.  windowBits is the base two
//    logarithm of the window size, in the range 8..15.  window is a caller
//    supplied buffer of that size.  Except for special applications where it is
//    assured that deflate was used with small window sizes, windowBits must be 15
//    and a 32K byte window must be supplied to be able to decompress general
//    deflate streams.
//
//      See inflateBack() for the usage of these routines.
//
//      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
//    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
//    allocated, or Z_VERSION_ERROR if the version of the library does not match
//    the version of the header file.

type In_func = uintptr  /* zlib.h:1092:18 */
type Out_func = uintptr /* zlib.h:1094:13 */
//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type GzFile_s = struct {
	Fhave uint32
	Fnext uintptr
	Fpos  Off64_t
} /* zlib.h:1300:9 */

//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type GzFile = uintptr /* zlib.h:1300:25 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type X__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:28:1 */

type X__locale_t = uintptr /* __locale_t.h:42:32 */

type Locale_t = X__locale_t /* locale_t.h:24:20 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get size_t, wchar_t and NULL from <stddef.h>.
// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

type Idtype_t = uint32 /* waitflags.h:57:3 */
// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this
//    glibc includes corresponding *f128 interfaces for it.  The required
//    libgcc support was added some time after the basic compiler
//    support, for x86_64 and x86.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.

// The remaining of this file provides support for older compilers.

// The type _Float128 exists only since GCC 7.0.

// __builtin_huge_valf128 doesn't exist before GCC 7.0.

// Older GCC has only a subset of built-in functions for _Float128 on
//    x86, and __builtin_infq is not usable in static initializers.
//    Converting a narrower sNaN to _Float128 produces a quiet NaN, so
//    attempts to use _Float128 sNaNs will not work properly with older
//    compilers.

// In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
//    e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
//    been a __builtin_signbitf128 in GCC and the type-generic builtin is
//    only available since GCC 6.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type Div_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type Ldiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type Lldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:80:5 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Random_data = struct {
	Ffptr      uintptr
	Frptr      uintptr
	Fstate     uintptr
	Frand_type int32
	Frand_deg  int32
	Frand_sep  int32
	Fend_ptr   uintptr
} /* stdlib.h:423:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type Drand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:490:1 */

// Shorthand for type of comparison functions.
type X__compar_fn_t = uintptr /* stdlib.h:805:13 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// since "static" is used to mean two completely different things in C, we
//    define "local" for the non-static meaning of "static", for readability
//    (compile with -Dlocal if your debugger can't find static symbols)

type Uch = uint8  /* zutil.h:43:24 */
type Uchf = Uch   /* zutil.h:44:17 */
type Ush = uint16 /* zutil.h:45:24 */
type Ushf = Ush   /* zutil.h:46:17 */
type Ulg = uint32 /* zutil.h:47:24 */

// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1

// use NO_DIVIDE if your processor does not do division in hardware --
//    try it both ways to see which is faster

// =========================================================================
func Xadler32_z(tls *libc.TLS, adler ULong, buf uintptr, len Z_size_t) ULong { /* adler32.c:63:15: */
	var sum2 uint32
	var n uint32

	// split Adler-32 into component sums
	sum2 = ((adler >> 16) & ULong(0xffff))
	adler = adler & (ULong(0xffff))

	// in case user likes doing a byte at a time, keep it fast
	if len == Z_size_t(1) {
		adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(buf))))
		if adler >= BASE {
			adler = adler - (BASE)
		}
		sum2 = sum2 + (adler)
		if sum2 >= BASE {
			sum2 = sum2 - (BASE)
		}
		return (adler | (sum2 << 16))
	}

	// initial Adler-32 value (deferred check for len == 1 speed)
	if buf == uintptr(Z_NULL) {
		return ULong(1)
	}

	// in case short lengths are provided, keep it somewhat fast
	if len < Z_size_t(16) {
		for libc.PostDecUint32(&len, 1) != 0 {
			adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))
			sum2 = sum2 + (adler)
		}
		if adler >= BASE {
			adler = adler - (BASE)
		}
		sum2 = sum2 % (BASE) // only added so many BASE's
		return (adler | (sum2 << 16))
	}

	// do length NMAX blocks -- requires just one modulo operation
	for len >= Z_size_t(NMAX) {
		len = len - (Z_size_t(NMAX))
		n = (uint32(NMAX / 16)) // NMAX is divisible by 16
		for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf)))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 1))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 2))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 3))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 4))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 5))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 6))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 7))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 8))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 9))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 10))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 11))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 12))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 13))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 14))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 15))))
				sum2 = sum2 + (adler)
			}

			// 16 sums unrolled
			buf += uintptr(16)
		}
		adler = adler % (BASE)
		sum2 = sum2 % (BASE)
	}

	// do remaining bytes (less than NMAX, still just one modulo)
	if len != 0 { // avoid modulos if none remaining
		for len >= Z_size_t(16) {
			len = len - (Z_size_t(16))
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf)))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 1))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 2))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 3))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 4))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 5))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 6))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 7))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 8))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 9))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 10))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 11))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 12))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 13))))
				sum2 = sum2 + (adler)
			}

			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 14))))
				sum2 = sum2 + (adler)
			}
			{
				adler = adler + (ULong(*(*Bytef)(unsafe.Pointer((buf) + 15))))
				sum2 = sum2 + (adler)
			}

			buf += uintptr(16)
		}
		for libc.PostDecUint32(&len, 1) != 0 {
			adler = adler + (ULong(*(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))
			sum2 = sum2 + (adler)
		}
		adler = adler % (BASE)
		sum2 = sum2 % (BASE)
	}

	// return recombined sums
	return (adler | (sum2 << 16))
}

// =========================================================================
func Xadler32(tls *libc.TLS, adler ULong, buf uintptr, len UInt) ULong { /* adler32.c:134:15: */
	return Xadler32_z(tls, adler, buf, len)
}

// =========================================================================
func adler32_combine_(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off64_t) ULong { /* adler32.c:143:13: */
	var sum1 uint32
	var sum2 uint32
	var rem uint32

	// for negative len, return invalid adler32 as a clue for debugging
	if len2 < int64(0) {
		return 0xffffffff
	}

	// the derivation of this formula is left as an exercise for the reader
	len2 = len2 % (int64(BASE)) // assumes len2 >= 0
	rem = uint32(len2)
	sum1 = (adler1 & ULong(0xffff))
	sum2 = (uint32(rem) * sum1)
	sum2 = sum2 % (BASE)
	sum1 = sum1 + (((adler2 & ULong(0xffff)) + BASE) - ULong(1))
	sum2 = sum2 + (((((adler1 >> 16) & ULong(0xffff)) + ((adler2 >> 16) & ULong(0xffff))) + BASE) - ULong(rem))
	if sum1 >= BASE {
		sum1 = sum1 - (BASE)
	}
	if sum1 >= BASE {
		sum1 = sum1 - (BASE)
	}
	if sum2 >= (uint32(BASE) << 1) {
		sum2 = sum2 - (uint32(BASE) << 1)
	}
	if sum2 >= BASE {
		sum2 = sum2 - (BASE)
	}
	return (sum1 | (sum2 << 16))
}

// =========================================================================
func Xadler32_combine(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off_t) ULong { /* adler32.c:172:15: */
	return adler32_combine_(tls, adler1, adler2, len2)
}

func Xadler32_combine64(tls *libc.TLS, adler1 ULong, adler2 ULong, len2 Off64_t) ULong { /* adler32.c:180:15: */
	return adler32_combine_(tls, adler1, adler2, len2)
}

// ===========================================================================
//      Compresses the source buffer into the destination buffer. The level
//    parameter has the same meaning as in deflateInit.  sourceLen is the byte
//    length of the source buffer. Upon entry, destLen is the total size of the
//    destination buffer, which must be at least 0.1% larger than sourceLen plus
//    12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
//
//      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
//    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
//    Z_STREAM_ERROR if the level parameter is invalid.
func Xcompress2(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong, level int32) int32 { /* compress.c:22:13: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var stream Z_stream at bp, 56

	var err int32
	var max UInt = libc.Uint32(libc.Uint32FromInt32(-1))
	var left ULong

	left = *(*ULongf)(unsafe.Pointer(destLen))
	*(*ULongf)(unsafe.Pointer(destLen)) = ULongf(0)

	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fzalloc = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fzfree = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fopaque = uintptr(0)

	err = XdeflateInit_(tls, bp /* &stream */, level, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
	if err != Z_OK {
		return err
	}

	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fnext_out = dest
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out = UInt(0)
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Fnext_in = source
	(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in = UInt(0)

	for ok := true; ok; ok = (err == Z_OK) {
		if (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out = func() uint32 {
				if left > ULong(max) {
					return max
				}
				return UInt(left)
			}()
			left = left - (ULong((*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_out))
		}
		if (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in = func() uint32 {
				if sourceLen > ULong(max) {
					return max
				}
				return UInt(sourceLen)
			}()
			sourceLen = sourceLen - (ULong((*Z_stream)(unsafe.Pointer(bp /* &stream */)).Favail_in))
		}
		err = Xdeflate(tls, bp /* &stream */, func() int32 {
			if sourceLen != 0 {
				return Z_NO_FLUSH
			}
			return Z_FINISH
		}())
	}

	*(*ULongf)(unsafe.Pointer(destLen)) = (*Z_stream)(unsafe.Pointer(bp /* &stream */)).Ftotal_out
	XdeflateEnd(tls, bp /* &stream */)
	if err == Z_STREAM_END {
		return Z_OK
	}
	return err
}

// ===========================================================================
func Xcompress(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong) int32 { /* compress.c:68:13: */
	return Xcompress2(tls, dest, destLen, source, sourceLen, -1)
}

// ===========================================================================
//      If the default memLevel or windowBits for deflateInit() is changed, then
//    this function needs to be updated.
//
func XcompressBound(tls *libc.TLS, sourceLen ULong) ULong { /* compress.c:81:15: */
	return ((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + ULong(13))
}

// ========================================================================
// Tables of CRC-32s of all single-byte values, made by make_crc_table().
// crc32.h -- tables for rapid CRC calculation
// Generated automatically by crc32.c

var crc_table = [8][256]Z_crc_t{
	{
		0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
		0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
		0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
		0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
		0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
		0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
		0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
		0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
		0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
		0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
		0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
		0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
		0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
		0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
		0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
		0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
		0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
		0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
		0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
		0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
		0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
		0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
		0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
		0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
		0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
		0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
		0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
		0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
		0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
		0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
		0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
		0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
		0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
		0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
		0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
		0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
		0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
		0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
		0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
		0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
		0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
		0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
		0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
		0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
		0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
		0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
		0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
		0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
		0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
		0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
		0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
		0x2d02ef8d,
	},
	{
		0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504,
		0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49,
		0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e,
		0x87981ccf, 0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192,
		0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859,
		0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c,
		0xd4413fdf, 0xcd5a0e9e, 0x958424a2, 0x8c9f15e3, 0xa7b24620,
		0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265,
		0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae,
		0x202a5aef, 0x0b07092c, 0x121c386d, 0xdf4636f3, 0xc65d07b2,
		0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175,
		0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38,
		0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c, 0xf0794f05,
		0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40,
		0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f,
		0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,
		0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850,
		0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d,
		0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da,
		0x3d23419b, 0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864,
		0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af,
		0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea,
		0xfb7e4629, 0xe2657768, 0x2f3f79f6, 0x362448b7, 0x1d091b74,
		0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31,
		0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa,
		0x9a9107bb, 0xb1bc5478, 0xa8a76539, 0x3b83984b, 0x2298a90a,
		0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd,
		0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180,
		0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484, 0x71418a1a,
		0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f,
		0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290,
		0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,
		0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed,
		0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0,
		0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167,
		0x299fa026, 0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b,
		0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0,
		0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5,
		0x7a468336, 0x635db277, 0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc,
		0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189,
		0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842,
		0x7e54a903, 0x5579fac0, 0x4c62cb81, 0x8138c51f, 0x9823f45e,
		0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299,
		0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4,
		0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0, 0x5e7ef3ec,
		0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9,
		0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66,
		0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,
		0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9,
		0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4,
		0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33,
		0x9324fd72,
	},
	{
		0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc,
		0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f,
		0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a,
		0x0b5c473d, 0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29,
		0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8,
		0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023,
		0x16b88e7a, 0x177ae44d, 0x384d46e0, 0x398f2cd7, 0x3bc9928e,
		0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065,
		0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84,
		0x3095d5b3, 0x32d36bea, 0x331101dd, 0x246be590, 0x25a98fa7,
		0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922,
		0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71,
		0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad, 0x709a8dc0,
		0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b,
		0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816,
		0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,
		0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c,
		0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f,
		0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba,
		0x67e0698d, 0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579,
		0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98,
		0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873,
		0x4249e62a, 0x438b8c1d, 0x54f16850, 0x55330267, 0x5775bc3e,
		0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5,
		0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134,
		0x5c29fb03, 0x5e6f455a, 0x5fad2f6d, 0xe1351b80, 0xe0f771b7,
		0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732,
		0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461,
		0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd, 0xfd13b8f0,
		0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b,
		0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26,
		0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,
		0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc,
		0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef,
		0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a,
		0xd2241a5d, 0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049,
		0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8,
		0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43,
		0xcfc0d31a, 0xce02b92d, 0x91af9640, 0x906dfc77, 0x922b422e,
		0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5,
		0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24,
		0x99770513, 0x9b31bb4a, 0x9af3d17d, 0x8d893530, 0x8c4b5f07,
		0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982,
		0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1,
		0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d, 0xa9e2d0a0,
		0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b,
		0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576,
		0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,
		0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c,
		0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f,
		0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda,
		0xbe9834ed,
	},
	{
		0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757,
		0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a,
		0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733,
		0x58631056, 0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871,
		0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70,
		0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42,
		0xb0c620ac, 0x087a47c9, 0xa032af3e, 0x188ec85b, 0x0a3b67b5,
		0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787,
		0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086,
		0x525877e3, 0x40edd80d, 0xf851bf68, 0xf02bf8a1, 0x48979fc4,
		0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d,
		0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0,
		0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7, 0x9b14583d,
		0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f,
		0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859,
		0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,
		0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5,
		0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028,
		0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891,
		0x936e1ff4, 0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed,
		0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec,
		0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde,
		0xdbf98030, 0x6345e755, 0x6b3fa09c, 0xd383c7f9, 0xc1366817,
		0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825,
		0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24,
		0x99557841, 0x8be0d7af, 0x335cb0ca, 0xed59b63b, 0x55e5d15e,
		0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7,
		0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a,
		0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d, 0xbd40e1a4,
		0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196,
		0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0,
		0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,
		0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52,
		0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f,
		0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36,
		0x15080953, 0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174,
		0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675,
		0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647,
		0xfdad39a9, 0x45115ecc, 0x764dee06, 0xcef18963, 0xdc44268d,
		0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf,
		0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be,
		0x842736db, 0x96929935, 0x2e2efe50, 0x2654b999, 0x9ee8defc,
		0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645,
		0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98,
		0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf, 0xd67f4138,
		0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a,
		0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c,
		0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,
		0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0,
		0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d,
		0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194,
		0xde0506f1,
	},
	{
		0x00000000, 0x96300777, 0x2c610eee, 0xba510999, 0x19c46d07,
		0x8ff46a70, 0x35a563e9, 0xa395649e, 0x3288db0e, 0xa4b8dc79,
		0x1ee9d5e0, 0x88d9d297, 0x2b4cb609, 0xbd7cb17e, 0x072db8e7,
		0x911dbf90, 0x6410b71d, 0xf220b06a, 0x4871b9f3, 0xde41be84,
		0x7dd4da1a, 0xebe4dd6d, 0x51b5d4f4, 0xc785d383, 0x56986c13,
		0xc0a86b64, 0x7af962fd, 0xecc9658a, 0x4f5c0114, 0xd96c0663,
		0x633d0ffa, 0xf50d088d, 0xc8206e3b, 0x5e10694c, 0xe44160d5,
		0x727167a2, 0xd1e4033c, 0x47d4044b, 0xfd850dd2, 0x6bb50aa5,
		0xfaa8b535, 0x6c98b242, 0xd6c9bbdb, 0x40f9bcac, 0xe36cd832,
		0x755cdf45, 0xcf0dd6dc, 0x593dd1ab, 0xac30d926, 0x3a00de51,
		0x8051d7c8, 0x1661d0bf, 0xb5f4b421, 0x23c4b356, 0x9995bacf,
		0x0fa5bdb8, 0x9eb80228, 0x0888055f, 0xb2d90cc6, 0x24e90bb1,
		0x877c6f2f, 0x114c6858, 0xab1d61c1, 0x3d2d66b6, 0x9041dc76,
		0x0671db01, 0xbc20d298, 0x2a10d5ef, 0x8985b171, 0x1fb5b606,
		0xa5e4bf9f, 0x33d4b8e8, 0xa2c90778, 0x34f9000f, 0x8ea80996,
		0x18980ee1, 0xbb0d6a7f, 0x2d3d6d08, 0x976c6491, 0x015c63e6,
		0xf4516b6b, 0x62616c1c, 0xd8306585, 0x4e0062f2, 0xed95066c,
		0x7ba5011b, 0xc1f40882, 0x57c40ff5, 0xc6d9b065, 0x50e9b712,
		0xeab8be8b, 0x7c88b9fc, 0xdf1ddd62, 0x492dda15, 0xf37cd38c,
		0x654cd4fb, 0x5861b24d, 0xce51b53a, 0x7400bca3, 0xe230bbd4,
		0x41a5df4a, 0xd795d83d, 0x6dc4d1a4, 0xfbf4d6d3, 0x6ae96943,
		0xfcd96e34, 0x468867ad, 0xd0b860da, 0x732d0444, 0xe51d0333,
		0x5f4c0aaa, 0xc97c0ddd, 0x3c710550, 0xaa410227, 0x10100bbe,
		0x86200cc9, 0x25b56857, 0xb3856f20, 0x09d466b9, 0x9fe461ce,
		0x0ef9de5e, 0x98c9d929, 0x2298d0b0, 0xb4a8d7c7, 0x173db359,
		0x810db42e, 0x3b5cbdb7, 0xad6cbac0, 0x2083b8ed, 0xb6b3bf9a,
		0x0ce2b603, 0x9ad2b174, 0x3947d5ea, 0xaf77d29d, 0x1526db04,
		0x8316dc73, 0x120b63e3, 0x843b6494, 0x3e6a6d0d, 0xa85a6a7a,
		0x0bcf0ee4, 0x9dff0993, 0x27ae000a, 0xb19e077d, 0x44930ff0,
		0xd2a30887, 0x68f2011e, 0xfec20669, 0x5d5762f7, 0xcb676580,
		0x71366c19, 0xe7066b6e, 0x761bd4fe, 0xe02bd389, 0x5a7ada10,
		0xcc4add67, 0x6fdfb9f9, 0xf9efbe8e, 0x43beb717, 0xd58eb060,
		0xe8a3d6d6, 0x7e93d1a1, 0xc4c2d838, 0x52f2df4f, 0xf167bbd1,
		0x6757bca6, 0xdd06b53f, 0x4b36b248, 0xda2b0dd8, 0x4c1b0aaf,
		0xf64a0336, 0x607a0441, 0xc3ef60df, 0x55df67a8, 0xef8e6e31,
		0x79be6946, 0x8cb361cb, 0x1a8366bc, 0xa0d26f25, 0x36e26852,
		0x95770ccc, 0x03470bbb, 0xb9160222, 0x2f260555, 0xbe3bbac5,
		0x280bbdb2, 0x925ab42b, 0x046ab35c, 0xa7ffd7c2, 0x31cfd0b5,
		0x8b9ed92c, 0x1daede5b, 0xb0c2649b, 0x26f263ec, 0x9ca36a75,
		0x0a936d02, 0xa906099c, 0x3f360eeb, 0x85670772, 0x13570005,
		0x824abf95, 0x147ab8e2, 0xae2bb17b, 0x381bb60c, 0x9b8ed292,
		0x0dbed5e5, 0xb7efdc7c, 0x21dfdb0b, 0xd4d2d386, 0x42e2d4f1,
		0xf8b3dd68, 0x6e83da1f, 0xcd16be81, 0x5b26b9f6, 0xe177b06f,
		0x7747b718, 0xe65a0888, 0x706a0fff, 0xca3b0666, 0x5c0b0111,
		0xff9e658f, 0x69ae62f8, 0xd3ff6b61, 0x45cf6c16, 0x78e20aa0,
		0xeed20dd7, 0x5483044e, 0xc2b30339, 0x612667a7, 0xf71660d0,
		0x4d476949, 0xdb776e3e, 0x4a6ad1ae, 0xdc5ad6d9, 0x660bdf40,
		0xf03bd837, 0x53aebca9, 0xc59ebbde, 0x7fcfb247, 0xe9ffb530,
		0x1cf2bdbd, 0x8ac2baca, 0x3093b353, 0xa6a3b424, 0x0536d0ba,
		0x9306d7cd, 0x2957de54, 0xbf67d923, 0x2e7a66b3, 0xb84a61c4,
		0x021b685d, 0x942b6f2a, 0x37be0bb4, 0xa18e0cc3, 0x1bdf055a,
		0x8def022d,
	},
	{
		0x00000000, 0x41311b19, 0x82623632, 0xc3532d2b, 0x04c56c64,
		0x45f4777d, 0x86a75a56, 0xc796414f, 0x088ad9c8, 0x49bbc2d1,
		0x8ae8effa, 0xcbd9f4e3, 0x0c4fb5ac, 0x4d7eaeb5, 0x8e2d839e,
		0xcf1c9887, 0x5112c24a, 0x1023d953, 0xd370f478, 0x9241ef61,
		0x55d7ae2e, 0x14e6b537, 0xd7b5981c, 0x96848305, 0x59981b82,
		0x18a9009b, 0xdbfa2db0, 0x9acb36a9, 0x5d5d77e6, 0x1c6c6cff,
		0xdf3f41d4, 0x9e0e5acd, 0xa2248495, 0xe3159f8c, 0x2046b2a7,
		0x6177a9be, 0xa6e1e8f1, 0xe7d0f3e8, 0x2483dec3, 0x65b2c5da,
		0xaaae5d5d, 0xeb9f4644, 0x28cc6b6f, 0x69fd7076, 0xae6b3139,
		0xef5a2a20, 0x2c09070b, 0x6d381c12, 0xf33646df, 0xb2075dc6,
		0x715470ed, 0x30656bf4, 0xf7f32abb, 0xb6c231a2, 0x75911c89,
		0x34a00790, 0xfbbc9f17, 0xba8d840e, 0x79dea925, 0x38efb23c,
		0xff79f373, 0xbe48e86a, 0x7d1bc541, 0x3c2ade58, 0x054f79f0,
		0x447e62e9, 0x872d4fc2, 0xc61c54db, 0x018a1594, 0x40bb0e8d,
		0x83e823a6, 0xc2d938bf, 0x0dc5a038, 0x4cf4bb21, 0x8fa7960a,
		0xce968d13, 0x0900cc5c, 0x4831d745, 0x8b62fa6e, 0xca53e177,
		0x545dbbba, 0x156ca0a3, 0xd63f8d88, 0x970e9691, 0x5098d7de,
		0x11a9ccc7, 0xd2fae1ec, 0x93cbfaf5, 0x5cd76272, 0x1de6796b,
		0xdeb55440, 0x9f844f59, 0x58120e16, 0x1923150f, 0xda703824,
		0x9b41233d, 0xa76bfd65, 0xe65ae67c, 0x2509cb57, 0x6438d04e,
		0xa3ae9101, 0xe29f8a18, 0x21cca733, 0x60fdbc2a, 0xafe124ad,
		0xeed03fb4, 0x2d83129f, 0x6cb20986, 0xab2448c9, 0xea1553d0,
		0x29467efb, 0x687765e2, 0xf6793f2f, 0xb7482436, 0x741b091d,
		0x352a1204, 0xf2bc534b, 0xb38d4852, 0x70de6579, 0x31ef7e60,
		0xfef3e6e7, 0xbfc2fdfe, 0x7c91d0d5, 0x3da0cbcc, 0xfa368a83,
		0xbb07919a, 0x7854bcb1, 0x3965a7a8, 0x4b98833b, 0x0aa99822,
		0xc9fab509, 0x88cbae10, 0x4f5def5f, 0x0e6cf446, 0xcd3fd96d,
		0x8c0ec274, 0x43125af3, 0x022341ea, 0xc1706cc1, 0x804177d8,
		0x47d73697, 0x06e62d8e, 0xc5b500a5, 0x84841bbc, 0x1a8a4171,
		0x5bbb5a68, 0x98e87743, 0xd9d96c5a, 0x1e4f2d15, 0x5f7e360c,
		0x9c2d1b27, 0xdd1c003e, 0x120098b9, 0x533183a0, 0x9062ae8b,
		0xd153b592, 0x16c5f4dd, 0x57f4efc4, 0x94a7c2ef, 0xd596d9f6,
		0xe9bc07ae, 0xa88d1cb7, 0x6bde319c, 0x2aef2a85, 0xed796bca,
		0xac4870d3, 0x6f1b5df8, 0x2e2a46e1, 0xe136de66, 0xa007c57f,
		0x6354e854, 0x2265f34d, 0xe5f3b202, 0xa4c2a91b, 0x67918430,
		0x26a09f29, 0xb8aec5e4, 0xf99fdefd, 0x3accf3d6, 0x7bfde8cf,
		0xbc6ba980, 0xfd5ab299, 0x3e099fb2, 0x7f3884ab, 0xb0241c2c,
		0xf1150735, 0x32462a1e, 0x73773107, 0xb4e17048, 0xf5d06b51,
		0x3683467a, 0x77b25d63, 0x4ed7facb, 0x0fe6e1d2, 0xccb5ccf9,
		0x8d84d7e0, 0x4a1296af, 0x0b238db6, 0xc870a09d, 0x8941bb84,
		0x465d2303, 0x076c381a, 0xc43f1531, 0x850e0e28, 0x42984f67,
		0x03a9547e, 0xc0fa7955, 0x81cb624c, 0x1fc53881, 0x5ef42398,
		0x9da70eb3, 0xdc9615aa, 0x1b0054e5, 0x5a314ffc, 0x996262d7,
		0xd85379ce, 0x174fe149, 0x567efa50, 0x952dd77b, 0xd41ccc62,
		0x138a8d2d, 0x52bb9634, 0x91e8bb1f, 0xd0d9a006, 0xecf37e5e,
		0xadc26547, 0x6e91486c, 0x2fa05375, 0xe836123a, 0xa9070923,
		0x6a542408, 0x2b653f11, 0xe479a796, 0xa548bc8f, 0x661b91a4,
		0x272a8abd, 0xe0bccbf2, 0xa18dd0eb, 0x62defdc0, 0x23efe6d9,
		0xbde1bc14, 0xfcd0a70d, 0x3f838a26, 0x7eb2913f, 0xb924d070,
		0xf815cb69, 0x3b46e642, 0x7a77fd5b, 0xb56b65dc, 0xf45a7ec5,
		0x370953ee, 0x763848f7, 0xb1ae09b8, 0xf09f12a1, 0x33cc3f8a,
		0x72fd2493,
	},
	{
		0x00000000, 0x376ac201, 0x6ed48403, 0x59be4602, 0xdca80907,
		0xebc2cb06, 0xb27c8d04, 0x85164f05, 0xb851130e, 0x8f3bd10f,
		0xd685970d, 0xe1ef550c, 0x64f91a09, 0x5393d808, 0x0a2d9e0a,
		0x3d475c0b, 0x70a3261c, 0x47c9e41d, 0x1e77a21f, 0x291d601e,
		0xac0b2f1b, 0x9b61ed1a, 0xc2dfab18, 0xf5b56919, 0xc8f23512,
		0xff98f713, 0xa626b111, 0x914c7310, 0x145a3c15, 0x2330fe14,
		0x7a8eb816, 0x4de47a17, 0xe0464d38, 0xd72c8f39, 0x8e92c93b,
		0xb9f80b3a, 0x3cee443f, 0x0b84863e, 0x523ac03c, 0x6550023d,
		0x58175e36, 0x6f7d9c37, 0x36c3da35, 0x01a91834, 0x84bf5731,
		0xb3d59530, 0xea6bd332, 0xdd011133, 0x90e56b24, 0xa78fa925,
		0xfe31ef27, 0xc95b2d26, 0x4c4d6223, 0x7b27a022, 0x2299e620,
		0x15f32421, 0x28b4782a, 0x1fdeba2b, 0x4660fc29, 0x710a3e28,
		0xf41c712d, 0xc376b32c, 0x9ac8f52e, 0xada2372f, 0xc08d9a70,
		0xf7e75871, 0xae591e73, 0x9933dc72, 0x1c259377, 0x2b4f5176,
		0x72f11774, 0x459bd575, 0x78dc897e, 0x4fb64b7f, 0x16080d7d,
		0x2162cf7c, 0xa4748079, 0x931e4278, 0xcaa0047a, 0xfdcac67b,
		0xb02ebc6c, 0x87447e6d, 0xdefa386f, 0xe990fa6e, 0x6c86b56b,
		0x5bec776a, 0x02523168, 0x3538f369, 0x087faf62, 0x3f156d63,
		0x66ab2b61, 0x51c1e960, 0xd4d7a665, 0xe3bd6464, 0xba032266,
		0x8d69e067, 0x20cbd748, 0x17a11549, 0x4e1f534b, 0x7975914a,
		0xfc63de4f, 0xcb091c4e, 0x92b75a4c, 0xa5dd984d, 0x989ac446,
		0xaff00647, 0xf64e4045, 0xc1248244, 0x4432cd41, 0x73580f40,
		0x2ae64942, 0x1d8c8b43, 0x5068f154, 0x67023355, 0x3ebc7557,
		0x09d6b756, 0x8cc0f853, 0xbbaa3a52, 0xe2147c50, 0xd57ebe51,
		0xe839e25a, 0xdf53205b, 0x86ed6659, 0xb187a458, 0x3491eb5d,
		0x03fb295c, 0x5a456f5e, 0x6d2fad5f, 0x801b35e1, 0xb771f7e0,
		0xeecfb1e2, 0xd9a573e3, 0x5cb33ce6, 0x6bd9fee7, 0x3267b8e5,
		0x050d7ae4, 0x384a26ef, 0x0f20e4ee, 0x569ea2ec, 0x61f460ed,
		0xe4e22fe8, 0xd388ede9, 0x8a36abeb, 0xbd5c69ea, 0xf0b813fd,
		0xc7d2d1fc, 0x9e6c97fe, 0xa90655ff, 0x2c101afa, 0x1b7ad8fb,
		0x42c49ef9, 0x75ae5cf8, 0x48e900f3, 0x7f83c2f2, 0x263d84f0,
		0x115746f1, 0x944109f4, 0xa32bcbf5, 0xfa958df7, 0xcdff4ff6,
		0x605d78d9, 0x5737bad8, 0x0e89fcda, 0x39e33edb, 0xbcf571de,
		0x8b9fb3df, 0xd221f5dd, 0xe54b37dc, 0xd80c6bd7, 0xef66a9d6,
		0xb6d8efd4, 0x81b22dd5, 0x04a462d0, 0x33cea0d1, 0x6a70e6d3,
		0x5d1a24d2, 0x10fe5ec5, 0x27949cc4, 0x7e2adac6, 0x494018c7,
		0xcc5657c2, 0xfb3c95c3, 0xa282d3c1, 0x95e811c0, 0xa8af4dcb,
		0x9fc58fca, 0xc67bc9c8, 0xf1110bc9, 0x740744cc, 0x436d86cd,
		0x1ad3c0cf, 0x2db902ce, 0x4096af91, 0x77fc6d90, 0x2e422b92,
		0x1928e993, 0x9c3ea696, 0xab546497, 0xf2ea2295, 0xc580e094,
		0xf8c7bc9f, 0xcfad7e9e, 0x9613389c, 0xa179fa9d, 0x246fb598,
		0x13057799, 0x4abb319b, 0x7dd1f39a, 0x3035898d, 0x075f4b8c,
		0x5ee10d8e, 0x698bcf8f, 0xec9d808a, 0xdbf7428b, 0x82490489,
		0xb523c688, 0x88649a83, 0xbf0e5882, 0xe6b01e80, 0xd1dadc81,
		0x54cc9384, 0x63a65185, 0x3a181787, 0x0d72d586, 0xa0d0e2a9,
		0x97ba20a8, 0xce0466aa, 0xf96ea4ab, 0x7c78ebae, 0x4b1229af,
		0x12ac6fad, 0x25c6adac, 0x1881f1a7, 0x2feb33a6, 0x765575a4,
		0x413fb7a5, 0xc429f8a0, 0xf3433aa1, 0xaafd7ca3, 0x9d97bea2,
		0xd073c4b5, 0xe71906b4, 0xbea740b6, 0x89cd82b7, 0x0cdbcdb2,
		0x3bb10fb3, 0x620f49b1, 0x55658bb0, 0x6822d7bb, 0x5f4815ba,
		0x06f653b8, 0x319c91b9, 0xb48adebc, 0x83e01cbd, 0xda5e5abf,
		0xed3498be,
	},
	{
		0x00000000, 0x6567bcb8, 0x8bc809aa, 0xeeafb512, 0x5797628f,
		0x32f0de37, 0xdc5f6b25, 0xb938d79d, 0xef28b4c5, 0x8a4f087d,
		0x64e0bd6f, 0x018701d7, 0xb8bfd64a, 0xddd86af2, 0x3377dfe0,
		0x56106358, 0x9f571950, 0xfa30a5e8, 0x149f10fa, 0x71f8ac42,
		0xc8c07bdf, 0xada7c767, 0x43087275, 0x266fcecd, 0x707fad95,
		0x1518112d, 0xfbb7a43f, 0x9ed01887, 0x27e8cf1a, 0x428f73a2,
		0xac20c6b0, 0xc9477a08, 0x3eaf32a0, 0x5bc88e18, 0xb5673b0a,
		0xd00087b2, 0x6938502f, 0x0c5fec97, 0xe2f05985, 0x8797e53d,
		0xd1878665, 0xb4e03add, 0x5a4f8fcf, 0x3f283377, 0x8610e4ea,
		0xe3775852, 0x0dd8ed40, 0x68bf51f8, 0xa1f82bf0, 0xc49f9748,
		0x2a30225a, 0x4f579ee2, 0xf66f497f, 0x9308f5c7, 0x7da740d5,
		0x18c0fc6d, 0x4ed09f35, 0x2bb7238d, 0xc518969f, 0xa07f2a27,
		0x1947fdba, 0x7c204102, 0x928ff410, 0xf7e848a8, 0x3d58149b,
		0x583fa823, 0xb6901d31, 0xd3f7a189, 0x6acf7614, 0x0fa8caac,
		0xe1077fbe, 0x8460c306, 0xd270a05e, 0xb7171ce6, 0x59b8a9f4,
		0x3cdf154c, 0x85e7c2d1, 0xe0807e69, 0x0e2fcb7b, 0x6b4877c3,
		0xa20f0dcb, 0xc768b173, 0x29c70461, 0x4ca0b8d9, 0xf5986f44,
		0x90ffd3fc, 0x7e5066ee, 0x1b37da56, 0x4d27b90e, 0x284005b6,
		0xc6efb0a4, 0xa3880c1c, 0x1ab0db81, 0x7fd76739, 0x9178d22b,
		0xf41f6e93, 0x03f7263b, 0x66909a83, 0x883f2f91, 0xed589329,
		0x546044b4, 0x3107f80c, 0xdfa84d1e, 0xbacff1a6, 0xecdf92fe,
		0x89b82e46, 0x67179b54, 0x027027ec, 0xbb48f071, 0xde2f4cc9,
		0x3080f9db, 0x55e74563, 0x9ca03f6b, 0xf9c783d3, 0x176836c1,
		0x720f8a79, 0xcb375de4, 0xae50e15c, 0x40ff544e, 0x2598e8f6,
		0x73888bae, 0x16ef3716, 0xf8408204, 0x9d273ebc, 0x241fe921,
		0x41785599, 0xafd7e08b, 0xcab05c33, 0x3bb659ed, 0x5ed1e555,
		0xb07e5047, 0xd519ecff, 0x6c213b62, 0x094687da, 0xe7e932c8,
		0x828e8e70, 0xd49eed28, 0xb1f95190, 0x5f56e482, 0x3a31583a,
		0x83098fa7, 0xe66e331f, 0x08c1860d, 0x6da63ab5, 0xa4e140bd,
		0xc186fc05, 0x2f294917, 0x4a4ef5af, 0xf3762232, 0x96119e8a,
		0x78be2b98, 0x1dd99720, 0x4bc9f478, 0x2eae48c0, 0xc001fdd2,
		0xa566416a, 0x1c5e96f7, 0x79392a4f, 0x97969f5d, 0xf2f123e5,
		0x05196b4d, 0x607ed7f5, 0x8ed162e7, 0xebb6de5f, 0x528e09c2,
		0x37e9b57a, 0xd9460068, 0xbc21bcd0, 0xea31df88, 0x8f566330,
		0x61f9d622, 0x049e6a9a, 0xbda6bd07, 0xd8c101bf, 0x366eb4ad,
		0x53090815, 0x9a4e721d, 0xff29cea5, 0x11867bb7, 0x74e1c70f,
		0xcdd91092, 0xa8beac2a, 0x46111938, 0x2376a580, 0x7566c6d8,
		0x10017a60, 0xfeaecf72, 0x9bc973ca, 0x22f1a457, 0x479618ef,
		0xa939adfd, 0xcc5e1145, 0x06ee4d76, 0x6389f1ce, 0x8d2644dc,
		0xe841f864, 0x51792ff9, 0x341e9341, 0xdab12653, 0xbfd69aeb,
		0xe9c6f9b3, 0x8ca1450b, 0x620ef019, 0x07694ca1, 0xbe519b3c,
		0xdb362784, 0x35999296, 0x50fe2e2e, 0x99b95426, 0xfcdee89e,
		0x12715d8c, 0x7716e134, 0xce2e36a9, 0xab498a11, 0x45e63f03,
		0x208183bb, 0x7691e0e3, 0x13f65c5b, 0xfd59e949, 0x983e55f1,
		0x2106826c, 0x44613ed4, 0xaace8bc6, 0xcfa9377e, 0x38417fd6,
		0x5d26c36e, 0xb389767c, 0xd6eecac4, 0x6fd61d59, 0x0ab1a1e1,
		0xe41e14f3, 0x8179a84b, 0xd769cb13, 0xb20e77ab, 0x5ca1c2b9,
		0x39c67e01, 0x80fea99c, 0xe5991524, 0x0b36a036, 0x6e511c8e,
		0xa7166686, 0xc271da3e, 0x2cde6f2c, 0x49b9d394, 0xf0810409,
		0x95e6b8b1, 0x7b490da3, 0x1e2eb11b, 0x483ed243, 0x2d596efb,
		0xc3f6dbe9, 0xa6916751, 0x1fa9b0cc, 0x7ace0c74, 0x9461b966,
		0xf10605de,
	},
} /* crc32.h:5:25 */

// =========================================================================
// This function can be used by asm versions of crc32()
func Xget_crc_table(tls *libc.TLS) uintptr { /* crc32.c:188:19: */
	return uintptr(uintptr(unsafe.Pointer(&crc_table)))
}

// =========================================================================

// =========================================================================
func Xcrc32_z(tls *libc.TLS, crc uint32, buf uintptr, len Z_size_t) uint32 { /* crc32.c:202:23: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if buf == uintptr(Z_NULL) {
		return 0
	}

	if uint32(unsafe.Sizeof(uintptr(0))) == uint32(unsafe.Sizeof(Ptrdiff_t(0))) {
		// var endian Z_crc_t at bp, 4

		*(*Z_crc_t)(unsafe.Pointer(bp /* endian */)) = Z_crc_t(1)
		if *(*uint8)(unsafe.Pointer(bp /* &endian */)) != 0 {
			return crc32_little(tls, crc, buf, len)
		} else {
			return crc32_big(tls, crc, buf, len)
		}
	}
	crc = (crc ^ 0xffffffff)
	for len >= Z_size_t(8) {
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		len = len - (Z_size_t(8))
	}
	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint32(&len, 1) != 0 {
			crc = (uint32(*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((int32(crc)^(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))&0xff))*4))) ^ (crc >> 8))
		}
	}
	return (crc ^ 0xffffffff)
}

// =========================================================================
func Xcrc32(tls *libc.TLS, crc uint32, buf uintptr, len UInt) uint32 { /* crc32.c:237:23: */
	return Xcrc32_z(tls, crc, buf, len)
}

//
//    This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
//    integer pointer type. This violates the strict aliasing rule, where a
//    compiler can assume, for optimization purposes, that two pointers to
//    fundamentally different types won't ever point to the same memory. This can
//    manifest as a problem only if one of the pointers is written to. This code
//    only reads from those pointers. So long as this code remains isolated in
//    this compilation unit, there won't be a problem. For this reason, this code
//    should not be copied and pasted into a compilation unit in which other code
//    writes to the buffer that is passed to these routines.
//

// =========================================================================

// =========================================================================
func crc32_little(tls *libc.TLS, crc uint32, buf uintptr, len Z_size_t) uint32 { /* crc32.c:266:21: */
	var c Z_crc_t
	var buf4 uintptr

	c = Z_crc_t(crc)
	c = ^c
	for (len != 0) && ((Ptrdiff_t(buf) & 3) != 0) {
		c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((c^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))&Z_crc_t(0xff)))*4)) ^ (c >> 8))
		len--
	}

	buf4 = buf
	for len >= Z_size_t(32) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		len = len - (Z_size_t(32))
	}
	for len >= Z_size_t(4) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 3*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 2*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 1*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr((c>>24))*4)))
		len = len - (Z_size_t(4))
	}
	buf = buf4

	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint32(&len, 1) != 0 {
			c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table))) + uintptr(((c^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1)))))&Z_crc_t(0xff)))*4)) ^ (c >> 8))
		}
	}
	c = ^c
	return uint32(c)
}

// =========================================================================

// =========================================================================
func crc32_big(tls *libc.TLS, crc uint32, buf uintptr, len Z_size_t) uint32 { /* crc32.c:306:21: */
	var c Z_crc_t
	var buf4 uintptr

	c = ((((((Z_crc_t(crc)) >> 24) & Z_crc_t(0xff)) + (((Z_crc_t(crc)) >> 8) & Z_crc_t(0xff00))) + (((Z_crc_t(crc)) & Z_crc_t(0xff00)) << 8)) + (((Z_crc_t(crc)) & Z_crc_t(0xff)) << 24))
	c = ^c
	for (len != 0) && ((Ptrdiff_t(buf) & 3) != 0) {
		c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr(((c>>24)^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))*4)) ^ (c << 8))
		len--
	}

	buf4 = buf
	for len >= Z_size_t(32) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		len = len - (Z_size_t(32))
	}
	for len >= Z_size_t(4) {
		c = c ^ (*(*Z_crc_t)(unsafe.Pointer(libc.PostIncUintptr(&buf4, 4))))
		c = (((*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr((c&Z_crc_t(0xff)))*4)) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 5*1024) + uintptr(((c>>8)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 6*1024) + uintptr(((c>>16)&Z_crc_t(0xff)))*4))) ^ *(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 7*1024) + uintptr((c>>24))*4)))
		len = len - (Z_size_t(4))
	}
	buf = buf4

	if len != 0 {
		for ok := true; ok; ok = libc.PreDecUint32(&len, 1) != 0 {
			c = (*(*Z_crc_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&crc_table)) + 4*1024) + uintptr(((c>>24)^Z_crc_t(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&buf, 1))))))*4)) ^ (c << 8))
		}
	}
	c = ^c
	return (uint32((((((c) >> 24) & Z_crc_t(0xff)) + (((c) >> 8) & Z_crc_t(0xff00))) + (((c) & Z_crc_t(0xff00)) << 8)) + (((c) & Z_crc_t(0xff)) << 24)))
}

// =========================================================================
func gf2_matrix_times(tls *libc.TLS, mat uintptr, vec uint32) uint32 { /* crc32.c:344:21: */
	var sum uint32

	sum = uint32(0)
	for vec != 0 {
		if (vec & uint32(1)) != 0 {
			sum = sum ^ (*(*uint32)(unsafe.Pointer(mat)))
		}
		vec >>= 1
		mat += 4
	}
	return sum
}

// =========================================================================
func gf2_matrix_square(tls *libc.TLS, square uintptr, mat uintptr) { /* crc32.c:361:12: */
	var n int32

	for n = 0; n < GF2_DIM; n++ {
		*(*uint32)(unsafe.Pointer(square + uintptr(n)*4)) = gf2_matrix_times(tls, mat, *(*uint32)(unsafe.Pointer(mat + uintptr(n)*4)))
	}
}

// =========================================================================
func crc32_combine_(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off64_t) ULong { /* crc32.c:372:13: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var n int32
	var row uint32
	// var even [32]uint32 at bp+128, 128
	// even-power-of-two zeros operator
	// var odd [32]uint32 at bp, 128
	// odd-power-of-two zeros operator

	// degenerate case (also disallow negative lengths)
	if len2 <= int64(0) {
		return crc1
	}

	// put operator for one zero bit in odd
	*(*uint32)(unsafe.Pointer(bp /* &odd[0] */)) = 0xedb88320 // CRC-32 polynomial
	row = uint32(1)
	for n = 1; n < GF2_DIM; n++ {
		*(*uint32)(unsafe.Pointer(bp /* &odd[0] */ + uintptr(n)*4)) = row
		row <<= 1
	}

	// put operator for two zero bits in even
	gf2_matrix_square(tls, bp+128 /* &even[0] */, bp /* &odd[0] */)

	// put operator for four zero bits in odd
	gf2_matrix_square(tls, bp /* &odd[0] */, bp+128 /* &even[0] */)

	// apply len2 zeros to crc1 (first square will put the operator for one
	//        zero byte, eight zero bits, in even)
	for ok := true; ok; ok = (len2 != int64(0)) {
		// apply zeros operator for this bit of len2
		gf2_matrix_square(tls, bp+128 /* &even[0] */, bp /* &odd[0] */)
		if (len2 & int64(1)) != 0 {
			crc1 = gf2_matrix_times(tls, bp+128 /* &even[0] */, crc1)
		}
		len2 >>= 1

		// if no more bits set, then done
		if len2 == int64(0) {
			break
		}

		// another iteration of the loop with odd and even swapped
		gf2_matrix_square(tls, bp /* &odd[0] */, bp+128 /* &even[0] */)
		if (len2 & int64(1)) != 0 {
			crc1 = gf2_matrix_times(tls, bp /* &odd[0] */, crc1)
		}
		len2 >>= 1

		// if no more bits set, then done
	}

	// return combined crc
	crc1 = crc1 ^ (crc2)
	return crc1
}

// =========================================================================
func Xcrc32_combine(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off_t) ULong { /* crc32.c:428:15: */
	return crc32_combine_(tls, crc1, crc2, len2)
}

func Xcrc32_combine64(tls *libc.TLS, crc1 ULong, crc2 ULong, len2 Off64_t) ULong { /* crc32.c:436:15: */
	return crc32_combine_(tls, crc1, crc2, len2)
}

// Reverse the bytes in a 32-bit value

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip encoding
//    should be left enabled.

// ===========================================================================
// Internal compression state.

// number of length codes, not counting the special END_BLOCK code

// number of literal bytes 0..255

// number of Literal or Length codes, including the END_BLOCK code

// number of distance codes

// number of codes used to transfer the bit lengths

// maximum heap size

// All codes must not exceed MAX_BITS bits

// size of bit buffer in bi_buf

// Stream status

// Data structure describing a single value and its code string.
type Ct_data_s = struct {
	Ffc struct{ Ffreq Ush }
	Fdl struct{ Fdad Ush }
} /* zlib.h:84:1 */

// Reverse the bytes in a 32-bit value

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip encoding
//    should be left enabled.

// ===========================================================================
// Internal compression state.

// number of length codes, not counting the special END_BLOCK code

// number of literal bytes 0..255

// number of Literal or Length codes, including the END_BLOCK code

// number of distance codes

// number of codes used to transfer the bit lengths

// maximum heap size

// All codes must not exceed MAX_BITS bits

// size of bit buffer in bi_buf

// Stream status

// Data structure describing a single value and its code string.
type Ct_data = Ct_data_s /* deflate.h:77:7 */

type Static_tree_desc_s = struct {
	Fstatic_tree uintptr
	Fextra_bits  uintptr
	Fextra_base  int32
	Felems       int32
	Fmax_length  int32
} /* deflate.h:84:9 */

type Tree_desc_s = struct {
	Fdyn_tree  uintptr
	Fmax_code  int32
	Fstat_desc uintptr
} /* zlib.h:84:1 */

type Tree_desc = Tree_desc_s /* deflate.h:90:7 */

type Pos = Ush     /* deflate.h:92:13 */
type Posf = Pos    /* deflate.h:93:17 */
type IPos = uint32 /* deflate.h:94:18 */

// A Pos is an index in the character window. We use short instead of int to
// save space in the various tables. IPos is used only for parameter passing.

type Deflate_state = Internal_state /* deflate.h:276:7 */

var Xdeflate_copyright = *(*[69]int8)(unsafe.Pointer(ts + 7 /* " deflate 1.2.11 ..." */)) /* deflate.c:54:12 */
//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

// ===========================================================================
//  Function prototypes.
type Block_state = uint32 /* deflate.c:71:3 */

type Compress_func = uintptr /* deflate.c:73:21 */

// ===========================================================================
// Local data

// Tail of hash chains

// Matches of length 3 are discarded if their distance exceeds TOO_FAR

// Values for max_lazy_match, good_match and max_chain_length, depending on
// the desired pack level (0..9). The values given below have been tuned to
// exclude worst case performance for pathological files. Better values may be
// found for specific files.
type Config_s = struct {
	Fgood_length Ush
	Fmax_lazy    Ush
	Fnice_length Ush
	Fmax_chain   Ush
	Ffunc        Compress_func
} /* deflate.c:120:9 */

// ===========================================================================
// Local data

// Tail of hash chains

// Matches of length 3 are discarded if their distance exceeds TOO_FAR

// Values for max_lazy_match, good_match and max_chain_length, depending on
// the desired pack level (0..9). The values given below have been tuned to
// exclude worst case performance for pathological files. Better values may be
// found for specific files.
type Config = Config_s /* deflate.c:126:3 */

var configuration_table = [10]Config{
	//      good lazy nice chain
	/* 0 */ {Ffunc: 0}, // store only
	/* 1 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(4), Fnice_length: Ush(8), Fmax_chain: Ush(4), Ffunc: 0}, // max speed, no lazy matches
	/* 2 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(5), Fnice_length: Ush(16), Fmax_chain: Ush(8), Ffunc: 0},
	/* 3 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(6), Fnice_length: Ush(32), Fmax_chain: Ush(32), Ffunc: 0},

	/* 4 */ {Fgood_length: Ush(4), Fmax_lazy: Ush(4), Fnice_length: Ush(16), Fmax_chain: Ush(16), Ffunc: 0}, // lazy matches
	/* 5 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(16), Fnice_length: Ush(32), Fmax_chain: Ush(32), Ffunc: 0},
	/* 6 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(16), Fnice_length: Ush(128), Fmax_chain: Ush(128), Ffunc: 0},
	/* 7 */ {Fgood_length: Ush(8), Fmax_lazy: Ush(32), Fnice_length: Ush(128), Fmax_chain: Ush(256), Ffunc: 0},
	/* 8 */ {Fgood_length: Ush(32), Fmax_lazy: Ush(128), Fnice_length: Ush(258), Fmax_chain: Ush(1024), Ffunc: 0},
	/* 9 */ {Fgood_length: Ush(32), Fmax_lazy: Ush(258), Fnice_length: Ush(258), Fmax_chain: Ush(4096), Ffunc: 0}} /* deflate.c:134:20 */

// max compression

// Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
// For deflate_fast() (levels <= 3) good is ignored and lazy has a different
// meaning.

// rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH

// ===========================================================================
// Update a hash value with the given input byte
// IN  assertion: all calls to UPDATE_HASH are made with consecutive input
//    characters, so that a running hash key can be computed from the previous
//    key instead of complete recalculation each time.

// ===========================================================================
// Insert string str in the dictionary and set match_head to the previous head
// of the hash chain (the most recent string with same hash key). Return
// the previous length of the hash chain.
// If this file is compiled with -DFASTEST, the compression level is forced
// to 1, and no hash chains are maintained.
// IN  assertion: all calls to INSERT_STRING are made with consecutive input
//    characters and the first MIN_MATCH bytes of str are valid (except for
//    the last MIN_MATCH-1 bytes of the input file).

// ===========================================================================
// Initialize the hash table (avoiding 64K overflow for 16 bit systems).
// prev[] will be initialized on the fly.

// ===========================================================================
// Slide the hash table when sliding the window down (could be avoided with 32
// bit values at the expense of memory usage). We slide even when level == 0 to
// keep the hash table consistent if we switch back to level > 0 later.
func slide_hash(tls *libc.TLS, s uintptr) { /* deflate.c:201:12: */
	var n uint32
	var m uint32
	var p uintptr
	var wsize UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_size

	n = (*Deflate_state)(unsafe.Pointer(s)).Fhash_size
	p = ((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(n)*2)
	for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
		m = uint32(*(*Posf)(unsafe.Pointer(libc.PreDecUintptr(&p, 2))))
		*(*Posf)(unsafe.Pointer(p)) = func() uint16 {
			if m >= wsize {
				return (uint16(m - wsize))
			}
			return uint16(NIL)
		}()
	}
	n = wsize
	p = ((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr(n)*2)
	for ok1 := true; ok1; ok1 = libc.PreDecUint32(&n, 1) != 0 {
		m = uint32(*(*Posf)(unsafe.Pointer(libc.PreDecUintptr(&p, 2))))
		*(*Posf)(unsafe.Pointer(p)) = func() uint16 {
			if m >= wsize {
				return (uint16(m - wsize))
			}
			return uint16(NIL)
		}()
		// If n is not on any hash chain, prev[n] is garbage but
		// its value will never be used.
	}
}

// =========================================================================
func XdeflateInit_(tls *libc.TLS, strm Z_streamp, level int32, version uintptr, stream_size int32) int32 { /* deflate.c:228:13: */
	return XdeflateInit2_(tls, strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
		Z_DEFAULT_STRATEGY, version, stream_size)
	// To do: ignore strm->next_in if we use it as window
}

// =========================================================================
func XdeflateInit2_(tls *libc.TLS, strm Z_streamp, level int32, method int32, windowBits int32, memLevel int32, strategy int32, version uintptr, stream_size int32) int32 { /* deflate.c:240:13: */
	var s uintptr
	var wrap int32 = 1
	var overlay uintptr
	// We overlay pending_buf and d_buf+l_buf. This works since the average
	// output size for (length,distance) codes is <= 24 bits.

	if ((version == uintptr(Z_NULL)) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(my_version[0]))) || (uint32(stream_size) != uint32(unsafe.Sizeof(Z_stream{}))) {
		return -6
	}
	if strm == uintptr(Z_NULL) {
		return -2
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL)
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}

	if level == (-1) {
		level = 6
	}

	if windowBits < 0 { // suppress zlib wrapper
		wrap = 0
		windowBits = -windowBits
	} else if windowBits > 15 {
		wrap = 2 // write gzip wrapper instead
		windowBits = windowBits - (16)
	}
	if (((((((((memLevel < 1) || (memLevel > MAX_MEM_LEVEL)) || (method != Z_DEFLATED)) || (windowBits < 8)) || (windowBits > 15)) || (level < 0)) || (level > 9)) || (strategy < 0)) || (strategy > Z_FIXED)) || ((windowBits == 8) && (wrap != 1)) {
		return -2
	}
	if windowBits == 8 {
		windowBits = 9
	} // until 256-byte window bug fixed
	s = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Deflate_state{})))
	if s == uintptr(Z_NULL) {
		return -4
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = s
	(*Deflate_state)(unsafe.Pointer(s)).Fstrm = strm
	(*Deflate_state)(unsafe.Pointer(s)).Fstatus = INIT_STATE // to pass state test in deflateReset()

	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = wrap
	(*Deflate_state)(unsafe.Pointer(s)).Fgzhead = Gz_headerp(Z_NULL)
	(*Deflate_state)(unsafe.Pointer(s)).Fw_bits = UInt(windowBits)
	(*Deflate_state)(unsafe.Pointer(s)).Fw_size = (UInt(int32(1) << (*Deflate_state)(unsafe.Pointer(s)).Fw_bits))
	(*Deflate_state)(unsafe.Pointer(s)).Fw_mask = ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - UInt(1))

	(*Deflate_state)(unsafe.Pointer(s)).Fhash_bits = (UInt(memLevel) + UInt(7))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_size = (UInt(int32(1) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_bits))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_mask = ((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1))
	(*Deflate_state)(unsafe.Pointer(s)).Fhash_shift = ((((*Deflate_state)(unsafe.Pointer(s)).Fhash_bits + UInt(MIN_MATCH)) - UInt(1)) / UInt(MIN_MATCH))

	(*Deflate_state)(unsafe.Pointer(s)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fw_size, (uint32(2) * uint32(unsafe.Sizeof(Byte(0)))))
	(*Deflate_state)(unsafe.Pointer(s)).Fprev = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fw_size, uint32(unsafe.Sizeof(Pos(0))))
	(*Deflate_state)(unsafe.Pointer(s)).Fhead = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Fhash_size, uint32(unsafe.Sizeof(Pos(0))))

	(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = Ulg(0) // nothing written to s->window yet

	(*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize = (UInt(int32(1) << (memLevel + 6))) // 16K elements by default

	overlay = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize, (uint32(unsafe.Sizeof(Ush(0))) + uint32(2)))
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_buf = overlay
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size = (Ulg((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize) * (uint32(unsafe.Sizeof(Ush(0))) + uint32(2)))

	if ((((*Deflate_state)(unsafe.Pointer(s)).Fwindow == uintptr(Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(s)).Fprev == uintptr(Z_NULL))) || ((*Deflate_state)(unsafe.Pointer(s)).Fhead == uintptr(Z_NULL))) || ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf == uintptr(Z_NULL)) {
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = FINISH_STATE
		(*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-4))]
		XdeflateEnd(tls, strm)
		return -4
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fd_buf = (overlay + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize/UInt(unsafe.Sizeof(Ush(0)))))*2)
	(*Deflate_state)(unsafe.Pointer(s)).Fl_buf = ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((uint32(1) + uint32(unsafe.Sizeof(Ush(0)))) * (*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize)))

	(*Deflate_state)(unsafe.Pointer(s)).Flevel = level
	(*Deflate_state)(unsafe.Pointer(s)).Fstrategy = strategy
	(*Deflate_state)(unsafe.Pointer(s)).Fmethod = Byte(method)

	return XdeflateReset(tls, strm)
}

var my_version = *(*[7]int8)(unsafe.Pointer(ts /* "1.2.11" */)) /* deflate.c:253:23 */

// =========================================================================
// Check for a valid deflate stream state. Return 0 if ok, 1 if not.
func deflateStateCheck(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:353:11: */
	var s uintptr
	if ((strm == uintptr(Z_NULL)) || ((*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0))) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return 1
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((s == uintptr(Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(s)).Fstrm != strm)) || (((((((((*Deflate_state)(unsafe.Pointer(s)).Fstatus != INIT_STATE) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != GZIP_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != EXTRA_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != NAME_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != COMMENT_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != HCRC_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != BUSY_STATE)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != FINISH_STATE)) {
		return 1
	}
	return 0
}

// =========================================================================
func XdeflateSetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength UInt) int32 { /* deflate.c:376:13: */
	var s uintptr
	var str UInt
	var n UInt
	var wrap int32
	var avail uint32
	var next uintptr

	if (deflateStateCheck(tls, strm) != 0) || (dictionary == uintptr(Z_NULL)) {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	wrap = (*Deflate_state)(unsafe.Pointer(s)).Fwrap
	if ((wrap == 2) || ((wrap == 1) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != INIT_STATE))) || ((*Deflate_state)(unsafe.Pointer(s)).Flookahead != 0) {
		return -2
	}

	// when using zlib wrappers, compute Adler-32 for provided dictionary
	if wrap == 1 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, dictionary, dictLength)
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = 0 // avoid computing Adler-32 in read_buf

	// if dictionary would fill window, just replace the history
	if dictLength >= (*Deflate_state)(unsafe.Pointer(s)).Fw_size {
		if wrap == 0 { // already empty otherwise
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = Posf(NIL)
			libc.Xmemset(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1)) * uint32(unsafe.Sizeof(Posf(0)))))

			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
			(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
		}
		dictionary += (uintptr(dictLength - (*Deflate_state)(unsafe.Pointer(s)).Fw_size)) // use the tail
		dictLength = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
	}

	// insert dictionary into window and hash
	avail = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = dictLength
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = dictionary
	fill_window(tls, s)
	for (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= UInt(MIN_MATCH) {
		str = (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		n = ((*Deflate_state)(unsafe.Pointer(s)).Flookahead - (UInt(MIN_MATCH - 1)))
		for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((str + UInt(MIN_MATCH)) - UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr((str&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2)) = *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos(str)
			str++
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = str
		(*Deflate_state)(unsafe.Pointer(s)).Flookahead = (UInt(MIN_MATCH - 1))
		fill_window(tls, s)
	}
	*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = (*Deflate_state)(unsafe.Pointer(s)).Flookahead
	(*Deflate_state)(unsafe.Pointer(s)).Flookahead = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = libc.AssignPtrUint32(s+120 /* &.prev_length */, (UInt(MIN_MATCH - 1)))
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = avail
	(*Deflate_state)(unsafe.Pointer(s)).Fwrap = wrap
	return Z_OK
}

// =========================================================================
func XdeflateGetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength uintptr) int32 { /* deflate.c:445:13: */
	var s uintptr
	var len UInt

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	len = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + (*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	if len > (*Deflate_state)(unsafe.Pointer(s)).Fw_size {
		len = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
	}
	if (dictionary != uintptr(Z_NULL)) && (len != 0) {
		libc.Xmemcpy(tls, dictionary, ((((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flookahead)) - uintptr(len)), len)
	}
	if dictLength != uintptr(Z_NULL) {
		*(*UInt)(unsafe.Pointer(dictLength)) = len
	}
	return Z_OK
}

// =========================================================================
func XdeflateResetKeep(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:467:13: */
	var s uintptr

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}

	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = libc.AssignPtrUint32(strm+20 /* &.total_out */, ULong(0))
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL) // use zfree if we ever allocate msg dynamically
	(*Z_stream)(unsafe.Pointer(strm)).Fdata_type = Z_UNKNOWN

	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Deflate_state)(unsafe.Pointer(s)).Fpending = Ulg(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fpending_out = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf

	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap < 0 {
		(*Deflate_state)(unsafe.Pointer(s)).Fwrap = -(*Deflate_state)(unsafe.Pointer(s)).Fwrap // was made negative by deflate(..., Z_FINISH);
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fstatus = func() int32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
			return GZIP_STATE
		}
		return func() int32 {
			if (*Deflate_state)(unsafe.Pointer(s)).Fwrap != 0 {
				return INIT_STATE
			}
			return BUSY_STATE
		}()
	}()
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = func() uint32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
			return Xcrc32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
		}
		return Xadler32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
	}()
	(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = Z_NO_FLUSH

	X_tr_init(tls, s)

	return Z_OK
}

// =========================================================================
func XdeflateReset(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:505:13: */
	var ret int32

	ret = XdeflateResetKeep(tls, strm)
	if ret == Z_OK {
		lm_init(tls, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	}
	return ret
}

// =========================================================================
func XdeflateSetHeader(tls *libc.TLS, strm Z_streamp, head Gz_headerp) int32 { /* deflate.c:517:13: */
	if (deflateStateCheck(tls, strm) != 0) || ((*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap != 2) {
		return -2
	}
	(*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fgzhead = head
	return Z_OK
}

// =========================================================================
func XdeflatePending(tls *libc.TLS, strm Z_streamp, pending uintptr, bits uintptr) int32 { /* deflate.c:528:13: */
	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	if pending != uintptr(Z_NULL) {
		*(*uint32)(unsafe.Pointer(pending)) = uint32((*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending)
	}
	if bits != uintptr(Z_NULL) {
		*(*int32)(unsafe.Pointer(bits)) = (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fbi_valid
	}
	return Z_OK
}

// =========================================================================
func XdeflatePrime(tls *libc.TLS, strm Z_streamp, bits int32, value int32) int32 { /* deflate.c:542:13: */
	var s uintptr
	var put int32

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Deflate_state)(unsafe.Pointer(s)).Fd_buf) < ((*Deflate_state)(unsafe.Pointer(s)).Fpending_out + uintptr((int32((Buf_size + 7)) >> 3))) {
		return -5
	}
	for ok := true; ok; ok = bits != 0 {
		put = (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)
		if put > bits {
			put = bits
		}
		*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush((value & ((int32(1) << put) - 1)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))))
		*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (put)
		X_tr_flush_bits(tls, s)
		value >>= put
		bits = bits - (put)
	}
	return Z_OK
}

// =========================================================================
func XdeflateParams(tls *libc.TLS, strm Z_streamp, level int32, strategy int32) int32 { /* deflate.c:568:13: */
	var s uintptr
	var func1 Compress_func

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	if level == (-1) {
		level = 6
	}
	if (((level < 0) || (level > 9)) || (strategy < 0)) || (strategy > Z_FIXED) {
		return -2
	}
	func1 = configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Ffunc

	if ((strategy != (*Deflate_state)(unsafe.Pointer(s)).Fstrategy) || (func1 != configuration_table[level].Ffunc)) && ((*Deflate_state)(unsafe.Pointer(s)).Fhigh_water != 0) {
		// Flush the last buffer:
		var err int32 = Xdeflate(tls, strm, Z_BLOCK)
		if err == (-2) {
			return err
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
			return -5
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flevel != level {
		if ((*Deflate_state)(unsafe.Pointer(s)).Flevel == 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fmatches != UInt(0)) {
			if (*Deflate_state)(unsafe.Pointer(s)).Fmatches == UInt(1) {
				slide_hash(tls, s)
			} else {
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = Posf(NIL)
			}
			libc.Xmemset(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1)) * uint32(unsafe.Sizeof(Posf(0)))))

			(*Deflate_state)(unsafe.Pointer(s)).Fmatches = UInt(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Flevel = level
		(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(configuration_table[level].Fmax_lazy)
		(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(configuration_table[level].Fgood_length)
		(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = int32(configuration_table[level].Fnice_length)
		(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(configuration_table[level].Fmax_chain)
	}
	(*Deflate_state)(unsafe.Pointer(s)).Fstrategy = strategy
	return Z_OK
}

// =========================================================================
func XdeflateTune(tls *libc.TLS, strm Z_streamp, good_length int32, max_lazy int32, nice_length int32, max_chain int32) int32 { /* deflate.c:617:13: */
	var s uintptr

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(good_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(max_lazy)
	(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = nice_length
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(max_chain)
	return Z_OK
}

// =========================================================================
// For the default windowBits of 15 and memLevel of 8, this function returns
// a close to exact, as well as small, upper bound on the compressed size.
// They are coded as constants here for a reason--if the #define's are
// changed, then this function needs to be changed as well.  The return
// value for 15 and 8 only works for those exact settings.
//
// For any setting other than those defaults for windowBits and memLevel,
// the value returned is a conservative worst case for the maximum expansion
// resulting from using fixed blocks instead of stored blocks, which deflate
// can emit on compressed data for some combinations of the parameters.
//
// This function could be more sophisticated to provide closer upper bounds for
// every combination of windowBits and memLevel.  But even the conservative
// upper bound of about 14% expansion does not seem onerous for output buffer
// allocation.
func XdeflateBound(tls *libc.TLS, strm Z_streamp, sourceLen ULong) ULong { /* deflate.c:652:15: */
	var s uintptr
	var complen ULong
	var wraplen ULong

	// conservative upper bound for compressed data
	complen = (((sourceLen + ((sourceLen + ULong(7)) >> 3)) + ((sourceLen + ULong(63)) >> 6)) + ULong(5))

	// if can't get parameters, return conservative bound plus zlib wrapper
	if deflateStateCheck(tls, strm) != 0 {
		return (complen + ULong(6))
	}

	// compute wrapper length
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	switch (*Deflate_state)(unsafe.Pointer(s)).Fwrap {
	case 0: // raw deflate
		wraplen = ULong(0)
		break
	case 1: // zlib wrapper
		wraplen = (ULong(6 + (func() int32 {
			if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != 0 {
				return 4
			}
			return 0
		}())))
		break
	case 2: // gzip wrapper
		wraplen = ULong(18)
		if (*Deflate_state)(unsafe.Pointer(s)).Fgzhead != uintptr(Z_NULL) { // user-supplied gzip header
			var str uintptr
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != uintptr(Z_NULL) {
				wraplen = wraplen + (ULong(UInt(2) + (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len))
			}
			str = (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname
			if str != uintptr(Z_NULL) {
				for ok := true; ok; ok = *(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&str, 1))) != 0 {
					wraplen++
				}
			}
			str = (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment
			if str != uintptr(Z_NULL) {
				for ok1 := true; ok1; ok1 = *(*Bytef)(unsafe.Pointer(libc.PostIncUintptr(&str, 1))) != 0 {
					wraplen++
				}
			}
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
				wraplen = wraplen + (ULong(2))
			}
		}
		break
	default: // for compiler happiness
		wraplen = ULong(6)
	}

	// if not default parameters, return conservative bound
	if ((*Deflate_state)(unsafe.Pointer(s)).Fw_bits != UInt(15)) || ((*Deflate_state)(unsafe.Pointer(s)).Fhash_bits != (UInt(8 + 7))) {
		return (complen + wraplen)
	}

	// default settings: return tight bound for that case
	return ((((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + ULong(13)) - ULong(6)) + wraplen)
}

// =========================================================================
// Put a short in the pending buffer. The 16-bit value is put in MSB order.
// IN assertion: the stream state is correct and there is enough room in
// pending_buf.
func putShortMSB(tls *libc.TLS, s uintptr, b UInt) { /* deflate.c:716:12: */
	{
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(b >> 8))
	}

	{
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(b & UInt(0xff)))
	}

}

// =========================================================================
// Flush as much pending output as possible. All deflate() output, except for
// some deflate_stored() output, goes through this function so some
// applications may wish to modify it to avoid allocating a large
// strm->next_out buffer and copying into it. (See also read_buf()).
func flush_pending(tls *libc.TLS, strm Z_streamp) { /* deflate.c:730:12: */
	var len uint32
	var s uintptr = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	X_tr_flush_bits(tls, s)
	len = uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending)
	if len > (*Z_stream)(unsafe.Pointer(strm)).Favail_out {
		len = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	}
	if len == uint32(0) {
		return
	}

	libc.Xmemcpy(tls, (*Z_stream)(unsafe.Pointer(strm)).Fnext_out, (*Deflate_state)(unsafe.Pointer(s)).Fpending_out, len)
	*(*uintptr)(unsafe.Pointer(strm + 12 /* &.next_out */)) += (uintptr(len))
	*(*uintptr)(unsafe.Pointer(s + 16 /* &.pending_out */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 20 /* &.total_out */)) += (ULong(len))
	*(*UInt)(unsafe.Pointer(strm + 16 /* &.avail_out */)) -= (len)
	*(*Ulg)(unsafe.Pointer(s + 20 /* &.pending */)) -= (Ulg(len))
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending == Ulg(0) {
		(*Deflate_state)(unsafe.Pointer(s)).Fpending_out = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf
	}
}

// ===========================================================================
// Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].

// =========================================================================
func Xdeflate(tls *libc.TLS, strm Z_streamp, flush int32) int32 { /* deflate.c:763:13: */
	var old_flush int32 // value of flush param for previous deflate call
	var s uintptr

	if ((deflateStateCheck(tls, strm) != 0) || (flush > Z_BLOCK)) || (flush < 0) {
		return -2
	}
	s = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	if (((*Z_stream)(unsafe.Pointer(strm)).Fnext_out == uintptr(Z_NULL)) || (((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) && ((*Z_stream)(unsafe.Pointer(strm)).Fnext_in == uintptr(Z_NULL)))) || (((*Deflate_state)(unsafe.Pointer(s)).Fstatus == FINISH_STATE) && (flush != Z_FINISH)) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-2))]; return -2 }()
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	old_flush = (*Deflate_state)(unsafe.Pointer(s)).Flast_flush
	(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = flush

	// Flush as much pending output as possible
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
		flush_pending(tls, strm)
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
			// Since avail_out is 0, deflate will be called again with
			// more output space, but possibly with both pending and
			// avail_in equal to zero. There won't be anything to do,
			// but this is not an error situation so make sure we
			// return OK instead of BUF_ERROR at next call of deflate:
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}

		// Make sure there is something to do and avoid duplicate consecutive
		// flushes. For repeated and useless calls with Z_FINISH, we keep
		// returning Z_STREAM_END instead of Z_BUF_ERROR.
	} else if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && ((((flush) * 2) - (func() int32 {
		if (flush) > 4 {
			return 9
		}
		return 0
	}())) <= (((old_flush) * 2) - (func() int32 {
		if (old_flush) > 4 {
			return 9
		}
		return 0
	}())))) && (flush != Z_FINISH) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	// User must not provide more input after the first FINISH:
	if ((*Deflate_state)(unsafe.Pointer(s)).Fstatus == FINISH_STATE) && ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) {
		return func() int32 { (*Z_stream)(unsafe.Pointer(strm)).Fmsg = Xz_errmsg[(Z_NEED_DICT - (-5))]; return -5 }()
	}

	// Write the header
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == INIT_STATE {
		// zlib header
		var header UInt = ((UInt(Z_DEFLATED) + (((*Deflate_state)(unsafe.Pointer(s)).Fw_bits - UInt(8)) << 4)) << 8)
		var level_flags UInt

		if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
			level_flags = UInt(0)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Flevel < 6 {
			level_flags = UInt(1)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 6 {
			level_flags = UInt(2)
		} else {
			level_flags = UInt(3)
		}
		header = header | (level_flags << 6)
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != UInt(0) {
			header = header | (UInt(PRESET_DICT))
		}
		header = header + (UInt(31) - (header % UInt(31)))

		putShortMSB(tls, s, header)

		// Save the adler32 of the preset dictionary:
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart != UInt(0) {
			putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16)))
			putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler & ULong(0xffff))))
		}
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

		// Compression must start with an empty pending buffer
		flush_pending(tls, strm)
		if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == GZIP_STATE {
		// gzip header
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(31)
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(139)
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(8)
		}

		if (*Deflate_state)(unsafe.Pointer(s)).Fgzhead == uintptr(Z_NULL) {
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(0)
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = func() uint8 {
					if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 9 {
						return uint8(2)
					}
					return func() uint8 {
						if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
							return uint8(4)
						}
						return uint8(0)
					}()
				}()
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(OS_CODE)
			}

			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

			// Compression must start with an empty pending buffer
			flush_pending(tls, strm)
			if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
				return Z_OK
			}
		} else {
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef(((((func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftext != 0 {
						return 1
					}
					return 0
				}()) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
						return 2
					}
					return 0
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra == uintptr(Z_NULL) {
						return 0
					}
					return 4
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname == uintptr(Z_NULL) {
						return 0
					}
					return 8
				}())) + (func() int32 {
					if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment == uintptr(Z_NULL) {
						return 0
					}
					return 16
				}())))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime & ULong(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 8) & ULong(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 16) & ULong(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Ftime >> 24) & ULong(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = func() uint8 {
					if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 9 {
						return uint8(2)
					}
					return func() uint8 {
						if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy >= Z_HUFFMAN_ONLY) || ((*Deflate_state)(unsafe.Pointer(s)).Flevel < 2) {
							return uint8(4)
						}
						return uint8(0)
					}()
				}()
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fos & 0xff))
			}

			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != uintptr(Z_NULL) {
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len & UInt(0xff)))
				}

				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Bytef(((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len >> 8) & UInt(0xff)))
				}

			}
			if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
				(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf,
					uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending))
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = Ulg(0)
			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = EXTRA_STATE
		}
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == EXTRA_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra != uintptr(Z_NULL) {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var left UInt = (UInt((Ulg((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra_len & UInt(0xffff))) - (*Deflate_state)(unsafe.Pointer(s)).Fgzindex))
			for ((*Deflate_state)(unsafe.Pointer(s)).Fpending + Ulg(left)) > (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
				var copy UInt = (UInt((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fpending))
				libc.Xmemcpy(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)),
					((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fgzindex)), copy)
				(*Deflate_state)(unsafe.Pointer(s)).Fpending = (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size
				for ok := true; ok; ok = 0 != 0 {
					if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
						(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
					}
				}
				*(*Ulg)(unsafe.Pointer(s + 32 /* &.gzindex */)) += (Ulg(copy))
				flush_pending(tls, strm)
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
					(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
					return Z_OK
				}
				beg = Ulg(0)
				left = left - (copy)
			}
			libc.Xmemcpy(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)),
				((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fextra + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fgzindex)), left)
			*(*Ulg)(unsafe.Pointer(s + 20 /* &.pending */)) += (Ulg(left))
			for ok1 := true; ok1; ok1 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = Ulg(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = NAME_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == NAME_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname != uintptr(Z_NULL) {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var val int32
			for ok2 := true; ok2; ok2 = (val != 0) {
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending == (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
					for ok3 := true; ok3; ok3 = 0 != 0 {
						if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
							(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
						}
					}
					flush_pending(tls, strm)
					if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
						return Z_OK
					}
					beg = Ulg(0)
				}
				val = int32(*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fname + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fgzindex, 1)))))
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(val)
				}

			}
			for ok4 := true; ok4; ok4 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fgzindex = Ulg(0)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = COMMENT_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == COMMENT_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment != uintptr(Z_NULL) {
			var beg Ulg = (*Deflate_state)(unsafe.Pointer(s)).Fpending // start of bytes to update crc
			var val int32
			for ok5 := true; ok5; ok5 = (val != 0) {
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending == (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
					for ok6 := true; ok6; ok6 = 0 != 0 {
						if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
							(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
						}
					}
					flush_pending(tls, strm)
					if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
						return Z_OK
					}
					beg = Ulg(0)
				}
				val = int32(*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fcomment + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fgzindex, 1)))))
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Bytef(val)
				}

			}
			for ok7 := true; ok7; ok7 = 0 != 0 {
				if ((*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0) && ((*Deflate_state)(unsafe.Pointer(s)).Fpending > (beg)) {
					(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((beg))), (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending - (beg))))
				}
			}
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = HCRC_STATE
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fstatus == HCRC_STATE {
		if (*Gz_header)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fgzhead)).Fhcrc != 0 {
			if ((*Deflate_state)(unsafe.Pointer(s)).Fpending + Ulg(2)) > (*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size {
				flush_pending(tls, strm)
				if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
					(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
					return Z_OK
				}
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Fadler & ULong(0xff)))
			}

			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 8) & ULong(0xff)))
			}

			(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fstatus = BUSY_STATE

		// Compression must start with an empty pending buffer
		flush_pending(tls, strm)
		if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
			(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1
			return Z_OK
		}
	}

	// Start a new block or continue the current one.
	if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)) || ((*Deflate_state)(unsafe.Pointer(s)).Flookahead != UInt(0))) || ((flush != Z_NO_FLUSH) && ((*Deflate_state)(unsafe.Pointer(s)).Fstatus != FINISH_STATE)) {
		var bstate Block_state

		if (*Deflate_state)(unsafe.Pointer(s)).Flevel == 0 {
			bstate = deflate_stored(tls, s, flush)
		} else {
			if (*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_HUFFMAN_ONLY {
				bstate = deflate_huff(tls, s, flush)
			} else {
				if (*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_RLE {
					bstate = deflate_rle(tls, s, flush)
				} else {
					bstate = (*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer((uintptr(unsafe.Pointer(&configuration_table)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flevel)*12 + 8 /* &.func */))))(tls, s, flush)
				}
			}
		}

		if (bstate == Finish_started) || (bstate == Finish_done) {
			(*Deflate_state)(unsafe.Pointer(s)).Fstatus = FINISH_STATE
		}
		if (bstate == Need_more) || (bstate == Finish_started) {
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1 // avoid BUF_ERROR next call, see above
			}
			return Z_OK
			// If flush != Z_NO_FLUSH && avail_out == 0, the next call
			// of deflate should use the same flush parameter to make sure
			// that the flush is complete. So we don't have to output an
			// empty block here, this will be done at next call. This also
			// ensures that for a very small output buffer, we emit at most
			// one empty block.
		}
		if bstate == Block_done {
			if flush == Z_PARTIAL_FLUSH {
				X_tr_align(tls, s)
			} else if flush != Z_BLOCK { // FULL_FLUSH or SYNC_FLUSH
				X_tr_stored_block(tls, s, uintptr(0), uint32(0), 0)
				// For a full flush, this empty block will be recognized
				// as a special marker by inflate_sync().
				if flush == Z_FULL_FLUSH {
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = Posf(NIL)
					libc.Xmemset(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1)) * uint32(unsafe.Sizeof(Posf(0)))))
					// forget history
					if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
						(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
						(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
						(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
					}
				}
			}
			flush_pending(tls, strm)
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Deflate_state)(unsafe.Pointer(s)).Flast_flush = -1 // avoid BUF_ERROR at next call, see above
				return Z_OK
			}
		}
	}

	if flush != Z_FINISH {
		return Z_OK
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap <= 0 {
		return Z_STREAM_END
	}

	// Write the trailer
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap == 2 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Fadler & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 8) & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16) & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 24) & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 8) & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 16) & ULong(0xff)))
		}

		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Byte(((*Z_stream)(unsafe.Pointer(strm)).Ftotal_in >> 24) & ULong(0xff)))
		}

	} else {
		putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler >> 16)))
		putShortMSB(tls, s, (UInt((*Z_stream)(unsafe.Pointer(strm)).Fadler & ULong(0xffff))))
	}
	flush_pending(tls, strm)
	// If avail_out is zero, the application will call deflate again
	// to flush the rest.
	if (*Deflate_state)(unsafe.Pointer(s)).Fwrap > 0 {
		(*Deflate_state)(unsafe.Pointer(s)).Fwrap = -(*Deflate_state)(unsafe.Pointer(s)).Fwrap
	} // write the trailer only once!
	if (*Deflate_state)(unsafe.Pointer(s)).Fpending != Ulg(0) {
		return Z_OK
	}
	return Z_STREAM_END
}

// =========================================================================
func XdeflateEnd(tls *libc.TLS, strm Z_streamp) int32 { /* deflate.c:1076:13: */
	var status int32

	if deflateStateCheck(tls, strm) != 0 {
		return -2
	}

	status = (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fstatus

	/* Deallocate in reverse order of allocations: */
	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending_buf != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fpending_buf)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fhead != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fhead)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fprev != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fprev)
		}
	}

	{
		if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwindow != 0 {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwindow)
		}
	}

	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = uintptr(Z_NULL)

	if status == BUSY_STATE {
		return -3
	}
	return Z_OK
}

// =========================================================================
// Copy the source state to the destination state.
// To simplify the source, this is not supported for 16-bit MSDOS (which
// doesn't have enough memory anyway to duplicate compression states).
func XdeflateCopy(tls *libc.TLS, dest Z_streamp, source Z_streamp) int32 { /* deflate.c:1102:13: */
	var ds uintptr
	var ss uintptr
	var overlay uintptr

	if (deflateStateCheck(tls, source) != 0) || (dest == uintptr(Z_NULL)) {
		return -2
	}

	ss = (*Z_stream)(unsafe.Pointer(source)).Fstate

	libc.Xmemcpy(tls, dest, source, uint32(unsafe.Sizeof(Z_stream{})))

	ds = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Deflate_state{})))
	if ds == uintptr(Z_NULL) {
		return -4
	}
	(*Z_stream)(unsafe.Pointer(dest)).Fstate = ds
	libc.Xmemcpy(tls, ds, ss, uint32(unsafe.Sizeof(Deflate_state{})))
	(*Deflate_state)(unsafe.Pointer(ds)).Fstrm = dest

	(*Deflate_state)(unsafe.Pointer(ds)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fw_size, (uint32(2) * uint32(unsafe.Sizeof(Byte(0)))))
	(*Deflate_state)(unsafe.Pointer(ds)).Fprev = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fw_size, uint32(unsafe.Sizeof(Pos(0))))
	(*Deflate_state)(unsafe.Pointer(ds)).Fhead = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Fhash_size, uint32(unsafe.Sizeof(Pos(0))))
	overlay = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((dest + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(dest)).Fopaque, (*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize, (uint32(unsafe.Sizeof(Ush(0))) + uint32(2)))
	(*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf = overlay

	if ((((*Deflate_state)(unsafe.Pointer(ds)).Fwindow == uintptr(Z_NULL)) || ((*Deflate_state)(unsafe.Pointer(ds)).Fprev == uintptr(Z_NULL))) || ((*Deflate_state)(unsafe.Pointer(ds)).Fhead == uintptr(Z_NULL))) || ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf == uintptr(Z_NULL)) {
		XdeflateEnd(tls, dest)
		return -4
	}
	// following zmemcpy do not work for 16-bit MSDOS
	libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fwindow, (*Deflate_state)(unsafe.Pointer(ss)).Fwindow, (((*Deflate_state)(unsafe.Pointer(ds)).Fw_size * UInt(2)) * UInt(unsafe.Sizeof(Byte(0)))))
	libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fprev, (*Deflate_state)(unsafe.Pointer(ss)).Fprev, ((*Deflate_state)(unsafe.Pointer(ds)).Fw_size * UInt(unsafe.Sizeof(Pos(0)))))
	libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fhead, (*Deflate_state)(unsafe.Pointer(ss)).Fhead, ((*Deflate_state)(unsafe.Pointer(ds)).Fhash_size * UInt(unsafe.Sizeof(Pos(0)))))
	libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf, (*Deflate_state)(unsafe.Pointer(ss)).Fpending_buf, UInt((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf_size))

	(*Deflate_state)(unsafe.Pointer(ds)).Fpending_out = ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf + uintptr(((int32((*Deflate_state)(unsafe.Pointer(ss)).Fpending_out) - int32((*Deflate_state)(unsafe.Pointer(ss)).Fpending_buf)) / 1)))
	(*Deflate_state)(unsafe.Pointer(ds)).Fd_buf = (overlay + uintptr(((*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize/UInt(unsafe.Sizeof(Ush(0)))))*2)
	(*Deflate_state)(unsafe.Pointer(ds)).Fl_buf = ((*Deflate_state)(unsafe.Pointer(ds)).Fpending_buf + uintptr(((uint32(1) + uint32(unsafe.Sizeof(Ush(0)))) * (*Deflate_state)(unsafe.Pointer(ds)).Flit_bufsize)))

	(*Deflate_state)(unsafe.Pointer(ds)).Fl_desc.Fdyn_tree = ds + 148   /* &.dyn_ltree */
	(*Deflate_state)(unsafe.Pointer(ds)).Fd_desc.Fdyn_tree = ds + 2440  /* &.dyn_dtree */
	(*Deflate_state)(unsafe.Pointer(ds)).Fbl_desc.Fdyn_tree = ds + 2684 /* &.bl_tree */

	return Z_OK
}

// ===========================================================================
// Read a new buffer from the current input stream, update the adler32
// and total number of bytes read.  All deflate() input goes through
// this function so some applications may wish to modify it to avoid
// allocating a large strm->next_in buffer and copying from it.
// (See also flush_pending()).
func read_buf(tls *libc.TLS, strm Z_streamp, buf uintptr, size uint32) uint32 { /* deflate.c:1164:16: */
	var len uint32 = (*Z_stream)(unsafe.Pointer(strm)).Favail_in

	if len > size {
		len = size
	}
	if len == uint32(0) {
		return uint32(0)
	}

	*(*UInt)(unsafe.Pointer(strm + 4 /* &.avail_in */)) -= (len)

	libc.Xmemcpy(tls, buf, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, len)
	if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap == 1 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xadler32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, buf, len)
	} else if (*Internal_state)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fstate)).Fwrap == 2 {
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = Xcrc32(tls, (*Z_stream)(unsafe.Pointer(strm)).Fadler, buf, len)
	}
	*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 8 /* &.total_in */)) += (ULong(len))

	return len
}

// ===========================================================================
// Initialize the "longest match" routines for a new zlib stream
func lm_init(tls *libc.TLS, s uintptr) { /* deflate.c:1194:12: */
	(*Deflate_state)(unsafe.Pointer(s)).Fwindow_size = (Ulg(2) * Ulg((*Deflate_state)(unsafe.Pointer(s)).Fw_size))

	*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fhash_size-UInt(1)))*2)) = Posf(NIL)
	libc.Xmemset(tls, (*Deflate_state)(unsafe.Pointer(s)).Fhead, 0, (((*Deflate_state)(unsafe.Pointer(s)).Fhash_size - UInt(1)) * uint32(unsafe.Sizeof(Posf(0)))))

	// Set the default configuration parameters:
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fmax_lazy)
	(*Deflate_state)(unsafe.Pointer(s)).Fgood_match = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fgood_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fnice_match = int32(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fnice_length)
	(*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length = UInt(configuration_table[(*Deflate_state)(unsafe.Pointer(s)).Flevel].Fmax_chain)

	(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = 0
	(*Deflate_state)(unsafe.Pointer(s)).Flookahead = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = libc.AssignPtrUint32(s+120 /* &.prev_length */, (UInt(MIN_MATCH - 1)))
	(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(0)
}

// ===========================================================================
// Set match_start to the longest match starting at the given string and
// return its length. Matches shorter or equal to prev_length are discarded,
// in which case the result is equal to prev_length and match_start is
// garbage.
// IN assertions: cur_match is the head of the hash chain for the current
//   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
// OUT assertion: the match length is not greater than s->lookahead.
// For 80x86 and 680x0, an optimized version will be provided in match.asm or
// match.S. The code will be functionally equivalent.
func longest_match(tls *libc.TLS, s uintptr, cur_match IPos) UInt { /* deflate.c:1236:12: */
	var chain_length uint32 = (*Deflate_state)(unsafe.Pointer(s)).Fmax_chain_length                                           // max hash chain length
	var scan uintptr = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) // current string
	var match uintptr                                                                                                         // matched string
	var len int32                                                                                                             // length of current match
	var best_len int32 = int32((*Deflate_state)(unsafe.Pointer(s)).Fprev_length)                                              // best match length so far
	var nice_match int32 = (*Deflate_state)(unsafe.Pointer(s)).Fnice_match                                                    // stop if match long enough
	var limit IPos
	if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart > ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1))) {
		limit = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1))))
	} else {
		limit = uint32(NIL)
	}
	// Stop when cur_match becomes <= limit. To simplify the code,
	// we prevent matches with the string of window index 0.
	var prev uintptr = (*Deflate_state)(unsafe.Pointer(s)).Fprev
	var wmask UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_mask

	var strend uintptr = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr(MAX_MATCH))
	var scan_end1 Byte = *(*Bytef)(unsafe.Pointer(scan + uintptr((best_len - 1))))
	var scan_end Byte = *(*Bytef)(unsafe.Pointer(scan + uintptr(best_len)))

	// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	// It is easy to get rid of this optimization if necessary.

	// Do not waste too much time if we already have a good match:
	if (*Deflate_state)(unsafe.Pointer(s)).Fprev_length >= (*Deflate_state)(unsafe.Pointer(s)).Fgood_match {
		chain_length >>= 2
	}
	// Do not look for matches beyond the end of the input. This is necessary
	// to make deflate deterministic.
	if UInt(nice_match) > (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
		nice_match = int32((*Deflate_state)(unsafe.Pointer(s)).Flookahead)
	}

	for ok := true; ok; ok = (((libc.AssignUint32(&cur_match, IPos(*(*Posf)(unsafe.Pointer(prev + uintptr((cur_match&wmask))*2))))) > limit) &&
		(libc.PreDecUint32(&chain_length, 1) != uint32(0))) {

		match = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(cur_match))

		// Skip to next match if the match length cannot increase
		// or if the match length is less than 2.  Note that the checks below
		// for insufficient lookahead only occur occasionally for performance
		// reasons.  Therefore uninitialized memory will be accessed, and
		// conditional jumps will be made that depend on those values.
		// However the length of the match is limited to the lookahead, so
		// the output of deflate is not affected by the uninitialized values.

		if (((int32(*(*Bytef)(unsafe.Pointer(match + uintptr(best_len)))) != int32(scan_end)) || (int32(*(*Bytef)(unsafe.Pointer(match + uintptr((best_len - 1))))) != int32(scan_end1))) || (int32(*(*Bytef)(unsafe.Pointer(match))) != int32(*(*Bytef)(unsafe.Pointer(scan))))) || (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))) != int32(*(*Bytef)(unsafe.Pointer(scan + 1)))) {
			continue
		}

		// The check at best_len-1 can be removed because it will be made
		// again later. (This heuristic is not always a win.)
		// It is not necessary to compare scan[2] and match[2] since they
		// are always equal when the other bytes match, given that
		// the hash keys are equal and that HASH_BITS >= 8.
		scan += uintptr(2)
		match++

		// We check for insufficient lookahead only every 8th comparison;
		// the 256th check will be made at strstart+258.
		for ok1 := true; ok1; ok1 = (((((((((int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))) == int32(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&match, 1)))))) && (scan < strend)) {
		}

		len = (MAX_MATCH - ((int32(strend) - int32(scan)) / 1))
		scan = (strend - uintptr(MAX_MATCH))

		if len > best_len {
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_start = cur_match
			best_len = len
			if len >= nice_match {
				break
			}
			scan_end1 = *(*Bytef)(unsafe.Pointer(scan + uintptr((best_len - 1))))
			scan_end = *(*Bytef)(unsafe.Pointer(scan + uintptr(best_len)))
		}
	}

	if UInt(best_len) <= (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
		return UInt(best_len)
	}
	return (*Deflate_state)(unsafe.Pointer(s)).Flookahead
}

// ===========================================================================
// Fill the window when the lookahead becomes insufficient.
// Updates strstart and lookahead.
//
// IN assertion: lookahead < MIN_LOOKAHEAD
// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
//    At least one byte has been read, or avail_in == 0; reads are
//    performed for at least two bytes (required for the zip translate_eol
//    option -- not supported here).
func fill_window(tls *libc.TLS, s uintptr) { /* deflate.c:1482:12: */
	var n uint32
	var more uint32 // Amount of free space at the end of the window.
	var wsize UInt = (*Deflate_state)(unsafe.Pointer(s)).Fw_size

	for ok := true; ok; ok = (((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in != UInt(0))) {
		more = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Flookahead)) - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))

		// Deal with !@#$% 64K limit:
		if uint32(unsafe.Sizeof(int32(0))) <= uint32(2) {
			if ((more == uint32(0)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart == UInt(0))) && ((*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0)) {
				more = wsize

			} else if more == libc.Uint32(libc.Uint32FromInt32(-1)) {
				// Very unlikely, but possible on 16 bit machine if
				// strstart == 0 && lookahead == 1 (input done a byte at time)
				more--
			}
		}

		// If the window is almost full and there is insufficient lookahead,
		// move the upper half to the lower one to make room in the upper half.
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart >= (wsize + ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {

			libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(wsize)), (wsize - more))
			*(*UInt)(unsafe.Pointer(s + 112 /* &.match_start */)) -= (wsize)
			*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) -= (wsize) // we now have strstart >= MAX_DIST
			*(*int32)(unsafe.Pointer(s + 92 /* &.block_start */)) -= (int32(wsize))
			slide_hash(tls, s)
			more = more + (wsize)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0) {
			break
		}

		// If there was no sliding:
		//    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
		//    more == window_size - lookahead - strstart
		// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
		// => more >= window_size - 2*WSIZE + 2
		// In the BIG_MEM or MMAP case (not yet supported),
		//   window_size == input_size + MIN_LOOKAHEAD  &&
		//   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
		// Otherwise, window_size == 2*WSIZE so more >= 2.
		// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

		n = read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flookahead)), more)
		*(*UInt)(unsafe.Pointer(s + 116 /* &.lookahead */)) += (n)

		// Initialize the hash value now that we have some input:
		if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead + (*Deflate_state)(unsafe.Pointer(s)).Finsert) >= UInt(MIN_MATCH) {
			var str UInt = ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Finsert)
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(str))))
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((str + UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			for (*Deflate_state)(unsafe.Pointer(s)).Finsert != 0 {
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((str + UInt(MIN_MATCH)) - UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fprev + uintptr((str&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2)) = *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))
				*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos(str)
				str++
				(*Deflate_state)(unsafe.Pointer(s)).Finsert--
				if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead + (*Deflate_state)(unsafe.Pointer(s)).Finsert) < UInt(MIN_MATCH) {
					break
				}
			}
		}
		// If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
		// but this is not important since only literal bytes will be emitted.

	}

	// If the WIN_INIT bytes after the end of the current data have never been
	// written, then zero those bytes in order to avoid memory check reports of
	// the use of uninitialized (or uninitialised as Julian writes) bytes by
	// the longest match routines.  Update the high water mark for the next
	// time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	// routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < (*Deflate_state)(unsafe.Pointer(s)).Fwindow_size {
		var curr Ulg = (Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (Ulg((*Deflate_state)(unsafe.Pointer(s)).Flookahead)))
		var init1 Ulg

		if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < curr {
			// Previous high water mark below current data -- zero WIN_INIT
			// bytes or up to end of window, whichever is less.
			init1 = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - curr)
			if init1 > Ulg(MAX_MATCH) {
				init1 = Ulg(MAX_MATCH)
			}
			libc.Xmemset(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(curr)), 0, uint32(init1))
			(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = (curr + init1)
		} else if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < (curr + Ulg(MAX_MATCH)) {
			// High water mark at or above current data, but below current data
			// plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
			// to end of window, whichever is less.
			init1 = ((curr + Ulg(MAX_MATCH)) - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)
			if init1 > ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water) {
				init1 = ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)
			}
			libc.Xmemset(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fhigh_water)), 0, uint32(init1))
			*(*Ulg)(unsafe.Pointer(s + 5824 /* &.high_water */)) += (init1)
		}
	}

}

// ===========================================================================
// Flush the current block, with given end-of-file flag.
// IN assertion: strstart is set to the end of the current match.

// Same but force premature exit if necessary.

// Maximum stored block length in deflate format (not including header).

// Minimum of a and b.

// ===========================================================================
// Copy without compression as much as possible from the input stream, return
// the current block state.
//
// In case deflateParams() is used to later switch to a non-zero compression
// level, s->matches (otherwise unused when storing) keeps track of the number
// of hash table slides to perform. If s->matches is 1, then one hash table
// slide will be done when switching. If s->matches is 2, the maximum value
// allowed here, then the hash table will be cleared, since two or more slides
// is the same as a clear.
//
// deflate_stored() is written to minimize the number of times an input byte is
// copied. It is most efficient with large input and output buffers, which
// maximizes the opportunites to have a single copy from next_in to next_out.
func deflate_stored(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1643:19: */
	// Smallest worthy block size when not flushing or finishing. By default
	// this is 32K. This can be as small as 507 bytes for memLevel == 1. For
	// large input and output buffers, the stored block size will be larger.
	var min_block uint32 = func() uint32 {
		if ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(5)) > (Ulg((*Deflate_state)(unsafe.Pointer(s)).Fw_size)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		}
		return (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(5)))
	}()

	// Copy as many min_block or larger stored blocks directly to next_out as
	// possible. If flushing, copy the remaining available input to next_out as
	// stored blocks, if there is enough space.
	var len uint32
	var left uint32
	var have uint32
	var last uint32 = uint32(0)
	var used uint32 = (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in
	for ok := true; ok; ok = (last == uint32(0)) {
		// Set len to the maximum size block that we can copy directly with the
		// available input data and output space. Set left to how much of that
		// would be copied from what's left in the window.
		len = uint32(MAX_STORED)                                                                      // maximum deflate stored block length
		have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_valid + 42) >> 3))                    // number of header bytes
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out < have { // need room for header
			break
		}
		// maximum stored block length that will fit in avail_out:
		have = ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out - have)
		left = (uint32(uint32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start))) // bytes left in window
		if Ulg(len) > (Ulg(left) + Ulg((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)) {
			len = (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)
		} // limit len to the input
		if len > have {
			len = have
		} // limit len to the output

		// If the stored block would be less than min_block in length, or if
		// unable to copy all of the available input when flushing, then try
		// copying to the window and the pending buffer instead. Also don't
		// write an empty block when flushing -- deflate() does that.
		if (len < min_block) && ((((len == uint32(0)) && (flush != Z_FINISH)) || (flush == Z_NO_FLUSH)) || (len != (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in))) {
			break
		}

		// Make a dummy stored block in pending to get the header bytes,
		// including any pending bits. This also updates the debugging counts.
		if (flush == Z_FINISH) && (len == (left + (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in)) {
			last = uint32(1)
		} else {
			last = uint32(0)
		}
		X_tr_stored_block(tls, s, uintptr(0), uint32(0), int32(last))

		// Replace the lengths in the dummy stored block with len.
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - Ulg(4))))) = Bytef(len)
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - Ulg(3))))) = (Bytef(len >> 8))
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - Ulg(2))))) = Bytef(^len)
		*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fpending - Ulg(1))))) = (Bytef(^len >> 8))

		// Write the stored block header bytes.
		flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)

		// Copy uncompressed bytes from the window to next_out.
		if left != 0 {
			if left > len {
				left = len
			}
			libc.Xmemcpy(tls, (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_out, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), left)
			*(*uintptr)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 12 /* &.next_out */)) += (uintptr(left))
			*(*UInt)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 16 /* &.avail_out */)) -= (left)
			*(*ULong)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 20 /* &.total_out */)) += (ULong(left))
			*(*int32)(unsafe.Pointer(s + 92 /* &.block_start */)) += int32((uint32(left)))
			len = len - (left)
		}

		// Copy uncompressed bytes directly from next_in to next_out, updating
		// the check value.
		if len != 0 {
			read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_out, len)
			*(*uintptr)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 12 /* &.next_out */)) += (uintptr(len))
			*(*UInt)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 16 /* &.avail_out */)) -= (len)
			*(*ULong)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm + 20 /* &.total_out */)) += (ULong(len))
		}
	}

	// Update the sliding window with the last s->w_size bytes of the copied
	// data, or append all of the copied data to the existing window if less
	// than s->w_size bytes were copied. Also update the number of bytes to
	// insert in the hash tables, in the event that deflateParams() switches to
	// a non-zero compression level.
	used = used - ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in) // number of input bytes directly copied
	if used != 0 {
		// If any input was used, then no unused input remains in the window,
		// therefore s->block_start == s->strstart.
		if used >= (*Deflate_state)(unsafe.Pointer(s)).Fw_size { // supplant the previous history
			(*Deflate_state)(unsafe.Pointer(s)).Fmatches = UInt(2) // clear hash
			libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_in - uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), (*Deflate_state)(unsafe.Pointer(s)).Fw_size)
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart = (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		} else {
			if ((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) <= Ulg(used) {
				// Slide the window down.
				*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fw_size)
				libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), (*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				if (*Deflate_state)(unsafe.Pointer(s)).Fmatches < UInt(2) {
					(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
				} // add a pending slide_hash()
			}
			libc.Xmemcpy(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)), ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fnext_in - uintptr(used)), used)
			*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) += (used)
		}
		(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		*(*UInt)(unsafe.Pointer(s + 5812 /* &.insert */)) += (func() uint32 {
			if (used) > ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - (*Deflate_state)(unsafe.Pointer(s)).Finsert) {
				return ((*Deflate_state)(unsafe.Pointer(s)).Fw_size - (*Deflate_state)(unsafe.Pointer(s)).Finsert)
			}
			return used
		}())
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) {
		(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	}

	// If the last block was written to next_out, then done.
	if last != 0 {
		return Finish_done
	}

	// If flushing and all input has been consumed, then done.
	if (((flush != Z_NO_FLUSH) && (flush != Z_FINISH)) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) == (*Deflate_state)(unsafe.Pointer(s)).Fblock_start) {
		return Block_done
	}

	// Fill the window with any remaining input.
	have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fwindow_size - Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) - Ulg(1)))
	if ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in > have) && ((*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= int32((*Deflate_state)(unsafe.Pointer(s)).Fw_size)) {
		// Slide the window down.
		*(*int32)(unsafe.Pointer(s + 92 /* &.block_start */)) -= int32((uint32((*Deflate_state)(unsafe.Pointer(s)).Fw_size)))
		*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fw_size)
		libc.Xmemcpy(tls, (*Deflate_state)(unsafe.Pointer(s)).Fwindow, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fw_size)), (*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatches < UInt(2) {
			(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
		} // add a pending slide_hash()
		have = have + ((*Deflate_state)(unsafe.Pointer(s)).Fw_size) // more space now
	}
	if have > (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in {
		have = (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in
	}
	if have != 0 {
		read_buf(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)), have)
		*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) += (have)
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Fhigh_water < Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) {
		(*Deflate_state)(unsafe.Pointer(s)).Fhigh_water = Ulg((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
	}

	// There was not enough avail_out to write a complete worthy or flushed
	// stored block to next_out. Write a stored block to pending instead, if we
	// have enough input for a worthy block, or if flushing and there is enough
	// room for the remaining input as a stored block in the pending buffer.
	have = (uint32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_valid + 42) >> 3)) // number of header bytes
	// maximum stored block length that will fit in pending:
	have = func() uint32 {
		if ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(have)) > (Ulg(MAX_STORED)) {
			return uint32(MAX_STORED)
		}
		return (uint32((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf_size - Ulg(have)))
	}()
	min_block = func() uint32 {
		if (have) > ((*Deflate_state)(unsafe.Pointer(s)).Fw_size) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fw_size
		}
		return have
	}()
	left = (uint32(uint32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
	if (left >= min_block) || (((((left != 0) || (flush == Z_FINISH)) && (flush != Z_NO_FLUSH)) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (left <= have)) {
		len = func() uint32 {
			if (left) > (have) {
				return have
			}
			return left
		}()
		if ((flush == Z_FINISH) && ((*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_in == UInt(0))) && (len == left) {
			last = uint32(1)
		} else {
			last = uint32(0)
		}
		X_tr_stored_block(tls, s, ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), uint32(len), int32(last))
		*(*int32)(unsafe.Pointer(s + 92 /* &.block_start */)) += int32((uint32(len)))
		flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
	}

	// We've done all we can with the available input and output.
	if last != 0 {
		return Finish_started
	}
	return Need_more
}

// ===========================================================================
// Compress as much as possible from the input stream, return the current
// block state.
// This function does not perform lazy evaluation of matches and inserts
// new strings in the dictionary only for unmatched strings or for short
// matches. It is used only for the fast compression options.
func deflate_fast(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1824:19: */
	var hash_head IPos // head of the hash chain
	var bflush int32   // set if current block must be flushed

	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the next match, plus MIN_MATCH bytes to insert the
		// string following the next match.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1)) {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// Insert the string window[strstart .. strstart+2] in the
		// dictionary, and set hash_head to the head of the hash chain:
		hash_head = IPos(NIL)
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= UInt(MIN_MATCH) {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		}

		// Find the longest match, discarding those <= prev_length.
		// At this point we have always match_length < MIN_MATCH
		if (hash_head != IPos(NIL)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - hash_head) <= ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {
			// To simplify the code, we prevent matches with the string
			// of window index 0 (in particular we have to avoid a match
			// of the string with itself at the start of the input file).
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = longest_match(tls, s, hash_head)
			// longest_match() sets match_start
		}
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length >= UInt(MIN_MATCH) {

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length - UInt(MIN_MATCH)))
				var dist Ush = (Ush((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2440 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			*(*UInt)(unsafe.Pointer(s + 116 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)

			// Insert new strings in the hash table only if the match length
			// is not too large. This saves time but degrades compression.
			if ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= (*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match) && ((*Deflate_state)(unsafe.Pointer(s)).Flookahead >= UInt(MIN_MATCH)) {
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length-- // string at strstart already in table
				for ok := true; ok; ok = (libc.PreDecUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length, 1) != UInt(0)) {
					(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
					(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
					hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					// strstart never exceeds WSIZE-MAX_MATCH, so there are
					// always MIN_MATCH bytes ahead.
				}
				(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			} else {
				*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart))))
				(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + UInt(1)))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
				// If lookahead < MIN_MATCH, ins_h is garbage, but it does not
				// matter since it will be recomputed at next deflate call.
			}
		} else {
			// No match, output a literal byte

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		}
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = func() uint32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart < (UInt(MIN_MATCH - 1)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		}
		return (uint32(MIN_MATCH - 1))
	}()
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return uintptr(Z_NULL)
			}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// Same as above, but achieves better compression. We use a lazy
// evaluation for matches: a match is finally adopted only if there is
// no better match at the next window position.
func deflate_slow(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:1926:19: */
	var hash_head IPos // head of hash chain
	var bflush int32   // set if current block must be flushed

	// Process the input block.
	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the next match, plus MIN_MATCH bytes to insert the
		// string following the next match.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1)) {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead < (UInt((MAX_MATCH + MIN_MATCH) + 1))) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// Insert the string window[strstart .. strstart+2] in the
		// dictionary, and set hash_head to the head of the hash chain:
		hash_head = IPos(NIL)
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead >= UInt(MIN_MATCH) {
			(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
			hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
			*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
		}

		// Find the longest match, discarding those <= prev_length.
		(*Deflate_state)(unsafe.Pointer(s)).Fprev_length = (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length
		(*Deflate_state)(unsafe.Pointer(s)).Fprev_match = (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))

		if ((hash_head != IPos(NIL)) && ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length < (*Deflate_state)(unsafe.Pointer(s)).Fmax_lazy_match)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - hash_head) <= ((*Deflate_state)(unsafe.Pointer((s))).Fw_size - (UInt((MAX_MATCH + MIN_MATCH) + 1)))) {
			// To simplify the code, we prevent matches with the string
			// of window index 0 (in particular we have to avoid a match
			// of the string with itself at the start of the input file).
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = longest_match(tls, s, hash_head)
			// longest_match() sets match_start

			if ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= UInt(5)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_FILTERED) ||
				(((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length == UInt(MIN_MATCH)) && (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - (*Deflate_state)(unsafe.Pointer(s)).Fmatch_start) > UInt(TOO_FAR)))) {

				// If prev_match is also MIN_MATCH, match_start is garbage
				// but we will ignore the current match anyway.
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))
			}
		}
		// If there was a match at the previous step and the current
		// match is not better, output the previous match:
		if ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length >= UInt(MIN_MATCH)) && ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length <= (*Deflate_state)(unsafe.Pointer(s)).Fprev_length) {
			var max_insert UInt = (((*Deflate_state)(unsafe.Pointer(s)).Fstrstart + (*Deflate_state)(unsafe.Pointer(s)).Flookahead) - UInt(MIN_MATCH))
			// Do not insert strings in hash table beyond this.

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fprev_length - UInt(MIN_MATCH)))
				var dist Ush = (Ush(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)) - (*Deflate_state)(unsafe.Pointer(s)).Fprev_match))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2440 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			// Insert in hash table all strings up to the end of the match.
			// strstart-1 and strstart are already inserted. If there is not
			// enough lookahead, the last two strings are not inserted in
			// the hash table.
			*(*UInt)(unsafe.Pointer(s + 116 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fprev_length - UInt(1))
			*(*UInt)(unsafe.Pointer(s + 120 /* &.prev_length */)) -= (UInt(2))
			for ok := true; ok; ok = (libc.PreDecUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fprev_length, 1) != UInt(0)) {
				if libc.PreIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fstrstart, 1) <= max_insert {
					(*Deflate_state)(unsafe.Pointer(s)).Fins_h = (((((*Deflate_state)(unsafe.Pointer(s)).Fins_h) << (*Deflate_state)(unsafe.Pointer(s)).Fhash_shift) ^ (UInt(*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) + (UInt(MIN_MATCH - 1))))))))) & (*Deflate_state)(unsafe.Pointer(s)).Fhash_mask)
					hash_head = IPos(libc.AssignPtrUint16((*Deflate_state)(unsafe.Pointer(s)).Fprev+uintptr((((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)&(*Deflate_state)(unsafe.Pointer(s)).Fw_mask))*2, *(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2))))
					*(*Posf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fhead + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fins_h)*2)) = Pos((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				}
			}
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MIN_MATCH - 1))
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++

			if bflush != 0 {
				{
					X_tr_flush_block(tls, s, func() uintptr {
						if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
							return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
						}
						return uintptr(Z_NULL)
					}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
					(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
				}
				if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
					if 0 != 0 {
						return Finish_started
					}
					return Need_more
				}
			}

		} else if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_available != 0 {
			// If there was no match at the previous position, output a
			// single literal. If there was a match but the current match
			// is longer, truncate the previous match to a single literal.

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)))))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			if bflush != 0 {
				{
					X_tr_flush_block(tls, s, func() uintptr {
						if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
							return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
						}
						return uintptr(Z_NULL)
					}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
					(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
					flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				return Need_more
			}
		} else {
			// There is no previous match to compare with, wait for
			// the next step to decide.
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 1
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
		}
	}

	if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_available != 0 {

		{
			var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(((*Deflate_state)(unsafe.Pointer(s)).Fstrstart - UInt(1)))))
			*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
			*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
			*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
			bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
		}

		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_available = 0
	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = func() uint32 {
		if (*Deflate_state)(unsafe.Pointer(s)).Fstrstart < (UInt(MIN_MATCH - 1)) {
			return (*Deflate_state)(unsafe.Pointer(s)).Fstrstart
		}
		return (uint32(MIN_MATCH - 1))
	}()
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return uintptr(Z_NULL)
			}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// For Z_RLE, simply look for runs of bytes, generate matches only of distance
// one.  Do not maintain a hash table.  (It will be regenerated if this run of
// deflate switches away from Z_RLE.)
func deflate_rle(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:2057:19: */
	var bflush int32 // set if current block must be flushed
	var prev UInt    // byte at distance one to match
	var scan uintptr
	var strend uintptr // scan goes up to strend for length of run

	for {
		// Make sure that we always have enough lookahead, except
		// at the end of the input file. We need MAX_MATCH bytes
		// for the longest run, plus one for the unrolled loop.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead <= UInt(MAX_MATCH) {
			fill_window(tls, s)
			if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead <= UInt(MAX_MATCH)) && (flush == Z_NO_FLUSH) {
				return Need_more
			}
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				break
			} // flush the current block
		}

		// See how many times the previous byte repeats
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
		if ((*Deflate_state)(unsafe.Pointer(s)).Flookahead >= UInt(MIN_MATCH)) && ((*Deflate_state)(unsafe.Pointer(s)).Fstrstart > UInt(0)) {
			scan = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) - uintptr(1))
			prev = UInt(*(*Bytef)(unsafe.Pointer(scan)))
			if ((prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) {
				strend = (((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)) + uintptr(MAX_MATCH))
				for ok := true; ok; ok = (((((((((prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (prev == UInt(*(*Bytef)(unsafe.Pointer(libc.PreIncUintptr(&scan, 1)))))) && (scan < strend)) {
				}
				(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (UInt(MAX_MATCH) - (UInt((int32(strend) - int32(scan)) / 1)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length > (*Deflate_state)(unsafe.Pointer(s)).Flookahead {
					(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = (*Deflate_state)(unsafe.Pointer(s)).Flookahead
				}
			}

		}

		// Emit match if have run of MIN_MATCH or longer, else emit literal
		if (*Deflate_state)(unsafe.Pointer(s)).Fmatch_length >= UInt(MIN_MATCH) {

			{
				var len Uch = (Uch((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length - UInt(MIN_MATCH)))
				var dist Ush = Ush(1)
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = dist
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = len
				dist--
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[len])+LITERALS)+1))*4 /* &.fc */))++
				*(*Ush)(unsafe.Pointer((s + 2440 /* &.dyn_dtree */) + uintptr((func() int32 {
					if (int32(dist)) < 256 {
						return int32(X_dist_code[dist])
					}
					return int32(X_dist_code[(256 + ((int32(dist)) >> 7))])
				}()))*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			*(*UInt)(unsafe.Pointer(s + 116 /* &.lookahead */)) -= ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
			*(*UInt)(unsafe.Pointer(s + 108 /* &.strstart */)) += ((*Deflate_state)(unsafe.Pointer(s)).Fmatch_length)
			(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)
		} else {
			// No match, output a literal byte

			{
				var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
				*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
				*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
				*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
				bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
			}

			(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
			(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		}
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return uintptr(Z_NULL)
			}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// ===========================================================================
// For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
// (It will be regenerated if this run of deflate switches away from Huffman.)
func deflate_huff(tls *libc.TLS, s uintptr, flush int32) Block_state { /* deflate.c:2130:19: */
	var bflush int32 // set if current block must be flushed

	for {
		// Make sure that we have a literal to write.
		if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
			fill_window(tls, s)
			if (*Deflate_state)(unsafe.Pointer(s)).Flookahead == UInt(0) {
				if flush == Z_NO_FLUSH {
					return Need_more
				}
				break // flush the current block
			}
		}

		// Output a literal byte
		(*Deflate_state)(unsafe.Pointer(s)).Fmatch_length = UInt(0)

		{
			var cc Uch = *(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)))
			*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ushf(0)
			*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = cc
			*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(cc)*4 /* &.fc */))++
			bflush = (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
		}

		(*Deflate_state)(unsafe.Pointer(s)).Flookahead--
		(*Deflate_state)(unsafe.Pointer(s)).Fstrstart++
		if bflush != 0 {
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 0 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Finsert = UInt(0)
	if flush == Z_FINISH {
		{
			{
				X_tr_flush_block(tls, s, func() uintptr {
					if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
						return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
					}
					return uintptr(Z_NULL)
				}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 1)
				(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
				flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
			}
			if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
				if 1 != 0 {
					return Finish_started
				}
				return Need_more
			}
		}

		return Finish_done
	}
	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != 0 {
		{
			X_tr_flush_block(tls, s, func() uintptr {
				if (*Deflate_state)(unsafe.Pointer(s)).Fblock_start >= 0 {
					return ((*Deflate_state)(unsafe.Pointer(s)).Fwindow + uintptr(uint32((*Deflate_state)(unsafe.Pointer(s)).Fblock_start)))
				}
				return uintptr(Z_NULL)
			}(), (Ulg(int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart) - (*Deflate_state)(unsafe.Pointer(s)).Fblock_start)), 0)
			(*Deflate_state)(unsafe.Pointer(s)).Fblock_start = int32((*Deflate_state)(unsafe.Pointer(s)).Fstrstart)
			flush_pending(tls, (*Deflate_state)(unsafe.Pointer(s)).Fstrm)
		}
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Favail_out == UInt(0) {
			if 0 != 0 {
				return Finish_started
			}
			return Need_more
		}
	}

	return Block_done
}

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type X__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type X_G_fpos_t = struct {
	F__pos   X__off_t
	F__state X__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type X__fpos_t = X_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type X_G_fpos64_t = struct {
	F__pos   X__off64_t
	F__state X__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type X__fpos64_t = X_G_fpos64_t /* __fpos64_t.h:14:3 */

type X_IO_FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     X__off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         X__off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          Size_t
	F_mode           int32
	F_unused2        [40]int8
} /* __FILE.h:4:1 */

type X__FILE = X_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = X_IO_FILE /* FILE.h:7:25 */

type Off_t1 = X__off_t /* stdio.h:63:17 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Fpos_t = X__fpos_t     /* stdio.h:84:18 */
type Fpos64_t = X__fpos64_t /* stdio.h:89:20 */

type Ino_t1 = X__ino_t /* types.h:47:17 */

// Types from the Large File Support interface.
type Blkcnt_t1 = X__blkcnt_t     /* types.h:209:20 */ // Type to count number of disk blocks.
type Fsblkcnt_t1 = X__fsblkcnt_t /* types.h:213:22 */ // Type to count file system blocks.
type Fsfilcnt_t1 = X__fsfilcnt_t /* types.h:217:22 */

type Flock64 = struct {
	Fl_type   int16
	Fl_whence int16
	Fl_start  X__off64_t
	Fl_len    X__off64_t
	Fl_pid    X__pid_t
} /* fcntl.h:50:1 */

// Note stat64 has the same shape as stat for x86-64.
type Stat64 = struct {
	Fst_dev     X__dev_t
	F__pad1     uint32
	F__st_ino   X__ino_t
	Fst_mode    X__mode_t
	Fst_nlink   X__nlink_t
	Fst_uid     X__uid_t
	Fst_gid     X__gid_t
	Fst_rdev    X__dev_t
	F__pad2     uint32
	Fst_size    X__off64_t
	Fst_blksize X__blksize_t
	Fst_blocks  X__blkcnt64_t
	Fst_atim    struct {
		Ftv_sec  X__time_t
		Ftv_nsec X__syscall_slong_t
	}
	Fst_mtim struct {
		Ftv_sec  X__time_t
		Ftv_nsec X__syscall_slong_t
	}
	Fst_ctim struct {
		Ftv_sec  X__time_t
		Ftv_nsec X__syscall_slong_t
	}
	Fst_ino X__ino64_t
} /* stat.h:119:1 */

// provide prototypes for these when building zlib without LFS

// default memLevel

// default i/o buffer size -- double this for output when reading (this and
//    twice this must be able to fit in an unsigned type)

// gzip modes, also provide a little integrity check on the passed structure

// values for gz_state how

// internal gzip file state data structure
type Gz_state = struct {
	Fx        GzFile_s
	Fmode     int32
	Ffd       int32
	Fpath     uintptr
	Fsize     uint32
	Fwant     uint32
	Fin       uintptr
	Fout      uintptr
	Fdirect   int32
	Fhow      int32
	Fstart    Off64_t
	Feof      int32
	Fpast     int32
	Flevel    int32
	Fstrategy int32
	Fskip     Off64_t
	Fseek     int32
	Ferr      int32
	Fmsg      uintptr
	Fstrm     Z_stream
}                        /* gzguts.h:201:3 */
type Gz_statep = uintptr /* gzguts.h:202:22 */

// GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
//    value -- needed when comparing unsigned to z_off64_t, which is signed
//    (possible z_off64_t types off_t, off64_t, and long are all signed)

// gzclose() is in a separate file so that it is linked in only if it is used.
//    That way the other gzclose functions can be used instead to avoid linking in
//    unneeded compression or decompression routines.
func Xgzclose(tls *libc.TLS, file GzFile) int32 { /* gzclose.c:11:13: */
	var state Gz_statep

	if file == (uintptr(0)) {
		return -2
	}
	state = file

	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		return Xgzclose_r(tls, file)
	}
	return Xgzclose_w(tls, file)
}

// Reset gzip file state
func gz_reset(tls *libc.TLS, state Gz_statep) { /* gzlib.c:75:12: */
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)  // no output data available
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ { // for reading ...
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0    // not at end of file
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0   // have not read past end yet
		(*Gz_state)(unsafe.Pointer(state)).Fhow = LOOK // look for gzip header
	}
	(*Gz_state)(unsafe.Pointer(state)).Fseek = 0                 // no seek request pending
	Xgz_error(tls, state, Z_OK, uintptr(0))                      // clear error
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos = int64(0)        // no uncompressed data yet
	(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0) // no input data yet
}

// Open a gzip file either by name or file descriptor.
func gz_open(tls *libc.TLS, path uintptr, fd int32, mode uintptr) GzFile { /* gzlib.c:91:14: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var state Gz_statep
	var len Z_size_t
	var oflag int32
	var cloexec int32 = 0
	var exclusive int32 = 0

	// check input
	if path == (uintptr(0)) {
		return uintptr(0)
	}

	// allocate gzFile structure to return
	state = libc.Xmalloc(tls, uint32(unsafe.Sizeof(Gz_state{})))
	if state == (uintptr(0)) {
		return uintptr(0)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fsize = uint32(0)         // no buffers allocated yet
	(*Gz_state)(unsafe.Pointer(state)).Fwant = uint32(GZBUFSIZE) // requested buffer size
	(*Gz_state)(unsafe.Pointer(state)).Fmsg = uintptr(0)         // no error message yet

	// interpret mode
	(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_NONE
	(*Gz_state)(unsafe.Pointer(state)).Flevel = -1
	(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_DEFAULT_STRATEGY
	(*Gz_state)(unsafe.Pointer(state)).Fdirect = 0
	for *(*int8)(unsafe.Pointer(mode)) != 0 {
		if (int32(*(*int8)(unsafe.Pointer(mode))) >= '0') && (int32(*(*int8)(unsafe.Pointer(mode))) <= '9') {
			(*Gz_state)(unsafe.Pointer(state)).Flevel = (int32(*(*int8)(unsafe.Pointer(mode))) - '0')
		} else {
			switch int32(*(*int8)(unsafe.Pointer(mode))) {
			case 'r':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_READ
				break
				fallthrough
			case 'w':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_WRITE
				break
				fallthrough
			case 'a':
				(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_APPEND
				break
				fallthrough
			case '+': // can't read and write at the same time
				libc.Xfree(tls, state)
				return uintptr(0)
				fallthrough
			case 'b': // ignore -- will request binary anyway
				break
				fallthrough
			case 'e':
				cloexec = 1
				break
				fallthrough
			case 'x':
				exclusive = 1
				break
				fallthrough
			case 'f':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_FILTERED
				break
				fallthrough
			case 'h':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_HUFFMAN_ONLY
				break
				fallthrough
			case 'R':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_RLE
				break
				fallthrough
			case 'F':
				(*Gz_state)(unsafe.Pointer(state)).Fstrategy = Z_FIXED
				break
				fallthrough
			case 'T':
				(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1
				break
				fallthrough
			default: // could consider as an error, but just ignore

			}
		}
		mode++
	}

	// must provide an "r", "w", or "a"
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_NONE {
		libc.Xfree(tls, state)
		return uintptr(0)
	}

	// can't force transparent read
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		if (*Gz_state)(unsafe.Pointer(state)).Fdirect != 0 {
			libc.Xfree(tls, state)
			return uintptr(0)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1 // for empty file
	}

	// save the path name for error messages
	len = libc.Xstrlen(tls, path)
	(*Gz_state)(unsafe.Pointer(state)).Fpath = libc.Xmalloc(tls, (len + Z_size_t(1)))
	if (*Gz_state)(unsafe.Pointer(state)).Fpath == (uintptr(0)) {
		libc.Xfree(tls, state)
		return uintptr(0)
	}
	libc.Xsnprintf(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath, (len + Z_size_t(1)), ts+76 /* "%s" */, libc.VaList(bp, path))

	// compute the flags for open()
	oflag = ((0100000 | (func() int32 {
		if cloexec != 0 {
			return 02000000
		}
		return 0
	}())) | (func() int32 {
		if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
			return O_RDONLY
		}
		return (((O_WRONLY | O_CREAT) | (func() int32 {
			if exclusive != 0 {
				return O_EXCL
			}
			return 0
		}())) | (func() int32 {
			if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_WRITE {
				return O_TRUNC
			}
			return O_APPEND
		}()))
	}()))

	// open the file with the appropriate flags (or just use fd)
	(*Gz_state)(unsafe.Pointer(state)).Ffd = func() int32 {
		if fd > -1 {
			return fd
		}
		return libc.Xopen(tls, path, oflag, libc.VaList(bp+8, 0666))
	}()
	if (*Gz_state)(unsafe.Pointer(state)).Ffd == -1 {
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
		libc.Xfree(tls, state)
		return uintptr(0)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_APPEND {
		libc.Xlseek64(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_END) // so gzoffset() is correct
		(*Gz_state)(unsafe.Pointer(state)).Fmode = GZ_WRITE                            // simplify later checks
	}

	// save the current position for rewinding (only if reading)
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		(*Gz_state)(unsafe.Pointer(state)).Fstart = libc.Xlseek64(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_CUR)
		if (*Gz_state)(unsafe.Pointer(state)).Fstart == int64(-1) {
			(*Gz_state)(unsafe.Pointer(state)).Fstart = int64(0)
		}
	}

	// initialize stream
	gz_reset(tls, state)

	// return stream
	return state
}

// -- see zlib.h --
func Xgzopen(tls *libc.TLS, path uintptr, mode uintptr) GzFile { /* gzlib.c:270:16: */
	return gz_open(tls, path, -1, mode)
}

// -- see zlib.h --
func Xgzopen64(tls *libc.TLS, path uintptr, mode uintptr) GzFile { /* gzlib.c:278:16: */
	return gz_open(tls, path, -1, mode)
}

// -- see zlib.h --
func Xgzdopen(tls *libc.TLS, fd int32, mode uintptr) GzFile { /* gzlib.c:286:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var path uintptr // identifier for error messages
	var gz GzFile

	if (fd == -1) || ((libc.AssignUintptr(&path, libc.Xmalloc(tls, (uint32(7)+(uint32(3)*uint32(unsafe.Sizeof(int32(0)))))))) == (uintptr(0))) {
		return uintptr(0)
	}
	libc.Xsnprintf(tls, path, (uint32(7) + (uint32(3) * uint32(unsafe.Sizeof(int32(0))))), ts+79 /* "<fd:%d>" */, libc.VaList(bp, fd))
	gz = gz_open(tls, path, fd, mode)
	libc.Xfree(tls, path)
	return gz
}

// -- see zlib.h --

// -- see zlib.h --
func Xgzbuffer(tls *libc.TLS, file GzFile, size uint32) int32 { /* gzlib.c:316:13: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return -1
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return -1
	}

	// make sure we haven't already allocated memory
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != uint32(0) {
		return -1
	}

	// check and set requested size
	if (size << 1) < size {
		return -1
	} // need to be able to double it
	if size < uint32(2) {
		size = uint32(2)
	} // need two bytes to check magic header
	(*Gz_state)(unsafe.Pointer(state)).Fwant = size
	return 0
}

// -- see zlib.h --
func Xgzrewind(tls *libc.TLS, file GzFile) int32 { /* gzlib.c:343:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// back up and start over
	if libc.Xlseek64(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Gz_state)(unsafe.Pointer(state)).Fstart, SEEK_SET) == int64(-1) {
		return -1
	}
	gz_reset(tls, state)
	return 0
}

// -- see zlib.h --
func Xgzseek64(tls *libc.TLS, file GzFile, offset Off64_t, whence int32) Off64_t { /* gzlib.c:366:19: */
	var n uint32
	var ret Off64_t
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// check that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return int64(-1)
	}

	// can only seek from start or relative to current position
	if (whence != SEEK_SET) && (whence != SEEK_CUR) {
		return int64(-1)
	}

	// normalize offset to a SEEK_CUR specification
	if whence == SEEK_SET {
		offset = offset - ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos)
	} else if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		offset = offset + ((*Gz_state)(unsafe.Pointer(state)).Fskip)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fseek = 0

	// if within raw area while reading, just go there
	if (((*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fhow == COPY1)) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + offset) >= int64(0)) {
		ret = libc.Xlseek64(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (offset - Off64_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave)), SEEK_CUR)
		if ret == int64(-1) {
			return int64(-1)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		Xgz_error(tls, state, Z_OK, uintptr(0))
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0)
		*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (offset)
		return (*Gz_state)(unsafe.Pointer(state)).Fx.Fpos
	}

	// calculate skip amount, rewinding if needed for back seek when reading
	if offset < int64(0) {
		if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ { // writing -- can't go backwards
			return int64(-1)
		}
		offset = offset + ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos)
		if offset < int64(0) { // before start of file!
			return int64(-1)
		}
		if Xgzrewind(tls, file) == -1 { // rewind, then skip to offset
			return int64(-1)
		}
	}

	// if reading, skip what's in output buffer (one less gzgetc() check)
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		if ((uint32(unsafe.Sizeof(int32(0))) == uint32(unsafe.Sizeof(Off64_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > uint32(0x7fffffff))) || (Off64_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > offset) {
			n = uint32(offset)
		} else {
			n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
		}
		*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
		*(*uintptr)(unsafe.Pointer(state /* &.x */ + 4 /* &.next */)) += (uintptr(n))
		*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(n))
		offset = offset - (Off64_t(n))
	}

	// request skip (if not zero)
	if offset != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 1
		(*Gz_state)(unsafe.Pointer(state)).Fskip = offset
	}
	return ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + offset)
}

// -- see zlib.h --
func Xgzseek(tls *libc.TLS, file GzFile, offset Off_t1, whence int32) Off_t1 { /* gzlib.c:443:17: */
	var ret Off64_t

	ret = Xgzseek64(tls, file, Off64_t(offset), whence)
	if ret == Off64_t(Off_t1(ret)) {
		return Off_t1(ret)
	}
	return -1
}

// -- see zlib.h --
func Xgztell64(tls *libc.TLS, file GzFile) Off64_t { /* gzlib.c:455:19: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// return position
	return ((*Gz_state)(unsafe.Pointer(state)).Fx.Fpos + (func() int64 {
		if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
			return (*Gz_state)(unsafe.Pointer(state)).Fskip
		}
		return int64(0)
	}()))
}

// -- see zlib.h --
func Xgztell(tls *libc.TLS, file GzFile) Off_t1 { /* gzlib.c:472:17: */
	var ret Off64_t

	ret = Xgztell64(tls, file)
	if ret == Off64_t(Off_t1(ret)) {
		return Off_t1(ret)
	}
	return -1
}

// -- see zlib.h --
func Xgzoffset64(tls *libc.TLS, file GzFile) Off64_t { /* gzlib.c:482:19: */
	var offset Off64_t
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return int64(-1)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return int64(-1)
	}

	// compute and return effective offset in file
	offset = libc.Xlseek64(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, int64(0), SEEK_CUR)
	if offset == int64(-1) {
		return int64(-1)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ { // reading
		offset = offset - (Off64_t((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in))
	} // don't count buffered input
	return offset
}

// -- see zlib.h --
func Xgzoffset(tls *libc.TLS, file GzFile) Off_t1 { /* gzlib.c:505:17: */
	var ret Off64_t

	ret = Xgzoffset64(tls, file)
	if ret == Off64_t(Off_t1(ret)) {
		return Off_t1(ret)
	}
	return -1
}

// -- see zlib.h --
func Xgzeof(tls *libc.TLS, file GzFile) int32 { /* gzlib.c:515:13: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return 0
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return 0
	}

	// return end-of-file state
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		return (*Gz_state)(unsafe.Pointer(state)).Fpast
	}
	return 0
}

// -- see zlib.h --
func Xgzerror(tls *libc.TLS, file GzFile, errnum uintptr) uintptr { /* gzlib.c:532:12: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return uintptr(0)
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return uintptr(0)
	}

	// return error information
	if errnum != (uintptr(0)) {
		*(*int32)(unsafe.Pointer(errnum)) = (*Gz_state)(unsafe.Pointer(state)).Ferr
	}
	if (*Gz_state)(unsafe.Pointer(state)).Ferr == (-4) {
		return ts + 87 /* "out of memory" */
	}
	return func() uintptr {
		if (*Gz_state)(unsafe.Pointer(state)).Fmsg == (uintptr(0)) {
			return ts + 101 /* "" */
		}
		return (*Gz_state)(unsafe.Pointer(state)).Fmsg
	}()
}

// -- see zlib.h --
func Xgzclearerr(tls *libc.TLS, file GzFile) { /* gzlib.c:553:14: */
	var state Gz_statep

	// get internal structure and check integrity
	if file == (uintptr(0)) {
		return
	}
	state = file
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) {
		return
	}

	// clear error and end-of-file
	if (*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ {
		(*Gz_state)(unsafe.Pointer(state)).Feof = 0
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
}

// Create an error message in allocated memory and set state->err and
//    state->msg accordingly.  Free any previous error message already there.  Do
//    not try to free or allocate space if the error is Z_MEM_ERROR (out of
//    memory).  Simply save the error message as a static string.  If there is an
//    allocation failure constructing the error message, then convert the error to
//    out of memory.
func Xgz_error(tls *libc.TLS, state Gz_statep, err int32, msg uintptr) { /* gzlib.c:579:20: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// free previously allocated message and clear
	if (*Gz_state)(unsafe.Pointer(state)).Fmsg != (uintptr(0)) {
		if (*Gz_state)(unsafe.Pointer(state)).Ferr != (-4) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fmsg)
		}
		(*Gz_state)(unsafe.Pointer(state)).Fmsg = uintptr(0)
	}

	// if fatal, set state->x.have to 0 so that the gzgetc() macro fails
	if (err != Z_OK) && (err != (-5)) {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
	}

	// set error code, and if no message, then done
	(*Gz_state)(unsafe.Pointer(state)).Ferr = err
	if msg == (uintptr(0)) {
		return
	}

	// for an out of memory error, return literal string when requested
	if err == (-4) {
		return
	}

	// construct error message with path
	if (libc.AssignPtrUintptr(state+92 /* &.msg */, libc.Xmalloc(tls, ((libc.Xstrlen(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)+libc.Xstrlen(tls, msg))+Size_t(3))))) == (uintptr(0)) {
		(*Gz_state)(unsafe.Pointer(state)).Ferr = -4
		return
	}
	libc.Xsnprintf(tls, (*Gz_state)(unsafe.Pointer(state)).Fmsg, ((libc.Xstrlen(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath) + libc.Xstrlen(tls, msg)) + Size_t(3)),
		ts+102 /* "%s%s%s" */, libc.VaList(bp, (*Gz_state)(unsafe.Pointer(state)).Fpath, ts+109 /* ": " */, msg))
}

// Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
//    state->fd, and update state->eof, state->err, and state->msg as appropriate.
//    This function needs to loop on read(), since read() is not guaranteed to
//    read the number of bytes requested, depending on the type of descriptor.
func gz_load(tls *libc.TLS, state Gz_statep, buf uintptr, len uint32, have uintptr) int32 { /* gzread.c:21:11: */
	var ret int32
	var get uint32
	var max uint32 = ((uint32(libc.Uint32(libc.Uint32FromInt32(-1))) >> 2) + uint32(1))

	*(*uint32)(unsafe.Pointer(have)) = uint32(0)
	for ok := true; ok; ok = (*(*uint32)(unsafe.Pointer(have)) < len) {
		get = (len - *(*uint32)(unsafe.Pointer(have)))
		if get > max {
			get = max
		}
		ret = libc.Xread(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (buf + uintptr(*(*uint32)(unsafe.Pointer(have)))), get)
		if ret <= 0 {
			break
		}
		*(*uint32)(unsafe.Pointer(have)) += (uint32(ret))
	}
	if ret < 0 {
		Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))))
		return -1
	}
	if ret == 0 {
		(*Gz_state)(unsafe.Pointer(state)).Feof = 1
	}
	return 0
}

// Load up input buffer and set eof flag if last data loaded -- return -1 on
//    error, 0 otherwise.  Note that the eof flag is set when the end of the input
//    file is reached, even though there may be unused data in the buffer.  Once
//    that data has been used, no more attempts will be made to read the file.
//    If strm->avail_in != 0, then the current data is moved to the beginning of
//    the input buffer, and then the remainder of the buffer is loaded with the
//    available data from the input file.
func gz_avail(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:56:11: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var got uint32 at bp, 4

	var strm Z_streamp = (state + 96 /* &.strm */)

	if ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return -1
	}
	if (*Gz_state)(unsafe.Pointer(state)).Feof == 0 {
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 { // copy what's there to the start
			var p uintptr = (*Gz_state)(unsafe.Pointer(state)).Fin
			var q uintptr = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
			var n uint32 = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
			for ok := true; ok; ok = libc.PreDecUint32(&n, 1) != 0 {
				*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1)))
			}
		}
		if gz_load(tls, state, ((*Gz_state)(unsafe.Pointer(state)).Fin+uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in)),
			((*Gz_state)(unsafe.Pointer(state)).Fsize-(*Z_stream)(unsafe.Pointer(strm)).Favail_in), bp /* &got */) == -1 {
			return -1
		}
		*(*UInt)(unsafe.Pointer(strm + 4 /* &.avail_in */)) += (*(*uint32)(unsafe.Pointer(bp /* got */)))
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
	}
	return 0
}

// Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
//    If this is the first time in, allocate required memory.  state->how will be
//    left unchanged if there is no more input data available, will be set to COPY
//    if there is no gzip header and direct copying will be performed, or it will
//    be set to GZIP for decompression.  If direct copying, then leftover input
//    data from the input buffer will be copied to the output buffer.  In that
//    case, all further file reads will be directly to either the output buffer or
//    a user buffer.  If decompressing, the inflate state will be initialized.
//    gz_look() will return 0 on success or -1 on failure.
func gz_look(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:91:11: */
	var strm Z_streamp = (state + 96 /* &.strm */)

	// allocate read buffers and inflate memory
	if (*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0) {
		// allocate buffers
		(*Gz_state)(unsafe.Pointer(state)).Fin = libc.Xmalloc(tls, (*Gz_state)(unsafe.Pointer(state)).Fwant)
		(*Gz_state)(unsafe.Pointer(state)).Fout = libc.Xmalloc(tls, ((*Gz_state)(unsafe.Pointer(state)).Fwant << 1))
		if ((*Gz_state)(unsafe.Pointer(state)).Fin == (uintptr(0))) || ((*Gz_state)(unsafe.Pointer(state)).Fout == (uintptr(0))) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		(*Gz_state)(unsafe.Pointer(state)).Fsize = (*Gz_state)(unsafe.Pointer(state)).Fwant

		// allocate inflate memory
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fzalloc = Alloc_func(Z_NULL)
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fzfree = Free_func(Z_NULL)
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fopaque = Voidpf(Z_NULL)
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = UInt(0)
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = uintptr(Z_NULL)
		if (XinflateInit2_(tls, (state+96 /* &.strm */), (15+16), ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{}))) != Z_OK) { // gunzip
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			(*Gz_state)(unsafe.Pointer(state)).Fsize = uint32(0)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
	}

	// get at least the magic bytes in the input buffer
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in < UInt(2) {
		if gz_avail(tls, state) == -1 {
			return -1
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			return 0
		}
	}

	// look for gzip magic bytes -- if there, do gzip decoding (note: there is
	//        a logical dilemma here when considering the case of a partially written
	//        gzip file, to wit, if a single 31 byte is written, then we cannot tell
	//        whether this is a single-byte file, or just a partially written gzip
	//        file -- for here we assume that if a gzip file is being written, then
	//        the header will be written in a single operation, so that reading a
	//        single byte is sufficient indication that it is not a gzip file)
	if (((*Z_stream)(unsafe.Pointer(strm)).Favail_in > UInt(1)) && (int32(*(*Bytef)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fnext_in))) == 31)) && (int32(*(*Bytef)(unsafe.Pointer((*Z_stream)(unsafe.Pointer(strm)).Fnext_in + 1))) == 139) {
		XinflateReset(tls, strm)
		(*Gz_state)(unsafe.Pointer(state)).Fhow = /* GZIP */ 2
		(*Gz_state)(unsafe.Pointer(state)).Fdirect = 0
		return 0
	}

	// no gzip header -- if we were decoding gzip before, then this is trailing
	//        garbage.  Ignore the trailing garbage and finish.
	if (*Gz_state)(unsafe.Pointer(state)).Fdirect == 0 {
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = UInt(0)
		(*Gz_state)(unsafe.Pointer(state)).Feof = 1
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		return 0
	}

	// doing raw i/o, copy any leftover input to output -- this assumes that
	//        the output buffer is larger than the input buffer, which also assures
	//        space for gzungetc()
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 {
		libc.Xmemcpy(tls, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, (*Z_stream)(unsafe.Pointer(strm)).Favail_in)
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = UInt(0)
	}
	(*Gz_state)(unsafe.Pointer(state)).Fhow = COPY1
	(*Gz_state)(unsafe.Pointer(state)).Fdirect = 1
	return 0
}

// Decompress from input to the provided next_out and avail_out in the state.
//    On return, state->x.have and state->x.next point to the just decompressed
//    data.  If the gzip stream completes, state->how is reset to LOOK to look for
//    the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
//    on success, -1 on failure.
func gz_decomp(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:175:11: */
	var ret int32 = Z_OK
	var had uint32
	var strm Z_streamp = (state + 96 /* &.strm */)

	// fill output buffer up to end of deflate stream
	had = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	for ok := true; ok; ok = (((*Z_stream)(unsafe.Pointer(strm)).Favail_out != 0) && (ret != Z_STREAM_END)) {
		// get more input for inflate()
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && (gz_avail(tls, state) == -1) {
			return -1
		}
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			Xgz_error(tls, state, -5, ts+112 /* "unexpected end o..." */)
			break
		}

		// decompress and handle errors
		ret = Xinflate(tls, strm, Z_NO_FLUSH)
		if (ret == (-2)) || (ret == Z_NEED_DICT) {
			Xgz_error(tls, state, -2,
				ts+135 /* "internal error: ..." */)
			return -1
		}
		if ret == (-4) {
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		if ret == (-3) { // deflate stream invalid
			Xgz_error(tls, state, -3,
				func() uintptr {
					if (*Z_stream)(unsafe.Pointer(strm)).Fmsg == (uintptr(0)) {
						return ts + 174 /* "compressed data ..." */
					}
					return (*Z_stream)(unsafe.Pointer(strm)).Fmsg
				}())
			return -1
		}
	}

	// update available output
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = (had - (*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave))

	// if the gzip stream completed successfully, look for another
	if ret == Z_STREAM_END {
		(*Gz_state)(unsafe.Pointer(state)).Fhow = LOOK
	}

	// good decompression
	return 0
}

// Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
//    Data is either copied from the input file or decompressed from the input
//    file depending on state->how.  If state->how is LOOK, then a gzip header is
//    looked for to determine whether to copy or decompress.  Returns -1 on error,
//    otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
//    end of the input file has been reached and all data has been processed.
func gz_fetch(tls *libc.TLS, state Gz_statep) int32 { /* gzread.c:229:11: */
	var strm Z_streamp = (state + 96 /* &.strm */)

	for ok := true; ok; ok = (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) && (!((*Gz_state)(unsafe.Pointer(state)).Feof != 0) || ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0))) {
		switch (*Gz_state)(unsafe.Pointer(state)).Fhow {
		case LOOK: // -> LOOK, COPY (only if never GZIP), or GZIP
			if gz_look(tls, state) == -1 {
				return -1
			}
			if (*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK {
				return 0
			}
			break
		case COPY1: // -> COPY
			if gz_load(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fout, ((*Gz_state)(unsafe.Pointer(state)).Fsize<<1), (state /* &.x */ /* &.have */)) ==
				-1 {
				return -1
			}
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
			return 0
		case /* GZIP */ 2: // -> GZIP or LOOK (if end of gzip stream)
			(*Z_stream)(unsafe.Pointer(strm)).Favail_out = ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)
			(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
			if gz_decomp(tls, state) == -1 {
				return -1
			}
		}
	}
	return 0
}

// Skip len uncompressed bytes of output.  Return -1 on error, 0 on success.
func gz_skip(tls *libc.TLS, state Gz_statep, len Off64_t) int32 { /* gzread.c:259:11: */
	var n uint32

	// skip over len bytes or reach end-of-file, whichever comes first
	for len != 0 {
		// skip over whatever is in output buffer
		if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
			if ((uint32(unsafe.Sizeof(int32(0))) == uint32(unsafe.Sizeof(Off64_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > uint32(0x7fffffff))) || (Off64_t((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave) > len) {
				n = uint32(len)
			} else {
				n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 4 /* &.next */)) += (uintptr(n))
			*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(n))
			len = len - (Off64_t(n))
		} else if ((*Gz_state)(unsafe.Pointer(state)).Feof != 0) && ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0)) {
			break
		} else {
			// get more output, looking for header if required
			if gz_fetch(tls, state) == -1 {
				return -1
			}
		}
	}
	return 0
}

// Read len bytes into buf from file, or less than len up to the end of the
//    input.  Return the number of bytes read.  If zero is returned, either the
//    end of file was reached, or there was an error.  state->err must be
//    consulted in that case to determine which.
func gz_read(tls *libc.TLS, state Gz_statep, buf Voidp, len Z_size_t) Z_size_t { /* gzread.c:294:16: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var got Z_size_t
	// var n uint32 at bp, 4

	// if len is zero, avoid unnecessary operations
	if len == Z_size_t(0) {
		return Z_size_t(0)
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return Z_size_t(0)
		}
	}

	// get len bytes to buf, or less than len if at the end
	got = Z_size_t(0)
	for ok := true; ok; ok = len != 0 {
		// set n to the maximum amount of len that fits in an unsigned int
		*(*uint32)(unsafe.Pointer(bp /* n */)) = libc.Uint32FromInt32(-1)
		if *(*uint32)(unsafe.Pointer(bp /* n */)) > len {
			*(*uint32)(unsafe.Pointer(bp /* n */)) = len
		}

		// first just try copying data from the output buffer
		if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave < *(*uint32)(unsafe.Pointer(bp /* n */)) {
				*(*uint32)(unsafe.Pointer(bp /* n */)) = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			libc.Xmemcpy(tls, buf, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, *(*uint32)(unsafe.Pointer(bp /* n */)))
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 4 /* &.next */)) += (uintptr(*(*uint32)(unsafe.Pointer(bp /* n */))))
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (*(*uint32)(unsafe.Pointer(bp /* n */)))
		} else if ((*Gz_state)(unsafe.Pointer(state)).Feof != 0) && ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0)) {
			(*Gz_state)(unsafe.Pointer(state)).Fpast = 1 // tried to read past end
			break
		} else if ((*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK) || (*(*uint32)(unsafe.Pointer(bp /* n */)) < ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)) {
			// get more output, looking for header if required
			if gz_fetch(tls, state) == -1 {
				return Z_size_t(0)
			}
			continue // no progress yet -- go back to copy above
			// the copy above assures that we will leave with space in the
			//                output buffer, allowing at least one gzungetc() to succeed
		} else if (*Gz_state)(unsafe.Pointer(state)).Fhow == COPY1 { // read directly
			if gz_load(tls, state, buf, *(*uint32)(unsafe.Pointer(bp /* n */)), bp /* &n */) == -1 {
				return Z_size_t(0)
			}
		} else { // state->how == GZIP
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_out = *(*uint32)(unsafe.Pointer(bp /* n */))
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_out = buf
			if gz_decomp(tls, state) == -1 {
				return Z_size_t(0)
			}
			*(*uint32)(unsafe.Pointer(bp /* n */)) = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(0)
		}

		// update progress
		len = len - (*(*uint32)(unsafe.Pointer(bp /* n */)))
		buf = (buf + uintptr(*(*uint32)(unsafe.Pointer(bp /* n */))))
		got = got + (*(*uint32)(unsafe.Pointer(bp /* n */)))
		*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(*(*uint32)(unsafe.Pointer(bp /* n */))))
	}

	// return number of bytes read into user buffer
	return got
}

// -- see zlib.h --
func Xgzread(tls *libc.TLS, file GzFile, buf Voidp, len uint32) int32 { /* gzread.c:375:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// since an int is returned, make sure len fits in one, otherwise return
	//        with an error (this avoids a flaw in the interface)
	if int32(len) < 0 {
		Xgz_error(tls, state, -2, ts+196 /* "request does not..." */)
		return -1
	}

	// read len or fewer bytes to buf
	len = gz_read(tls, state, buf, len)

	// check for an error
	if ((len == uint32(0)) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK)) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5)) {
		return -1
	}

	// return the number of bytes read (this is assured to fit in an int)
	return int32(len)
}

// -- see zlib.h --
func Xgzfread(tls *libc.TLS, buf Voidp, size Z_size_t, nitems Z_size_t, file GzFile) Z_size_t { /* gzread.c:411:18: */
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return Z_size_t(0)
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return Z_size_t(0)
	}

	// compute bytes to read -- error on overflow
	len = (nitems * size)
	if (size != 0) && ((len / size) != nitems) {
		Xgz_error(tls, state, -2, ts+227 /* "request does not..." */)
		return Z_size_t(0)
	}

	// read len or fewer bytes to buf, return the number of full items read
	if len != 0 {
		return (gz_read(tls, state, buf, len) / size)
	}
	return uint32(0)
}

// -- see zlib.h --
func Xgzgetc(tls *libc.TLS, file GzFile) int32 { /* gzread.c:447:13: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var ret int32
	// var buf [1]uint8 at bp, 1

	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// try output buffer (no need to check for skip request)
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave--
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos++
		return int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext), 1))))
	}

	// nothing there -- try gz_read()
	ret = int32(gz_read(tls, state, bp /* &buf[0] */, uint32(1)))
	if ret < 1 {
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer(bp /* &buf[0] */)))
}

func Xgzgetc_(tls *libc.TLS, file GzFile) int32 { /* gzread.c:476:13: */
	return Xgzgetc(tls, file)
}

// -- see zlib.h --
func Xgzungetc(tls *libc.TLS, c int32, file GzFile) int32 { /* gzread.c:483:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return -1
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return -1
		}
	}

	// can't push EOF
	if c < 0 {
		return -1
	}

	// if output buffer empty, put byte at end (allows more pushing)
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0) {
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave = uint32(1)
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize << 1))) - uintptr(1))
		*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) = uint8(c)
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos--
		(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
		return c
	}

	// if no room, give up (must have already done a gzungetc())
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == ((*Gz_state)(unsafe.Pointer(state)).Fsize << 1) {
		Xgz_error(tls, state, -3, ts+260 /* "out of room to p..." */)
		return -1
	}

	// slide output data if needed and insert byte before existing data
	if (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext == (*Gz_state)(unsafe.Pointer(state)).Fout {
		var src uintptr = ((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave))
		var dest uintptr = ((*Gz_state)(unsafe.Pointer(state)).Fout + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize << 1)))
		for src > (*Gz_state)(unsafe.Pointer(state)).Fout {
			*(*uint8)(unsafe.Pointer(libc.PreDecUintptr(&dest, 1))) = *(*uint8)(unsafe.Pointer(libc.PreDecUintptr(&src, 1)))
		}
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = dest
	}
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fhave++
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext--
	*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) = uint8(c)
	(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos--
	(*Gz_state)(unsafe.Pointer(state)).Fpast = 0
	return c
}

// -- see zlib.h --
func Xgzgets(tls *libc.TLS, file GzFile, buf uintptr, len int32) uintptr { /* gzread.c:543:6: */
	var left uint32
	var n uint32
	var str uintptr
	var eol uintptr
	var state Gz_statep

	// check parameters and get internal structure
	if ((file == (uintptr(0))) || (buf == (uintptr(0)))) || (len < 1) {
		return uintptr(0)
	}
	state = file

	// check that we're reading and that there's no (serious) error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ) || (((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) && ((*Gz_state)(unsafe.Pointer(state)).Ferr != (-5))) {
		return uintptr(0)
	}

	// process a skip request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_skip(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return uintptr(0)
		}
	}

	// copy output bytes up to new line or len - 1, whichever comes first --
	//        append a terminating zero to the string (we don't check for a zero in
	//        the contents, let the user worry about that)
	str = buf
	left = (uint32(len) - uint32(1))
	if left != 0 {
		for ok := true; ok; ok = ((left != 0) && (eol == (uintptr(0)))) {
			// assure that something is in the output buffer
			if ((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) && (gz_fetch(tls, state) == -1) {
				return uintptr(0)
			} // error
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0) { // end of file
				(*Gz_state)(unsafe.Pointer(state)).Fpast = 1 // read past end
				break                                        // return what we have
			}

			// look for end-of-line in current output buffer
			if (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave > left {
				n = left
			} else {
				n = (*Gz_state)(unsafe.Pointer(state)).Fx.Fhave
			}
			eol = libc.Xmemchr(tls, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, '\n', n)
			if eol != (uintptr(0)) {
				n = ((uint32((int32(eol) - int32((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1)) + uint32(1))
			}

			// copy through end-of-line, or remainder if not found
			libc.Xmemcpy(tls, buf, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, n)
			*(*uint32)(unsafe.Pointer(state /* &.x */ /* &.have */)) -= (n)
			*(*uintptr)(unsafe.Pointer(state /* &.x */ + 4 /* &.next */)) += (uintptr(n))
			*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(n))
			left = left - (n)
			buf += uintptr(n)
		}
	}

	// return terminated string, or if nothing, end of file
	if buf == str {
		return uintptr(0)
	}
	*(*int8)(unsafe.Pointer(buf)) = int8(0)
	return str
}

// -- see zlib.h --
func Xgzdirect(tls *libc.TLS, file GzFile) int32 { /* gzread.c:607:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return 0
	}
	state = file

	// if the state is not known, but we can find out, then do so (this is
	//        mainly for right after a gzopen() or gzdopen())
	if (((*Gz_state)(unsafe.Pointer(state)).Fmode == GZ_READ) && ((*Gz_state)(unsafe.Pointer(state)).Fhow == LOOK)) && ((*Gz_state)(unsafe.Pointer(state)).Fx.Fhave == uint32(0)) {
		gz_look(tls, state)
	}

	// return 1 if transparent, 0 if processing a gzip stream
	return (*Gz_state)(unsafe.Pointer(state)).Fdirect
}

// -- see zlib.h --
func Xgzclose_r(tls *libc.TLS, file GzFile) int32 { /* gzread.c:627:13: */
	var ret int32
	var err int32
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're reading
	if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_READ {
		return -2
	}

	// free memory and close file
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		XinflateEnd(tls, (state + 96 /* &.strm */))
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
	}
	if (*Gz_state)(unsafe.Pointer(state)).Ferr == (-5) {
		err = -5
	} else {
		err = Z_OK
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
	libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
	ret = libc.Xclose(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd)
	libc.Xfree(tls, state)
	if ret != 0 {
		return -1
	}
	return err
}

// Initialize state for writing a gzip file.  Mark initialization by setting
//    state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
//    success.
func gz_init(tls *libc.TLS, state Gz_statep) int32 { /* gzwrite.c:17:11: */
	var ret int32
	var strm Z_streamp = (state + 96 /* &.strm */)

	// allocate input buffer (double size for gzprintf)
	(*Gz_state)(unsafe.Pointer(state)).Fin = libc.Xmalloc(tls, ((*Gz_state)(unsafe.Pointer(state)).Fwant << 1))
	if (*Gz_state)(unsafe.Pointer(state)).Fin == (uintptr(0)) {
		Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
		return -1
	}

	// only need output buffer and deflate state if compressing
	if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
		// allocate output buffer
		(*Gz_state)(unsafe.Pointer(state)).Fout = libc.Xmalloc(tls, (*Gz_state)(unsafe.Pointer(state)).Fwant)
		if (*Gz_state)(unsafe.Pointer(state)).Fout == (uintptr(0)) {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}

		// allocate deflate memory, set up for gzip compression
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = Alloc_func(Z_NULL)
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = Free_func(Z_NULL)
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = Voidpf(Z_NULL)
		ret = XdeflateInit2_(tls, strm, (*Gz_state)(unsafe.Pointer(state)).Flevel, Z_DEFLATED, (MAX_WBITS + 16), DEF_MEM_LEVEL, (*Gz_state)(unsafe.Pointer(state)).Fstrategy, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
		if ret != Z_OK {
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
			Xgz_error(tls, state, -4, ts+87 /* "out of memory" */)
			return -1
		}
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = uintptr(0)
	}

	// mark state as initialized
	(*Gz_state)(unsafe.Pointer(state)).Fsize = (*Gz_state)(unsafe.Pointer(state)).Fwant

	// initialize write buffer if compressing
	if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
		(*Z_stream)(unsafe.Pointer(strm)).Favail_out = (*Gz_state)(unsafe.Pointer(state)).Fsize
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
		(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	}
	return 0
}

// Compress whatever is at avail_in and next_in and write to the output file.
//    Return -1 if there is an error writing to the output file or if gz_init()
//    fails to allocate memory, otherwise 0.  flush is assumed to be a valid
//    deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
//    reset to start a new gzip stream.  If gz->direct is true, then simply write
//    to the output file without compressing, and ignore flush.
func gz_comp(tls *libc.TLS, state Gz_statep, flush int32) int32 { /* gzwrite.c:73:11: */
	var ret int32
	var writ int32
	var have uint32
	var put uint32
	var max uint32 = ((uint32(libc.Uint32(libc.Uint32FromInt32(-1))) >> 2) + uint32(1))
	var strm Z_streamp = (state + 96 /* &.strm */)

	// allocate memory if this is the first time through
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return -1
	}

	// write directly if requested
	if (*Gz_state)(unsafe.Pointer(state)).Fdirect != 0 {
		for (*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0 {
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_in > max {
				put = max
			} else {
				put = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
			}
			writ = libc.Xwrite(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, put)
			if writ < 0 {
				Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))))
				return -1
			}
			*(*UInt)(unsafe.Pointer(strm + 4 /* &.avail_in */)) -= (uint32(writ))
			*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(writ))
		}
		return 0
	}

	// run deflate() on provided input until it produces no more output
	ret = Z_OK
	for ok := true; ok; ok = have != 0 {
		// write out current buffer contents if full, or if flushing, but if
		//            doing Z_FINISH then don't write until we get to Z_STREAM_END
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0)) || ((flush != Z_NO_FLUSH) && ((flush != Z_FINISH) || (ret == Z_STREAM_END))) {
			for (*Z_stream)(unsafe.Pointer(strm)).Fnext_out > (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext {
				if ((int32((*Z_stream)(unsafe.Pointer(strm)).Fnext_out) - int32((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1) > int32(max) {
					put = max
				} else {
					put = (uint32((int32((*Z_stream)(unsafe.Pointer(strm)).Fnext_out) - int32((*Gz_state)(unsafe.Pointer(state)).Fx.Fnext)) / 1))
				}
				writ = libc.Xwrite(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd, (*Gz_state)(unsafe.Pointer(state)).Fx.Fnext, put)
				if writ < 0 {
					Xgz_error(tls, state, -1, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))))
					return -1
				}
				*(*uintptr)(unsafe.Pointer(state /* &.x */ + 4 /* &.next */)) += (uintptr(writ))
			}
			if (*Z_stream)(unsafe.Pointer(strm)).Favail_out == UInt(0) {
				(*Z_stream)(unsafe.Pointer(strm)).Favail_out = (*Gz_state)(unsafe.Pointer(state)).Fsize
				(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = (*Gz_state)(unsafe.Pointer(state)).Fout
				(*Gz_state)(unsafe.Pointer(state)).Fx.Fnext = (*Gz_state)(unsafe.Pointer(state)).Fout
			}
		}

		// compress
		have = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
		ret = Xdeflate(tls, strm, flush)
		if ret == (-2) {
			Xgz_error(tls, state, -2,
				ts+291 /* "internal error: ..." */)
			return -1
		}
		have = have - ((*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	}

	// if that completed a deflate stream, allow another to start
	if flush == Z_FINISH {
		XdeflateReset(tls, strm)
	}

	// all done, no errors
	return 0
}

// Compress len zeros to output.  Return -1 on a write error or memory
//    allocation failure by gz_comp(), or 0 on success.
func gz_zero(tls *libc.TLS, state Gz_statep, len Off64_t) int32 { /* gzwrite.c:145:11: */
	var first int32
	var n uint32
	var strm Z_streamp = (state + 96 /* &.strm */)

	// consume whatever's left in the input buffer
	if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
		return -1
	}

	// compress len zeros (len guaranteed > 0)
	first = 1
	for len != 0 {
		if ((uint32(unsafe.Sizeof(int32(0))) == uint32(unsafe.Sizeof(Off64_t(0)))) && (((*Gz_state)(unsafe.Pointer(state)).Fsize) > uint32(0x7fffffff))) || (Off64_t((*Gz_state)(unsafe.Pointer(state)).Fsize) > len) {
			n = uint32(len)
		} else {
			n = (*Gz_state)(unsafe.Pointer(state)).Fsize
		}
		if first != 0 {
			libc.Xmemset(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, 0, n)
			first = 0
		}
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = n
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(n))
		if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
			return -1
		}
		len = len - (Off64_t(n))
	}
	return 0
}

// Write len bytes from buf to file.  Return the number of bytes written.  If
//    the returned value is less than len, then there was an error.
func gz_write(tls *libc.TLS, state Gz_statep, buf Voidpc, len Z_size_t) Z_size_t { /* gzwrite.c:178:16: */
	var put Z_size_t = len

	// if len is zero, avoid unnecessary operations
	if len == Z_size_t(0) {
		return Z_size_t(0)
	}

	// allocate memory if this is the first time through
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return Z_size_t(0)
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return Z_size_t(0)
		}
	}

	// for small len, copy to input buffer, otherwise compress directly
	if len < (*Gz_state)(unsafe.Pointer(state)).Fsize {
		// copy to input buffer, compress when full
		for ok := true; ok; ok = len != 0 {
			var have uint32
			var copy uint32

			if (*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in == UInt(0) {
				(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
			}
			have = (uint32(((int32((*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in + uintptr((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in))) - int32((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))
			copy = ((*Gz_state)(unsafe.Pointer(state)).Fsize - have)
			if copy > len {
				copy = len
			}
			libc.Xmemcpy(tls, ((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(have)), buf, copy)
			*(*UInt)(unsafe.Pointer(state + 96 /* &.strm */ + 4 /* &.avail_in */)) += (copy)
			*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(copy))
			buf = (buf + uintptr(copy))
			len = len - (copy)
			if (len != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
				return Z_size_t(0)
			}
		}
	} else {
		// consume whatever's left in the input buffer
		if ((*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in != 0) && (gz_comp(tls, state, Z_NO_FLUSH) == -1) {
			return Z_size_t(0)
		}

		// directly compress user buffer to file
		(*Gz_state)(unsafe.Pointer(state)).Fstrm.Fnext_in = buf
		for ok1 := true; ok1; ok1 = len != 0 {
			var n uint32 = libc.Uint32(libc.Uint32FromInt32(-1))
			if n > len {
				n = len
			}
			(*Gz_state)(unsafe.Pointer(state)).Fstrm.Favail_in = n
			*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(n))
			if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
				return Z_size_t(0)
			}
			len = len - (n)
		}
	}

	// input was all buffered or compressed
	return put
}

// -- see zlib.h --
func Xgzwrite(tls *libc.TLS, file GzFile, buf Voidpc, len uint32) int32 { /* gzwrite.c:246:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return 0
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return 0
	}

	// since an int is returned, make sure len fits in one, otherwise return
	//        with an error (this avoids a flaw in the interface)
	if int32(len) < 0 {
		Xgz_error(tls, state, -3, ts+330 /* "requested length..." */)
		return 0
	}

	// write len bytes from buf (the return value will fit in an int)
	return int32(gz_write(tls, state, buf, len))
}

// -- see zlib.h --
func Xgzfwrite(tls *libc.TLS, buf Voidpc, size Z_size_t, nitems Z_size_t, file GzFile) Z_size_t { /* gzwrite.c:274:18: */
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return Z_size_t(0)
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return Z_size_t(0)
	}

	// compute bytes to read -- error on overflow
	len = (nitems * size)
	if (size != 0) && ((len / size) != nitems) {
		Xgz_error(tls, state, -2, ts+227 /* "request does not..." */)
		return Z_size_t(0)
	}

	// write len bytes to buf, return the number of full items written
	if len != 0 {
		return (gz_write(tls, state, buf, len) / size)
	}
	return uint32(0)
}

// -- see zlib.h --
func Xgzputc(tls *libc.TLS, file GzFile, c int32) int32 { /* gzwrite.c:304:13: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var have uint32
	// var buf [1]uint8 at bp, 1

	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file
	strm = (state + 96 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -1
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return -1
		}
	}

	// try writing to input buffer for speed (state->size == 0 if buffer not
	//        initialized)
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		}
		have = (uint32(((int32((*Z_stream)(unsafe.Pointer(strm)).Fnext_in + uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in))) - int32((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))
		if have < (*Gz_state)(unsafe.Pointer(state)).Fsize {
			*(*uint8)(unsafe.Pointer((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(have))) = uint8(c)
			(*Z_stream)(unsafe.Pointer(strm)).Favail_in++
			(*Gz_state)(unsafe.Pointer(state)).Fx.Fpos++
			return (c & 0xff)
		}
	}

	// no room in buffer or not initialized, use gz_write()
	*(*uint8)(unsafe.Pointer(bp /* &buf[0] */)) = uint8(c)
	if gz_write(tls, state, bp /* &buf[0] */, uint32(1)) != Z_size_t(1) {
		return -1
	}
	return (c & 0xff)
}

// -- see zlib.h --
func Xgzputs(tls *libc.TLS, file GzFile, str uintptr) int32 { /* gzwrite.c:352:13: */
	var ret int32
	var len Z_size_t
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -1
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -1
	}

	// write string
	len = libc.Xstrlen(tls, str)
	ret = int32(gz_write(tls, state, str, len))
	if (ret == 0) && (len != Z_size_t(0)) {
		return -1
	}
	return ret
}

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// -- see zlib.h --
func Xgzvprintf(tls *libc.TLS, file GzFile, format uintptr, va Va_list) int32 { /* gzwrite.c:379:15: */
	var len int32
	var left uint32
	var next uintptr
	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file
	strm = (state + 96 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// make sure we have some buffer space
	if ((*Gz_state)(unsafe.Pointer(state)).Fsize == uint32(0)) && (gz_init(tls, state) == -1) {
		return (*Gz_state)(unsafe.Pointer(state)).Ferr
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// do the printf() into the input buffer, put length in len -- the input
	//        buffer is double-sized just for this function, so there is guaranteed to
	//        be state->size bytes available after the current contents
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
	}
	next = (((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr(((int32((*Z_stream)(unsafe.Pointer(strm)).Fnext_in) - int32((*Gz_state)(unsafe.Pointer(state)).Fin)) / 1))) + uintptr((*Z_stream)(unsafe.Pointer(strm)).Favail_in))
	*(*int8)(unsafe.Pointer(next + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize - uint32(1))))) = int8(0)
	len = libc.Xvsnprintf(tls, next, (*Gz_state)(unsafe.Pointer(state)).Fsize, format, va)

	// check that printf() results fit in buffer
	if ((len == 0) || (uint32(len) >= (*Gz_state)(unsafe.Pointer(state)).Fsize)) || (int32(*(*int8)(unsafe.Pointer(next + uintptr(((*Gz_state)(unsafe.Pointer(state)).Fsize - uint32(1)))))) != 0) {
		return 0
	}

	// update buffer and position, compress first half if past that
	*(*UInt)(unsafe.Pointer(strm + 4 /* &.avail_in */)) += (uint32(len))
	*(*Off64_t)(unsafe.Pointer(state /* &.x */ + 8 /* &.pos */)) += (Off64_t(len))
	if (*Z_stream)(unsafe.Pointer(strm)).Favail_in >= (*Gz_state)(unsafe.Pointer(state)).Fsize {
		left = ((*Z_stream)(unsafe.Pointer(strm)).Favail_in - (*Gz_state)(unsafe.Pointer(state)).Fsize)
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = (*Gz_state)(unsafe.Pointer(state)).Fsize
		if gz_comp(tls, state, Z_NO_FLUSH) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
		libc.Xmemcpy(tls, (*Gz_state)(unsafe.Pointer(state)).Fin, ((*Gz_state)(unsafe.Pointer(state)).Fin + uintptr((*Gz_state)(unsafe.Pointer(state)).Fsize)), left)
		(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = (*Gz_state)(unsafe.Pointer(state)).Fin
		(*Z_stream)(unsafe.Pointer(strm)).Favail_in = left
	}
	return len
}

func Xgzprintf(tls *libc.TLS, file GzFile, format uintptr, va uintptr) int32 { /* gzwrite.c:451:15: */
	var va1 Va_list
	_ = va1
	var ret int32

	va1 = va
	ret = Xgzvprintf(tls, file, format, va1)
	_ = va1
	return ret
}

// -- see zlib.h --
func Xgzflush(tls *libc.TLS, file GzFile, flush int32) int32 { /* gzwrite.c:553:13: */
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// check flush parameter
	if (flush < 0) || (flush > Z_FINISH) {
		return -2
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// compress remaining data with requested flush
	gz_comp(tls, state, flush)
	return (*Gz_state)(unsafe.Pointer(state)).Ferr
}

// -- see zlib.h --
func Xgzsetparams(tls *libc.TLS, file GzFile, level int32, strategy int32) int32 { /* gzwrite.c:585:13: */
	var state Gz_statep
	var strm Z_streamp

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file
	strm = (state + 96 /* &.strm */)

	// check that we're writing and that there's no error
	if ((*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE) || ((*Gz_state)(unsafe.Pointer(state)).Ferr != Z_OK) {
		return -2
	}

	// if no change is requested, then do nothing
	if (level == (*Gz_state)(unsafe.Pointer(state)).Flevel) && (strategy == (*Gz_state)(unsafe.Pointer(state)).Fstrategy) {
		return Z_OK
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// change compression parameters for subsequent input
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		// flush previous input with previous parameters before changing
		if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != 0) && (gz_comp(tls, state, Z_BLOCK) == -1) {
			return (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
		XdeflateParams(tls, strm, level, strategy)
	}
	(*Gz_state)(unsafe.Pointer(state)).Flevel = level
	(*Gz_state)(unsafe.Pointer(state)).Fstrategy = strategy
	return Z_OK
}

// -- see zlib.h --
func Xgzclose_w(tls *libc.TLS, file GzFile) int32 { /* gzwrite.c:627:13: */
	var ret int32 = Z_OK
	var state Gz_statep

	// get internal structure
	if file == (uintptr(0)) {
		return -2
	}
	state = file

	// check that we're writing
	if (*Gz_state)(unsafe.Pointer(state)).Fmode != GZ_WRITE {
		return -2
	}

	// check for seek request
	if (*Gz_state)(unsafe.Pointer(state)).Fseek != 0 {
		(*Gz_state)(unsafe.Pointer(state)).Fseek = 0
		if gz_zero(tls, state, (*Gz_state)(unsafe.Pointer(state)).Fskip) == -1 {
			ret = (*Gz_state)(unsafe.Pointer(state)).Ferr
		}
	}

	// flush, free memory, and close file
	if gz_comp(tls, state, Z_FINISH) == -1 {
		ret = (*Gz_state)(unsafe.Pointer(state)).Ferr
	}
	if (*Gz_state)(unsafe.Pointer(state)).Fsize != 0 {
		if !((*Gz_state)(unsafe.Pointer(state)).Fdirect != 0) {
			XdeflateEnd(tls, (state + 96 /* &.strm */))
			libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fout)
		}
		libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fin)
	}
	Xgz_error(tls, state, Z_OK, uintptr(0))
	libc.Xfree(tls, (*Gz_state)(unsafe.Pointer(state)).Fpath)
	if libc.Xclose(tls, (*Gz_state)(unsafe.Pointer(state)).Ffd) == -1 {
		ret = -1
	}
	libc.Xfree(tls, state)
	return ret
}

type Ino_t2 = X__ino64_t /* types.h:49:19 */

type Off_t2 = X__off64_t /* types.h:87:19 */

// Types from the Large File Support interface.
type Blkcnt_t2 = X__blkcnt64_t     /* types.h:222:22 */ // Type to count number of disk blocks.
type Fsblkcnt_t2 = X__fsblkcnt64_t /* types.h:226:24 */ // Type to count file system blocks.
type Fsfilcnt_t2 = X__fsfilcnt64_t /* types.h:230:24 */

// Reverse the bytes in a 32-bit value

// inftrees.h -- header to use inftrees.c
// Copyright (C) 1995-2005, 2010 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// Structure for decoding tables.  Each entry provides either the
//    information needed to do the operation requested by the code that
//    indexed that table entry, or it provides a pointer to another
//    table that indexes more bits of the code.  op indicates whether
//    the entry is a pointer to another table, a literal, a length or
//    distance, an end-of-block, or an invalid code.  For a table
//    pointer, the low four bits of op is the number of index bits of
//    that table.  For a length or distance, the low four bits of op
//    is the number of extra bits to get after the code.  bits is
//    the number of bits in this code or part of the code to drop off
//    of the bit buffer.  val is the actual byte to output in the case
//    of a literal, the base length or distance, or the offset from
//    the current table to the next table.  Each entry is four bytes.
type Code = struct {
	Fop   uint8
	Fbits uint8
	Fval  uint16
} /* inftrees.h:28:3 */

// op values as set by inflate_table():
//     00000000 - literal
//     0000tttt - table link, tttt != 0 is the number of table index bits
//     0001eeee - length or distance, eeee is the number of extra bits
//     01100000 - end of block
//     01000000 - invalid code
//

// Maximum size of the dynamic table.  The maximum number of code structures is
//    1444, which is the sum of 852 for literal/length codes and 592 for distance
//    codes.  These values were found by exhaustive searches using the program
//    examples/enough.c found in the zlib distribtution.  The arguments to that
//    program are the number of symbols, the initial root table size, and the
//    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
//    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
//    The initial root table size (9 or 6) is found in the fifth argument of the
//    inflate_table() calls in inflate.c and infback.c.  If the root table size is
//    changed, then these maximum sizes would be need to be recalculated and
//    updated.

// Type of code to build for inflate_table()
type Codetype = uint32 /* inftrees.h:58:3 */
// inflate.h -- internal inflate state definition
// Copyright (C) 1995-2016 Mark Adler
// For conditions of distribution and use, see copyright notice in zlib.h

// WARNING: this file should *not* be used by applications. It is
//    part of the implementation of the compression library and is
//    subject to change. Applications should only use zlib.h.
//

// define NO_GZIP when compiling if you want to disable gzip header and
//    trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
//    the crc code when it is not needed.  For shared libraries, gzip decoding
//    should be left enabled.

// Possible inflate modes between inflate() calls
type Inflate_mode = uint32 /* inflate.h:53:3 */

//
//     State transitions between above modes -
//
//     (most modes can go to BAD or MEM on error -- not shown for clarity)
//
//     Process header:
//         HEAD -> (gzip) or (zlib) or (raw)
//         (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
//                   HCRC -> TYPE
//         (zlib) -> DICTID or TYPE
//         DICTID -> DICT -> TYPE
//         (raw) -> TYPEDO
//     Read deflate blocks:
//             TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
//             STORED -> COPY_ -> COPY -> TYPE
//             TABLE -> LENLENS -> CODELENS -> LEN_
//             LEN_ -> LEN
//     Read deflate codes in fixed or dynamic block:
//                 LEN -> LENEXT or LIT or TYPE
//                 LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
//                 LIT -> LEN
//     Process trailer:
//         CHECK -> LENGTH -> DONE
//

// State maintained between inflate() calls -- approximately 7K bytes, not
//    including the allocated sliding window, which is up to 32K bytes.
type Inflate_state = struct {
	Fstrm     Z_streamp
	Fmode     Inflate_mode
	Flast     int32
	Fwrap     int32
	Fhavedict int32
	Fflags    int32
	Fdmax     uint32
	Fcheck    uint32
	Ftotal    uint32
	Fhead     Gz_headerp
	Fwbits    uint32
	Fwsize    uint32
	Fwhave    uint32
	Fwnext    uint32
	Fwindow   uintptr
	Fhold     uint32
	Fbits     uint32
	Flength   uint32
	Foffset   uint32
	Fextra    uint32
	Flencode  uintptr
	Fdistcode uintptr
	Flenbits  uint32
	Fdistbits uint32
	Fncode    uint32
	Fnlen     uint32
	Fndist    uint32
	Fhave     uint32
	Fnext     uintptr
	Flens     [320]uint16
	Fwork     [288]uint16
	Fcodes    [1444]Code
	Fsane     int32
	Fback     int32
	Fwas      uint32
} /* inflate.h:82:1 */

//
//    strm provides memory allocation functions in zalloc and zfree, or
//    Z_NULL to use the library memory allocation functions.
//
//    windowBits is in the range 8..15, and window is a user-supplied
//    window and output buffer that is 2**windowBits bytes.
//
func XinflateBackInit_(tls *libc.TLS, strm Z_streamp, windowBits int32, window uintptr, version uintptr, stream_size int32) int32 { /* infback.c:28:13: */
	var state uintptr

	if ((version == uintptr(Z_NULL)) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(*(*int8)(unsafe.Pointer(ts /* "1.2.11" */))))) || (stream_size != (int32(unsafe.Sizeof(Z_stream{})))) {
		return -6
	}
	if (((strm == uintptr(Z_NULL)) || (window == uintptr(Z_NULL))) || (windowBits < 8)) || (windowBits > 15) {
		return -2
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL) // in case we return an error
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}
	state = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if state == uintptr(Z_NULL) {
		return -4
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fstate = state
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = 32768
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = UInt(windowBits)
	(*Inflate_state)(unsafe.Pointer(state)).Fwsize = (uint32(1) << windowBits)
	(*Inflate_state)(unsafe.Pointer(state)).Fwindow = window
	(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	return Z_OK
}

//
//    Return state with length and distance decoding tables and index sizes set to
//    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
//    If BUILDFIXED is defined, then instead this routine builds the tables the
//    first time it's called, and returns those tables the first time and
//    thereafter.  This reduces the size of the code by about 2K bytes, in
//    exchange for a little execution time.  However, BUILDFIXED should not be
//    used for threaded applications, since the rewriting of the tables and virgin
//    may not be thread-safe.
//
func fixedtables(tls *libc.TLS, state uintptr) { /* infback.c:82:12: */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = uintptr(unsafe.Pointer(&lenfix))
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = uintptr(unsafe.Pointer(&distfix))
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(5)
}

var lenfix = [512]Code{
	{Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)}, {Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)},
	{Fbits: uint8(9), Fval: uint16(192)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)}, {Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(160)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)},
	{Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(224)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(144)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)},
	{Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(208)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(176)},
	{Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)}, {Fbits: uint8(9), Fval: uint16(240)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)},
	{Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)}, {Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(200)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)},
	{Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(168)}, {Fbits: uint8(8), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(232)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)},
	{Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(152)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(216)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)}, {Fbits: uint8(9), Fval: uint16(184)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)},
	{Fbits: uint8(9), Fval: uint16(248)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)}, {Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)},
	{Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(196)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(164)}, {Fbits: uint8(8), Fval: uint16(2)},
	{Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(228)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(148)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)}, {Fbits: uint8(9), Fval: uint16(212)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)},
	{Fbits: uint8(9), Fval: uint16(180)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)}, {Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(244)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)},
	{Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(204)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)},
	{Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(172)}, {Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(236)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)}, {Fbits: uint8(9), Fval: uint16(156)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)},
	{Fbits: uint8(9), Fval: uint16(220)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)}, {Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(188)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)},
	{Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(252)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)},
	{Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(194)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(162)},
	{Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)}, {Fbits: uint8(9), Fval: uint16(226)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)},
	{Fbits: uint8(9), Fval: uint16(146)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)}, {Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(210)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)},
	{Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(178)}, {Fbits: uint8(8), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(242)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(202)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)}, {Fbits: uint8(9), Fval: uint16(170)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)},
	{Fbits: uint8(9), Fval: uint16(234)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)}, {Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(154)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)},
	{Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(218)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(186)}, {Fbits: uint8(8), Fval: uint16(13)},
	{Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(250)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)}, {Fbits: uint8(9), Fval: uint16(198)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)},
	{Fbits: uint8(9), Fval: uint16(166)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)}, {Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(230)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)},
	{Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(150)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(214)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)},
	{Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(182)}, {Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(246)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)},
	{Fbits: uint8(9), Fval: uint16(206)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)}, {Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(174)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)},
	{Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(238)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(158)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)},
	{Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(222)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(190)},
	{Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)}, {Fbits: uint8(9), Fval: uint16(254)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)},
	{Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)}, {Fbits: uint8(9), Fval: uint16(193)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)},
	{Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(161)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)}, {Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(225)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)},
	{Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(145)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(209)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(177)}, {Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)},
	{Fbits: uint8(9), Fval: uint16(241)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)},
	{Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(201)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)}, {Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(169)}, {Fbits: uint8(8), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(233)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(153)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(217)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)},
	{Fbits: uint8(9), Fval: uint16(185)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)}, {Fbits: uint8(9), Fval: uint16(249)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)},
	{Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)}, {Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(197)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)},
	{Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(165)}, {Fbits: uint8(8), Fval: uint16(2)}, {Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(229)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(149)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)},
	{Fbits: uint8(9), Fval: uint16(213)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)}, {Fbits: uint8(9), Fval: uint16(181)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)},
	{Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(245)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)}, {Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)},
	{Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(205)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(173)},
	{Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(237)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)},
	{Fbits: uint8(9), Fval: uint16(157)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)}, {Fbits: uint8(9), Fval: uint16(221)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)},
	{Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(189)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)}, {Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(253)}, {Fop: uint8(96), Fbits: uint8(7)},
	{Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(195)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(163)}, {Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)},
	{Fbits: uint8(9), Fval: uint16(227)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)}, {Fbits: uint8(9), Fval: uint16(147)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)},
	{Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(211)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)}, {Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(179)}, {Fbits: uint8(8), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(243)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(203)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)},
	{Fbits: uint8(9), Fval: uint16(171)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)}, {Fbits: uint8(9), Fval: uint16(235)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)},
	{Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(155)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)}, {Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(219)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)},
	{Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(187)}, {Fbits: uint8(8), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(251)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)},
	{Fbits: uint8(9), Fval: uint16(199)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)}, {Fbits: uint8(9), Fval: uint16(167)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)},
	{Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(231)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)}, {Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(151)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)},
	{Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(215)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(183)},
	{Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(247)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)},
	{Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)}, {Fbits: uint8(9), Fval: uint16(207)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)},
	{Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(175)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)}, {Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(239)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(159)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(223)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(191)}, {Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)},
	{Fbits: uint8(9), Fval: uint16(255)},
} /* inffixed.h:10:23 */
var distfix = [32]Code{
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(1)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(257)}, {Fop: uint8(19), Fbits: uint8(5), Fval: uint16(17)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(4097)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(5)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1025)},
	{Fop: uint8(21), Fbits: uint8(5), Fval: uint16(65)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(16385)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(3)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(513)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(33)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(8193)},
	{Fop: uint8(18), Fbits: uint8(5), Fval: uint16(9)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(2049)}, {Fop: uint8(22), Fbits: uint8(5), Fval: uint16(129)}, {Fop: uint8(64), Fbits: uint8(5)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(2)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(385)},
	{Fop: uint8(19), Fbits: uint8(5), Fval: uint16(25)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(6145)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(7)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1537)}, {Fop: uint8(21), Fbits: uint8(5), Fval: uint16(97)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(24577)},
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(4)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(769)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(49)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(12289)}, {Fop: uint8(18), Fbits: uint8(5), Fval: uint16(13)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(3073)},
	{Fop: uint8(22), Fbits: uint8(5), Fval: uint16(193)}, {Fop: uint8(64), Fbits: uint8(5)},
} /* inffixed.h:87:23 */

// Macros for inflateBack():

// Load returned state from inflate_fast()

// Set state from registers for inflate_fast()

// Clear the input bit accumulator

// Assure that some input is available.  If input is requested, but denied,
//    then return a Z_BUF_ERROR from inflateBack().

// Get a byte of input into the bit accumulator, or return from inflateBack()
//    with an error if there is no input available.

// Assure that there are at least n bits in the bit accumulator.  If there is
//    not enough available input to do that, then return from inflateBack() with
//    an error.

// Return the low n bits of the bit accumulator (n < 16)

// Remove n bits from the bit accumulator

// Remove zero to seven bits as needed to go to a byte boundary

// Assure that some output space is available, by writing out the window
//    if it's full.  If the write fails, return from inflateBack() with a
//    Z_BUF_ERROR.

//
//    strm provides the memory allocation functions and window buffer on input,
//    and provides information on the unused input on return.  For Z_DATA_ERROR
//    returns, strm will also provide an error message.
//
//    in() and out() are the call-back input and output functions.  When
//    inflateBack() needs more input, it calls in().  When inflateBack() has
//    filled the window with output, or when it completes with data in the
//    window, it calls out() to write out the data.  The application must not
//    change the provided input until in() is called again or inflateBack()
//    returns.  The application must not change the window/output buffer until
//    inflateBack() returns.
//
//    in() and out() are called with a descriptor parameter provided in the
//    inflateBack() call.  This parameter can be a structure that provides the
//    information required to do the read or write, as well as accumulated
//    information on the input and output such as totals and check values.
//
//    in() should return zero on failure.  out() should return non-zero on
//    failure.  If either in() or out() fails, than inflateBack() returns a
//    Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
//    was in() or out() that caused in the error.  Otherwise,  inflateBack()
//    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
//    error, or Z_MEM_ERROR if it could not allocate memory for the state.
//    inflateBack() can also return Z_STREAM_ERROR if the input parameters
//    are not correct, i.e. strm is Z_NULL or the state was not initialized.
//
func XinflateBack(tls *libc.TLS, strm Z_streamp, in In_func, in_desc uintptr, out Out_func, out_desc uintptr) int32 { /* infback.c:250:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var state uintptr
	// var next uintptr at bp, 4
	// next input
	var put uintptr // next output
	var have uint32
	var left uint32  // available input and output
	var hold uint32  // bit buffer
	var bits uint32  // bits in bit buffer
	var copy uint32  // number of stored or match bytes to copy
	var from uintptr // where to copy match bytes from
	var here Code    // current decoding table entry
	var last Code    // parent table entry
	var len uint32   // length to copy for repeats, bits to drop
	var ret int32

	// Check that the strm exists and that the state was initialized
	if !((strm == uintptr(Z_NULL)) || ((*Z_stream)(unsafe.Pointer(strm)).Fstate == uintptr(Z_NULL))) {
		goto __1
	}
	return -2
__1:
	;
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// Reset the state
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	(*Inflate_state)(unsafe.Pointer(state)).Flast = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	if *(*uintptr)(unsafe.Pointer(bp /* next */)) != uintptr(Z_NULL) {
		have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	} else {
		have = uint32(0)
	}
	hold = uint32(0)
	bits = uint32(0)
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize

	// Inflate until end of block marked as last
__2:
	switch (*Inflate_state)(unsafe.Pointer(state)).Fmode {
	case TYPE:
		goto __6

	case STORED:
		goto __7

	case TABLE:
		goto __8

	case LEN:
		goto __9

	case DONE:
		goto __10

	case BAD:
		goto __11

	default:
		goto __12
	}
	goto __5
__6:
	// determine and dispatch block type
	if !((*Inflate_state)(unsafe.Pointer(state)).Flast != 0) {
		goto __13
	}
__14:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DONE
	goto __5
__13:
	;
__17:
__20:
	if !(bits < (uint32(3))) {
		goto __21
	}
__22:
__25:
	if !(have == uint32(0)) {
		goto __28
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __29
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__29:
	;
__28:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	goto __20
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flast = (int32(uint32(hold) & ((uint32(1) << (1)) - uint32(1))))
__30:
	hold >>= 1
	bits = bits - (uint32(1))
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	switch uint32(hold) & ((uint32(1) << (2)) - uint32(1)) {
	case uint32(0):
		goto __34
	case uint32(1):
		goto __35
	case uint32(2):
		goto __36
	case uint32(3):
		goto __37
	}
	goto __33
__34: // stored block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = STORED
	goto __33
__35: // fixed block
	fixedtables(tls, state)

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN // decode codes
	goto __33
__36: // dynamic block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TABLE
	goto __33
__37:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 367 /* "invalid block ty..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
__33:
	;
__38:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
	goto __5

__7:
	// get and verify stored block length
__41:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	; // go to byte boundary
__44:
__47:
	if !(bits < (uint32(32))) {
		goto __48
	}
__49:
__52:
	if !(have == uint32(0)) {
		goto __55
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __56
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__56:
	;
__55:
	;
	goto __53
__53:
	if 0 != 0 {
		goto __52
	}
	goto __54
__54:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __50
__50:
	if 0 != 0 {
		goto __49
	}
	goto __51
__51:
	;
	goto __47
__48:
	;
	goto __45
__45:
	if 0 != 0 {
		goto __44
	}
	goto __46
__46:
	;
	if !((hold & uint32(0xffff)) != ((hold >> 16) ^ uint32(0xffff))) {
		goto __57
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 386 /* "invalid stored b..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__57:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = (uint32(hold) & uint32(0xffff))

__58:
	hold = uint32(0)
	bits = uint32(0)
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;

	// copy stored block from input to output
__61:
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength != uint32(0)) {
		goto __62
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__63:
	if !(have == uint32(0)) {
		goto __66
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __67
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__67:
	;
__66:
	;
	goto __64
__64:
	if 0 != 0 {
		goto __63
	}
	goto __65
__65:
	;
__68:
	if !(left == uint32(0)) {
		goto __71
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __72
	}
	ret = -5
	goto inf_leave
__72:
	;
__71:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
	if !(copy > have) {
		goto __73
	}
	copy = have
__73:
	;
	if !(copy > left) {
		goto __74
	}
	copy = left
__74:
	;
	libc.Xmemcpy(tls, put, *(*uintptr)(unsafe.Pointer(bp /* next */)), copy)
	have = have - (copy)
	*(*uintptr)(unsafe.Pointer(bp /* next */)) += uintptr(copy)
	left = left - (copy)
	put += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) -= (copy)
	goto __61
__62:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __5

__8:
	// get dynamic table entries descriptor
__75:
__78:
	if !(bits < (uint32(14))) {
		goto __79
	}
__80:
__83:
	if !(have == uint32(0)) {
		goto __86
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __87
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__87:
	;
__86:
	;
	goto __84
__84:
	if 0 != 0 {
		goto __83
	}
	goto __85
__85:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __81
__81:
	if 0 != 0 {
		goto __80
	}
	goto __82
__82:
	;
	goto __78
__79:
	;
	goto __76
__76:
	if 0 != 0 {
		goto __75
	}
	goto __77
__77:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnlen = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(257))
__88:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __89
__89:
	if 0 != 0 {
		goto __88
	}
	goto __90
__90:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fndist = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(1))
__91:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fncode = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(4))
__94:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __95
__95:
	if 0 != 0 {
		goto __94
	}
	goto __96
__96:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fnlen > uint32(286)) || ((*Inflate_state)(unsafe.Pointer(state)).Fndist > uint32(30))) {
		goto __97
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 415 /* "too many length ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__97:
	;

	// get code length code lengths (not a typo)
	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
__98:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < (*Inflate_state)(unsafe.Pointer(state)).Fncode) {
		goto __99
	}
__100:
__103:
	if !(bits < (uint32(3))) {
		goto __104
	}
__105:
__108:
	if !(have == uint32(0)) {
		goto __111
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __112
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__112:
	;
__111:
	;
	goto __109
__109:
	if 0 != 0 {
		goto __108
	}
	goto __110
__110:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __106
__106:
	if 0 != 0 {
		goto __105
	}
	goto __107
__107:
	;
	goto __103
__104:
	;
	goto __101
__101:
	if 0 != 0 {
		goto __100
	}
	goto __102
__102:
	;
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(order[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = (uint16(uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__113:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __114
__114:
	if 0 != 0 {
		goto __113
	}
	goto __115
__115:
	;
	goto __98
__99:
	;
__116:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < uint32(19)) {
		goto __117
	}
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(order[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = uint16(0)
	goto __116
__117:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1332 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(7)
	ret = Xinflate_table(tls, CODES, state+116 /* &.lens */, uint32(19), (state + 112 /* &.next */),
		(state + 88 /* &.lenbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __118
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 451 /* "invalid code len..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__118:
	;

	// get length and distance code code lengths
	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
__119:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __120
	}
__121:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __124
	}
	goto __123
__124:
	;
__125:
__128:
	if !(have == uint32(0)) {
		goto __131
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __132
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__132:
	;
__131:
	;
	goto __129
__129:
	if 0 != 0 {
		goto __128
	}
	goto __130
__130:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __126
__126:
	if 0 != 0 {
		goto __125
	}
	goto __127
__127:
	;
	goto __122
__122:
	goto __121
	goto __123
__123:
	;
	if !(int32(here.Fval) < 16) {
		goto __133
	}
__135:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __136
__136:
	if 0 != 0 {
		goto __135
	}
	goto __137
__137:
	;
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = here.Fval
	goto __134
__133:
	if !(int32(here.Fval) == 16) {
		goto __138
	}
__140:
__143:
	if !(bits < (uint32(int32(here.Fbits) + 2))) {
		goto __144
	}
__145:
__148:
	if !(have == uint32(0)) {
		goto __151
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __152
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__152:
	;
__151:
	;
	goto __149
__149:
	if 0 != 0 {
		goto __148
	}
	goto __150
__150:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __146
__146:
	if 0 != 0 {
		goto __145
	}
	goto __147
__147:
	;
	goto __143
__144:
	;
	goto __141
__141:
	if 0 != 0 {
		goto __140
	}
	goto __142
__142:
	;
__153:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __154
__154:
	if 0 != 0 {
		goto __153
	}
	goto __155
__155:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave == uint32(0)) {
		goto __156
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __120
__156:
	;
	len = uint32(*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fhave-uint32(1)))*2)))
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (2)) - uint32(1))))
__157:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __158
__158:
	if 0 != 0 {
		goto __157
	}
	goto __159
__159:
	;
	goto __139
__138:
	if !(int32(here.Fval) == 17) {
		goto __160
	}
__162:
__165:
	if !(bits < (uint32(int32(here.Fbits) + 3))) {
		goto __166
	}
__167:
__170:
	if !(have == uint32(0)) {
		goto __173
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __174
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__174:
	;
__173:
	;
	goto __171
__171:
	if 0 != 0 {
		goto __170
	}
	goto __172
__172:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __168
__168:
	if 0 != 0 {
		goto __167
	}
	goto __169
__169:
	;
	goto __165
__166:
	;
	goto __163
__163:
	if 0 != 0 {
		goto __162
	}
	goto __164
__164:
	;
__175:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __176
__176:
	if 0 != 0 {
		goto __175
	}
	goto __177
__177:
	;
	len = uint32(0)
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__178:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __179
__179:
	if 0 != 0 {
		goto __178
	}
	goto __180
__180:
	;
	goto __161
__160:
__181:
__184:
	if !(bits < (uint32(int32(here.Fbits) + 7))) {
		goto __185
	}
__186:
__189:
	if !(have == uint32(0)) {
		goto __192
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __193
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__193:
	;
__192:
	;
	goto __190
__190:
	if 0 != 0 {
		goto __189
	}
	goto __191
__191:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __187
__187:
	if 0 != 0 {
		goto __186
	}
	goto __188
__188:
	;
	goto __184
__185:
	;
	goto __182
__182:
	if 0 != 0 {
		goto __181
	}
	goto __183
__183:
	;
__194:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __195
__195:
	if 0 != 0 {
		goto __194
	}
	goto __196
__196:
	;
	len = uint32(0)
	copy = (uint32(11) + (uint32(hold) & ((uint32(1) << (7)) - uint32(1))))
__197:
	hold >>= 7
	bits = bits - (uint32(7))
	goto __198
__198:
	if 0 != 0 {
		goto __197
	}
	goto __199
__199:
	;
__161:
	;
__139:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhave + copy) > ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __200
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __120
__200:
	;
__201:
	if !(libc.PostDecUint32(&copy, 1) != 0) {
		goto __202
	}
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = uint16(len)
	goto __201
__202:
	;
__134:
	;
	goto __119
__120:
	;

	// handle error breaks in while
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == BAD) {
		goto __203
	}
	goto __5
__203:
	;

	// check for end-of-block code (better have one)
	if !(int32(*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + 256*2))) == 0) {
		goto __204
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 502 /* "invalid code -- ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__204:
	;

	// build code tables -- note: do not change the lenbits or distbits
	//                values here (9 and 6) without reading the comments in inftrees.h
	//                concerning the ENOUGH constants, which depend on those values
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1332 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	ret = Xinflate_table(tls, LENS, state+116 /* &.lens */, (*Inflate_state)(unsafe.Pointer(state)).Fnlen, (state + 112 /* &.next */),
		(state + 88 /* &.lenbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __205
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 539 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__205:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(6)
	ret = Xinflate_table(tls, DISTS, ((state + 116 /* &.lens */) + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fnlen)*2), (*Inflate_state)(unsafe.Pointer(state)).Fndist,
		(state + 112 /* &.next */), (state + 92 /* &.distbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __206
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 567 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__206:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN

__9:
	// use inflate_fast() if we have enough input and output
	if !((have >= uint32(6)) && (left >= uint32(258))) {
		goto __207
	}
__208:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = *(*uintptr)(unsafe.Pointer(bp /* next */))
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __209
__209:
	if 0 != 0 {
		goto __208
	}
	goto __210
__210:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize) {
		goto __211
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - left)
__211:
	;
	Xinflate_fast(tls, strm, (*Inflate_state)(unsafe.Pointer(state)).Fwsize)
__212:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
	goto __5
__207:
	;

	// get a literal, length, or end-of-block code
__215:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __218
	}
	goto __217
__218:
	;
__219:
__222:
	if !(have == uint32(0)) {
		goto __225
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __226
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__226:
	;
__225:
	;
	goto __223
__223:
	if 0 != 0 {
		goto __222
	}
	goto __224
__224:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __220
__220:
	if 0 != 0 {
		goto __219
	}
	goto __221
__221:
	;
	goto __216
__216:
	goto __215
	goto __217
__217:
	;
	if !((here.Fop != 0) && ((int32(here.Fop) & 0xf0) == 0)) {
		goto __227
	}
	last = here
__228:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __231
	}
	goto __230
__231:
	;
__232:
__235:
	if !(have == uint32(0)) {
		goto __238
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __239
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__239:
	;
__238:
	;
	goto __236
__236:
	if 0 != 0 {
		goto __235
	}
	goto __237
__237:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __233
__233:
	if 0 != 0 {
		goto __232
	}
	goto __234
__234:
	;
	goto __229
__229:
	goto __228
	goto __230
__230:
	;
__240:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __241
__241:
	if 0 != 0 {
		goto __240
	}
	goto __242
__242:
	;
__227:
	;
__243:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __244
__244:
	if 0 != 0 {
		goto __243
	}
	goto __245
__245:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(here.Fval)

	// process literal
	if !(int32(here.Fop) == 0) {
		goto __246
	}

__247:
	if !(left == uint32(0)) {
		goto __250
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __251
	}
	ret = -5
	goto inf_leave
__251:
	;
__250:
	;
	goto __248
__248:
	if 0 != 0 {
		goto __247
	}
	goto __249
__249:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Flength)
	left--
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
	goto __5
__246:
	;

	// process end of block
	if !((int32(here.Fop) & 32) != 0) {
		goto __252
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __5
__252:
	;

	// invalid code
	if !((int32(here.Fop) & 64) != 0) {
		goto __253
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__253:
	;

	// length code -- get extra bits, if any
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != uint32(0)) {
		goto __254
	}
__255:
__258:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __259
	}
__260:
__263:
	if !(have == uint32(0)) {
		goto __266
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __267
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__267:
	;
__266:
	;
	goto __264
__264:
	if 0 != 0 {
		goto __263
	}
	goto __265
__265:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __261
__261:
	if 0 != 0 {
		goto __260
	}
	goto __262
__262:
	;
	goto __258
__259:
	;
	goto __256
__256:
	if 0 != 0 {
		goto __255
	}
	goto __257
__257:
	;
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__268:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __269
__269:
	if 0 != 0 {
		goto __268
	}
	goto __270
__270:
	;
__254:
	;

	// get distance code
__271:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Fdistbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __274
	}
	goto __273
__274:
	;
__275:
__278:
	if !(have == uint32(0)) {
		goto __281
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __282
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__282:
	;
__281:
	;
	goto __279
__279:
	if 0 != 0 {
		goto __278
	}
	goto __280
__280:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __276
__276:
	if 0 != 0 {
		goto __275
	}
	goto __277
__277:
	;
	goto __272
__272:
	goto __271
	goto __273
__273:
	;
	if !((int32(here.Fop) & 0xf0) == 0) {
		goto __283
	}
	last = here
__284:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __287
	}
	goto __286
__287:
	;
__288:
__291:
	if !(have == uint32(0)) {
		goto __294
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __295
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__295:
	;
__294:
	;
	goto __292
__292:
	if 0 != 0 {
		goto __291
	}
	goto __293
__293:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __289
__289:
	if 0 != 0 {
		goto __288
	}
	goto __290
__290:
	;
	goto __285
__285:
	goto __284
	goto __286
__286:
	;
__296:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __297
__297:
	if 0 != 0 {
		goto __296
	}
	goto __298
__298:
	;
__283:
	;
__299:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __300
__300:
	if 0 != 0 {
		goto __299
	}
	goto __301
__301:
	;
	if !((int32(here.Fop) & 64) != 0) {
		goto __302
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__302:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Foffset = uint32(here.Fval)

	// get distance extra bits, if any
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != uint32(0)) {
		goto __303
	}
__304:
__307:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __308
	}
__309:
__312:
	if !(have == uint32(0)) {
		goto __315
	}
	have = (*(*func(*libc.TLS, uintptr, uintptr) uint32)(unsafe.Pointer(&in)))(tls, in_desc, bp /* &next */)
	if !(have == uint32(0)) {
		goto __316
	}
	*(*uintptr)(unsafe.Pointer(bp /* next */)) = uintptr(Z_NULL)
	ret = -5
	goto inf_leave
__316:
	;
__315:
	;
	goto __313
__313:
	if 0 != 0 {
		goto __312
	}
	goto __314
__314:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* next */)), 1))))) << bits)
	bits = bits + (uint32(8))
	goto __310
__310:
	if 0 != 0 {
		goto __309
	}
	goto __311
__311:
	;
	goto __307
__308:
	;
	goto __305
__305:
	if 0 != 0 {
		goto __304
	}
	goto __306
__306:
	;
	*(*uint32)(unsafe.Pointer(state + 72 /* &.offset */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__317:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __318
__318:
	if 0 != 0 {
		goto __317
	}
	goto __319
__319:
	;
__303:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Foffset > ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
			return left
		}
		return uint32(0)
	}()))) {
		goto __320
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __5
__320:
	;

	// copy match from window to output
__321:
__324:
	if !(left == uint32(0)) {
		goto __327
	}
	put = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	left = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = left
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, put, left) != 0) {
		goto __328
	}
	ret = -5
	goto inf_leave
__328:
	;
__327:
	;
	goto __325
__325:
	if 0 != 0 {
		goto __324
	}
	goto __326
__326:
	;
	copy = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (*Inflate_state)(unsafe.Pointer(state)).Foffset)
	if !(copy < left) {
		goto __329
	}
	from = (put + uintptr(copy))
	copy = (left - copy)
	goto __330
__329:
	from = (put - uintptr((*Inflate_state)(unsafe.Pointer(state)).Foffset))
	copy = left
__330:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Flength) {
		goto __331
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__331:
	;
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) -= (copy)
	left = left - (copy)
__332:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __333
__333:
	if libc.PreDecUint32(&copy, 1) != 0 {
		goto __332
	}
	goto __334
__334:
	;
	goto __322
__322:
	if (*Inflate_state)(unsafe.Pointer(state)).Flength != uint32(0) {
		goto __321
	}
	goto __323
__323:
	;
	goto __5

__10:
	// inflate stream terminated properly -- write leftover output
	ret = Z_STREAM_END
	if !(left < (*Inflate_state)(unsafe.Pointer(state)).Fwsize) {
		goto __335
	}
	if !((*(*func(*libc.TLS, uintptr, uintptr, uint32) int32)(unsafe.Pointer(&out)))(tls, out_desc, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, ((*Inflate_state)(unsafe.Pointer(state)).Fwsize-left)) != 0) {
		goto __336
	}
	ret = -5
__336:
	;
__335:
	;
	goto inf_leave

__11:
	ret = -3
	goto inf_leave

__12: // can't happen, but makes compilers happy
	ret = -2
	goto inf_leave
__5:
	;
	goto __3
__3:
	goto __2
	goto __4
__4:
	;

	// Return unused input
inf_leave:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = *(*uintptr)(unsafe.Pointer(bp /* next */))
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	return ret
}

var order =                                                                                                                                                                                                                          // permutation of code lengths
[19]uint16{uint16(16), uint16(17), uint16(18), uint16(0), uint16(8), uint16(7), uint16(9), uint16(6), uint16(10), uint16(5), uint16(11), uint16(4), uint16(12), uint16(3), uint16(13), uint16(2), uint16(14), uint16(1), uint16(15)} /* infback.c:269:33 */

func XinflateBackEnd(tls *libc.TLS, strm Z_streamp) int32 { /* infback.c:631:13: */
	if ((strm == uintptr(Z_NULL)) || ((*Z_stream)(unsafe.Pointer(strm)).Fstate == uintptr(Z_NULL))) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return -2
	}
	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = uintptr(Z_NULL)

	return Z_OK
}

//
//    Decode literal, length, and distance codes and write out the resulting
//    literal and match bytes until either not enough input or output is
//    available, an end-of-block is encountered, or a data error is encountered.
//    When large enough input and output buffers are supplied to inflate(), for
//    example, a 16K input buffer and a 64K output buffer, more than 95% of the
//    inflate execution time is spent in this routine.
//
//    Entry assumptions:
//
//         state->mode == LEN
//         strm->avail_in >= 6
//         strm->avail_out >= 258
//         start >= strm->avail_out
//         state->bits < 8
//
//    On return, state->mode is one of:
//
//         LEN -- ran out of enough output space or enough available input
//         TYPE -- reached end of block code, inflate() to interpret next block
//         BAD -- error in block data
//
//    Notes:
//
//     - The maximum input bits used by a length/distance pair is 15 bits for the
//       length code, 5 bits for the length extra, 15 bits for the distance code,
//       and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
//       Therefore if strm->avail_in >= 6, then there is enough input to avoid
//       checking for available input while decoding.
//
//     - The maximum bytes that a single length/distance pair can output is 258
//       bytes, which is the maximum length that can be coded.  inflate_fast()
//       requires strm->avail_out >= 258 for each loop to avoid checking for
//       output space.
//
func Xinflate_fast(tls *libc.TLS, strm Z_streamp, start uint32) { /* inffast.c:50:20: */
	var state uintptr
	var in uintptr     // local strm->next_in
	var last uintptr   // have enough input while in < last
	var out uintptr    // local strm->next_out
	var beg uintptr    // inflate()'s initial strm->next_out
	var end uintptr    // while out < end, enough space available
	var wsize uint32   // window size or zero if not using window
	var whave uint32   // valid bytes in the window
	var wnext uint32   // window write index
	var window uintptr // allocated sliding window, if wsize != 0
	var hold uint32    // local strm->hold
	var bits uint32    // local strm->bits
	var lcode uintptr  // local strm->lencode
	var dcode uintptr  // local strm->distcode
	var lmask uint32   // mask for first level of length codes
	var dmask uint32   // mask for first level of distance codes
	var here Code      // retrieved table entry
	var op uint32      // code bits, operation, extra bits, or
	//  window position, window bytes to copy
	var len uint32   // match length, unused bytes
	var dist uint32  // match distance
	var from uintptr // where to copy match from

	// copy state to local variables
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	in = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	last = (in + uintptr(((*Z_stream)(unsafe.Pointer(strm)).Favail_in - UInt(5))))
	out = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	beg = (out - uintptr((start - (*Z_stream)(unsafe.Pointer(strm)).Favail_out)))
	end = (out + uintptr(((*Z_stream)(unsafe.Pointer(strm)).Favail_out - UInt(257))))
	wsize = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	whave = (*Inflate_state)(unsafe.Pointer(state)).Fwhave
	wnext = (*Inflate_state)(unsafe.Pointer(state)).Fwnext
	window = (*Inflate_state)(unsafe.Pointer(state)).Fwindow
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	lcode = (*Inflate_state)(unsafe.Pointer(state)).Flencode
	dcode = (*Inflate_state)(unsafe.Pointer(state)).Fdistcode
	lmask = ((uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Flenbits) - uint32(1))
	dmask = ((uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fdistbits) - uint32(1))

	// decode literals and length/distances until end-of-block or not enough
	//        input data or output space
__1:
	if !(bits < uint32(15)) {
		goto __4
	}
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__4:
	;
	here = *(*Code)(unsafe.Pointer(lcode + uintptr((hold&uint32(lmask)))*4))
dolen:
	op = uint32(here.Fbits)
	hold >>= op
	bits = bits - (op)
	op = uint32(here.Fop)
	if !(op == uint32(0)) {
		goto __5
	} // literal

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = uint8(here.Fval)
	goto __6
__5:
	if !((op & uint32(16)) != 0) {
		goto __7
	} // length base
	len = uint32(here.Fval)
	op = op & (uint32(15)) // number of extra bits
	if !(op != 0) {
		goto __9
	}
	if !(bits < op) {
		goto __10
	}
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__10:
	;
	len = len + (uint32(hold) & ((uint32(1) << op) - uint32(1)))
	hold >>= op
	bits = bits - (op)
__9:
	;

	if !(bits < uint32(15)) {
		goto __11
	}
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__11:
	;
	here = *(*Code)(unsafe.Pointer(dcode + uintptr((hold&uint32(dmask)))*4))
dodist:
	op = uint32(here.Fbits)
	hold >>= op
	bits = bits - (op)
	op = uint32(here.Fop)
	if !((op & uint32(16)) != 0) {
		goto __12
	} // distance base
	dist = uint32(here.Fval)
	op = op & (uint32(15)) // number of extra bits
	if !(bits < op) {
		goto __14
	}
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
	if !(bits < op) {
		goto __15
	}
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&in, 1))))) << bits)
	bits = bits + (uint32(8))
__15:
	;
__14:
	;
	dist = dist + (uint32(hold) & ((uint32(1) << op) - uint32(1)))
	hold >>= op
	bits = bits - (op)

	op = (uint32((int32(out) - int32(beg)) / 1)) // max distance in output
	if !(dist > op) {
		goto __16
	} // see if copy from window
	op = (dist - op) // distance back in window
	if !(op > whave) {
		goto __18
	}
	if !((*Inflate_state)(unsafe.Pointer(state)).Fsane != 0) {
		goto __19
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__19:
	;
__18:
	;
	from = window
	if !(wnext == uint32(0)) {
		goto __20
	} // very common case
	from += (uintptr(wsize - op))
	if !(op < len) {
		goto __22
	} // some from window
	len = len - (op)
__23:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __24
__24:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __23
	}
	goto __25
__25:
	;
	from = (out - uintptr(dist)) // rest from output
__22:
	;
	goto __21
__20:
	if !(wnext < op) {
		goto __26
	} // wrap around window
	from += (uintptr((wsize + wnext) - op))
	op = op - (wnext)
	if !(op < len) {
		goto __28
	} // some from end of window
	len = len - (op)
__29:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __30
__30:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __29
	}
	goto __31
__31:
	;
	from = window
	if !(wnext < len) {
		goto __32
	} // some from start of window
	op = wnext
	len = len - (op)
__33:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __34
__34:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __33
	}
	goto __35
__35:
	;
	from = (out - uintptr(dist)) // rest from output
__32:
	;
__28:
	;
	goto __27
__26: // contiguous in window
	from += (uintptr(wnext - op))
	if !(op < len) {
		goto __36
	} // some from window
	len = len - (op)
__37:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __38
__38:
	if libc.PreDecUint32(&op, 1) != 0 {
		goto __37
	}
	goto __39
__39:
	;
	from = (out - uintptr(dist)) // rest from output
__36:
	;
__27:
	;
__21:
	;
__40:
	if !(len > uint32(2)) {
		goto __41
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	len = len - (uint32(3))
	goto __40
__41:
	;
	if !(len != 0) {
		goto __42
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	if !(len > uint32(1)) {
		goto __43
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
__43:
	;
__42:
	;
	goto __17
__16:
	from = (out - uintptr(dist)) // copy direct from output
__44: // minimum length is three
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	len = len - (uint32(3))
	goto __45
__45:
	if len > uint32(2) {
		goto __44
	}
	goto __46
__46:
	;
	if !(len != 0) {
		goto __47
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	if !(len > uint32(1)) {
		goto __48
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
__48:
	;
__47:
	;
__17:
	;
	goto __13
__12:
	if !((op & uint32(64)) == uint32(0)) {
		goto __49
	} // 2nd level distance code
	here = *(*Code)(unsafe.Pointer(dcode + uintptr((uint32(here.Fval)+(hold&(uint32((uint32(1)<<op)-uint32(1))))))*4))
	goto dodist
	goto __50
__49:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__50:
	;
__13:
	;
	goto __8
__7:
	if !((op & uint32(64)) == uint32(0)) {
		goto __51
	} // 2nd level length code
	here = *(*Code)(unsafe.Pointer(lcode + uintptr((uint32(here.Fval)+(hold&(uint32((uint32(1)<<op)-uint32(1))))))*4))
	goto dolen
	goto __52
__51:
	if !((op & uint32(32)) != 0) {
		goto __53
	} // end-of-block

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __3
	goto __54
__53:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __3
__54:
	;
__52:
	;
__8:
	;
__6:
	;
	goto __2
__2:
	if (in < last) && (out < end) {
		goto __1
	}
	goto __3
__3:
	;

	// return unused bytes (on entry, bits < 8, so in won't go too far back)
	len = (bits >> 3)
	in -= uintptr(len)
	bits = bits - (len << 3)
	hold = hold & (uint32((uint32(1) << bits) - uint32(1)))

	// update state and return
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = in
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = out
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = func() uint32 {
		if in < last {
			return (uint32(5 + ((int32(last) - int32(in)) / 1)))
		}
		return (uint32(5 - ((int32(in) - int32(last)) / 1)))
	}()
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = func() uint32 {
		if out < end {
			return (uint32(257 + ((int32(end) - int32(out)) / 1)))
		}
		return (uint32(257 - ((int32(out) - int32(end)) / 1)))
	}()
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	return
}

//
//    inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
//    - Using bit fields for code structure
//    - Different op definition to avoid & for extra bits (do & for table bits)
//    - Three separate decoding do-loops for direct, window, and wnext == 0
//    - Special case for distance > 1 copies to do overlapped load and store copy
//    - Explicit branch predictions (based on measured branch probabilities)
//    - Deferring match copy and interspersed it with decoding subsequent codes
//    - Swapping literal/length else
//    - Swapping window/direct else
//    - Larger unrolled copy loops (three is about right)
//    - Moving len -= 3 statement into middle of loop
//

func inflateStateCheck(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:105:11: */
	var state uintptr
	if ((strm == uintptr(Z_NULL)) || ((*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0))) || ((*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0)) {
		return 1
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if (((state == uintptr(Z_NULL)) || ((*Inflate_state)(unsafe.Pointer(state)).Fstrm != strm)) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode < HEAD)) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode > SYNC) {
		return 1
	}
	return 0
}

func XinflateResetKeep(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:119:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = libc.AssignPtrUint32(strm+20 /* &.total_out */, libc.AssignPtrUint32(state+32 /* &.total */, uint32(0)))
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL)
	if (*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0 { // to support ill-conceived Java test suite
		(*Z_stream)(unsafe.Pointer(strm)).Fadler = (ULong((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 1))
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HEAD
	(*Inflate_state)(unsafe.Pointer(state)).Flast = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fhavedict = 0
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = 32768
	(*Inflate_state)(unsafe.Pointer(state)).Fhead = Gz_headerp(Z_NULL)
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = libc.AssignPtrUintptr(state+84 /* &.distcode */, libc.AssignPtrUintptr(state+112 /* &.next */, state+1332 /* &.codes */))
	(*Inflate_state)(unsafe.Pointer(state)).Fsane = 1
	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1

	return Z_OK
}

func XinflateReset(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:144:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	(*Inflate_state)(unsafe.Pointer(state)).Fwsize = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
	return XinflateResetKeep(tls, strm)
}

func XinflateReset2(tls *libc.TLS, strm Z_streamp, windowBits int32) int32 { /* inflate.c:157:13: */
	var wrap int32
	var state uintptr

	// get the state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// extract wrap request from windowBits parameter
	if windowBits < 0 {
		wrap = 0
		windowBits = -windowBits
	} else {
		wrap = ((windowBits >> 4) + 5)
		if windowBits < 48 {
			windowBits = windowBits & (15)
		}
	}

	// set number of window bits, free window if different
	if (windowBits != 0) && ((windowBits < 8) || (windowBits > 15)) {
		return -2
	}
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwindow != uintptr(Z_NULL)) && ((*Inflate_state)(unsafe.Pointer(state)).Fwbits != uint32(windowBits)) {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Inflate_state)(unsafe.Pointer(state)).Fwindow)
		(*Inflate_state)(unsafe.Pointer(state)).Fwindow = uintptr(Z_NULL)
	}

	// update state and reset the rest of it
	(*Inflate_state)(unsafe.Pointer(state)).Fwrap = wrap
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = uint32(windowBits)
	return XinflateReset(tls, strm)
}

func XinflateInit2_(tls *libc.TLS, strm Z_streamp, windowBits int32, version uintptr, stream_size int32) int32 { /* inflate.c:195:13: */
	var ret int32
	var state uintptr

	if ((version == uintptr(Z_NULL)) || (int32(*(*int8)(unsafe.Pointer(version))) != int32(*(*int8)(unsafe.Pointer(ts /* "1.2.11" */))))) || (stream_size != (int32(unsafe.Sizeof(Z_stream{})))) {
		return -6
	}
	if strm == uintptr(Z_NULL) {
		return -2
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = uintptr(Z_NULL) // in case we return an error
	if (*Z_stream)(unsafe.Pointer(strm)).Fzalloc == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, uint32, uint32) Voidpf
		}{Xzcalloc}))
		(*Z_stream)(unsafe.Pointer(strm)).Fopaque = uintptr(0)
	}
	if (*Z_stream)(unsafe.Pointer(strm)).Fzfree == uintptr(0) {
		(*Z_stream)(unsafe.Pointer(strm)).Fzfree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Voidpf, Voidpf)
		}{Xzcfree}))
	}
	state = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if state == uintptr(Z_NULL) {
		return -4
	}

	(*Z_stream)(unsafe.Pointer(strm)).Fstate = state
	(*Inflate_state)(unsafe.Pointer(state)).Fstrm = strm
	(*Inflate_state)(unsafe.Pointer(state)).Fwindow = uintptr(Z_NULL)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HEAD // to pass state test in inflateReset2()
	ret = XinflateReset2(tls, strm, windowBits)
	if ret != Z_OK {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, state)
		(*Z_stream)(unsafe.Pointer(strm)).Fstate = uintptr(Z_NULL)
	}
	return ret
}

func XinflateInit_(tls *libc.TLS, strm Z_streamp, version uintptr, stream_size int32) int32 { /* inflate.c:239:13: */
	return XinflateInit2_(tls, strm, MAX_WBITS, version, stream_size)
}

func XinflatePrime(tls *libc.TLS, strm Z_streamp, bits int32, value int32) int32 { /* inflate.c:247:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if bits < 0 {
		(*Inflate_state)(unsafe.Pointer(state)).Fhold = uint32(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fbits = uint32(0)
		return Z_OK
	}
	if (bits > 16) || (((*Inflate_state)(unsafe.Pointer(state)).Fbits + UInt(bits)) > uint32(32)) {
		return -2
	}
	value = int32(int32(value) & ((int32(1) << bits) - 1))
	*(*uint32)(unsafe.Pointer(state + 60 /* &.hold */)) += (uint32(uint32(value) << (*Inflate_state)(unsafe.Pointer(state)).Fbits))
	*(*uint32)(unsafe.Pointer(state + 64 /* &.bits */)) += (UInt(bits))
	return Z_OK
}

//
//    Return state with length and distance decoding tables and index sizes set to
//    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
//    If BUILDFIXED is defined, then instead this routine builds the tables the
//    first time it's called, and returns those tables the first time and
//    thereafter.  This reduces the size of the code by about 2K bytes, in
//    exchange for a little execution time.  However, BUILDFIXED should not be
//    used for threaded applications, since the rewriting of the tables and virgin
//    may not be thread-safe.
//
func fixedtables1(tls *libc.TLS, state uintptr) { /* inflate.c:278:12: */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = uintptr(unsafe.Pointer(&lenfix1))
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = uintptr(unsafe.Pointer(&distfix1))
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(5)
}

var lenfix1 = [512]Code{
	{Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)}, {Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)},
	{Fbits: uint8(9), Fval: uint16(192)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)}, {Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(160)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)},
	{Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(224)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(144)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)},
	{Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(208)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(176)},
	{Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)}, {Fbits: uint8(9), Fval: uint16(240)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)},
	{Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)}, {Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(200)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)},
	{Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(168)}, {Fbits: uint8(8), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(232)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)},
	{Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(152)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(216)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)}, {Fbits: uint8(9), Fval: uint16(184)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)},
	{Fbits: uint8(9), Fval: uint16(248)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)}, {Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)},
	{Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(196)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(164)}, {Fbits: uint8(8), Fval: uint16(2)},
	{Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(228)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(148)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)}, {Fbits: uint8(9), Fval: uint16(212)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)},
	{Fbits: uint8(9), Fval: uint16(180)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)}, {Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(244)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)},
	{Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(204)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)},
	{Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(172)}, {Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(236)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)}, {Fbits: uint8(9), Fval: uint16(156)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)},
	{Fbits: uint8(9), Fval: uint16(220)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)}, {Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(188)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)},
	{Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(252)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)},
	{Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(194)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(162)},
	{Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)}, {Fbits: uint8(9), Fval: uint16(226)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)},
	{Fbits: uint8(9), Fval: uint16(146)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)}, {Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(210)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)},
	{Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(178)}, {Fbits: uint8(8), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(242)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(202)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)}, {Fbits: uint8(9), Fval: uint16(170)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)},
	{Fbits: uint8(9), Fval: uint16(234)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)}, {Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(154)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)},
	{Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(218)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(186)}, {Fbits: uint8(8), Fval: uint16(13)},
	{Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(250)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)}, {Fbits: uint8(9), Fval: uint16(198)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)},
	{Fbits: uint8(9), Fval: uint16(166)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)}, {Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(230)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)},
	{Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(150)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(214)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)},
	{Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(182)}, {Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(246)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)},
	{Fbits: uint8(9), Fval: uint16(206)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)}, {Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(174)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)},
	{Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(238)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(158)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)},
	{Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(222)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(190)},
	{Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)}, {Fbits: uint8(9), Fval: uint16(254)}, {Fop: uint8(96), Fbits: uint8(7)}, {Fbits: uint8(8), Fval: uint16(80)}, {Fbits: uint8(8), Fval: uint16(16)},
	{Fop: uint8(20), Fbits: uint8(8), Fval: uint16(115)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(112)}, {Fbits: uint8(8), Fval: uint16(48)}, {Fbits: uint8(9), Fval: uint16(193)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(96)},
	{Fbits: uint8(8), Fval: uint16(32)}, {Fbits: uint8(9), Fval: uint16(161)}, {Fbits: uint8(8)}, {Fbits: uint8(8), Fval: uint16(128)}, {Fbits: uint8(8), Fval: uint16(64)}, {Fbits: uint8(9), Fval: uint16(225)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)},
	{Fbits: uint8(8), Fval: uint16(88)}, {Fbits: uint8(8), Fval: uint16(24)}, {Fbits: uint8(9), Fval: uint16(145)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(120)}, {Fbits: uint8(8), Fval: uint16(56)}, {Fbits: uint8(9), Fval: uint16(209)},
	{Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(104)}, {Fbits: uint8(8), Fval: uint16(40)}, {Fbits: uint8(9), Fval: uint16(177)}, {Fbits: uint8(8), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(136)}, {Fbits: uint8(8), Fval: uint16(72)},
	{Fbits: uint8(9), Fval: uint16(241)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(84)}, {Fbits: uint8(8), Fval: uint16(20)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(227)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(116)},
	{Fbits: uint8(8), Fval: uint16(52)}, {Fbits: uint8(9), Fval: uint16(201)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(100)}, {Fbits: uint8(8), Fval: uint16(36)}, {Fbits: uint8(9), Fval: uint16(169)}, {Fbits: uint8(8), Fval: uint16(4)},
	{Fbits: uint8(8), Fval: uint16(132)}, {Fbits: uint8(8), Fval: uint16(68)}, {Fbits: uint8(9), Fval: uint16(233)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(92)}, {Fbits: uint8(8), Fval: uint16(28)}, {Fbits: uint8(9), Fval: uint16(153)},
	{Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(124)}, {Fbits: uint8(8), Fval: uint16(60)}, {Fbits: uint8(9), Fval: uint16(217)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)}, {Fbits: uint8(8), Fval: uint16(108)}, {Fbits: uint8(8), Fval: uint16(44)},
	{Fbits: uint8(9), Fval: uint16(185)}, {Fbits: uint8(8), Fval: uint16(12)}, {Fbits: uint8(8), Fval: uint16(140)}, {Fbits: uint8(8), Fval: uint16(76)}, {Fbits: uint8(9), Fval: uint16(249)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(82)},
	{Fbits: uint8(8), Fval: uint16(18)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(163)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(114)}, {Fbits: uint8(8), Fval: uint16(50)}, {Fbits: uint8(9), Fval: uint16(197)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)},
	{Fbits: uint8(8), Fval: uint16(98)}, {Fbits: uint8(8), Fval: uint16(34)}, {Fbits: uint8(9), Fval: uint16(165)}, {Fbits: uint8(8), Fval: uint16(2)}, {Fbits: uint8(8), Fval: uint16(130)}, {Fbits: uint8(8), Fval: uint16(66)}, {Fbits: uint8(9), Fval: uint16(229)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(90)}, {Fbits: uint8(8), Fval: uint16(26)}, {Fbits: uint8(9), Fval: uint16(149)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)}, {Fbits: uint8(8), Fval: uint16(122)}, {Fbits: uint8(8), Fval: uint16(58)},
	{Fbits: uint8(9), Fval: uint16(213)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(106)}, {Fbits: uint8(8), Fval: uint16(42)}, {Fbits: uint8(9), Fval: uint16(181)}, {Fbits: uint8(8), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(138)},
	{Fbits: uint8(8), Fval: uint16(74)}, {Fbits: uint8(9), Fval: uint16(245)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(86)}, {Fbits: uint8(8), Fval: uint16(22)}, {Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)},
	{Fbits: uint8(8), Fval: uint16(118)}, {Fbits: uint8(8), Fval: uint16(54)}, {Fbits: uint8(9), Fval: uint16(205)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(102)}, {Fbits: uint8(8), Fval: uint16(38)}, {Fbits: uint8(9), Fval: uint16(173)},
	{Fbits: uint8(8), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(134)}, {Fbits: uint8(8), Fval: uint16(70)}, {Fbits: uint8(9), Fval: uint16(237)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)}, {Fbits: uint8(8), Fval: uint16(94)}, {Fbits: uint8(8), Fval: uint16(30)},
	{Fbits: uint8(9), Fval: uint16(157)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(126)}, {Fbits: uint8(8), Fval: uint16(62)}, {Fbits: uint8(9), Fval: uint16(221)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(110)},
	{Fbits: uint8(8), Fval: uint16(46)}, {Fbits: uint8(9), Fval: uint16(189)}, {Fbits: uint8(8), Fval: uint16(14)}, {Fbits: uint8(8), Fval: uint16(142)}, {Fbits: uint8(8), Fval: uint16(78)}, {Fbits: uint8(9), Fval: uint16(253)}, {Fop: uint8(96), Fbits: uint8(7)},
	{Fbits: uint8(8), Fval: uint16(81)}, {Fbits: uint8(8), Fval: uint16(17)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(131)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(31)}, {Fbits: uint8(8), Fval: uint16(113)}, {Fbits: uint8(8), Fval: uint16(49)}, {Fbits: uint8(9), Fval: uint16(195)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(10)}, {Fbits: uint8(8), Fval: uint16(97)}, {Fbits: uint8(8), Fval: uint16(33)}, {Fbits: uint8(9), Fval: uint16(163)}, {Fbits: uint8(8), Fval: uint16(1)}, {Fbits: uint8(8), Fval: uint16(129)}, {Fbits: uint8(8), Fval: uint16(65)},
	{Fbits: uint8(9), Fval: uint16(227)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(6)}, {Fbits: uint8(8), Fval: uint16(89)}, {Fbits: uint8(8), Fval: uint16(25)}, {Fbits: uint8(9), Fval: uint16(147)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(59)}, {Fbits: uint8(8), Fval: uint16(121)},
	{Fbits: uint8(8), Fval: uint16(57)}, {Fbits: uint8(9), Fval: uint16(211)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(17)}, {Fbits: uint8(8), Fval: uint16(105)}, {Fbits: uint8(8), Fval: uint16(41)}, {Fbits: uint8(9), Fval: uint16(179)}, {Fbits: uint8(8), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(137)}, {Fbits: uint8(8), Fval: uint16(73)}, {Fbits: uint8(9), Fval: uint16(243)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(4)}, {Fbits: uint8(8), Fval: uint16(85)}, {Fbits: uint8(8), Fval: uint16(21)}, {Fop: uint8(16), Fbits: uint8(8), Fval: uint16(258)},
	{Fop: uint8(19), Fbits: uint8(7), Fval: uint16(43)}, {Fbits: uint8(8), Fval: uint16(117)}, {Fbits: uint8(8), Fval: uint16(53)}, {Fbits: uint8(9), Fval: uint16(203)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(101)}, {Fbits: uint8(8), Fval: uint16(37)},
	{Fbits: uint8(9), Fval: uint16(171)}, {Fbits: uint8(8), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(133)}, {Fbits: uint8(8), Fval: uint16(69)}, {Fbits: uint8(9), Fval: uint16(235)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(8)}, {Fbits: uint8(8), Fval: uint16(93)},
	{Fbits: uint8(8), Fval: uint16(29)}, {Fbits: uint8(9), Fval: uint16(155)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(125)}, {Fbits: uint8(8), Fval: uint16(61)}, {Fbits: uint8(9), Fval: uint16(219)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(23)},
	{Fbits: uint8(8), Fval: uint16(109)}, {Fbits: uint8(8), Fval: uint16(45)}, {Fbits: uint8(9), Fval: uint16(187)}, {Fbits: uint8(8), Fval: uint16(13)}, {Fbits: uint8(8), Fval: uint16(141)}, {Fbits: uint8(8), Fval: uint16(77)}, {Fbits: uint8(9), Fval: uint16(251)},
	{Fop: uint8(16), Fbits: uint8(7), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(83)}, {Fbits: uint8(8), Fval: uint16(19)}, {Fop: uint8(21), Fbits: uint8(8), Fval: uint16(195)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(35)}, {Fbits: uint8(8), Fval: uint16(115)}, {Fbits: uint8(8), Fval: uint16(51)},
	{Fbits: uint8(9), Fval: uint16(199)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(35)}, {Fbits: uint8(9), Fval: uint16(167)}, {Fbits: uint8(8), Fval: uint16(3)}, {Fbits: uint8(8), Fval: uint16(131)},
	{Fbits: uint8(8), Fval: uint16(67)}, {Fbits: uint8(9), Fval: uint16(231)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(91)}, {Fbits: uint8(8), Fval: uint16(27)}, {Fbits: uint8(9), Fval: uint16(151)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(67)},
	{Fbits: uint8(8), Fval: uint16(123)}, {Fbits: uint8(8), Fval: uint16(59)}, {Fbits: uint8(9), Fval: uint16(215)}, {Fop: uint8(18), Fbits: uint8(7), Fval: uint16(19)}, {Fbits: uint8(8), Fval: uint16(107)}, {Fbits: uint8(8), Fval: uint16(43)}, {Fbits: uint8(9), Fval: uint16(183)},
	{Fbits: uint8(8), Fval: uint16(11)}, {Fbits: uint8(8), Fval: uint16(139)}, {Fbits: uint8(8), Fval: uint16(75)}, {Fbits: uint8(9), Fval: uint16(247)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(5)}, {Fbits: uint8(8), Fval: uint16(87)}, {Fbits: uint8(8), Fval: uint16(23)},
	{Fop: uint8(64), Fbits: uint8(8)}, {Fop: uint8(19), Fbits: uint8(7), Fval: uint16(51)}, {Fbits: uint8(8), Fval: uint16(119)}, {Fbits: uint8(8), Fval: uint16(55)}, {Fbits: uint8(9), Fval: uint16(207)}, {Fop: uint8(17), Fbits: uint8(7), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(103)},
	{Fbits: uint8(8), Fval: uint16(39)}, {Fbits: uint8(9), Fval: uint16(175)}, {Fbits: uint8(8), Fval: uint16(7)}, {Fbits: uint8(8), Fval: uint16(135)}, {Fbits: uint8(8), Fval: uint16(71)}, {Fbits: uint8(9), Fval: uint16(239)}, {Fop: uint8(16), Fbits: uint8(7), Fval: uint16(9)},
	{Fbits: uint8(8), Fval: uint16(95)}, {Fbits: uint8(8), Fval: uint16(31)}, {Fbits: uint8(9), Fval: uint16(159)}, {Fop: uint8(20), Fbits: uint8(7), Fval: uint16(99)}, {Fbits: uint8(8), Fval: uint16(127)}, {Fbits: uint8(8), Fval: uint16(63)}, {Fbits: uint8(9), Fval: uint16(223)},
	{Fop: uint8(18), Fbits: uint8(7), Fval: uint16(27)}, {Fbits: uint8(8), Fval: uint16(111)}, {Fbits: uint8(8), Fval: uint16(47)}, {Fbits: uint8(9), Fval: uint16(191)}, {Fbits: uint8(8), Fval: uint16(15)}, {Fbits: uint8(8), Fval: uint16(143)}, {Fbits: uint8(8), Fval: uint16(79)},
	{Fbits: uint8(9), Fval: uint16(255)},
} /* inffixed.h:10:23 */
var distfix1 = [32]Code{
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(1)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(257)}, {Fop: uint8(19), Fbits: uint8(5), Fval: uint16(17)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(4097)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(5)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1025)},
	{Fop: uint8(21), Fbits: uint8(5), Fval: uint16(65)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(16385)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(3)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(513)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(33)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(8193)},
	{Fop: uint8(18), Fbits: uint8(5), Fval: uint16(9)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(2049)}, {Fop: uint8(22), Fbits: uint8(5), Fval: uint16(129)}, {Fop: uint8(64), Fbits: uint8(5)}, {Fop: uint8(16), Fbits: uint8(5), Fval: uint16(2)}, {Fop: uint8(23), Fbits: uint8(5), Fval: uint16(385)},
	{Fop: uint8(19), Fbits: uint8(5), Fval: uint16(25)}, {Fop: uint8(27), Fbits: uint8(5), Fval: uint16(6145)}, {Fop: uint8(17), Fbits: uint8(5), Fval: uint16(7)}, {Fop: uint8(25), Fbits: uint8(5), Fval: uint16(1537)}, {Fop: uint8(21), Fbits: uint8(5), Fval: uint16(97)}, {Fop: uint8(29), Fbits: uint8(5), Fval: uint16(24577)},
	{Fop: uint8(16), Fbits: uint8(5), Fval: uint16(4)}, {Fop: uint8(24), Fbits: uint8(5), Fval: uint16(769)}, {Fop: uint8(20), Fbits: uint8(5), Fval: uint16(49)}, {Fop: uint8(28), Fbits: uint8(5), Fval: uint16(12289)}, {Fop: uint8(18), Fbits: uint8(5), Fval: uint16(13)}, {Fop: uint8(26), Fbits: uint8(5), Fval: uint16(3073)},
	{Fop: uint8(22), Fbits: uint8(5), Fval: uint16(193)}, {Fop: uint8(64), Fbits: uint8(5)},
} /* inffixed.h:87:23 */

//
//    Update the window with the last wsize (normally 32K) bytes written before
//    returning.  If window does not exist yet, create it.  This is only called
//    when a window is already in use, or when output has been written during this
//    inflate call, but the end of the deflate stream has not been reached yet.
//    It is also called to create a window for dictionary data when a dictionary
//    is loaded.
//
//    Providing output buffers larger than 32K to inflate() should provide a speed
//    advantage, since only the last 32K of output is copied to the sliding window
//    upon return from inflate(), and since all distances after the first 32K of
//    output will fall in the output data, making match copies simpler and faster.
//    The advantage may be dependent on the size of the processor's data caches.
//
func updatewindow(tls *libc.TLS, strm Z_streamp, end uintptr, copy uint32) int32 { /* inflate.c:396:11: */
	var state uintptr
	var dist uint32

	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// if it hasn't been done already, allocate space for the window
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow == uintptr(Z_NULL) {
		(*Inflate_state)(unsafe.Pointer(state)).Fwindow = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((strm + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits), uint32(unsafe.Sizeof(uint8(0))))
		if (*Inflate_state)(unsafe.Pointer(state)).Fwindow == uintptr(Z_NULL) {
			return 1
		}
	}

	// if window not in use yet, initialize
	if (*Inflate_state)(unsafe.Pointer(state)).Fwsize == uint32(0) {
		(*Inflate_state)(unsafe.Pointer(state)).Fwsize = (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits)
		(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fwhave = uint32(0)
	}

	// copy state->wsize or less output bytes into the circular window
	if copy >= (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
		libc.Xmemcpy(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, (end - uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwsize)), (*Inflate_state)(unsafe.Pointer(state)).Fwsize)
		(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
		(*Inflate_state)(unsafe.Pointer(state)).Fwhave = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
	} else {
		dist = ((*Inflate_state)(unsafe.Pointer(state)).Fwsize - (*Inflate_state)(unsafe.Pointer(state)).Fwnext)
		if dist > copy {
			dist = copy
		}
		libc.Xmemcpy(tls, ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)), (end - uintptr(copy)), dist)
		copy = copy - (dist)
		if copy != 0 {
			libc.Xmemcpy(tls, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, (end - uintptr(copy)), copy)
			(*Inflate_state)(unsafe.Pointer(state)).Fwnext = copy
			(*Inflate_state)(unsafe.Pointer(state)).Fwhave = (*Inflate_state)(unsafe.Pointer(state)).Fwsize
		} else {
			*(*uint32)(unsafe.Pointer(state + 52 /* &.wnext */)) += (dist)
			if (*Inflate_state)(unsafe.Pointer(state)).Fwnext == (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
				(*Inflate_state)(unsafe.Pointer(state)).Fwnext = uint32(0)
			}
			if (*Inflate_state)(unsafe.Pointer(state)).Fwhave < (*Inflate_state)(unsafe.Pointer(state)).Fwsize {
				*(*uint32)(unsafe.Pointer(state + 48 /* &.whave */)) += (dist)
			}
		}
	}
	return 0
}

// Macros for inflate():

// check function to use adler32() for zlib or crc32() for gzip

// check macros for header crc

// Load registers with state in inflate() for speed

// Restore state from registers in inflate()

// Clear the input bit accumulator

// Get a byte of input into the bit accumulator, or return from inflate()
//    if there is no input available.

// Assure that there are at least n bits in the bit accumulator.  If there is
//    not enough available input to do that, then return from inflate().

// Return the low n bits of the bit accumulator (n < 16)

// Remove n bits from the bit accumulator

// Remove zero to seven bits as needed to go to a byte boundary

//
//    inflate() uses a state machine to process as much input data and generate as
//    much output data as possible before returning.  The state machine is
//    structured roughly as follows:
//
//     for (;;) switch (state) {
//     ...
//     case STATEn:
//         if (not enough input data or output space to make progress)
//             return;
//         ... make progress ...
//         state = STATEm;
//         break;
//     ...
//     }
//
//    so when inflate() is called again, the same case is attempted again, and
//    if the appropriate resources are provided, the machine proceeds to the
//    next state.  The NEEDBITS() macro is usually the way the state evaluates
//    whether it can proceed or should return.  NEEDBITS() does the return if
//    the requested bits are not available.  The typical use of the BITS macros
//    is:
//
//         NEEDBITS(n);
//         ... do something with BITS(n) ...
//         DROPBITS(n);
//
//    where NEEDBITS(n) either returns from inflate() if there isn't enough
//    input left to load n bits into the accumulator, or it continues.  BITS(n)
//    gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
//    the low n bits off the accumulator.  INITBITS() clears the accumulator
//    and sets the number of available bits to zero.  BYTEBITS() discards just
//    enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
//    and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
//
//    NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
//    if there is no input available.  The decoding of variable length codes uses
//    PULLBYTE() directly in order to pull just enough bytes to decode the next
//    code, and no more.
//
//    Some states loop until they get enough input, making sure that enough
//    state information is maintained to continue the loop where it left off
//    if NEEDBITS() returns in the loop.  For example, want, need, and keep
//    would all have to actually be part of the saved state in case NEEDBITS()
//    returns:
//
//     case STATEw:
//         while (want < need) {
//             NEEDBITS(n);
//             keep[want++] = BITS(n);
//             DROPBITS(n);
//         }
//         state = STATEx;
//     case STATEx:
//
//    As shown above, if the next state is also the next case, then the break
//    is omitted.
//
//    A state may also return if there is not enough output space available to
//    complete that state.  Those states are copying stored data, writing a
//    literal byte, and copying a matching string.
//
//    When returning, a "goto inf_leave" is used to update the total counters,
//    update the check value, and determine whether any progress has been made
//    during that inflate() call in order to return the proper return code.
//    Progress is defined as a change in either strm->avail_in or strm->avail_out.
//    When there is a window, goto inf_leave will update the window with the last
//    output written.  If a goto inf_leave occurs in the middle of decompression
//    and there is no window currently, goto inf_leave will create one and copy
//    output to the window for the next call of inflate().
//
//    In this implementation, the flush parameter of inflate() only affects the
//    return code (per zlib.h).  inflate() always writes as much as possible to
//    strm->next_out, given the space available and the provided input--the effect
//    documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
//    the allocation of and copying into a sliding window until necessary, which
//    provides the effect documented in zlib.h for Z_FINISH when the entire input
//    stream available.  So the only thing the flush parameter actually does is:
//    when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
//    will return Z_BUF_ERROR if it has not reached the end of the stream.
//

func Xinflate(tls *libc.TLS, strm Z_streamp, flush int32) int32 { /* inflate.c:622:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var state uintptr
	var next uintptr // next input
	var put uintptr  // next output
	var have uint32
	var left uint32 // available input and output
	var hold uint32 // bit buffer
	var bits uint32 // bits in bit buffer
	var in uint32
	var out uint32   // save starting available input and output
	var copy uint32  // number of stored or match bytes to copy
	var from uintptr // where to copy match bytes from
	var here Code    // current decoding table entry
	var last Code    // parent table entry
	var len uint32   // length to copy for repeats, bits to drop
	var ret int32    // return code
	// var hbuf [4]uint8 at bp, 4

	if !(((inflateStateCheck(tls, strm) != 0) || ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out == uintptr(Z_NULL))) || (((*Z_stream)(unsafe.Pointer(strm)).Fnext_in == uintptr(Z_NULL)) && ((*Z_stream)(unsafe.Pointer(strm)).Favail_in != UInt(0)))) {
		goto __1
	}
	return -2
__1:
	;

	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE) {
		goto __2
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPEDO
__2:
	; // skip check
__3:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	in = have
	out = left
	ret = Z_OK
__6:
	switch (*Inflate_state)(unsafe.Pointer(state)).Fmode {
	case HEAD:
		goto __10
	case FLAGS:
		goto __11
	case TIME:
		goto __12
	case OS:
		goto __13
	case EXLEN:
		goto __14
	case EXTRA:
		goto __15
	case NAME:
		goto __16
	case COMMENT:
		goto __17
	case HCRC:
		goto __18
	case DICTID:
		goto __19
	case DICT:
		goto __20
	case TYPE:
		goto __21
	case TYPEDO:
		goto __22
	case STORED:
		goto __23
	case COPY_:
		goto __24
	case COPY:
		goto __25
	case TABLE:
		goto __26
	case LENLENS:
		goto __27
	case CODELENS:
		goto __28
	case LEN_:
		goto __29
	case LEN:
		goto __30
	case LENEXT:
		goto __31
	case DIST:
		goto __32
	case DISTEXT:
		goto __33
	case MATCH:
		goto __34
	case LIT:
		goto __35
	case CHECK:
		goto __36
	case LENGTH:
		goto __37
	case DONE:
		goto __38
	case BAD:
		goto __39
	case MEM:
		goto __40
	case SYNC:
		goto __41
	default:
		goto __42
	}
	goto __9
__10:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwrap == 0) {
		goto __43
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPEDO
	goto __9
__43:
	;
__44:
__47:
	if !(bits < (uint32(16))) {
		goto __48
	}
__49:
	if !(have == uint32(0)) {
		goto __52
	}
	goto inf_leave
__52:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __50
__50:
	if 0 != 0 {
		goto __49
	}
	goto __51
__51:
	;
	goto __47
__48:
	;
	goto __45
__45:
	if 0 != 0 {
		goto __44
	}
	goto __46
__46:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 2) != 0) && (hold == uint32(0x8b1f))) {
		goto __53
	} // gzip header
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwbits == uint32(0)) {
		goto __54
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = uint32(15)
__54:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
__55:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
__58:
	hold = uint32(0)
	bits = uint32(0)
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = FLAGS
	goto __9
__53:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fflags = 0 // expect zlib header
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __61
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fdone = -1
__61:
	;
	if !(!(((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 1) != 0) || ((((uint32((uint32(hold) & ((uint32(1) << (8)) - uint32(1))) << 8)) + (hold >> 8)) % uint32(31)) != 0)) {
		goto __62
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 669 /* "incorrect header..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__62:
	;
	if !((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) != uint32(Z_DEFLATED)) {
		goto __63
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 692 /* "unknown compress..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__63:
	;
__64:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __65
__65:
	if 0 != 0 {
		goto __64
	}
	goto __66
__66:
	;
	len = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(8))
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwbits == uint32(0)) {
		goto __67
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fwbits = len
__67:
	;
	if !((len > uint32(15)) || (len > (*Inflate_state)(unsafe.Pointer(state)).Fwbits)) {
		goto __68
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 719 /* "invalid window s..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__68:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdmax = (uint32(1) << len)

	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, Xadler32(tls, uint32(0), uintptr(Z_NULL), uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = func() uint32 {
		if (hold & uint32(0x200)) != 0 {
			return DICTID
		}
		return TYPE
	}()
__69:
	hold = uint32(0)
	bits = uint32(0)
	goto __70
__70:
	if 0 != 0 {
		goto __69
	}
	goto __71
__71:
	;
	goto __9
__11:
__72:
__75:
	if !(bits < (uint32(16))) {
		goto __76
	}
__77:
	if !(have == uint32(0)) {
		goto __80
	}
	goto inf_leave
__80:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __78
__78:
	if 0 != 0 {
		goto __77
	}
	goto __79
__79:
	;
	goto __75
__76:
	;
	goto __73
__73:
	if 0 != 0 {
		goto __72
	}
	goto __74
__74:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fflags = int32(hold)
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0xff) != Z_DEFLATED) {
		goto __81
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 692 /* "unknown compress..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__81:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0xe000) != 0) {
		goto __82
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 739 /* "unknown header f..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__82:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __83
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Ftext = (int32((hold >> 8) & uint32(1)))
__83:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __84
	}
__85:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __86
__86:
	if 0 != 0 {
		goto __85
	}
	goto __87
__87:
	;
__84:
	;
__88:
	hold = uint32(0)
	bits = uint32(0)
	goto __89
__89:
	if 0 != 0 {
		goto __88
	}
	goto __90
__90:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TIME
__12:
__91:
__94:
	if !(bits < (uint32(32))) {
		goto __95
	}
__96:
	if !(have == uint32(0)) {
		goto __99
	}
	goto inf_leave
__99:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __97
__97:
	if 0 != 0 {
		goto __96
	}
	goto __98
__98:
	;
	goto __94
__95:
	;
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __100
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Ftime = hold
__100:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __101
	}
__102:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 2)) = (uint8((hold) >> 16))
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 3)) = (uint8((hold) >> 24))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(4))
	goto __103
__103:
	if 0 != 0 {
		goto __102
	}
	goto __104
__104:
	;
__101:
	;
__105:
	hold = uint32(0)
	bits = uint32(0)
	goto __106
__106:
	if 0 != 0 {
		goto __105
	}
	goto __107
__107:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = OS
__13:
__108:
__111:
	if !(bits < (uint32(16))) {
		goto __112
	}
__113:
	if !(have == uint32(0)) {
		goto __116
	}
	goto inf_leave
__116:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __114
__114:
	if 0 != 0 {
		goto __113
	}
	goto __115
__115:
	;
	goto __111
__112:
	;
	goto __109
__109:
	if 0 != 0 {
		goto __108
	}
	goto __110
__110:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __117
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fxflags = (int32(hold & uint32(0xff)))
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fos = (int32(hold >> 8))
__117:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __118
	}
__119:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __120
__120:
	if 0 != 0 {
		goto __119
	}
	goto __121
__121:
	;
__118:
	;
__122:
	hold = uint32(0)
	bits = uint32(0)
	goto __123
__123:
	if 0 != 0 {
		goto __122
	}
	goto __124
__124:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = EXLEN
__14:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0400) != 0) {
		goto __125
	}
__127:
__130:
	if !(bits < (uint32(16))) {
		goto __131
	}
__132:
	if !(have == uint32(0)) {
		goto __135
	}
	goto inf_leave
__135:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __133
__133:
	if 0 != 0 {
		goto __132
	}
	goto __134
__134:
	;
	goto __130
__131:
	;
	goto __128
__128:
	if 0 != 0 {
		goto __127
	}
	goto __129
__129:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(hold)
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __136
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_len = uint32(hold)
__136:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __137
	}
__138:
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */)) = uint8(hold)
	*(*uint8)(unsafe.Pointer(bp /* &hbuf[0] */ + 1)) = (uint8((hold) >> 8))
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, bp /* &hbuf[0] */, uint32(2))
	goto __139
__139:
	if 0 != 0 {
		goto __138
	}
	goto __140
__140:
	;
__137:
	;
__141:
	hold = uint32(0)
	bits = uint32(0)
	goto __142
__142:
	if 0 != 0 {
		goto __141
	}
	goto __143
__143:
	;
	goto __126
__125:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __144
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra = uintptr(Z_NULL)
__144:
	;
__126:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = EXTRA
__15:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0400) != 0) {
		goto __145
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
	if !(copy > have) {
		goto __146
	}
	copy = have
__146:
	;
	if !(copy != 0) {
		goto __147
	}
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra != uintptr(Z_NULL))) {
		goto __148
	}
	len = ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_len - (*Inflate_state)(unsafe.Pointer(state)).Flength)
	libc.Xmemcpy(tls, ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra + uintptr(len)), next,
		func() uint32 {
			if (len + copy) > (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_max {
				return ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fextra_max - len)
			}
			return copy
		}())
__148:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __149
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__149:
	;
	have = have - (copy)
	next += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) -= (copy)
__147:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength != 0) {
		goto __150
	}
	goto inf_leave
__150:
	;
__145:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = NAME
__16:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0800) != 0) {
		goto __151
	}
	if !(have == uint32(0)) {
		goto __153
	}
	goto inf_leave
__153:
	;
	copy = uint32(0)
__154:
	len = uint32(*(*uint8)(unsafe.Pointer(next + uintptr(libc.PostIncUint32(&copy, 1)))))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname != uintptr(Z_NULL))) && ((*Inflate_state)(unsafe.Pointer(state)).Flength < (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname_max)) {
		goto __157
	}
	*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Flength, 1)))) = Bytef(len)
__157:
	;
	goto __155
__155:
	if (len != 0) && (copy < have) {
		goto __154
	}
	goto __156
__156:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __158
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__158:
	;
	have = have - (copy)
	next += uintptr(copy)
	if !(len != 0) {
		goto __159
	}
	goto inf_leave
__159:
	;
	goto __152
__151:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __160
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fname = uintptr(Z_NULL)
__160:
	;
__152:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COMMENT
__17:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x1000) != 0) {
		goto __161
	}
	if !(have == uint32(0)) {
		goto __163
	}
	goto inf_leave
__163:
	;
	copy = uint32(0)
__164:
	len = uint32(*(*uint8)(unsafe.Pointer(next + uintptr(libc.PostIncUint32(&copy, 1)))))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) && ((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment != uintptr(Z_NULL))) && ((*Inflate_state)(unsafe.Pointer(state)).Flength < (*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomm_max)) {
		goto __167
	}
	*(*Bytef)(unsafe.Pointer((*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Flength, 1)))) = Bytef(len)
__167:
	;
	goto __165
__165:
	if (len != 0) && (copy < have) {
		goto __164
	}
	goto __166
__166:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) && (((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0)) {
		goto __168
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fcheck = Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, next, copy)
__168:
	;
	have = have - (copy)
	next += uintptr(copy)
	if !(len != 0) {
		goto __169
	}
	goto inf_leave
__169:
	;
	goto __162
__161:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __170
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fcomment = uintptr(Z_NULL)
__170:
	;
__162:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = HCRC
__18:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fflags & 0x0200) != 0) {
		goto __171
	}
__172:
__175:
	if !(bits < (uint32(16))) {
		goto __176
	}
__177:
	if !(have == uint32(0)) {
		goto __180
	}
	goto inf_leave
__180:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __178
__178:
	if 0 != 0 {
		goto __177
	}
	goto __179
__179:
	;
	goto __175
__176:
	;
	goto __173
__173:
	if 0 != 0 {
		goto __172
	}
	goto __174
__174:
	;
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (hold != ((*Inflate_state)(unsafe.Pointer(state)).Fcheck & uint32(0xffff)))) {
		goto __181
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 764 /* "header crc misma..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__181:
	;
__182:
	hold = uint32(0)
	bits = uint32(0)
	goto __183
__183:
	if 0 != 0 {
		goto __182
	}
	goto __184
__184:
	;
__171:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhead != uintptr(Z_NULL)) {
		goto __185
	}
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fhcrc = (((*Inflate_state)(unsafe.Pointer(state)).Fflags >> 9) & 1)
	(*Gz_header)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fhead)).Fdone = 1
__185:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, Xcrc32(tls, uint32(0), uintptr(Z_NULL), uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__19:
__186:
__189:
	if !(bits < (uint32(32))) {
		goto __190
	}
__191:
	if !(have == uint32(0)) {
		goto __194
	}
	goto inf_leave
__194:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __192
__192:
	if 0 != 0 {
		goto __191
	}
	goto __193
__193:
	;
	goto __189
__190:
	;
	goto __187
__187:
	if 0 != 0 {
		goto __186
	}
	goto __188
__188:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, ((((((hold) >> 24) & uint32(0xff)) + (((hold) >> 8) & uint32(0xff00))) + (((hold) & uint32(0xff00)) << 8)) + (((hold) & uint32(0xff)) << 24)))
__195:
	hold = uint32(0)
	bits = uint32(0)
	goto __196
__196:
	if 0 != 0 {
		goto __195
	}
	goto __197
__197:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DICT
__20:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhavedict == 0) {
		goto __198
	}
__199:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __200
__200:
	if 0 != 0 {
		goto __199
	}
	goto __201
__201:
	;
	return Z_NEED_DICT
__198:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, Xadler32(tls, uint32(0), uintptr(Z_NULL), uint32(0)))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
__21:
	if !((flush == Z_BLOCK) || (flush == Z_TREES)) {
		goto __202
	}
	goto inf_leave
__202:
	;
__22:
	if !((*Inflate_state)(unsafe.Pointer(state)).Flast != 0) {
		goto __203
	}
__204:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __205
__205:
	if 0 != 0 {
		goto __204
	}
	goto __206
__206:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = CHECK
	goto __9
__203:
	;
__207:
__210:
	if !(bits < (uint32(3))) {
		goto __211
	}
__212:
	if !(have == uint32(0)) {
		goto __215
	}
	goto inf_leave
__215:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
	goto __210
__211:
	;
	goto __208
__208:
	if 0 != 0 {
		goto __207
	}
	goto __209
__209:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flast = (int32(uint32(hold) & ((uint32(1) << (1)) - uint32(1))))
__216:
	hold >>= 1
	bits = bits - (uint32(1))
	goto __217
__217:
	if 0 != 0 {
		goto __216
	}
	goto __218
__218:
	;
	switch uint32(hold) & ((uint32(1) << (2)) - uint32(1)) {
	case uint32(0):
		goto __220
	case uint32(1):
		goto __221
	case uint32(2):
		goto __222
	case uint32(3):
		goto __223
	}
	goto __219
__220: // stored block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = STORED
	goto __219
__221: // fixed block
	fixedtables1(tls, state)

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN_ // decode codes
	if !(flush == Z_TREES) {
		goto __224
	}
__225:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __226
__226:
	if 0 != 0 {
		goto __225
	}
	goto __227
__227:
	;
	goto inf_leave
__224:
	;
	goto __219
__222: // dynamic block
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TABLE
	goto __219
__223:
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 367 /* "invalid block ty..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
__219:
	;
__228:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __229
__229:
	if 0 != 0 {
		goto __228
	}
	goto __230
__230:
	;
	goto __9
__23:
__231:
	hold >>= (bits & uint32(7))
	bits = bits - (bits & uint32(7))
	goto __232
__232:
	if 0 != 0 {
		goto __231
	}
	goto __233
__233:
	; // go to byte boundary
__234:
__237:
	if !(bits < (uint32(32))) {
		goto __238
	}
__239:
	if !(have == uint32(0)) {
		goto __242
	}
	goto inf_leave
__242:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __240
__240:
	if 0 != 0 {
		goto __239
	}
	goto __241
__241:
	;
	goto __237
__238:
	;
	goto __235
__235:
	if 0 != 0 {
		goto __234
	}
	goto __236
__236:
	;
	if !((hold & uint32(0xffff)) != ((hold >> 16) ^ uint32(0xffff))) {
		goto __243
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 386 /* "invalid stored b..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__243:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Flength = (uint32(hold) & uint32(0xffff))

__244:
	hold = uint32(0)
	bits = uint32(0)
	goto __245
__245:
	if 0 != 0 {
		goto __244
	}
	goto __246
__246:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COPY_
	if !(flush == Z_TREES) {
		goto __247
	}
	goto inf_leave
__247:
	;
__24:
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = COPY
__25:
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
	if !(copy != 0) {
		goto __248
	}
	if !(copy > have) {
		goto __249
	}
	copy = have
__249:
	;
	if !(copy > left) {
		goto __250
	}
	copy = left
__250:
	;
	if !(copy == uint32(0)) {
		goto __251
	}
	goto inf_leave
__251:
	;
	libc.Xmemcpy(tls, put, next, copy)
	have = have - (copy)
	next += uintptr(copy)
	left = left - (copy)
	put += uintptr(copy)
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) -= (copy)
	goto __9
__248:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__26:
__252:
__255:
	if !(bits < (uint32(14))) {
		goto __256
	}
__257:
	if !(have == uint32(0)) {
		goto __260
	}
	goto inf_leave
__260:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __258
__258:
	if 0 != 0 {
		goto __257
	}
	goto __259
__259:
	;
	goto __255
__256:
	;
	goto __253
__253:
	if 0 != 0 {
		goto __252
	}
	goto __254
__254:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnlen = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(257))
__261:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __262
__262:
	if 0 != 0 {
		goto __261
	}
	goto __263
__263:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fndist = ((uint32(hold) & ((uint32(1) << (5)) - uint32(1))) + uint32(1))
__264:
	hold >>= 5
	bits = bits - (uint32(5))
	goto __265
__265:
	if 0 != 0 {
		goto __264
	}
	goto __266
__266:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fncode = ((uint32(hold) & ((uint32(1) << (4)) - uint32(1))) + uint32(4))
__267:
	hold >>= 4
	bits = bits - (uint32(4))
	goto __268
__268:
	if 0 != 0 {
		goto __267
	}
	goto __269
__269:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fnlen > uint32(286)) || ((*Inflate_state)(unsafe.Pointer(state)).Fndist > uint32(30))) {
		goto __270
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 415 /* "too many length ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__270:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENLENS
__27:
__271:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < (*Inflate_state)(unsafe.Pointer(state)).Fncode) {
		goto __272
	}
__273:
__276:
	if !(bits < (uint32(3))) {
		goto __277
	}
__278:
	if !(have == uint32(0)) {
		goto __281
	}
	goto inf_leave
__281:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __279
__279:
	if 0 != 0 {
		goto __278
	}
	goto __280
__280:
	;
	goto __276
__277:
	;
	goto __274
__274:
	if 0 != 0 {
		goto __273
	}
	goto __275
__275:
	;
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(order1[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = (uint16(uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__282:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __283
__283:
	if 0 != 0 {
		goto __282
	}
	goto __284
__284:
	;
	goto __271
__272:
	;
__285:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < uint32(19)) {
		goto __286
	}
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(order1[libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1)])*2)) = uint16(0)
	goto __285
__286:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1332 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(7)
	ret = Xinflate_table(tls, CODES, state+116 /* &.lens */, uint32(19), (state + 112 /* &.next */),
		(state + 88 /* &.lenbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __287
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 451 /* "invalid code len..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__287:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = CODELENS
__28:
__288:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave < ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __289
	}
__290:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __293
	}
	goto __292
__293:
	;
__294:
	if !(have == uint32(0)) {
		goto __297
	}
	goto inf_leave
__297:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __295
__295:
	if 0 != 0 {
		goto __294
	}
	goto __296
__296:
	;
	goto __291
__291:
	goto __290
	goto __292
__292:
	;
	if !(int32(here.Fval) < 16) {
		goto __298
	}
__300:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __301
__301:
	if 0 != 0 {
		goto __300
	}
	goto __302
__302:
	;
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = here.Fval
	goto __299
__298:
	if !(int32(here.Fval) == 16) {
		goto __303
	}
__305:
__308:
	if !(bits < (uint32(int32(here.Fbits) + 2))) {
		goto __309
	}
__310:
	if !(have == uint32(0)) {
		goto __313
	}
	goto inf_leave
__313:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __311
__311:
	if 0 != 0 {
		goto __310
	}
	goto __312
__312:
	;
	goto __308
__309:
	;
	goto __306
__306:
	if 0 != 0 {
		goto __305
	}
	goto __307
__307:
	;
__314:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __315
__315:
	if 0 != 0 {
		goto __314
	}
	goto __316
__316:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fhave == uint32(0)) {
		goto __317
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __289
__317:
	;
	len = uint32(*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fhave-uint32(1)))*2)))
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (2)) - uint32(1))))
__318:
	hold >>= 2
	bits = bits - (uint32(2))
	goto __319
__319:
	if 0 != 0 {
		goto __318
	}
	goto __320
__320:
	;
	goto __304
__303:
	if !(int32(here.Fval) == 17) {
		goto __321
	}
__323:
__326:
	if !(bits < (uint32(int32(here.Fbits) + 3))) {
		goto __327
	}
__328:
	if !(have == uint32(0)) {
		goto __331
	}
	goto inf_leave
__331:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __329
__329:
	if 0 != 0 {
		goto __328
	}
	goto __330
__330:
	;
	goto __326
__327:
	;
	goto __324
__324:
	if 0 != 0 {
		goto __323
	}
	goto __325
__325:
	;
__332:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __333
__333:
	if 0 != 0 {
		goto __332
	}
	goto __334
__334:
	;
	len = uint32(0)
	copy = (uint32(3) + (uint32(hold) & ((uint32(1) << (3)) - uint32(1))))
__335:
	hold >>= 3
	bits = bits - (uint32(3))
	goto __336
__336:
	if 0 != 0 {
		goto __335
	}
	goto __337
__337:
	;
	goto __322
__321:
__338:
__341:
	if !(bits < (uint32(int32(here.Fbits) + 7))) {
		goto __342
	}
__343:
	if !(have == uint32(0)) {
		goto __346
	}
	goto inf_leave
__346:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __344
__344:
	if 0 != 0 {
		goto __343
	}
	goto __345
__345:
	;
	goto __341
__342:
	;
	goto __339
__339:
	if 0 != 0 {
		goto __338
	}
	goto __340
__340:
	;
__347:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __348
__348:
	if 0 != 0 {
		goto __347
	}
	goto __349
__349:
	;
	len = uint32(0)
	copy = (uint32(11) + (uint32(hold) & ((uint32(1) << (7)) - uint32(1))))
__350:
	hold >>= 7
	bits = bits - (uint32(7))
	goto __351
__351:
	if 0 != 0 {
		goto __350
	}
	goto __352
__352:
	;
__322:
	;
__304:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fhave + copy) > ((*Inflate_state)(unsafe.Pointer(state)).Fnlen + (*Inflate_state)(unsafe.Pointer(state)).Fndist)) {
		goto __353
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 476 /* "invalid bit leng..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __289
__353:
	;
__354:
	if !(libc.PostDecUint32(&copy, 1) != 0) {
		goto __355
	}
	*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + uintptr(libc.PostIncUint32(&(*Inflate_state)(unsafe.Pointer(state)).Fhave, 1))*2)) = uint16(len)
	goto __354
__355:
	;
__299:
	;
	goto __288
__289:
	;

	// handle error breaks in while
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == BAD) {
		goto __356
	}
	goto __9
__356:
	;

	// check for end-of-block code (better have one)
	if !(int32(*(*uint16)(unsafe.Pointer((state + 116 /* &.lens */) + 256*2))) == 0) {
		goto __357
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 502 /* "invalid code -- ..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__357:
	;

	// build code tables -- note: do not change the lenbits or distbits
	//                values here (9 and 6) without reading the comments in inftrees.h
	//                concerning the ENOUGH constants, which depend on those values
	(*Inflate_state)(unsafe.Pointer(state)).Fnext = state + 1332 /* &.codes */
	(*Inflate_state)(unsafe.Pointer(state)).Flencode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Flenbits = uint32(9)
	ret = Xinflate_table(tls, LENS, state+116 /* &.lens */, (*Inflate_state)(unsafe.Pointer(state)).Fnlen, (state + 112 /* &.next */),
		(state + 88 /* &.lenbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __358
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 539 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__358:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fdistcode = (*Inflate_state)(unsafe.Pointer(state)).Fnext
	(*Inflate_state)(unsafe.Pointer(state)).Fdistbits = uint32(6)
	ret = Xinflate_table(tls, DISTS, ((state + 116 /* &.lens */) + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fnlen)*2), (*Inflate_state)(unsafe.Pointer(state)).Fndist,
		(state + 112 /* &.next */), (state + 92 /* &.distbits */), state+756 /* &.work */)
	if !(ret != 0) {
		goto __359
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 567 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__359:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN_
	if !(flush == Z_TREES) {
		goto __360
	}
	goto inf_leave
__360:
	;
__29:
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
__30:
	if !((have >= uint32(6)) && (left >= uint32(258))) {
		goto __361
	}
__362:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __363
__363:
	if 0 != 0 {
		goto __362
	}
	goto __364
__364:
	;
	Xinflate_fast(tls, strm, out)
__365:
	put = (*Z_stream)(unsafe.Pointer(strm)).Fnext_out
	left = (*Z_stream)(unsafe.Pointer(strm)).Favail_out
	next = (*Z_stream)(unsafe.Pointer(strm)).Fnext_in
	have = (*Z_stream)(unsafe.Pointer(strm)).Favail_in
	hold = (*Inflate_state)(unsafe.Pointer(state)).Fhold
	bits = (*Inflate_state)(unsafe.Pointer(state)).Fbits
	goto __366
__366:
	if 0 != 0 {
		goto __365
	}
	goto __367
__367:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE) {
		goto __368
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1
__368:
	;
	goto __9
__361:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fback = 0
__369:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Flenbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __372
	}
	goto __371
__372:
	;
__373:
	if !(have == uint32(0)) {
		goto __376
	}
	goto inf_leave
__376:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __374
__374:
	if 0 != 0 {
		goto __373
	}
	goto __375
__375:
	;
	goto __370
__370:
	goto __369
	goto __371
__371:
	;
	if !((here.Fop != 0) && ((int32(here.Fop) & 0xf0) == 0)) {
		goto __377
	}
	last = here
__378:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Flencode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __381
	}
	goto __380
__381:
	;
__382:
	if !(have == uint32(0)) {
		goto __385
	}
	goto inf_leave
__385:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __383
__383:
	if 0 != 0 {
		goto __382
	}
	goto __384
__384:
	;
	goto __379
__379:
	goto __378
	goto __380
__380:
	;
__386:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __387
__387:
	if 0 != 0 {
		goto __386
	}
	goto __388
__388:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += (int32(last.Fbits))
__377:
	;
__389:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __390
__390:
	if 0 != 0 {
		goto __389
	}
	goto __391
__391:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += (int32(here.Fbits))
	(*Inflate_state)(unsafe.Pointer(state)).Flength = uint32(here.Fval)
	if !((int32(here.Fop)) == 0) {
		goto __392
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LIT
	goto __9
__392:
	;
	if !((int32(here.Fop) & 32) != 0) {
		goto __393
	}

	(*Inflate_state)(unsafe.Pointer(state)).Fback = -1
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	goto __9
__393:
	;
	if !((int32(here.Fop) & 64) != 0) {
		goto __394
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 589 /* "invalid literal/..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__394:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENEXT
__31:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != 0) {
		goto __395
	}
__396:
__399:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __400
	}
__401:
	if !(have == uint32(0)) {
		goto __404
	}
	goto inf_leave
__404:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __402
__402:
	if 0 != 0 {
		goto __401
	}
	goto __403
__403:
	;
	goto __399
__400:
	;
	goto __397
__397:
	if 0 != 0 {
		goto __396
	}
	goto __398
__398:
	;
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__405:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __406
__406:
	if 0 != 0 {
		goto __405
	}
	goto __407
__407:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += int32(((*Inflate_state)(unsafe.Pointer(state)).Fextra))
__395:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fwas = (*Inflate_state)(unsafe.Pointer(state)).Flength
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DIST
__32:
__408:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(hold)&((uint32(1)<<((*Inflate_state)(unsafe.Pointer(state)).Fdistbits))-uint32(1))))*4))
	if !((uint32(here.Fbits)) <= bits) {
		goto __411
	}
	goto __410
__411:
	;
__412:
	if !(have == uint32(0)) {
		goto __415
	}
	goto inf_leave
__415:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __413
__413:
	if 0 != 0 {
		goto __412
	}
	goto __414
__414:
	;
	goto __409
__409:
	goto __408
	goto __410
__410:
	;
	if !((int32(here.Fop) & 0xf0) == 0) {
		goto __416
	}
	last = here
__417:
	here = *(*Code)(unsafe.Pointer((*Inflate_state)(unsafe.Pointer(state)).Fdistcode + uintptr((uint32(last.Fval)+((uint32(hold)&((uint32(1)<<(int32(last.Fbits)+int32(last.Fop)))-uint32(1)))>>int32(last.Fbits))))*4))
	if !((uint32(int32(last.Fbits) + int32(here.Fbits))) <= bits) {
		goto __420
	}
	goto __419
__420:
	;
__421:
	if !(have == uint32(0)) {
		goto __424
	}
	goto inf_leave
__424:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __422
__422:
	if 0 != 0 {
		goto __421
	}
	goto __423
__423:
	;
	goto __418
__418:
	goto __417
	goto __419
__419:
	;
__425:
	hold >>= int32(last.Fbits)
	bits = bits - (uint32(last.Fbits))
	goto __426
__426:
	if 0 != 0 {
		goto __425
	}
	goto __427
__427:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += (int32(last.Fbits))
__416:
	;
__428:
	hold >>= int32(here.Fbits)
	bits = bits - (uint32(here.Fbits))
	goto __429
__429:
	if 0 != 0 {
		goto __428
	}
	goto __430
__430:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += (int32(here.Fbits))
	if !((int32(here.Fop) & 64) != 0) {
		goto __431
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 617 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__431:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Foffset = uint32(here.Fval)
	(*Inflate_state)(unsafe.Pointer(state)).Fextra = ((uint32(here.Fop)) & uint32(15))
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DISTEXT
__33:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fextra != 0) {
		goto __432
	}
__433:
__436:
	if !(bits < ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) {
		goto __437
	}
__438:
	if !(have == uint32(0)) {
		goto __441
	}
	goto inf_leave
__441:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __439
__439:
	if 0 != 0 {
		goto __438
	}
	goto __440
__440:
	;
	goto __436
__437:
	;
	goto __434
__434:
	if 0 != 0 {
		goto __433
	}
	goto __435
__435:
	;
	*(*uint32)(unsafe.Pointer(state + 72 /* &.offset */)) += (uint32(hold) & ((uint32(1) << ((*Inflate_state)(unsafe.Pointer(state)).Fextra)) - uint32(1)))
__442:
	hold >>= (*Inflate_state)(unsafe.Pointer(state)).Fextra
	bits = bits - ((*Inflate_state)(unsafe.Pointer(state)).Fextra)
	goto __443
__443:
	if 0 != 0 {
		goto __442
	}
	goto __444
__444:
	;
	*(*int32)(unsafe.Pointer(state + 7112 /* &.back */)) += int32(((*Inflate_state)(unsafe.Pointer(state)).Fextra))
__432:
	;

	(*Inflate_state)(unsafe.Pointer(state)).Fmode = MATCH
__34:
	if !(left == uint32(0)) {
		goto __445
	}
	goto inf_leave
__445:
	;
	copy = (out - left)
	if !((*Inflate_state)(unsafe.Pointer(state)).Foffset > copy) {
		goto __446
	} // copy from window
	copy = ((*Inflate_state)(unsafe.Pointer(state)).Foffset - copy)
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Fwhave) {
		goto __448
	}
	if !((*Inflate_state)(unsafe.Pointer(state)).Fsane != 0) {
		goto __449
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 639 /* "invalid distance..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__449:
	;
__448:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Fwnext) {
		goto __450
	}
	copy = copy - ((*Inflate_state)(unsafe.Pointer(state)).Fwnext)
	from = ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fwsize - copy)))
	goto __451
__450:
	from = ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr(((*Inflate_state)(unsafe.Pointer(state)).Fwnext - copy)))
__451:
	;
	if !(copy > (*Inflate_state)(unsafe.Pointer(state)).Flength) {
		goto __452
	}
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__452:
	;
	goto __447
__446: // copy from output
	from = (put - uintptr((*Inflate_state)(unsafe.Pointer(state)).Foffset))
	copy = (*Inflate_state)(unsafe.Pointer(state)).Flength
__447:
	;
	if !(copy > left) {
		goto __453
	}
	copy = left
__453:
	;
	left = left - (copy)
	*(*uint32)(unsafe.Pointer(state + 68 /* &.length */)) -= (copy)
__454:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&from, 1)))
	goto __455
__455:
	if libc.PreDecUint32(&copy, 1) != 0 {
		goto __454
	}
	goto __456
__456:
	;
	if !((*Inflate_state)(unsafe.Pointer(state)).Flength == uint32(0)) {
		goto __457
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
__457:
	;
	goto __9
__35:
	if !(left == uint32(0)) {
		goto __458
	}
	goto inf_leave
__458:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&put, 1))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Flength)
	left--
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LEN
	goto __9
__36:
	if !((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) {
		goto __459
	}
__460:
__463:
	if !(bits < (uint32(32))) {
		goto __464
	}
__465:
	if !(have == uint32(0)) {
		goto __468
	}
	goto inf_leave
__468:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __466
__466:
	if 0 != 0 {
		goto __465
	}
	goto __467
__467:
	;
	goto __463
__464:
	;
	goto __461
__461:
	if 0 != 0 {
		goto __460
	}
	goto __462
__462:
	;
	out = out - (left)
	*(*ULong)(unsafe.Pointer(strm + 20 /* &.total_out */)) += (ULong(out))
	*(*uint32)(unsafe.Pointer(state + 32 /* &.total */)) += (uint32(out))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (out != 0)) {
		goto __469
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, (put - uintptr(out)), out)
		}
		return Xadler32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, (put - uintptr(out)), out)
	}())
__469:
	;
	out = left
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && ((func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return hold
		}
		return ((((((hold) >> 24) & uint32(0xff)) + (((hold) >> 8) & uint32(0xff00))) + (((hold) & uint32(0xff00)) << 8)) + (((hold) & uint32(0xff)) << 24))
	}()) != (*Inflate_state)(unsafe.Pointer(state)).Fcheck)) {
		goto __470
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 784 /* "incorrect data c..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__470:
	;
__471:
	hold = uint32(0)
	bits = uint32(0)
	goto __472
__472:
	if 0 != 0 {
		goto __471
	}
	goto __473
__473:
	;

__459:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = LENGTH
__37:
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) && ((*Inflate_state)(unsafe.Pointer(state)).Fflags != 0)) {
		goto __474
	}
__475:
__478:
	if !(bits < (uint32(32))) {
		goto __479
	}
__480:
	if !(have == uint32(0)) {
		goto __483
	}
	goto inf_leave
__483:
	;
	have--
	hold = hold + ((uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&next, 1))))) << bits)
	bits = bits + (uint32(8))
	goto __481
__481:
	if 0 != 0 {
		goto __480
	}
	goto __482
__482:
	;
	goto __478
__479:
	;
	goto __476
__476:
	if 0 != 0 {
		goto __475
	}
	goto __477
__477:
	;
	if !(hold != ((*Inflate_state)(unsafe.Pointer(state)).Ftotal & 0xffffffff)) {
		goto __484
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fmsg = ts + 805 /* "incorrect length..." */
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = BAD
	goto __9
__484:
	;
__485:
	hold = uint32(0)
	bits = uint32(0)
	goto __486
__486:
	if 0 != 0 {
		goto __485
	}
	goto __487
__487:
	;

__474:
	;
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = DONE
__38:
	ret = Z_STREAM_END
	goto inf_leave
__39:
	ret = -3
	goto inf_leave
__40:
	return -4
__41:
__42:
	return -2
__9:
	;
	goto __7
__7:
	goto __6
	goto __8
__8:
	;

	//
	//        Return from inflate(), updating the total counts and the check value.
	//        If there was no progress during the inflate() call, return a buffer
	//        error.  Call updatewindow() to create and/or update the window state.
	//        Note: a memory error from inflate() is non-recoverable.
	//
inf_leave:
__488:
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_out = put
	(*Z_stream)(unsafe.Pointer(strm)).Favail_out = left
	(*Z_stream)(unsafe.Pointer(strm)).Fnext_in = next
	(*Z_stream)(unsafe.Pointer(strm)).Favail_in = have
	(*Inflate_state)(unsafe.Pointer(state)).Fhold = hold
	(*Inflate_state)(unsafe.Pointer(state)).Fbits = bits
	goto __489
__489:
	if 0 != 0 {
		goto __488
	}
	goto __490
__490:
	;
	if !(((*Inflate_state)(unsafe.Pointer(state)).Fwsize != 0) || (((out != (*Z_stream)(unsafe.Pointer(strm)).Favail_out) && ((*Inflate_state)(unsafe.Pointer(state)).Fmode < BAD)) && (((*Inflate_state)(unsafe.Pointer(state)).Fmode < CHECK) || (flush != Z_FINISH)))) {
		goto __491
	}
	if !(updatewindow(tls, strm, (*Z_stream)(unsafe.Pointer(strm)).Fnext_out, (out-(*Z_stream)(unsafe.Pointer(strm)).Favail_out)) != 0) {
		goto __492
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = MEM
	return -4
__492:
	;
__491:
	;
	in = in - ((*Z_stream)(unsafe.Pointer(strm)).Favail_in)
	out = out - ((*Z_stream)(unsafe.Pointer(strm)).Favail_out)
	*(*ULong)(unsafe.Pointer(strm + 8 /* &.total_in */)) += (ULong(in))
	*(*ULong)(unsafe.Pointer(strm + 20 /* &.total_out */)) += (ULong(out))
	*(*uint32)(unsafe.Pointer(state + 32 /* &.total */)) += (uint32(out))
	if !((((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 4) != 0) && (out != 0)) {
		goto __493
	}
	(*Z_stream)(unsafe.Pointer(strm)).Fadler = libc.AssignPtrUint32(state+28 /* &.check */, func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fflags != 0 {
			return Xcrc32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr(out)), out)
		}
		return Xadler32(tls, (*Inflate_state)(unsafe.Pointer(state)).Fcheck, ((*Z_stream)(unsafe.Pointer(strm)).Fnext_out - uintptr(out)), out)
	}())
__493:
	;
	(*Z_stream)(unsafe.Pointer(strm)).Fdata_type = (((int32((*Inflate_state)(unsafe.Pointer(state)).Fbits) + (func() int32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Flast != 0 {
			return 64
		}
		return 0
	}())) + (func() int32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fmode == TYPE {
			return 128
		}
		return 0
	}())) + (func() int32 {
		if ((*Inflate_state)(unsafe.Pointer(state)).Fmode == LEN_) || ((*Inflate_state)(unsafe.Pointer(state)).Fmode == COPY_) {
			return 256
		}
		return 0
	}()))
	if !((((in == uint32(0)) && (out == uint32(0))) || (flush == Z_FINISH)) && (ret == Z_OK)) {
		goto __494
	}
	ret = -5
__494:
	;
	return ret
}

var order1 =                                                                                                                                                                                                                         // permutation of code lengths
[19]uint16{uint16(16), uint16(17), uint16(18), uint16(0), uint16(8), uint16(7), uint16(9), uint16(6), uint16(10), uint16(5), uint16(11), uint16(4), uint16(12), uint16(3), uint16(13), uint16(2), uint16(14), uint16(1), uint16(15)} /* inflate.c:642:33 */

func XinflateEnd(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1277:13: */
	var state uintptr
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow != uintptr(Z_NULL) {
		(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Inflate_state)(unsafe.Pointer(state)).Fwindow)
	}
	(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((strm + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(strm)).Fopaque, (*Z_stream)(unsafe.Pointer(strm)).Fstate)
	(*Z_stream)(unsafe.Pointer(strm)).Fstate = uintptr(Z_NULL)

	return Z_OK
}

func XinflateGetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength uintptr) int32 { /* inflate.c:1291:13: */
	var state uintptr

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate

	// copy dictionary
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwhave != 0) && (dictionary != uintptr(Z_NULL)) {
		libc.Xmemcpy(tls, dictionary, ((*Inflate_state)(unsafe.Pointer(state)).Fwindow + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)),
			((*Inflate_state)(unsafe.Pointer(state)).Fwhave - (*Inflate_state)(unsafe.Pointer(state)).Fwnext))
		libc.Xmemcpy(tls, ((dictionary + uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwhave)) - uintptr((*Inflate_state)(unsafe.Pointer(state)).Fwnext)),
			(*Inflate_state)(unsafe.Pointer(state)).Fwindow, (*Inflate_state)(unsafe.Pointer(state)).Fwnext)
	}
	if dictLength != uintptr(Z_NULL) {
		*(*UInt)(unsafe.Pointer(dictLength)) = (*Inflate_state)(unsafe.Pointer(state)).Fwhave
	}
	return Z_OK
}

func XinflateSetDictionary(tls *libc.TLS, strm Z_streamp, dictionary uintptr, dictLength UInt) int32 { /* inflate.c:1314:13: */
	var state uintptr
	var dictid uint32
	var ret int32

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwrap != 0) && ((*Inflate_state)(unsafe.Pointer(state)).Fmode != DICT) {
		return -2
	}

	// check for correct dictionary identifier
	if (*Inflate_state)(unsafe.Pointer(state)).Fmode == DICT {
		dictid = Xadler32(tls, uint32(0), uintptr(Z_NULL), uint32(0))
		dictid = Xadler32(tls, dictid, dictionary, dictLength)
		if dictid != (*Inflate_state)(unsafe.Pointer(state)).Fcheck {
			return -3
		}
	}

	// copy dictionary to window using updatewindow(), which will amend the
	//        existing dictionary if appropriate
	ret = updatewindow(tls, strm, (dictionary + uintptr(dictLength)), dictLength)
	if ret != 0 {
		(*Inflate_state)(unsafe.Pointer(state)).Fmode = MEM
		return -4
	}
	(*Inflate_state)(unsafe.Pointer(state)).Fhavedict = 1

	return Z_OK
}

func XinflateGetHeader(tls *libc.TLS, strm Z_streamp, head Gz_headerp) int32 { /* inflate.c:1349:13: */
	var state uintptr

	// check state
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Inflate_state)(unsafe.Pointer(state)).Fwrap & 2) == 0 {
		return -2
	}

	// save header structure
	(*Inflate_state)(unsafe.Pointer(state)).Fhead = head
	(*Gz_header)(unsafe.Pointer(head)).Fdone = 0
	return Z_OK
}

//
//    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
//    or when out of input.  When called, *have is the number of pattern bytes
//    found in order so far, in 0..3.  On return *have is updated to the new
//    state.  If on return *have equals four, then the pattern was found and the
//    return value is how many bytes were read including the last byte of the
//    pattern.  If *have is less than four, then the pattern has not been found
//    yet and the return value is len.  In the latter case, syncsearch() can be
//    called again with more data and the *have state.  *have is initialized to
//    zero for the first call.
//
func syncsearch(tls *libc.TLS, have uintptr, buf uintptr, len uint32) uint32 { /* inflate.c:1377:16: */
	var got uint32
	var next uint32

	got = *(*uint32)(unsafe.Pointer(have))
	next = uint32(0)
	for (next < len) && (got < uint32(4)) {
		if (int32(*(*uint8)(unsafe.Pointer(buf + uintptr(next))))) == (func() int32 {
			if got < uint32(2) {
				return 0
			}
			return 0xff
		}()) {
			got++
		} else if *(*uint8)(unsafe.Pointer(buf + uintptr(next))) != 0 {
			got = uint32(0)
		} else {
			got = (uint32(4) - got)
		}
		next++
	}
	*(*uint32)(unsafe.Pointer(have)) = got
	return next
}

func XinflateSync(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1400:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var len uint32 // number of bytes to look at or looked at
	var in uint32
	var out uint32 // temporary to save total_in and total_out
	// var buf [4]uint8 at bp, 4
	// to restore bit buffer to byte string
	var state uintptr

	// check parameters
	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if ((*Z_stream)(unsafe.Pointer(strm)).Favail_in == UInt(0)) && ((*Inflate_state)(unsafe.Pointer(state)).Fbits < uint32(8)) {
		return -5
	}

	// if first time, start search in bit buffer
	if (*Inflate_state)(unsafe.Pointer(state)).Fmode != SYNC {
		(*Inflate_state)(unsafe.Pointer(state)).Fmode = SYNC
		libc.AssignShlPtrUint32(state+60 /* &.hold */, int(((*Inflate_state)(unsafe.Pointer(state)).Fbits & uint32(7))))
		*(*uint32)(unsafe.Pointer(state + 64 /* &.bits */)) -= ((*Inflate_state)(unsafe.Pointer(state)).Fbits & uint32(7))
		len = uint32(0)
		for (*Inflate_state)(unsafe.Pointer(state)).Fbits >= uint32(8) {
			*(*uint8)(unsafe.Pointer(bp /* &buf[0] */ + uintptr(libc.PostIncUint32(&len, 1)))) = uint8((*Inflate_state)(unsafe.Pointer(state)).Fhold)
			libc.AssignShrPtrUint32(state+60 /* &.hold */, int(8))
			*(*uint32)(unsafe.Pointer(state + 64 /* &.bits */)) -= (uint32(8))
		}
		(*Inflate_state)(unsafe.Pointer(state)).Fhave = uint32(0)
		syncsearch(tls, (state + 108 /* &.have */), bp /* &buf[0] */, len)
	}

	// search available input
	len = syncsearch(tls, (state + 108 /* &.have */), (*Z_stream)(unsafe.Pointer(strm)).Fnext_in, (*Z_stream)(unsafe.Pointer(strm)).Favail_in)
	*(*UInt)(unsafe.Pointer(strm + 4 /* &.avail_in */)) -= (len)
	*(*uintptr)(unsafe.Pointer(strm /* &.next_in */)) += (uintptr(len))
	*(*ULong)(unsafe.Pointer(strm + 8 /* &.total_in */)) += (ULong(len))

	// return no joy or set up to restart inflate() on a new block
	if (*Inflate_state)(unsafe.Pointer(state)).Fhave != uint32(4) {
		return -3
	}
	in = (*Z_stream)(unsafe.Pointer(strm)).Ftotal_in
	out = (*Z_stream)(unsafe.Pointer(strm)).Ftotal_out
	XinflateReset(tls, strm)
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_in = in
	(*Z_stream)(unsafe.Pointer(strm)).Ftotal_out = out
	(*Inflate_state)(unsafe.Pointer(state)).Fmode = TYPE
	return Z_OK
}

//
//    Returns true if inflate is currently at the end of a block generated by
//    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
//    implementation to provide an additional safety check. PPP uses
//    Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
//    block. When decompressing, PPP checks that at the end of input packet,
//    inflate is waiting for these length bytes.
//
func XinflateSyncPoint(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1451:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return (libc.Bool32(((*Inflate_state)(unsafe.Pointer(state)).Fmode == STORED) && ((*Inflate_state)(unsafe.Pointer(state)).Fbits == uint32(0))))
}

func XinflateCopy(tls *libc.TLS, dest Z_streamp, source Z_streamp) int32 { /* inflate.c:1461:13: */
	var state uintptr
	var copy uintptr
	var window uintptr
	var wsize uint32

	// check input
	if (inflateStateCheck(tls, source) != 0) || (dest == uintptr(Z_NULL)) {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(source)).Fstate

	// allocate space
	copy = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((source + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, uint32(1), uint32(unsafe.Sizeof(Inflate_state{})))
	if copy == uintptr(Z_NULL) {
		return -4
	}
	window = uintptr(Z_NULL)
	if (*Inflate_state)(unsafe.Pointer(state)).Fwindow != uintptr(Z_NULL) {
		window = (*(*func(*libc.TLS, Voidpf, UInt, UInt) Voidpf)(unsafe.Pointer((source + 32 /* &.zalloc */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits), uint32(unsafe.Sizeof(uint8(0))))
		if window == uintptr(Z_NULL) {
			(*(*func(*libc.TLS, Voidpf, Voidpf))(unsafe.Pointer((source + 36 /* &.zfree */))))(tls, (*Z_stream)(unsafe.Pointer(source)).Fopaque, copy)
			return -4
		}
	}

	// copy state
	libc.Xmemcpy(tls, dest, source, uint32(unsafe.Sizeof(Z_stream{})))
	libc.Xmemcpy(tls, copy, state, uint32(unsafe.Sizeof(Inflate_state{})))
	(*Inflate_state)(unsafe.Pointer(copy)).Fstrm = dest
	if ((*Inflate_state)(unsafe.Pointer(state)).Flencode >= state+1332 /* &.codes */) && ((*Inflate_state)(unsafe.Pointer(state)).Flencode <= (((state + 1332 /* &.codes */) + uintptr((ENOUGH_LENS+ENOUGH_DISTS))*4) - uintptr(1)*4)) {
		(*Inflate_state)(unsafe.Pointer(copy)).Flencode = ((copy + 1332 /* &.codes */) + uintptr((int32(((*Inflate_state)(unsafe.Pointer(state)).Flencode-(state+1332 /* &.codes */))/4)))*4)
		(*Inflate_state)(unsafe.Pointer(copy)).Fdistcode = ((copy + 1332 /* &.codes */) + uintptr((int32(((*Inflate_state)(unsafe.Pointer(state)).Fdistcode-(state+1332 /* &.codes */))/4)))*4)
	}
	(*Inflate_state)(unsafe.Pointer(copy)).Fnext = ((copy + 1332 /* &.codes */) + uintptr((int32(((*Inflate_state)(unsafe.Pointer(state)).Fnext-(state+1332 /* &.codes */))/4)))*4)
	if window != uintptr(Z_NULL) {
		wsize = (uint32(1) << (*Inflate_state)(unsafe.Pointer(state)).Fwbits)
		libc.Xmemcpy(tls, window, (*Inflate_state)(unsafe.Pointer(state)).Fwindow, wsize)
	}
	(*Inflate_state)(unsafe.Pointer(copy)).Fwindow = window
	(*Z_stream)(unsafe.Pointer(dest)).Fstate = copy
	return Z_OK
}

func XinflateUndermine(tls *libc.TLS, strm Z_streamp, subvert int32) int32 { /* inflate.c:1508:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	_ = subvert
	(*Inflate_state)(unsafe.Pointer(state)).Fsane = 1
	return -3
}

func XinflateValidate(tls *libc.TLS, strm Z_streamp, check int32) int32 { /* inflate.c:1526:13: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -2
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	if check != 0 {
		*(*int32)(unsafe.Pointer(state + 12 /* &.wrap */)) |= (4)
	} else {
		*(*int32)(unsafe.Pointer(state + 12 /* &.wrap */)) &= (libc.CplInt32(4))
	}
	return Z_OK
}

func XinflateMark(tls *libc.TLS, strm Z_streamp) int32 { /* inflate.c:1541:14: */
	var state uintptr

	if inflateStateCheck(tls, strm) != 0 {
		return -(int32(1) << 16)
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return (int32(uint32((int32((uint32(int32((*Inflate_state)(unsafe.Pointer(state)).Fback))) << 16))) + (func() uint32 {
		if (*Inflate_state)(unsafe.Pointer(state)).Fmode == COPY {
			return uint32((*Inflate_state)(unsafe.Pointer(state)).Flength)
		}
		return func() uint32 {
			if (*Inflate_state)(unsafe.Pointer(state)).Fmode == MATCH {
				return (uint32((*Inflate_state)(unsafe.Pointer(state)).Fwas - (*Inflate_state)(unsafe.Pointer(state)).Flength))
			}
			return uint32(0)
		}()
	}())))
}

func XinflateCodesUsed(tls *libc.TLS, strm Z_streamp) uint32 { /* inflate.c:1554:23: */
	var state uintptr
	if inflateStateCheck(tls, strm) != 0 {
		return libc.Uint32(libc.Uint32FromInt32(-1))
	}
	state = (*Z_stream)(unsafe.Pointer(strm)).Fstate
	return (uint32(int32(((*Inflate_state)(unsafe.Pointer(state)).Fnext - (state + 1332 /* &.codes */)) / 4)))
}

var Xinflate_copyright = *(*[48]int8)(unsafe.Pointer(ts + 828 /* " inflate 1.2.11 ..." */)) /* inftrees.c:11:12 */

//
//   If you use the zlib library in a product, an acknowledgment is welcome
//   in the documentation of your product. If for some reason you cannot
//   include such an acknowledgment, I would appreciate that you keep this
//   copyright string in the executable of your product.
//

//
//    Build a set of tables to decode the provided canonical Huffman code.
//    The code lengths are lens[0..codes-1].  The result starts at *table,
//    whose indices are 0..2^bits-1.  work is a writable array of at least
//    lens shorts, which is used as a work area.  type is the type of code
//    to be generated, CODES, LENS, or DISTS.  On return, zero is success,
//    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
//    on return points to the next available entry's address.  bits is the
//    requested root table index bits, and on return it is the actual root
//    table index bits.  It will differ if the request is greater than the
//    longest code or if it is less than the shortest code.
//
func Xinflate_table(tls *libc.TLS, type1 Codetype, lens uintptr, codes uint32, table uintptr, bits uintptr, work uintptr) int32 { /* inftrees.c:32:19: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var len uint32 // a code's length in bits
	var sym uint32 // index of code symbols
	var min uint32
	var max uint32    // minimum and maximum code lengths
	var root uint32   // number of index bits for root table
	var curr uint32   // number of index bits for current table
	var drop uint32   // code bits to drop for sub-table
	var left int32    // number of prefix codes available
	var used uint32   // code entries in table used
	var huff uint32   // Huffman code
	var incr uint32   // for incrementing code, index
	var fill uint32   // index for replicating entries
	var low uint32    // low bits for current root entry
	var mask uint32   // mask for low root bits
	var here Code     // table entry for duplication
	var next uintptr  // next available space in table
	var base uintptr  // base value table to use
	var extra uintptr // extra bits table to use
	var match uint32  // use base and extra for symbol >= match
	// var count [16]uint16 at bp, 32
	// number of codes of each length
	// var offs [16]uint16 at bp+32, 32

	//
	//        Process a set of code lengths to create a canonical Huffman code.  The
	//        code lengths are lens[0..codes-1].  Each length corresponds to the
	//        symbols 0..codes-1.  The Huffman code is generated by first sorting the
	//        symbols by length from short to long, and retaining the symbol order
	//        for codes with equal lengths.  Then the code starts with all zero bits
	//        for the first code of the shortest length, and the codes are integer
	//        increments for the same length, and zeros are appended as the length
	//        increases.  For the deflate format, these bits are stored backwards
	//        from their more natural integer increment ordering, and so when the
	//        decoding tables are built in the large loop below, the integer codes
	//        are incremented backwards.
	//
	//        This routine assumes, but does not check, that all of the entries in
	//        lens[] are in the range 0..MAXBITS.  The caller must assure this.
	//        1..MAXBITS is interpreted as that code length.  zero means that that
	//        symbol does not occur in this code.
	//
	//        The codes are sorted by computing a count of codes for each length,
	//        creating from that a table of starting indices for each length in the
	//        sorted table, and then entering the symbols in order in the sorted
	//        table.  The sorted table is work[], with that space being provided by
	//        the caller.
	//
	//        The length counts are used for other purposes as well, i.e. finding
	//        the minimum and maximum length codes, determining if there are any
	//        codes at all, checking for a valid set of lengths, and looking ahead
	//        at length counts to determine sub-table sizes when building the
	//        decoding tables.
	//

	// accumulate lengths for codes (assumes lens[] all in 0..MAXBITS)
	for len = uint32(0); len <= uint32(MAXBITS); len++ {
		*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2)) = uint16(0)
	}
	for sym = uint32(0); sym < codes; sym++ {
		*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2)))*2))++
	}

	// bound code lengths, force root to be within code lengths
	root = *(*uint32)(unsafe.Pointer(bits))
	for max = uint32(MAXBITS); max >= uint32(1); max-- {
		if int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(max)*2))) != 0 {
			break
		}
	}
	if root > max {
		root = max
	}
	if max == uint32(0) { // no symbols to code at all
		here.Fop = uint8(64) // invalid code marker
		here.Fbits = uint8(1)
		here.Fval = uint16(0)
		*(*Code)(unsafe.Pointer(libc.PostIncUintptr(&(*(*uintptr)(unsafe.Pointer(table))), 4))) = here // make a table to force an error
		*(*Code)(unsafe.Pointer(libc.PostIncUintptr(&(*(*uintptr)(unsafe.Pointer(table))), 4))) = here
		*(*uint32)(unsafe.Pointer(bits)) = uint32(1)
		return 0 // no symbols, but wait for decoding to report error
	}
	for min = uint32(1); min < max; min++ {
		if int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(min)*2))) != 0 {
			break
		}
	}
	if root < min {
		root = min
	}

	// check for an over-subscribed or incomplete set of lengths
	left = 1
	for len = uint32(1); len <= uint32(MAXBITS); len++ {
		left <<= 1
		left = left - (int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2))))
		if left < 0 {
			return -1
		} // over-subscribed
	}
	if (left > 0) && ((type1 == CODES) || (max != uint32(1))) {
		return -1
	} // incomplete set

	// generate offsets into symbol table for each length for sorting
	*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + 1*2)) = uint16(0)
	for len = uint32(1); len < uint32(MAXBITS); len++ {
		*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr((len+uint32(1)))*2)) = (uint16(int32(*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr(len)*2))) + int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2)))))
	}

	// sort symbols by length, by symbol order within each length
	for sym = uint32(0); sym < codes; sym++ {
		if int32(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2))) != 0 {
			*(*uint16)(unsafe.Pointer(work + uintptr(libc.PostIncUint16(&*(*uint16)(unsafe.Pointer(bp + 32 /* &offs[0] */ + uintptr(*(*uint16)(unsafe.Pointer(lens + uintptr(sym)*2)))*2)), 1))*2)) = uint16(sym)
		}
	}

	//
	//        Create and fill in decoding tables.  In this loop, the table being
	//        filled is at next and has curr index bits.  The code being used is huff
	//        with length len.  That code is converted to an index by dropping drop
	//        bits off of the bottom.  For codes where len is less than drop + curr,
	//        those top drop + curr - len bits are incremented through all values to
	//        fill the table with replicated entries.
	//
	//        root is the number of index bits for the root table.  When len exceeds
	//        root, sub-tables are created pointed to by the root entry with an index
	//        of the low root bits of huff.  This is saved in low to check for when a
	//        new sub-table should be started.  drop is zero when the root table is
	//        being filled, and drop is root when sub-tables are being filled.
	//
	//        When a new sub-table is needed, it is necessary to look ahead in the
	//        code lengths to determine what size sub-table is needed.  The length
	//        counts are used for this, and so count[] is decremented as codes are
	//        entered in the tables.
	//
	//        used keeps track of how many table entries have been allocated from the
	//        provided *table space.  It is checked for LENS and DIST tables against
	//        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	//        the initial root table size constants.  See the comments in inftrees.h
	//        for more information.
	//
	//        sym increments through all symbols, and the loop terminates when
	//        all codes of length max, i.e. all codes, have been processed.  This
	//        routine permits incomplete codes, so another loop after this one fills
	//        in the rest of the decoding tables with invalid code markers.
	//

	// set up for code type
	switch type1 {
	case CODES:
		base = libc.AssignUintptr(&extra, work) // dummy value--not used
		match = uint32(20)
		break
	case LENS:
		base = uintptr(unsafe.Pointer(&lbase))
		extra = uintptr(unsafe.Pointer(&lext))
		match = uint32(257)
		break
	default: // DISTS
		base = uintptr(unsafe.Pointer(&dbase))
		extra = uintptr(unsafe.Pointer(&dext))
		match = uint32(0)
	}

	// initialize state for loop
	huff = uint32(0)                            // starting code
	sym = uint32(0)                             // starting code symbol
	len = min                                   // starting code length
	next = *(*uintptr)(unsafe.Pointer(table))   // current table to fill in
	curr = root                                 // current table index bits
	drop = uint32(0)                            // current bits to drop from code for index
	low = libc.Uint32(libc.Uint32FromInt32(-1)) // trigger new sub-table when len > root
	used = (uint32(1) << root)                  // use root table entries
	mask = (used - uint32(1))                   // mask for comparing low

	// check available table space
	if ((type1 == LENS) && (used > uint32(ENOUGH_LENS))) || ((type1 == DISTS) && (used > uint32(ENOUGH_DISTS))) {
		return 1
	}

	// process all codes and make table entries
	for {
		// create table entry
		here.Fbits = (uint8(len - drop))
		if (uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))) + 1) < match {
			here.Fop = uint8(0)
			here.Fval = *(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))
		} else if uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2))) >= match {
			here.Fop = uint8(*(*uint16)(unsafe.Pointer(extra + uintptr((uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))-match))*2)))
			here.Fval = *(*uint16)(unsafe.Pointer(base + uintptr((uint32(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))-match))*2))
		} else {
			here.Fop = (uint8(32 + 64)) // end of block
			here.Fval = uint16(0)
		}

		// replicate for those indices with low len bits equal to huff
		incr = (uint32(1) << (len - drop))
		fill = (uint32(1) << curr)
		min = fill // save offset to next table
		for ok := true; ok; ok = (fill != uint32(0)) {
			fill = fill - (incr)
			*(*Code)(unsafe.Pointer(next + uintptr(((huff>>drop)+fill))*4)) = here
		}

		// backwards increment the len-bit code huff
		incr = (uint32(1) << (len - uint32(1)))
		for (huff & incr) != 0 {
			incr >>= 1
		}
		if incr != uint32(0) {
			huff = huff & (incr - uint32(1))
			huff = huff + (incr)
		} else {
			huff = uint32(0)
		}

		// go to next symbol, update count, len
		sym++
		if int32(libc.PreDecUint16(&(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr(len)*2))), 1)) == 0 {
			if len == max {
				break
			}
			len = uint32(*(*uint16)(unsafe.Pointer(lens + uintptr(*(*uint16)(unsafe.Pointer(work + uintptr(sym)*2)))*2)))
		}

		// create new sub-table if needed
		if (len > root) && ((huff & mask) != low) {
			// if first time, transition to sub-tables
			if drop == uint32(0) {
				drop = root
			}

			// increment past last table
			next += 4 * (uintptr(min)) // here min is 1 << curr

			// determine length of next table
			curr = (len - drop)
			left = (int32(1) << curr)
			for (curr + drop) < max {
				left = left - (int32(*(*uint16)(unsafe.Pointer(bp /* &count[0] */ + uintptr((curr+drop))*2))))
				if left <= 0 {
					break
				}
				curr++
				left <<= 1
			}

			// check for enough space
			used = used + (uint32(1) << curr)
			if ((type1 == LENS) && (used > uint32(ENOUGH_LENS))) || ((type1 == DISTS) && (used > uint32(ENOUGH_DISTS))) {
				return 1
			}

			// point entry in root table to sub-table
			low = (huff & mask)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fop = uint8(curr)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fbits = uint8(root)
			(*Code)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(table))) + uintptr(low)*4)).Fval = (uint16((int32(next) - int32(*(*uintptr)(unsafe.Pointer(table)))) / 4))
		}
	}

	// fill in remaining table entry if code is incomplete (guaranteed to have
	//        at most one remaining entry, since if the code is incomplete, the
	//        maximum code length that was allowed to get this far is one bit)
	if huff != uint32(0) {
		here.Fop = uint8(64) // invalid code marker
		here.Fbits = (uint8(len - drop))
		here.Fval = uint16(0)
		*(*Code)(unsafe.Pointer(next + uintptr(huff)*4)) = here
	}

	// set return parameters
	*(*uintptr)(unsafe.Pointer(table)) += (uintptr(used)) * 4
	*(*uint32)(unsafe.Pointer(bits)) = root
	return 0
}

var lbase = [31]uint16{ // Length codes 257..285 base
	uint16(3), uint16(4), uint16(5), uint16(6), uint16(7), uint16(8), uint16(9), uint16(10), uint16(11), uint16(13), uint16(15), uint16(17), uint16(19), uint16(23), uint16(27), uint16(31),
			uint16(35), uint16(43), uint16(51), uint16(59), uint16(67), uint16(83), uint16(99), uint16(115), uint16(131), uint16(163), uint16(195), uint16(227), uint16(258), uint16(0), uint16(0)} /* inftrees.c:60:33 */
var lext = [31]uint16{ // Length codes 257..285 extra
	uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(16), uint16(17), uint16(17), uint16(17), uint16(17), uint16(18), uint16(18), uint16(18), uint16(18),
			uint16(19), uint16(19), uint16(19), uint16(19), uint16(20), uint16(20), uint16(20), uint16(20), uint16(21), uint16(21), uint16(21), uint16(21), uint16(16), uint16(77), uint16(202)} /* inftrees.c:63:33 */
var dbase = [32]uint16{ // Distance codes 0..29 base
	uint16(1), uint16(2), uint16(3), uint16(4), uint16(5), uint16(7), uint16(9), uint16(13), uint16(17), uint16(25), uint16(33), uint16(49), uint16(65), uint16(97), uint16(129), uint16(193),
	uint16(257), uint16(385), uint16(513), uint16(769), uint16(1025), uint16(1537), uint16(2049), uint16(3073), uint16(4097), uint16(6145),
			uint16(8193), uint16(12289), uint16(16385), uint16(24577), uint16(0), uint16(0)} /* inftrees.c:66:33 */
var dext = [32]uint16{ // Distance codes 0..29 extra
	uint16(16), uint16(16), uint16(16), uint16(16), uint16(17), uint16(17), uint16(18), uint16(18), uint16(19), uint16(19), uint16(20), uint16(20), uint16(21), uint16(21), uint16(22), uint16(22),
	uint16(23), uint16(23), uint16(24), uint16(24), uint16(25), uint16(25), uint16(26), uint16(26), uint16(27), uint16(27),
	uint16(28), uint16(28), uint16(29), uint16(29), uint16(64), uint16(64)} /* inftrees.c:70:33 */

type Static_tree_desc = Static_tree_desc_s /* deflate.h:84:36 */

// ===========================================================================
// Constants

// Bit length codes must not exceed MAX_BL_BITS bits

// end of block literal code

// repeat previous bit length 3-6 times (2 bits of repeat count)

// repeat a zero length 3-10 times  (3 bits of repeat count)

// repeat a zero length 11-138 times  (7 bits of repeat count)

var extra_lbits = [29]int32{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0} /* trees.c:62:17 */

var extra_dbits = [30]int32{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13} /* trees.c:65:17 */

var extra_blbits = [19]int32{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7} /* trees.c:68:17 */

var bl_order = [19]Uch{Uch(16), Uch(17), Uch(18), Uch(0), Uch(8), Uch(7), Uch(9), Uch(6), Uch(10), Uch(5), Uch(11), Uch(4), Uch(12), Uch(3), Uch(13), Uch(2), Uch(14), Uch(1), Uch(15)} /* trees.c:71:17 */
// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit length codes.

// ===========================================================================
// Local data. These are initialized only once.

// header created automatically with -DGEN_TREES_H

var static_ltree = [288]Ct_data{{
	Ffc: struct{ Ffreq Ush }{Ffreq: Ush(12)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(140)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(76)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(204)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(44)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(172)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(108)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(236)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(28)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(156)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(92)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(220)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(60)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(188)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(124)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(252)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(2)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(130)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(66)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(194)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(34)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(162)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(98)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(226)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(18)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(146)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(82)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(210)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(50)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(178)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(114)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(242)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(10)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(138)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(74)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(202)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(42)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(170)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(106)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(234)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(26)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(154)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(90)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(218)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(58)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(186)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(122)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(250)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(6)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(134)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(70)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(198)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(38)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(166)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(102)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(230)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(22)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(150)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(86)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(214)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(54)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(182)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(118)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(246)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(14)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(142)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(78)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(206)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(46)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(174)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(110)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(238)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(30)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(158)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(94)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(222)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(62)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(190)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(126)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(254)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(1)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(129)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(65)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(193)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(33)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(161)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(97)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(225)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(17)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(145)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(81)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(209)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(49)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(177)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(113)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(241)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(9)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(137)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(73)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(201)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(41)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(169)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(105)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(233)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(25)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(153)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(89)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(217)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(57)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(185)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(121)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(249)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(5)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(133)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(69)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(197)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(37)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(165)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(101)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(229)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(21)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(149)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(85)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(213)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(53)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(181)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(117)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(245)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(13)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(141)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(77)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(205)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(45)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(173)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(109)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(237)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(29)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(157)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(93)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(221)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(61)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(189)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(125)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(253)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(19)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(275)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(147)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(403)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(83)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(339)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(211)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(467)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(51)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(307)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(179)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(435)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(115)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(371)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(243)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(499)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(11)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(267)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(139)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(395)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(75)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(331)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(203)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(459)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(43)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(299)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(171)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(427)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(107)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(363)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(235)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(491)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(27)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(283)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(155)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(411)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(91)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(347)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(219)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(475)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(59)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(315)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(187)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(443)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(123)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(379)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(251)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(507)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(7)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(263)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(135)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(391)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(71)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(327)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(199)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(455)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(39)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(295)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(167)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(423)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(103)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(359)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(231)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(487)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(23)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(279)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(151)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(407)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(87)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(343)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(215)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(471)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(55)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(311)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(183)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(439)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(119)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(375)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(247)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(503)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(15)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(271)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(143)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(399)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(79)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(335)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(207)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(463)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(47)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(303)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(175)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(431)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(111)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(367)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(239)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(495)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(31)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(287)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(159)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(415)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(95)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(351)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(223)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(479)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(63)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(319)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(191)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(447)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(127)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(383)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(255)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(511)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(9)}}, {Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(64)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(32)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(96)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(16)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(80)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(48)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(112)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(8)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(72)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(40)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(104)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(24)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(88)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(56)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(120)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(4)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(68)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(36)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(100)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(20)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(84)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(52)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(116)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(7)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(3)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(131)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(67)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(195)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(35)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(163)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(99)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(227)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(8)}}} /* trees.h:3:21 */

var static_dtree = [30]Ct_data{{Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(16)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(8)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(24)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(4)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(20)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(12)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(28)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(2)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(18)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(10)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(26)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(6)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(22)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(14)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(30)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(1)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(17)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(9)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(25)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(5)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(21)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(13)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(29)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(3)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}},
	{Ffc: struct{ Ffreq Ush }{Ffreq: Ush(19)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(11)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(27)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(7)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}, {Ffc: struct{ Ffreq Ush }{Ffreq: Ush(23)}, Fdl: struct{ Fdad Ush }{Fdad: Ush(5)}}} /* trees.h:64:21 */

var X_dist_code = [512]Uch{
	Uch(0), Uch(1), Uch(2), Uch(3), Uch(4), Uch(4), Uch(5), Uch(5), Uch(6), Uch(6), Uch(6), Uch(6), Uch(7), Uch(7), Uch(7), Uch(7), Uch(8), Uch(8), Uch(8), Uch(8),
	Uch(8), Uch(8), Uch(8), Uch(8), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(9), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10),
	Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(10), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11), Uch(11),
	Uch(11), Uch(11), Uch(11), Uch(11), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12),
	Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(12), Uch(13), Uch(13), Uch(13), Uch(13),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(13), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14),
	Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(14), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15),
	Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(15), Uch(0), Uch(0), Uch(16), Uch(17),
	Uch(18), Uch(18), Uch(19), Uch(19), Uch(20), Uch(20), Uch(20), Uch(20), Uch(21), Uch(21), Uch(21), Uch(21), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22),
	Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(24), Uch(24), Uch(24), Uch(24), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28),
	Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(28), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
	Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29), Uch(29),
} /* trees.h:73:25 */

var X_length_code = [256]Uch{
	Uch(0), Uch(1), Uch(2), Uch(3), Uch(4), Uch(5), Uch(6), Uch(7), Uch(8), Uch(8), Uch(9), Uch(9), Uch(10), Uch(10), Uch(11), Uch(11), Uch(12), Uch(12), Uch(12), Uch(12),
	Uch(13), Uch(13), Uch(13), Uch(13), Uch(14), Uch(14), Uch(14), Uch(14), Uch(15), Uch(15), Uch(15), Uch(15), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16), Uch(16),
	Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(17), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(18), Uch(19), Uch(19), Uch(19), Uch(19),
	Uch(19), Uch(19), Uch(19), Uch(19), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20), Uch(20),
	Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(21), Uch(22), Uch(22), Uch(22), Uch(22),
	Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(22), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23),
	Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(23), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24), Uch(24),
	Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25),
	Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(25), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26), Uch(26),
	Uch(26), Uch(26), Uch(26), Uch(26), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27),
	Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(27), Uch(28),
} /* trees.h:102:25 */

var base_length = [29]int32{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
	64, 80, 96, 112, 128, 160, 192, 224, 0,
} /* trees.h:118:17 */

var base_dist = [30]int32{
	0, 1, 2, 3, 4, 6, 8, 12, 16, 24,
	32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
	1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,
} /* trees.h:123:17 */

var static_l_desc = Static_tree_desc{Fstatic_tree: 0, Fextra_bits: 0, Fextra_base: (LITERALS + 1), Felems: ((LITERALS + 1) + LENGTH_CODES), Fmax_length: MAX_BITS} /* trees.c:125:31 */

var static_d_desc = Static_tree_desc{Fstatic_tree: 0, Fextra_bits: 0, Felems: D_CODES, Fmax_length: MAX_BITS} /* trees.c:128:31 */

var static_bl_desc = Static_tree_desc{Fextra_bits: 0, Felems: BL_CODES, Fmax_length: MAX_BL_BITS} /* trees.c:131:31 */

// Send a code of the given tree. c and tree must not have side effects

// ===========================================================================
// Output a short LSB first on the stream.
// IN assertion: there is enough room in pendingBuf.

// ===========================================================================
// Send a value on a given number of bits.
// IN assertion: length <= 16 and value fits in length bits.

// the arguments must not have side effects

// ===========================================================================
// Initialize the various 'constant' tables.
func tr_static_init(tls *libc.TLS) { /* trees.c:232:12: */
}

// ===========================================================================
// Genererate the file trees.h describing the static trees.

// ===========================================================================
// Initialize the tree data structures for a new zlib stream.
func X_tr_init(tls *libc.TLS, s uintptr) { /* trees.c:379:20: */
	tr_static_init(tls)

	(*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fdyn_tree = s + 148 /* &.dyn_ltree */
	(*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_l_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fdyn_tree = s + 2440 /* &.dyn_dtree */
	(*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_d_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fbl_desc.Fdyn_tree = s + 2684 /* &.bl_tree */
	(*Deflate_state)(unsafe.Pointer(s)).Fbl_desc.Fstat_desc = uintptr(unsafe.Pointer(&static_bl_desc))

	(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0

	// Initialize the first block of the first file:
	init_block(tls, s)
}

// ===========================================================================
// Initialize a new block.
func init_block(tls *libc.TLS, s uintptr) { /* trees.c:407:12: */
	var n int32 // iterates over tree elements

	// Initialize the trees.
	for n = 0; n < ((LITERALS + 1) + LENGTH_CODES); n++ {
		*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}
	for n = 0; n < D_CODES; n++ {
		*(*Ush)(unsafe.Pointer((s + 2440 /* &.dyn_dtree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}
	for n = 0; n < BL_CODES; n++ {
		*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(n)*4 /* &.fc */)) = Ush(0)
	}

	*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + 256*4 /* &.fc */)) = Ush(1)
	(*Deflate_state)(unsafe.Pointer(s)).Fopt_len = libc.AssignPtrUint32(s+5804 /* &.static_len */, Ulg(0))
	(*Deflate_state)(unsafe.Pointer(s)).Flast_lit = libc.AssignPtrUint32(s+5808 /* &.matches */, UInt(0))
}

// Index within the heap array of least frequent node in the Huffman tree

// ===========================================================================
// Remove the smallest element from the heap and recreate the heap with
// one less element. Updates heap and heap_len.

// ===========================================================================
// Compares to subtrees, using the tree depth as tie breaker when
// the subtrees have equal frequency. This minimizes the worst case length.

// ===========================================================================
// Restore the heap property by moving down the tree starting at node k,
// exchanging a node with the smallest of its two sons if necessary, stopping
// when the heap property is re-established (each father smaller than its
// two sons).
func pqdownheap(tls *libc.TLS, s uintptr, tree uintptr, k int32) { /* trees.c:451:12: */
	var v int32 = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(k)*4))
	var j int32 = (k << 1) // left son of k
	for j <= (*Deflate_state)(unsafe.Pointer(s)).Fheap_len {
		// Set j to the smallest of the two sons:
		if (j < (*Deflate_state)(unsafe.Pointer(s)).Fheap_len) && ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr((j+1))*4)))*4 /* &.fc */))) < int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) || ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr((j+1))*4)))*4 /* &.fc */))) == int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) && (int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr((j+1))*4)))))) <= int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4))))))))) {
			j++
		}
		// Exit if v is smaller than both sons
		if (int32(*(*Ush)(unsafe.Pointer(tree + uintptr(v)*4 /* &.fc */))) < int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) || ((int32(*(*Ush)(unsafe.Pointer(tree + uintptr(v)*4 /* &.fc */))) == int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4)))*4 /* &.fc */)))) && (int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(v)))) <= int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4)))))))) {
			break
		}

		// Exchange v with the smallest son
		*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(k)*4)) = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(j)*4))
		k = j

		// And continue down the tree, setting j to the left son of k
		j <<= 1
	}
	*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(k)*4)) = v
}

// ===========================================================================
// Compute the optimal bit lengths for a tree and update the total bit length
// for the current block.
// IN assertion: the fields freq and dad are set, heap[heap_max] and
//    above are the tree nodes sorted by increasing frequency.
// OUT assertions: the field len is set to the optimal bit length, the
//     array bl_count contains the frequencies for each bit length.
//     The length opt_len is updated; static_len is also updated if stree is
//     not null.
func gen_bitlen(tls *libc.TLS, s uintptr, desc uintptr) { /* trees.c:486:12: */
	var tree uintptr = (*Tree_desc)(unsafe.Pointer(desc)).Fdyn_tree
	var max_code int32 = (*Tree_desc)(unsafe.Pointer(desc)).Fmax_code
	var stree uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fstatic_tree
	var extra uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fextra_bits
	var base int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fextra_base
	var max_length int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fmax_length
	var h int32 // heap index
	var n int32
	var m int32            // iterate over the tree elements
	var bits int32         // bit length
	var xbits int32        // extra bits
	var f Ush              // frequency
	var overflow int32 = 0 // number of elements with bit length too large

	for bits = 0; bits <= MAX_BITS; bits++ {
		*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(bits)*2)) = Ush(0)
	}

	// In a first pass, compute the optimal bit lengths (which may
	// overflow in the case of the bit length tree).
	*(*Ush)(unsafe.Pointer(tree + uintptr(*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fheap_max)*4)))*4 + 2 /* &.dl */)) = Ush(0) // root of the heap

	for h = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_max + 1); h < ((2 * ((LITERALS + 1) + LENGTH_CODES)) + 1); h++ {
		n = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(h)*4))
		bits = (int32(*(*Ush)(unsafe.Pointer(tree + uintptr(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)))*4 + 2 /* &.dl */))) + 1)
		if bits > max_length {
			bits = max_length
			overflow++
		}
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = Ush(bits)
		// We overwrite tree[n].Dad which is no longer needed

		if n > max_code {
			continue
		} // not a leaf node

		*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(bits)*2))++
		xbits = 0
		if n >= base {
			xbits = *(*Intf)(unsafe.Pointer(extra + uintptr((n-base))*4))
		}
		f = *(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))
		*(*Ulg)(unsafe.Pointer(s + 5800 /* &.opt_len */)) += (Ulg(f) * Ulg((uint32(bits + xbits))))
		if stree != 0 {
			*(*Ulg)(unsafe.Pointer(s + 5804 /* &.static_len */)) += (Ulg(f) * Ulg((uint32(int32(*(*Ush)(unsafe.Pointer(stree + uintptr(n)*4 + 2 /* &.dl */))) + xbits))))
		}
	}
	if overflow == 0 {
		return
	}

	// This happens for example on obj2 and pic of the Calgary corpus

	// Find the first bit length which could increase:
	for ok := true; ok; ok = (overflow > 0) {
		bits = (max_length - 1)
		for int32(*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(bits)*2))) == 0 {
			bits--
		}
		*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(bits)*2))--               // move one leaf down the tree
		*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr((bits+1))*2)) += Ush((2)) // move one overflow item as its brother
		*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(max_length)*2))--
		// The brother of the overflow item also moves one step up,
		// but this does not affect bl_count[max_length]
		overflow = overflow - (2)
	}

	// Now recompute all bit lengths, scanning in increasing frequency.
	// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	// lengths instead of fixing only the wrong ones. This idea is taken
	// from 'ar' written by Haruhiko Okumura.)
	for bits = max_length; bits != 0; bits-- {
		n = int32(*(*Ush)(unsafe.Pointer((s + 2876 /* &.bl_count */) + uintptr(bits)*2)))
		for n != 0 {
			m = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PreDecInt32(&h, 1))*4))
			if m > max_code {
				continue
			}
			if uint32(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */))) != uint32(bits) {

				*(*Ulg)(unsafe.Pointer(s + 5800 /* &.opt_len */)) += ((Ulg(bits) - Ulg(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */)))) * Ulg(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 /* &.fc */))))
				*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 + 2 /* &.dl */)) = Ush(bits)
			}
			n--
		}
	}
}

// ===========================================================================
// Generate the codes for a given tree and bit counts (which need not be
// optimal).
// IN assertion: the array bl_count contains the bit length statistics for
// the given tree and the field len is set for all tree elements.
// OUT assertion: the field code is set for all tree elements of non
//     zero code length.
func gen_codes(tls *libc.TLS, tree uintptr, max_code int32, bl_count uintptr) { /* trees.c:572:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var next_code [16]Ush at bp, 32
	// next code value for each bit length
	var code uint32 = uint32(0) // running code value
	var bits int32              // bit index
	var n int32                 // code index

	// The distribution counts are first used to generate the code values
	// without bit reversal.
	for bits = 1; bits <= MAX_BITS; bits++ {
		code = ((code + uint32(*(*Ushf)(unsafe.Pointer(bl_count + uintptr((bits-1))*2)))) << 1)
		*(*Ush)(unsafe.Pointer(bp /* &next_code[0] */ + uintptr(bits)*2)) = Ush(code)
	}
	// Check that the bit counts in bl_count are consistent. The last code
	// must be all ones.

	for n = 0; n <= max_code; n++ {
		var len int32 = int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)))
		if len == 0 {
			continue
		}
		// Now reverse the bits
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */)) = Ush(bi_reverse(tls, uint32(libc.PostIncUint16(&*(*Ush)(unsafe.Pointer(bp /* &next_code[0] */ + uintptr(len)*2)), 1)), len))

	}
}

// ===========================================================================
// Construct one Huffman tree and assigns the code bit strings and lengths.
// Update the total bit length for the current block.
// IN assertion: the field freq is set for all tree elements.
// OUT assertions: the fields len and code are set to the optimal bit length
//     and corresponding code. The length opt_len is updated; static_len is
//     also updated if stree is not null. The field max_code is set.
func build_tree(tls *libc.TLS, s uintptr, desc uintptr) { /* trees.c:615:12: */
	var tree uintptr = (*Tree_desc)(unsafe.Pointer(desc)).Fdyn_tree
	var stree uintptr = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Fstatic_tree
	var elems int32 = (*Static_tree_desc)(unsafe.Pointer((*Tree_desc)(unsafe.Pointer(desc)).Fstat_desc)).Felems
	var n int32
	var m int32             // iterate over heap elements
	var max_code int32 = -1 // largest code with non zero frequency
	var node int32          // new node being created

	// Construct the initial heap, with least frequent element in
	// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	// heap[0] is not used.
	(*Deflate_state)(unsafe.Pointer(s)).Fheap_len = 0
	(*Deflate_state)(unsafe.Pointer(s)).Fheap_max = ((2 * ((LITERALS + 1) + LENGTH_CODES)) + 1)

	for n = 0; n < elems; n++ {
		if int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))) != 0 {
			*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PreIncInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_len), 1))*4)) = libc.AssignInt32(&max_code, n)
			*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(n))) = Uch(0)
		} else {
			*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = Ush(0)
		}
	}

	// The pkzip format requires that at least one distance code exists,
	// and that at least one bit should be sent even if there is only one
	// possible code. So to avoid special checks later on we force at least
	// two codes of non zero frequency.
	for (*Deflate_state)(unsafe.Pointer(s)).Fheap_len < 2 {
		node = libc.AssignPtrInt32((s+2908 /* &.heap */)+uintptr(libc.PreIncInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_len), 1))*4, func() int32 {
			if max_code < 2 {
				return libc.PreIncInt32(&max_code, 1)
			}
			return 0
		}())
		*(*Ush)(unsafe.Pointer(tree + uintptr(node)*4 /* &.fc */)) = Ush(1)
		*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(node))) = Uch(0)
		(*Deflate_state)(unsafe.Pointer(s)).Fopt_len--
		if stree != 0 {
			*(*Ulg)(unsafe.Pointer(s + 5804 /* &.static_len */)) -= (Ulg(*(*Ush)(unsafe.Pointer(stree + uintptr(node)*4 + 2 /* &.dl */))))
		}
		// node is 0 or 1 so it does not have extra bits
	}
	(*Tree_desc)(unsafe.Pointer(desc)).Fmax_code = max_code

	// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	// establish sub-heaps of increasing lengths:
	for n = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_len / 2); n >= 1; n-- {
		pqdownheap(tls, s, tree, n)
	}

	// Construct the Huffman tree by repeatedly combining the least two
	// frequent nodes.
	node = elems // next internal node of the tree
	for ok := true; ok; ok = ((*Deflate_state)(unsafe.Pointer(s)).Fheap_len >= 2) {
		{
			n = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + 1*4))
			*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + 1*4)) = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PostDecInt32(&(*Deflate_state)(unsafe.Pointer(s)).Fheap_len, 1))*4))
			pqdownheap(tls, s, tree, SMALLEST)
		}
		// n = node of least frequency
		m = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + 1*4)) // m = node of next least frequency

		*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = n // keep the nodes sorted by frequency
		*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = m

		// Create a new node father of n and m
		*(*Ush)(unsafe.Pointer(tree + uintptr(node)*4 /* &.fc */)) = (Ush(int32(*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 /* &.fc */))) + int32(*(*Ush)(unsafe.Pointer(tree + uintptr(m)*4 /* &.fc */)))))
		*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(node))) = (Uch((func() int32 {
			if int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(n)))) >= int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(m)))) {
				return int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(n))))
			}
			return int32(*(*Uch)(unsafe.Pointer((s + 5208 /* &.depth */) + uintptr(m))))
		}()) + 1))
		*(*Ush)(unsafe.Pointer(tree + uintptr(n)*4 + 2 /* &.dl */)) = libc.AssignPtrUint16(tree+uintptr(m)*4+2 /* &.dl */ /* &.dad */, Ush(node))
		// and insert the new node in the heap
		*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + 1*4)) = libc.PostIncInt32(&node, 1)
		pqdownheap(tls, s, tree, SMALLEST)

	}

	*(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + uintptr(libc.PreDecInt32(&((*Deflate_state)(unsafe.Pointer(s)).Fheap_max), 1))*4)) = *(*int32)(unsafe.Pointer((s + 2908 /* &.heap */) + 1*4))

	// At this point, the fields freq and dad are set. We can now
	// generate the bit lengths.
	gen_bitlen(tls, s, desc)

	// The field len is now set, we can generate the bit codes
	gen_codes(tls, tree, max_code, s+2876 /* &.bl_count */)
}

// ===========================================================================
// Scan a literal or distance tree to determine the frequencies of the codes
// in the bit length tree.
func scan_tree(tls *libc.TLS, s uintptr, tree uintptr, max_code int32) { /* trees.c:703:12: */
	var n int32                                                             // iterates over all tree elements
	var prevlen int32 = -1                                                  // last emitted length
	var curlen int32                                                        // length of current code
	var nextlen int32 = int32(*(*Ush)(unsafe.Pointer(tree + 2 /* &.dl */))) // length of next code
	var count int32 = 0                                                     // repeat count of the current code
	var max_count int32 = 7                                                 // max repeat count
	var min_count int32 = 4                                                 // min repeat count

	if nextlen == 0 {
		max_count = 138
		min_count = 3
	}
	*(*Ush)(unsafe.Pointer(tree + uintptr((max_code+1))*4 + 2 /* &.dl */)) = Ush(0xffff) // guard

	for n = 0; n <= max_code; n++ {
		curlen = nextlen
		nextlen = int32(*(*Ush)(unsafe.Pointer(tree + uintptr((n+1))*4 + 2 /* &.dl */)))
		if (libc.PreIncInt32(&count, 1) < max_count) && (curlen == nextlen) {
			continue
		} else if count < min_count {
			*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */ /* &.freq */)) += Ush((count))
		} else if curlen != 0 {
			if curlen != prevlen {
				*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */))++
			}
			*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 16*4 /* &.fc */))++
		} else if count <= 10 {
			*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 17*4 /* &.fc */))++
		} else {
			*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 18*4 /* &.fc */))++
		}
		count = 0
		prevlen = curlen
		if nextlen == 0 {
			max_count = 138
			min_count = 3
		} else if curlen == nextlen {
			max_count = 6
			min_count = 3
		} else {
			max_count = 7
			min_count = 4
		}
	}
}

// ===========================================================================
// Send a literal or distance tree in compressed form, using the codes in
// bl_tree.
func send_tree(tls *libc.TLS, s uintptr, tree uintptr, max_code int32) { /* trees.c:748:12: */
	var n int32                                                             // iterates over all tree elements
	var prevlen int32 = -1                                                  // last emitted length
	var curlen int32                                                        // length of current code
	var nextlen int32 = int32(*(*Ush)(unsafe.Pointer(tree + 2 /* &.dl */))) // length of next code
	var count int32 = 0                                                     // repeat count of the current code
	var max_count int32 = 7                                                 // max repeat count
	var min_count int32 = 4                                                 // min repeat count

	/* tree[max_code+1].Len = -1; */ // guard already set
	if nextlen == 0 {
		max_count = 138
		min_count = 3
	}

	for n = 0; n <= max_code; n++ {
		curlen = nextlen
		nextlen = int32(*(*Ush)(unsafe.Pointer(tree + uintptr((n+1))*4 + 2 /* &.dl */)))
		if (libc.PreIncInt32(&count, 1) < max_count) && (curlen == nextlen) {
			continue
		} else if count < min_count {
			for ok := true; ok; ok = (libc.PreDecInt32(&count, 1) != 0) {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
					}
				}
			}

		} else if curlen != 0 {
			if curlen != prevlen {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(curlen)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
					}
				}
				count--
			}

			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 16*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 16*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 16*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 2
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 3)
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(count - 3))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}

		} else if count <= 10 {
			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 17*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 17*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 17*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 3
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 3)
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(count - 3))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}

		} else {
			{
				var len int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 18*4 + 2 /* &.dl */)))
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 18*4 /* &.fc */)))
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + 18*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}
			{
				var len int32 = 7
				if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
					var val int32 = (count - 11)
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					{
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
						}
						{
							*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
						}

					}
					(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
				} else {
					*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(count - 11))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
					*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
				}
			}

		}
		count = 0
		prevlen = curlen
		if nextlen == 0 {
			max_count = 138
			min_count = 3
		} else if curlen == nextlen {
			max_count = 6
			min_count = 3
		} else {
			max_count = 7
			min_count = 4
		}
	}
}

// ===========================================================================
// Construct the Huffman tree for the bit lengths and return the index in
// bl_order of the last bit length code to send.
func build_bl_tree(tls *libc.TLS, s uintptr) int32 { /* trees.c:799:11: */
	var max_blindex int32 // index of last bit length code of non zero freq

	// Determine the bit length frequencies for literal and distance trees
	scan_tree(tls, s, s+148 /* &.dyn_ltree */, (*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fmax_code)
	scan_tree(tls, s, s+2440 /* &.dyn_dtree */, (*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fmax_code)

	// Build the bit length tree:
	build_tree(tls, s, (s + 2864 /* &.bl_desc */))
	// opt_len now includes the length of the tree representations, except
	// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

	// Determine the number of bit length codes to send. The pkzip format
	// requires that at least 4 bit length codes be sent. (appnote.txt says
	// 3 but the actual value used is 4.)
	for max_blindex = (BL_CODES - 1); max_blindex >= 3; max_blindex-- {
		if int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(bl_order[max_blindex])*4 + 2 /* &.dl */))) != 0 {
			break
		}
	}
	// Update opt_len to include the bit length tree and counts
	*(*Ulg)(unsafe.Pointer(s + 5800 /* &.opt_len */)) += ((((Ulg(3) * (Ulg(max_blindex) + Ulg(1))) + Ulg(5)) + Ulg(5)) + Ulg(4))

	return max_blindex
}

// ===========================================================================
// Send the header for a block using dynamic Huffman trees: the counts, the
// lengths of the bit length codes, the literal tree and the distance tree.
// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
func send_all_trees(tls *libc.TLS, s uintptr, lcodes int32, dcodes int32, blcodes int32) { /* trees.c:834:12: */
	var rank int32 // index in bl_order

	{
		var len int32 = 5
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (lcodes - 257)
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(lcodes - 257))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}
	/* not +255 as stated in appnote.txt */
	{
		var len int32 = 5
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (dcodes - 1)
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(dcodes - 1))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}

	{
		var len int32 = 4
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (blcodes - 4)
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(blcodes - 4))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}
	// not -3 as stated in appnote.txt
	for rank = 0; rank < blcodes; rank++ {

		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = int32(*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(bl_order[rank])*4 + 2 /* &.dl */)))
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer((s + 2684 /* &.bl_tree */) + uintptr(bl_order[rank])*4 + 2 /* &.dl */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
			}
		}

	}

	send_tree(tls, s, s+148 /* &.dyn_ltree */, (lcodes - 1)) // literal tree

	send_tree(tls, s, s+2440 /* &.dyn_dtree */, (dcodes - 1)) // distance tree

}

// ===========================================================================
// Send a stored block
func X_tr_stored_block(tls *libc.TLS, s uintptr, buf uintptr, stored_len Ulg, last int32) { /* trees.c:863:20: */
	{
		var len int32 = 3
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = ((int32(STORED_BLOCK) << 1) + last)
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush((int32(STORED_BLOCK) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}
	// send block type
	bi_windup(tls, s) /* align on byte boundary */
	{
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32(Ush(stored_len))) & 0xff))
		}
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32((Ush(stored_len))) >> 8))
		}

	}

	{
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32(Ush(^stored_len))) & 0xff))
		}
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32((Ush(^stored_len))) >> 8))
		}

	}

	libc.Xmemcpy(tls, ((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Fpending)), buf, uint32(stored_len))
	*(*Ulg)(unsafe.Pointer(s + 20 /* &.pending */)) += (stored_len)
}

// ===========================================================================
// Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
func X_tr_flush_bits(tls *libc.TLS, s uintptr) { /* trees.c:886:20: */
	bi_flush(tls, s)
}

// ===========================================================================
// Send one empty static block to give enough lookahead for inflate.
// This takes 10 bits, of which 7 may remain in the bit buffer.
func X_tr_align(tls *libc.TLS, s uintptr) { /* trees.c:896:20: */
	{
		var len int32 = 3
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = (int32(STATIC_TREES) << 1)
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(int32((Ush(int32(STATIC_TREES) << 1)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}

	{
		var len int32 = int32(*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 + 2 /* &.dl */)))
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = int32(*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 /* &.fc */)))
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_ltree)) + 256*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}

	bi_flush(tls, s)
}

// ===========================================================================
// Determine the best encoding for the current block: dynamic trees, static
// trees or store, and write out the encoded block.
func X_tr_flush_block(tls *libc.TLS, s uintptr, buf uintptr, stored_len Ulg, last int32) { /* trees.c:911:20: */
	var opt_lenb Ulg
	var static_lenb Ulg       // opt_len and static_len in bytes
	var max_blindex int32 = 0 // index of last bit length code of non zero freq

	// Build the Huffman trees unless a stored block is forced
	if (*Deflate_state)(unsafe.Pointer(s)).Flevel > 0 {

		// Check if the file is binary or text
		if (*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fdata_type == Z_UNKNOWN {
			(*Z_stream)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fstrm)).Fdata_type = detect_data_type(tls, s)
		}

		// Construct the literal and distance trees
		build_tree(tls, s, (s + 2840 /* &.l_desc */))

		build_tree(tls, s, (s + 2852 /* &.d_desc */))

		// At this point, opt_len and static_len are the total bit lengths of
		// the compressed block data, excluding the tree representations.

		// Build the bit length tree for the above two trees, and get the index
		// in bl_order of the last bit length code to send.
		max_blindex = build_bl_tree(tls, s)

		// Determine the best encoding. Compute the block lengths in bytes.
		opt_lenb = ((((*Deflate_state)(unsafe.Pointer(s)).Fopt_len + Ulg(3)) + Ulg(7)) >> 3)
		static_lenb = ((((*Deflate_state)(unsafe.Pointer(s)).Fstatic_len + Ulg(3)) + Ulg(7)) >> 3)

		if static_lenb <= opt_lenb {
			opt_lenb = static_lenb
		}

	} else {

		opt_lenb = libc.AssignUint32(&static_lenb, (stored_len + Ulg(5))) // force a stored block
	}

	if ((stored_len + Ulg(4)) <= opt_lenb) && (buf != uintptr(0)) {
		// 4: two words for the lengths
		// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
		// Otherwise we can't have processed more than WSIZE input bytes since
		// the last block flush, because compression would have been
		// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
		// transform a block into a stored block.
		X_tr_stored_block(tls, s, buf, stored_len, last)

	} else if ((*Deflate_state)(unsafe.Pointer(s)).Fstrategy == Z_FIXED) || (static_lenb == opt_lenb) {
		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = ((int32(STATIC_TREES) << 1) + last)
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush((int32(STATIC_TREES) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
			}
		}

		compress_block(tls, s, uintptr(uintptr(unsafe.Pointer(&static_ltree))),
			uintptr(uintptr(unsafe.Pointer(&static_dtree))))
	} else {
		{
			var len int32 = 3
			if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
				var val int32 = ((int32(DYN_TREES) << 1) + last)
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				{
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
					}
					{
						*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
					}

				}
				(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
			} else {
				*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush((int32(DYN_TREES) << 1) + last))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
				*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
			}
		}

		send_all_trees(tls, s, ((*Deflate_state)(unsafe.Pointer(s)).Fl_desc.Fmax_code + 1), ((*Deflate_state)(unsafe.Pointer(s)).Fd_desc.Fmax_code + 1),
			(max_blindex + 1))
		compress_block(tls, s, s+148, /* &.dyn_ltree */
			s+2440 /* &.dyn_dtree */)
	}

	// The above check is made mod 2^32, for files larger than 512 MB
	// and uLong implemented on 32 bits.
	init_block(tls, s)

	if last != 0 {
		bi_windup(tls, s)
	}

}

// ===========================================================================
// Save the match info and tally the frequency counts. Return true if
// the current block must be flushed.
func X_tr_tally(tls *libc.TLS, s uintptr, dist uint32, lc uint32) int32 { /* trees.c:1014:19: */
	*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr((*Deflate_state)(unsafe.Pointer(s)).Flast_lit)*2)) = Ush(dist)
	*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Flast_lit, 1)))) = Uch(lc)
	if dist == uint32(0) {
		// lc is the unmatched char
		*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(lc)*4 /* &.fc */))++
	} else {
		(*Deflate_state)(unsafe.Pointer(s)).Fmatches++
		// Here, lc is the match length - MIN_MATCH
		dist-- // dist = match distance - 1

		*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(((int32(X_length_code[lc])+LITERALS)+1))*4 /* &.fc */))++
		*(*Ush)(unsafe.Pointer((s + 2440 /* &.dyn_dtree */) + uintptr((func() int32 {
			if (dist) < uint32(256) {
				return int32(X_dist_code[dist])
			}
			return int32(X_dist_code[(uint32(256) + ((dist) >> 7))])
		}()))*4 /* &.fc */))++
	}

	return (libc.Bool32((*Deflate_state)(unsafe.Pointer(s)).Flast_lit == ((*Deflate_state)(unsafe.Pointer(s)).Flit_bufsize - UInt(1))))
	// We avoid equality with lit_bufsize because of wraparound at 64K
	// on 16 bit machines and because stored blocks are restricted to
	// 64K-1 bytes.
}

// ===========================================================================
// Send the block data compressed using the given Huffman trees
func compress_block(tls *libc.TLS, s uintptr, ltree uintptr, dtree uintptr) { /* trees.c:1064:12: */
	var dist uint32           // distance of matched string
	var lc int32              // match length or unmatched char (if dist == 0)
	var lx uint32 = uint32(0) // running index in l_buf
	var code uint32           // the code to send
	var extra int32           // number of extra bits to send

	if (*Deflate_state)(unsafe.Pointer(s)).Flast_lit != UInt(0) {
		for ok := true; ok; ok = (lx < (*Deflate_state)(unsafe.Pointer(s)).Flast_lit) {
			dist = uint32(*(*Ushf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fd_buf + uintptr(lx)*2)))
			lc = int32(*(*Uchf)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fl_buf + uintptr(libc.PostIncUint32(&lx, 1)))))
			if dist == uint32(0) {
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + uintptr(lc)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
					}
				}
				// send a literal byte

			} else {
				// Here, lc is the match length - MIN_MATCH
				code = uint32(X_length_code[lc])
				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+uint32(LITERALS))+uint32(1)))*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+uint32(LITERALS))+uint32(1)))*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + uintptr(((code+uint32(LITERALS))+uint32(1)))*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
					}
				}
				// send the length code
				extra = extra_lbits[code]
				if extra != 0 {
					lc = lc - (base_length[code])
					{
						var len int32 = extra
						if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
							var val int32 = lc
							*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							{
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
								}
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
								}

							}
							(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
							*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
						} else {
							*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(lc))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
						}
					}
					// send the extra length bits
				}
				dist-- // dist is now the match distance - 1
				code = func() uint32 {
					if (dist) < uint32(256) {
						return uint32(X_dist_code[dist])
					}
					return uint32(X_dist_code[(uint32(256) + ((dist) >> 7))])
				}()

				{
					var len int32 = int32(*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 + 2 /* &.dl */)))
					if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
						var val int32 = int32(*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 /* &.fc */)))
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						{
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
							}
							{
								*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
							}

						}
						(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
					} else {
						*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(dtree + uintptr(code)*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
						*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
					}
				}
				// send the distance code
				extra = extra_dbits[code]
				if extra != 0 {
					dist = dist - (uint32(base_dist[code]))
					{
						var len int32 = extra
						if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
							var val int32 = int32(dist)
							*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							{
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
								}
								{
									*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
								}

							}
							(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
							*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
						} else {
							*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((Ush(dist))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
							*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
						}
					}
					// send the extra distance bits
				}
			} // literal or match pair ?

			// Check that the overlay between pending_buf and d_buf+l_buf is ok:

		}
	}

	{
		var len int32 = int32(*(*Ush)(unsafe.Pointer(ltree + 256*4 + 2 /* &.dl */)))
		if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > (Buf_size - len) {
			var val int32 = int32(*(*Ush)(unsafe.Pointer(ltree + 256*4 /* &.fc */)))
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32(Ush(val)) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			{
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
				}
				{
					*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
				}

			}
			(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = (Ush(int32(Ush(val)) >> (Buf_size - (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid)))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len - Buf_size)
		} else {
			*(*Ush)(unsafe.Pointer(s + 5816 /* &.bi_buf */)) |= Ush((int32((*(*Ush)(unsafe.Pointer(ltree + 256*4 /* &.fc */)))) << (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid))
			*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) += (len)
		}
	}

}

// ===========================================================================
// Check if the data type is TEXT or BINARY, using the following algorithm:
// - TEXT if the two conditions below are satisfied:
//    a) There are no non-portable control characters belonging to the
//       "black list" (0..6, 14..25, 28..31).
//    b) There is at least one printable character belonging to the
//       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
// - BINARY otherwise.
// - The following partially-portable control characters form a
//   "gray list" that is ignored in this detection algorithm:
//   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
// IN assertion: the fields Freq of dyn_ltree are set.
func detect_data_type(tls *libc.TLS, s uintptr) int32 { /* trees.c:1124:11: */
	// black_mask is the bit mask of black-listed bytes
	// set bits 0..6, 14..25, and 28..31
	// 0xf3ffc07f = binary 11110011111111111100000001111111
	var black_mask uint32 = 0xf3ffc07f
	var n int32

	// Check for non-textual ("black-listed") bytes.
	n = 0
__1:
	if !(n <= 31) {
		goto __3
	}
	if ((black_mask & uint32(1)) != 0) && (int32(*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */))) != 0) {
		return Z_BINARY
	}
	goto __2
__2:
	n++
	black_mask >>= 1
	goto __1
	goto __3
__3:
	;

	// Check for textual ("white-listed") bytes.
	if ((int32(*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + 9*4 /* &.fc */))) != 0) || (int32(*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + 10*4 /* &.fc */))) != 0)) ||
		(int32(*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + 13*4 /* &.fc */))) != 0) {
		return Z_TEXT
	}
	for n = 32; n < LITERALS; n++ {
		if int32(*(*Ush)(unsafe.Pointer((s + 148 /* &.dyn_ltree */) + uintptr(n)*4 /* &.fc */))) != 0 {
			return Z_TEXT
		}
	}

	// There are no "black-listed" or "white-listed" bytes:
	// this stream either is empty or has tolerated ("gray-listed") bytes only.
	return Z_BINARY
}

// ===========================================================================
// Reverse the first len bits of a code, using straightforward code (a faster
// method would use a table)
// IN assertion: 1 <= len <= 15
func bi_reverse(tls *libc.TLS, code uint32, len int32) uint32 { /* trees.c:1158:16: */
	var res uint32 = uint32(0)
	for ok := true; ok; ok = (libc.PreDecInt32(&len, 1) > 0) {
		res = res | (code & uint32(1))
		code >>= 1
		res <<= 1
	}
	return (res >> 1)
}

// ===========================================================================
// Flush the bit buffer, keeping at most 7 bits in it.
func bi_flush(tls *libc.TLS, s uintptr) { /* trees.c:1173:12: */
	if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid == 16 {
		{
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
			}

		}

		(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
		(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0
	} else if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid >= 8 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Byte((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)
		}

		libc.AssignShrPtrUint16(s+5816 /* &.bi_buf */, int(8))
		*(*int32)(unsafe.Pointer(s + 5820 /* &.bi_valid */)) -= (8)
	}
}

// ===========================================================================
// Flush the bit buffer and align the output on a byte boundary
func bi_windup(tls *libc.TLS, s uintptr) { /* trees.c:1190:12: */
	if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > 8 {
		{
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch((int32((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) & 0xff))
			}
			{
				*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = (Uch(int32(((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)) >> 8))
			}

		}

	} else if (*Deflate_state)(unsafe.Pointer(s)).Fbi_valid > 0 {
		{
			*(*Bytef)(unsafe.Pointer((*Deflate_state)(unsafe.Pointer(s)).Fpending_buf + uintptr(libc.PostIncUint32(&(*Deflate_state)(unsafe.Pointer(s)).Fpending, 1)))) = Byte((*Deflate_state)(unsafe.Pointer(s)).Fbi_buf)
		}

	}
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_buf = Ush(0)
	(*Deflate_state)(unsafe.Pointer(s)).Fbi_valid = 0
}

// ===========================================================================
//      Decompresses the source buffer into the destination buffer.  *sourceLen is
//    the byte length of the source buffer. Upon entry, *destLen is the total size
//    of the destination buffer, which must be large enough to hold the entire
//    uncompressed data. (The size of the uncompressed data must have been saved
//    previously by the compressor and transmitted to the decompressor by some
//    mechanism outside the scope of this compression library.) Upon exit,
//    *destLen is the size of the decompressed data and *sourceLen is the number
//    of source bytes consumed. Upon return, source + *sourceLen points to the
//    first unused input byte.
//
//      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
//    memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
//    Z_DATA_ERROR if the input data was corrupted, including if the input data is
//    an incomplete zlib stream.
func Xuncompress2(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen uintptr) int32 { /* uncompr.c:27:13: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	// var stream Z_stream at bp+4, 56

	var err int32
	var max UInt = libc.Uint32(libc.Uint32FromInt32(-1))
	var len ULong
	var left ULong
	// var buf [1]Byte at bp, 1
	// for detection of incomplete stream when *destLen == 0

	len = *(*ULong)(unsafe.Pointer(sourceLen))
	if *(*ULongf)(unsafe.Pointer(destLen)) != 0 {
		left = *(*ULongf)(unsafe.Pointer(destLen))
		*(*ULongf)(unsafe.Pointer(destLen)) = ULongf(0)
	} else {
		left = ULong(1)
		dest = bp /* &buf[0] */
	}

	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Fnext_in = source
	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_in = UInt(0)
	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Fzalloc = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Fzfree = uintptr(0)
	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Fopaque = uintptr(0)

	err = XinflateInit_(tls, bp+4 /* &stream */, ts /* "1.2.11" */, int32(unsafe.Sizeof(Z_stream{})))
	if err != Z_OK {
		return err
	}

	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Fnext_out = dest
	(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_out = UInt(0)

	for ok := true; ok; ok = (err == Z_OK) {
		if (*Z_stream)(unsafe.Pointer(bp+4 /* &stream */)).Favail_out == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_out = func() uint32 {
				if left > ULong(max) {
					return max
				}
				return UInt(left)
			}()
			left = left - (ULong((*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_out))
		}
		if (*Z_stream)(unsafe.Pointer(bp+4 /* &stream */)).Favail_in == UInt(0) {
			(*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_in = func() uint32 {
				if len > ULong(max) {
					return max
				}
				return UInt(len)
			}()
			len = len - (ULong((*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Favail_in))
		}
		err = Xinflate(tls, bp+4 /* &stream */, Z_NO_FLUSH)
	}

	*(*ULong)(unsafe.Pointer(sourceLen)) -= (len + ULong((*Z_stream)(unsafe.Pointer(bp+4 /* &stream */)).Favail_in))
	if dest != bp /* buf */ {
		*(*ULongf)(unsafe.Pointer(destLen)) = (*Z_stream)(unsafe.Pointer(bp + 4 /* &stream */)).Ftotal_out
	} else if ((*Z_stream)(unsafe.Pointer(bp+4 /* &stream */)).Ftotal_out != 0) && (err == (-5)) {
		left = ULong(1)
	}

	XinflateEnd(tls, bp+4 /* &stream */)
	if err == Z_STREAM_END {
		return Z_OK
	}
	if err == Z_NEED_DICT {
		return -3
	}
	if (err == (-5)) && ((left + ULong((*Z_stream)(unsafe.Pointer(bp+4 /* &stream */)).Favail_out)) != 0) {
		return -3
	}
	return err
}

func Xuncompress(tls *libc.TLS, dest uintptr, destLen uintptr, source uintptr, sourceLen ULong) int32 { /* uncompr.c:86:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*ULong)(unsafe.Pointer(bp)) = sourceLen

	return Xuncompress2(tls, dest, destLen, source, bp /* &sourceLen */)
}

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

// The type of the second argument to `fgetpos' and `fsetpos'.
type Fpos_t1 = X__fpos64_t /* stdio.h:86:20 */

// GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
//    value -- needed when comparing unsigned to z_off64_t, which is signed
//    (possible z_off64_t types off_t, off64_t, and long are all signed)

var Xz_errmsg = [10]uintptr{
	uintptr(ts + 876 /* "need dictionary" */),     // Z_NEED_DICT       2
	uintptr(ts + 892 /* "stream end" */),          // Z_STREAM_END      1
	uintptr(ts + 101 /* "" */),                    // Z_OK              0
	uintptr(ts + 903 /* "file error" */),          // Z_ERRNO         (-1)
	uintptr(ts + 914 /* "stream error" */),        // Z_STREAM_ERROR  (-2)
	uintptr(ts + 927 /* "data error" */),          // Z_DATA_ERROR    (-3)
	uintptr(ts + 938 /* "insufficient mem..." */), // Z_MEM_ERROR     (-4)
	uintptr(ts + 958 /* "buffer error" */),        // Z_BUF_ERROR     (-5)
	uintptr(ts + 971 /* "incompatible ver..." */), // Z_VERSION_ERROR (-6)
	uintptr(ts + 101 /* "" */),
} /* zutil.c:13:14 */

func XzlibVersion(tls *libc.TLS) uintptr { /* zutil.c:27:12: */
	return ts /* "1.2.11" */
}

func XzlibCompileFlags(tls *libc.TLS) ULong { /* zutil.c:32:15: */
	var flags ULong

	flags = ULong(0)
	switch int32(unsafe.Sizeof(UInt(0))) {
	case 2:
		break
	case 4:
		flags = flags + (ULong(1))
		break
	case 8:
		flags = flags + (ULong(2))
		break
	default:
		flags = flags + (ULong(3))
	}
	switch int32(unsafe.Sizeof(ULong(0))) {
	case 2:
		break
	case 4:
		flags = flags + (ULong(int32(1) << 2))
		break
	case 8:
		flags = flags + (ULong(int32(2) << 2))
		break
	default:
		flags = flags + (ULong(int32(3) << 2))
	}
	switch int32(unsafe.Sizeof(Voidpf(0))) {
	case 2:
		break
	case 4:
		flags = flags + (ULong(int32(1) << 4))
		break
	case 8:
		flags = flags + (ULong(int32(2) << 4))
		break
	default:
		flags = flags + (ULong(int32(3) << 4))
	}
	switch int32(unsafe.Sizeof(Off_t2(0))) {
	case 2:
		break
	case 4:
		flags = flags + (ULong(int32(1) << 6))
		break
	case 8:
		flags = flags + (ULong(int32(2) << 6))
		break
	default:
		flags = flags + (ULong(int32(3) << 6))
	}
	return flags
}

// exported to allow conversion of error code to string for compress() and
// uncompress()
func XzError(tls *libc.TLS, err int32) uintptr { /* zutil.c:133:12: */
	return Xz_errmsg[(Z_NEED_DICT - (err))]
}

func Xzcalloc(tls *libc.TLS, opaque Voidpf, items uint32, size uint32) Voidpf { /* zutil.c:305:22: */
	_ = opaque
	if uint32(unsafe.Sizeof(UInt(0))) > uint32(2) {
		return libc.Xmalloc(tls, (items * size))
	}
	return libc.Xcalloc(tls, items, size)
}

func Xzcfree(tls *libc.TLS, opaque Voidpf, ptr Voidpf) { /* zutil.c:315:20: */
	_ = opaque
	libc.Xfree(tls, ptr)
}

func init() {
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 8 /* .func */)) = deflate_stored // deflate.c:136:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 20 /* .func */)) = deflate_fast  // deflate.c:137:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 32 /* .func */)) = deflate_fast  // deflate.c:138:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 44 /* .func */)) = deflate_fast  // deflate.c:139:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 56 /* .func */)) = deflate_slow  // deflate.c:141:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 68 /* .func */)) = deflate_slow  // deflate.c:142:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 80 /* .func */)) = deflate_slow  // deflate.c:143:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 92 /* .func */)) = deflate_slow  // deflate.c:144:29:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 104 /* .func */)) = deflate_slow // deflate.c:145:30:
	*(*func(*libc.TLS, uintptr, int32) Block_state)(unsafe.Pointer(uintptr(unsafe.Pointer(&configuration_table)) + 116 /* .func */)) = deflate_slow // deflate.c:146:30:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_bl_desc)) + 4 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_blbits))            // trees.c:132:22:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_d_desc)) + 0 /* .static_tree */)) = uintptr(unsafe.Pointer(&static_dtree))            // trees.c:129:2:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_d_desc)) + 4 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_dbits))              // trees.c:129:16:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_l_desc)) + 0 /* .static_tree */)) = uintptr(unsafe.Pointer(&static_ltree))            // trees.c:126:2:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&static_l_desc)) + 4 /* .extra_bits */)) = uintptr(unsafe.Pointer(&extra_lbits))              // trees.c:126:16:
}

var ts1 = "1.2.11\x00 deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler \x00%s\x00<fd:%d>\x00out of memory\x00\x00%s%s%s\x00: \x00unexpected end of file\x00internal error: inflate stream corrupt\x00compressed data error\x00request does not fit in an int\x00request does not fit in a size_t\x00out of room to push characters\x00internal error: deflate stream corrupt\x00requested length does not fit in int\x00invalid block type\x00invalid stored block lengths\x00too many length or distance symbols\x00invalid code lengths set\x00invalid bit length repeat\x00invalid code -- missing end-of-block\x00invalid literal/lengths set\x00invalid distances set\x00invalid literal/length code\x00invalid distance code\x00invalid distance too far back\x00incorrect header check\x00unknown compression method\x00invalid window size\x00unknown header flags set\x00header crc mismatch\x00incorrect data check\x00incorrect length check\x00 inflate 1.2.11 Copyright 1995-2017 Mark Adler \x00need dictionary\x00stream end\x00file error\x00stream error\x00data error\x00insufficient memory\x00buffer error\x00incompatible version\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
